

//Function DistributeHumansToBuildings - base = 2 won't change soldier class to special class in barracks (sniper,bazooker,mortar).
//Scientist control code - Exception for Alliance main characters (base = 2).
//ai_buildings_locations is modified in module "Events_Alliance".

//Known "bug" - if a factory is having an extension rebuilt and the base comes under attack that factory will not produce vehicles
//while under attack even if it should.

                                                              
//The computer has unlimited resources
Every 0$1.5 do
     var i, un, base, val;
     begin
          for i in ai_depots do
              for un in i do
                  if IsOk(un) and GetSide(un) <> you then  //IsOk -> no sib spawn if depot is destroyed. See UnitGoesToRed.
                     begin
                         base = GetBase(un);

                         SetResourceType(base,mat_cans,500);
                         SetResourceType(base,mat_oil,500);
                         SetResourceType(base,mat_siberit,500);
                    end;

          for i in mb_bases do
              for un in mb_buildings[i] do
                  if GetBType(un)=b_depot and not GetSide(un) = 2 then
                  begin
                       base = GetBase(un);
                       SetResourceType(base,mat_cans,200);
                       SetResourceType(base,mat_oil,500);

                       if i=2 then
                          SetResourceType(base,mat_siberit,20);
                  end;

          enable;
     end;


On UnitGoesToRed(un) do
     var base, i, temp, temp2;
     begin
          //Leaders saying their last words
          if un = LegionLeader and not LegionLeader in dlg_list then
          begin
               dlg_list = dlg_list ^ LegionLeader;
               
               case LegionLeader of
                    Kurt: begin
                               DialogueOn;

                               ForceSay(Kurt, 'Lead_Kurt1');            
                               Say(Heike, 'Lead_Heike');
                               ForceSay(Kurt, 'Lead_Kurt2');
                               ForceSay(Kurt, 'Lead_Kurt3');

                               DialogueOff;
                          end;

                    Gordon: begin
                                 DialogueOn;

                                 ForceSay(Gordon, 'Lead_Gordon1');
                                 ForceSay(Gordon, 'Lead_Gordon2');

                                 DialogueOff;
                            end;

               end;   
          end;

          if un = Powell and not Powell in dlg_list then
          begin
               dlg_list = dlg_list ^ Powell;

               temp = UnitShoot(Powell);

               if AmericansNuked then
                  ForceSay(Powell, 'Lead_Powell2')
               else
                   case GetSide(temp) of
                        0,2,8: ForceSay(Powell, 'Lead_Powell1');
                        else ForceSay(Powell, 'Lead_Powell2');
                   end;
          end;

          if un = Platonov and not Platonov in dlg_list then
          begin
               dlg_list = dlg_list ^ Platonov;

               ForceSay(Platonov, 'Lead_Platonov');
          end;


          if GetSide(un) = you then
               exit;
                                                    
          if IsInArea(un, base_legion) then
             base = 1
          else
              if IsInArea(un, base_russians) then
                 base = 2
              else
                  if IsInArea(un, base_us) then
                     base = 3
                  else base = 0;

          if GetBType(un) in [b_depot,b_warehouse] then
             case base of
                  0: begin
                          SetResourceType(GetBase(un),mat_cans,0);
                          SetResourceType(GetBase(un),mat_oil,150);
                          SetResourceType(GetBase(un),mat_siberit,0);
                     end;
                  1: begin
                          SetResourceType(GetBase(un),mat_cans,100);
                          SetResourceType(GetBase(un),mat_oil,200);
                          SetResourceType(GetBase(un),mat_siberit,0);
                     end;
                  2: begin
                          SetResourceType(GetBase(un),mat_cans,200);
                          SetResourceType(GetBase(un),mat_oil,200);
                          SetResourceType(GetBase(un),mat_siberit,1000 + Rand(500, 4000));
                     end;
                  3: begin
                          if GetSide(un) = 4 then
                          begin
                               SetResourceType(GetBase(un),mat_cans,0);
                               SetResourceType(GetBase(un),mat_oil,0);
                               SetResourceType(GetBase(un),mat_siberit,0);
                          end
                          else
                          begin
                               SetResourceType(GetBase(un),mat_cans,100);
                               SetResourceType(GetBase(un),mat_oil,200);
                               SetResourceType(GetBase(un),mat_siberit,[300,240,160][difficulty]);
                          end;
                     end;
             end;

          if base = 0 then
               exit;
          {
          //Russian teleporter exit is reset when teleporter goes to red.
          if un = ai_teleporter[base] then
               ai_teleporter_exit_placed = Replace(ai_teleporter_exit_placed,base,false);
          }

          //If the player destroys a depot no siberite shall spawn. This cannot be set in UnitDestroyed but works fine
          //here in UnitGoesToRed even if the depot goes from yellow to destroyed in one go.



          if GetSide(un) = 3 and GetBType(un) in [b_depot,b_warehouse] then
             for i in FilterAllUnits([[f_side,3],[f_bweapon,ru_time_lapser]]) do
                 if GetBase(i) = GetBase(un) then
                 begin
                      temp = [GetX(i), GetY(i), GetDir(i), GetLives(i), GetBLevel(i)];
                      RemoveBuildingFromVariables(base,i);
                      DestroyUnit(i);

                      uc_side = 3;
                      uc_nation = nation_russian;
                      bc_type = b_turret;
                      uc_direction = temp[3];

                      temp2 = CreateBuilding;

                      SetLives(temp2, temp[4]);
                      SetBLevel(temp2, temp[5]);

                      PlaceUnitXY(temp2, temp[1], temp[2], false);
                      PlaceWeaponTurret(temp2, ru_time_lapser);

                      temp = ai_all_buildings[base] ^ temp2;
                      ai_all_buildings = Replace(ai_all_buildings,base,temp);

                      UpdateBuildingBasicVariables(base,temp2,true);
                 end;

     end;


On UnitDestroyed(un) do
     var side, temp_list, base, temp_value, i;
     begin
          if un = Heike then
               begin
                    ExclusiveOn;
                    Wait(0$1);
                    YouLost('HeikeDied');
                    ExclusiveOff;
               end;

          if un = Omar then
               begin
                    ExclusiveOn;
                    Wait(0$1);
                    YouLost('OmarDied');
                    ExclusiveOff;
               end;


          for base in ai_bases do
               begin
                    temp_list = ai_captured_buildings[base] diff un;
                    ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
               end;

          side = GetSide(un);

          if side = 2 and (FilterAllUnits([[f_side,2],[f_class,class_scientistic],[f_placed]]) diff un) < Contamination_count then
             if CheckIfCanMakeMoreSci = false then
             begin
                  ExclusiveOn;
                  Wait(0$1);
                  YouLost('TooManyCasualties_sci');
                  ExclusiveOff;
             end;


          if side = you then
               exit;


          //Update computer variables
          case GetType(un) of
               unit_human:
                    for base in ai_bases do
                        RemoveHumanFromVariables(base,un,true);
               unit_vehicle:
                    for base in ai_bases do
                         RemoveVehicleFromVariables(base,un);
               unit_building:
                    for base in ai_bases do
                         RemoveBuildingFromVariables(base,un);
          end;
     end;

//Possible to make more sci if:
//                             Have enough people
//                             Have a lab
//                             Have an engineer and a depot (to capture) to build a lab (or capture)
Function CheckIfCanMakeMoreSci;
var i, temp;
begin
     result = false;

     if FilterAllUnits([[f_side,2],[f_type,unit_human],[f_nation,nation_arabian]]) < Contamination_count then
        exit;

     if FilterAllUnits([[f_side,2],[f_or,[f_btype,b_lab],[f_btype,b_lab_half],[f_btype,b_lab_full]]]) > 0 then
     begin
          result = true;
          exit;
     end;

     if FilterAllUnits([[f_side,2],[f_class,class_engineer]]) > 0 then
        if FilterAllUnits([f_or,[f_btype,b_lab],[f_btype,b_lab_half],[f_btype,b_lab_full],[f_btype,b_depot],[f_btype,b_warehouse]]) > 0 then
           result = true;
end;

//Annoyingly siberite implosion vehicles and kamikaze apes don't trigger event UnitDestroyed.
//Self destruction (Arab tech) does trigger event UnitDestroyed, though.
Every 0$0.5 do
     var base, i;
     begin
          for base in ai_bases do
               begin
                    for i in ai_implosion_vehicles[base] do
                         if IsDead(i) then
                              RemoveVehicleFromVariables(base,i);

                    for i in ai_vehicles_attack[base] do  //Can't do a filter on implosion vehicles because if the vehicle is dead no info about it can be fetched
                         if IsDead(i) then
                              RemoveVehicleFromVariables(base,i);
               end;

          enable;
     end;
Export Function RemoveBuildingFromVariables(base,building);
     var temp_list;
     begin
          temp_list = ai_all_buildings[base] diff building;
          ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

          temp_list = ai_excepted_buildings[base] diff building;
          ai_excepted_buildings = Replace(ai_excepted_buildings,base,temp_list);

          temp_list = ai_dismantle_these_buildings[base] diff building;
          ai_dismantle_these_buildings = Replace(ai_dismantle_these_buildings,base,temp_list);

          if building = ai_building_under_construction[base] then
               ai_building_under_construction = Replace(ai_building_under_construction,base,0);

          if building = ai_sib_bomb_fact[base] then
               ai_sib_bomb_fact = Replace(ai_sib_bomb_fact,base,0);

          UpdateBuildingBasicVariables(base,building,false);
     end;
Function RemoveVehicleFromVariables(base,vehicle);
     var temp_list;
     begin
          //Global "basis" lists of vehicles. If a vehicle belong to this base it will be in one
          //and only one of these lists.
          if vehicle in ai_vehicles_defend[base] then
               begin
                    temp_list = ai_vehicles_defend[base] diff vehicle;
                    ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
               end;

          if vehicle in ai_vehicles_attack[base] then
               begin
                    temp_list = ai_vehicles_attack[base] diff vehicle;
                    ai_vehicles_attack = Replace(ai_vehicles_attack,base,temp_list);
               end;

          if vehicle in ai_taufield_vehicles[base] then
               begin
                    temp_list = ai_taufield_vehicles[base] diff vehicle;
                    ai_taufield_vehicles = Replace(ai_taufield_vehicles,base,temp_list);
               end;

          if vehicle in ai_implosion_vehicles[base] then
               begin
                    temp_list = ai_implosion_vehicles[base] diff vehicle;
                    ai_implosion_vehicles = Replace(ai_implosion_vehicles,base,temp_list);
               end;

          if vehicle in ai_control_tower_vehicles[base] then
               begin
                    temp_list = ai_control_tower_vehicles[base] diff vehicle;
                    ai_control_tower_vehicles = Replace(ai_control_tower_vehicles,base,temp_list);
               end;

          if vehicle = ai_cargo_bay[base] then
               begin
                    ai_cargo_bay = Replace(ai_cargo_bay,base,0);
                    ai_cargo_bay_destroy_tick = Replace(ai_cargo_bay_destroy_tick,base,tick);
               end;

          if vehicle = ai_crane[base] then
               begin
                    ai_crane = Replace(ai_crane,base,0);
                    ai_crane_destroy_tick = Replace(ai_crane_destroy_tick,base,tick);
                    ai_crane_driver = Replace(ai_crane_driver,base,0);
                    ai_crane_is_being_repaired = Replace(ai_crane_is_being_repaired,base,false);

                    if vehicle = ai_building_constructor[base] then
                         ai_building_constructor = Replace(ai_building_constructor,base,0);
               end;

          if vehicle in ai_sib_bomb_vehicles[base] then
               begin
                    temp_list = ai_sib_bomb_vehicles[base] diff vehicle;
                    ai_sib_bomb_vehicles = Replace(ai_sib_bomb_vehicles,base,temp_list);
               end;

          if vehicle in ai_behemoths[base] then
               begin                               
                    temp_list = ai_behemoths[base] diff vehicle;
                    ai_behemoths = Replace(ai_behemoths,base,temp_list);
               end;


          //Global "transient" lists of vehicles. Vehicles belonging to this base may be in one or more of these lists if
          //it performs a special or temporary job (you could say that the vehicle is in a special state).
          if vehicle in ai_retreating_vehicles_defend[base] then
               begin
                    temp_list = ai_retreating_vehicles_defend[base] diff vehicle;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);
               end;

          if vehicle in ai_vehicles_being_repaired[base] then
               begin
                    temp_list = ai_vehicles_being_repaired[base] diff vehicle;
                    ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);
               end;

          if vehicle in ai_refuel_vehicles_list[base] then
               begin
                    temp_list = ai_refuel_vehicles_list[base] diff vehicle;
                    ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);
               end;

          if vehicle = ai_vehicle_being_moved[base] then
               ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);

          if vehicle in ai_vehicles_having_been_moved[base] then
               begin
                    temp_list = ai_vehicles_having_been_moved[base] diff vehicle;
                    ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,temp_list);
               end;

     end;
Export Function RemoveHumanFromVariables(base,human,check_if_base_is_dead);
     var temp_list, i;
     begin
          result = false;

          //Global "basis" lists of humans. If a human belong to this base he/she will be in one
          //and only one of these lists.
          if human in ai_soldiers[base] then
               begin
                    temp_list = ai_soldiers[base] diff human;
                    ai_soldiers = Replace(ai_soldiers,base,temp_list);
                    result = true;
               end;

          if human in ai_attacking_soldiers[base] then
               begin
                    temp_list = ai_attacking_soldiers[base] diff human;
                    ai_attacking_soldiers = Replace(ai_attacking_soldiers,base,temp_list);
                    result = true;
               end;

          if human in ai_engineers[base] then
               begin
                    temp_list = ai_engineers[base] diff human;
                    ai_engineers = Replace(ai_engineers,base,temp_list);
                    result = true;
               end;

          if human in ai_apemen_engineers[base] then
               begin
                    temp_list = ai_apemen_engineers[base] diff human;
                    ai_apemen_engineers = Replace(ai_apemen_engineers,base,temp_list);
                    result = true;
               end;

          if human in ai_mechanics_defend[base] then
               begin
                    temp_list = ai_mechanics_defend[base] diff human;
                    ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
                    result = true;
               end;

          if human in ai_mechanics_attack[base] then
               begin
                    temp_list = ai_mechanics_attack[base] diff human;
                    ai_mechanics_attack = Replace(ai_mechanics_attack,base,temp_list);
                    result = true;
               end;

          if human in ai_sib_bomb_mechanics[base] then
               begin
                    temp_list = ai_sib_bomb_mechanics[base] diff human;
                    ai_sib_bomb_mechanics = Replace(ai_sib_bomb_mechanics,base,temp_list);
                    result = true;

                    {if ai_mechanics_defend[base] > 0 then
                         begin
                              temp_list = ai_sib_bomb_mechanics[base] ^ ai_mechanics_defend[base][1];
                              ai_sib_bomb_mechanics = Replace(ai_sib_bomb_mechanics,base,temp_list);

                              temp_list = Delete(ai_mechanics_defend[base],1);
                              ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
                         end;} //Dangerous - what if the picked mechanic is doing a job where he/she is also in other global variables?
               end;

          if human in ai_scientists[base] then
               begin
                    temp_list = ai_scientists[base] diff human;
                    ai_scientists = Replace(ai_scientists,base,temp_list);
                    result = true;
               end;

          if human in ai_attacking_scientists[base] then
               begin
                    temp_list = ai_attacking_scientists[base] diff human;
                    ai_attacking_scientists = Replace(ai_attacking_scientists,base,temp_list);
                    result = true;
               end;


          //Global "transient" lists of humans. Humans belonging to this base may be in one or more of these lists if
          //he/she performs a special or temporary job (you could say that the human is in a special state).
          if human in ai_heal_these_humans[base] then
               begin
                    temp_list = ai_heal_these_humans[base] diff human;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
               end;

          if human = ai_building_constructor[base] then
               ai_building_constructor = Replace(ai_building_constructor,base,0);

          if human in ai_retreating_attacking_humans[base] then
               begin
                    temp_list = ai_retreating_attacking_humans[base] diff human;
                    ai_retreating_attacking_humans = Replace(ai_retreating_attacking_humans,base,temp_list);
               end;

          if human = ai_crane_driver[base] then
               ai_crane_driver = Replace(ai_crane_driver,base,0);

          //If there are no human units left the base is "dead"
          if check_if_base_is_dead then
               if ((ai_soldiers[base] ^ ai_attacking_soldiers[base] ^ ai_engineers[base] ^ ai_apemen_engineers[base] ^ ai_mechanics_defend[base] ^ ai_mechanics_attack[base] ^ ai_sib_bomb_mechanics[base] ^ ai_scientists[base] ^
                   ai_attacking_scientists[base]) diff 0) = 0 then
                    begin
                         ai_bases = ai_bases diff base;
                    end;
     end;


Export Function GetBaseArea(base);
     begin
          case base of
               1: result = base_legion;
               2: result = base_russians;
               3: result = base_us;
          end;
     end;
Export Function GetBaseSide(base);
     begin
          case base of
               1: result = legion;
               2: result = russians;
               3: result = americans;
          end;
     end;
Export Function GetBaseNation(base);
     begin
          case base of
               1: result = nation_arabian;
               2: result = nation_russian;
               3: result = nation_american;
          end;
     end;
Export Function FindBase(un);
     var base;
     begin
          result = 0;

          for base in ai_bases do
               if IsInArea(un,GetBaseArea(base)) then
                    begin
                         result = base;
                         exit;
                    end;
     end;

{
//Every which tries to spawn new units for AI.
Every 0$2+0$0.1 do
     var base, i, temp_unit, temp_list, away, buildings_list, b, cl;
     begin

          repeat
          wait(0$2);

          for base in ai_bases do
               begin
                    if base in [1,3,4] then
                         continue;  //Only spawning for Alliance

                    if am_going_to_destroy_alli then
                         begin
                              for i in ai_spawn_people[base] do
                                   DestroyUnit(i);

                              ai_spawn_people = Replace(ai_spawn_people,base,[]);
                              exit;
                         end;

                    if BaseUnderAttack(base,-1) then
                         continue;

                    i = 1;
                    while i <= ai_spawn_people[base] do
                         begin
                              temp_unit = 0;
                              cl = GetClass(ai_spawn_people[base][i]);

                              case cl of
                                   class_soldier, class_apeman_soldier, class_sniper, class_mortar, class_bazooker: buildings_list = ai_armouries[base];
                                   class_engineer,class_apeman_engineer: buildings_list = [ai_depot[base]];
                                   class_mechanic: buildings_list = ai_facts[base];
                                   class_scientistic: buildings_list = ai_labs[base];
                              end;

                              away = false;
                              for b in buildings_list do
                                   begin
                                        //Spawn engineers at human pullback hex if there are no depot.
                                        if ( IsOk(b) and UnitsInside(b) < 6 ) or cl = class_engineer then
                                             begin
                                                  if IsOk(b) and UnitsInside(b) < 6 then
                                                       PlaceHumanInUnit(ai_spawn_people[base][i],b)
                                                  else
                                                       PlaceUnitXYR(ai_spawn_people[base][i],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2],7,false);

                                                  case cl of
                                                       class_soldier, class_apeman_soldier, class_sniper, class_mortar, class_bazooker: begin
                                                            temp_list = ai_soldiers[base] ^ ai_spawn_people[base][i];
                                                            ai_soldiers = Replace(ai_soldiers,base,temp_list);
                                                       end;
                                                       class_engineer: begin
                                                            temp_list = ai_engineers[base] ^ ai_spawn_people[base][i];
                                                            ai_engineers = Replace(ai_engineers,base,temp_list);
                                                       end;
                                                       class_apeman_engineer: begin
                                                            temp_list = ai_apemen_engineers[base] ^ ai_spawn_people[base][i];
                                                            ai_apemen_engineers = Replace(ai_apemen_engineers,base,temp_list);
                                                       end;
                                                       class_mechanic: begin
                                                            temp_list = ai_mechanics_defend[base] ^ ai_spawn_people[base][i];
                                                            ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
                                                       end;
                                                       class_scientistic: begin
                                                            temp_list = ai_scientists[base] ^ ai_spawn_people[base][i];
                                                            ai_scientists = Replace(ai_scientists,base,temp_list);
                                                       end;
                                                  end;

                                                  away = true;
                                                  break;
                                             end;
                                   end;

                              if away then
                                   begin
                                        temp_list = Delete(ai_spawn_people[base],i);
                                        ai_spawn_people = Replace(ai_spawn_people,base,temp_list);

                                        continue;
                                   end;

                              i = i + 1;
                         end;
               end;

          until false;
     end;
}

//Soldiers
//Keep them in bunkers/armouries. If that's not possible due to structure restrictions then help construct buildings. Else retreat to
//the center of the base.
Every 0$1+0$0.1 do
     var side, i, temp_list, buildings_list, soldiers_list, temp_unit, base, val, special_units, bunkers, under_attack, j, area;
     var temp_list_2, special_defenders;
     begin

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    side = GetBaseSide(base);

                    soldiers_list = ai_soldiers[base] diff (ai_excepted_soldiers[base] ^ [Platonov,Powell,LegionLeader]);
                    under_attack := BaseUnderAttack(base,-1);


                    //Control leaders (Kurt or Gordon, Platonov, Powell). Stay in depot.
                    case base of
                         1: val = LegionLeader;
                         2: val = Platonov;
                         3: if PowellAttack = 0 then
                               val = Powell
                            else
                                val = 0;
                    end;

                    if val > 0 and IsLive(val) and not val in ai_heal_these_humans[base] then
                         begin
                              if GetLives(val) <= 500 or ( GetLives(val) < 1000 and not under_attack ) then
                                   begin
                                        temp_list = ai_heal_these_humans[base] ^ val;
                                        ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
                                   end
                              else
                                  if ai_depots[base] > 0 then
                                     DistributeHumansToBuildings(base,[val], UnitFilter(ai_depots[base][1],[[f_ok],[f_not,[f_constructed]]]),0,6,true,true);
                         end;


                    if base in [8] and under_attack then
                         begin
                              special_defenders = UnitFilter(soldiers_list,[f_not,[f_inside]]);

                              for i in ai_armouries[base] do
                                   begin
                                        temp_list = UnitFilter(UnitsInside(i),[f_or,[f_class,class_sniper],[f_class,class_mortar],[f_class,class_bazooker]]);
                                        for j = 1 to temp_list - [5,4,3][difficulty] do  //leave some units inside
                                             special_defenders = special_defenders ^ temp_list[j];
                                   end;
                         end
                    else
                         special_defenders = [];

                    //Identify soldiers who need healing.
                    temp_list = ai_heal_these_humans[base];
                    for i in soldiers_list diff ai_heal_these_humans[base] do
                         if GetLives(i) <= 500 or ( GetLives(i) < 800 and not i in special_defenders ) then
                              temp_list = temp_list ^ i;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Make soldiers needing healing go outside (else they won't be healed, cf. the healing
                    //code (controlling scientists) below.

                    if not under_attack then
                         begin
                              for i in ai_heal_these_humans[base] do
                                   if i in soldiers_list then
                                        case GetType(IsInUnit(i)) of
                                             unit_vehicle: ComExitVehicle(i);
                                             unit_building: ComExitBuilding(i);
                                        end;
                         end;


                    soldiers_list = soldiers_list diff ai_heal_these_humans[base];
                    special_defenders = special_defenders diff ai_heal_these_humans[base];


                    if soldiers_list = 0 then
                         continue;


                    //Special defenders charge towards attackers.
                 {   if special_defenders > 0 then
                         begin
                              case base of
                                   1: begin
                                        temp_list_2 = FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_inarea,ru_bazooker_defend_area]]);
                                   end;
                                   2: begin
                                        temp_list_2 = [];
                                   end;
                                   3: begin
                                        temp_list_2 = FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_inarea,ar_mortar_defend_area]]);
                                   end;
                                   4: begin
                                        temp_list_2 = FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_inarea,am_sniper_defend_area]]);
                                   end;
                              end;

                              if temp_list_2 > 0 then
                                   begin
                                        soldiers_list = soldiers_list diff special_defenders;

                                        //Charge!
                                        ComAgressiveMove(GetHumansOutOfUnits(special_defenders),GetX(temp_list_2[1]),GetY(temp_list_2[1]));
                                   end;
                         end;
                 }

                    //Find the bunkers which need to be occupied.
                    //Remember which soldiers are already inside a building.
                    //Don't occupy b_bunker if there is no power.
                    bunkers = [];
                    temp_list = unitfilter(ai_bunkers[base], [f_not,[f_btype,b_breastwork]] );

                    for i = 1 to temp_list do
                        if GetBase(temp_list[i]) > 0 then
                           if GetEnergy( GetBase(temp_list[i]) )[4] > 0 then
                              bunkers = bunkers ^ temp_list[i];

                    bunkers = bunkers ^ unitfilter(ai_bunkers[base], [f_btype,b_breastwork] );


                    buildings_list = [];
                    for i in UnitFilter(bunkers,[f_ok]) do
                         begin
                              temp_unit = UnitsInside(i);
                              if temp_unit = 0 and not i in ai_units_irradiated then
                                   buildings_list = buildings_list ^ i
                              else soldiers_list = soldiers_list diff temp_unit;
                         end;


                    //The best soldiers should go to the bunkers. The rest in the armouries.
                    //If the base is under attack then just the nearest soldier.
                    if buildings_list > 0 then
                         begin
                              if not under_attack then
                                   begin
                                        temp_list = [];

                                        for i in soldiers_list do
                                            temp_list = temp_list ^ GetSkill(i,skill_combat);

                                        soldiers_list = SortListByListDesc(soldiers_list,temp_list);

                                   end;

                              //Bazookers/snipers/mortar in armouries or breastworks if possible.
                              special_units = UnitFilter(soldiers_list,[f_or,[f_class,class_bazooker],[f_class,class_sniper],[f_class,class_mortar]]);
                              soldiers_list = soldiers_list diff special_units;

                              for i = 1 to buildings_list do
                                   begin
                                        if soldiers_list = 0 then
                                             begin
                                                  if special_units = 0 then
                                                       break;

                                                  soldiers_list = special_units;
                                                  special_units = [];
                                             end;

                                        if not under_attack then
                                             begin
                                                  if GetBType(buildings_list[i]) = b_breastwork and special_units > 0 then
                                                       temp_unit = special_units[1]
                                                  else
                                                       temp_unit = soldiers_list[1];
                                             end
                                        else
                                             begin
                                                  if GetBType(buildings_list[i]) = b_breastwork and special_units > 0 then
                                                       temp_list_2 = special_units
                                                  else
                                                       temp_list_2 = soldiers_list;

                                                  temp_list = [];
                                                  for j in temp_list_2 do
                                                       temp_list = temp_list ^ GetDistUnits(j,buildings_list[i]);

                                                  temp_unit = WorstFromListByList(temp_list_2,temp_list);
                                             end;

                                        //If a special class is picked for a bunker, make them change into a soldier first
                                        if GetClass(temp_unit) in [class_mortar, class_bazooker, class_sniper] and ai_armouries[base] > 0 then
                                        begin
                                             if GetBType(IsInUnit(temp_unit)) in [b_barracks, b_armoury] then
                                                ComChangeProfession(temp_unit, class_soldier)
                                             else
                                                 if IsInUnit(temp_unit) then
                                                    ComMoveUnit(temp_unit, ai_armouries[base][1])
                                                 else
                                                     begin
                                                          ComEnterUnit(temp_unit, ai_armouries[base][1]);
                                                          AddComChangeProfession(temp_unit, class_soldier);
                                                     end;

                                        end
                                           else
                                               if IsOk(buildings_list[i]) then
                                                  ComEnterUnit(temp_unit,buildings_list[i])
                                               else
                                                   if GetDistUnits(temp_unit,buildings_list[i]) > 4 then
                                                      ComAgressiveMove(temp_unit,GetX(buildings_list[i]),GetY(buildings_list[i]));

                                        soldiers_list = soldiers_list diff temp_unit;
                                        special_units = special_units diff temp_unit;
                                   end;
                         end
                    else
                         special_units = [];


                    //The rest enter armouries (if possible)
                    temp_list = UnitFilter(ai_armouries[base],[[f_ok],[f_not,[f_constructed]]]) diff ai_units_irradiated;

                    DistributeHumansToBuildings(base,soldiers_list ^ special_units, temp_list,
                         false,6,true,true);

               end;

          until false;
     end;


//When someone steps on a landmine.
Every 0$1+0$0.2 do
     var i, un, base, temp_list, temp_list_2;
     begin

          repeat
                wait(0$0.5);

                ai_mines = ai_mines diff 0;

                if not 1 in ai_bases then
                   exit;

                for i in ai_mines do
                    if GetSide( HexInfo(i[1], i[2]) ) = 2 then
                       LaunchMineAtPos(i[1], i[2], 8);

          until false;
     end;

//Make defending snipers use soporific ammo.
Every 0$1+0$0.4 do
     var side, base, i, temp_list, un1, temp_list_2, temp_value, val;
     var sopo_cooldown;
     begin
          //Index is unit id, value is cooldown. So the same sniper won't use soporific ammo all the time.
          //Sleeping time is about 10 seconds.
          sopo_cooldown = [];

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    if base in [1,2] then
                         continue;

                    side = GetBaseSide(base);

                    for i in ai_soldiers[base] do
                         if sopo_cooldown >= i then
                              if sopo_cooldown[i] > 0$0 then
                                   sopo_cooldown = Replace(sopo_cooldown,i,sopo_cooldown[i]-0$0.5);

                    for i in ai_soldiers[base] diff ai_heal_these_humans[base] do
                              if GetClass(i) = class_sniper then
                                   begin
                                        //Don't bother the sniper if he/she is about to use the sopo ammo.
                                        temp_list = GetTaskList(i);
                                        if temp_list > 0 then
                                             if temp_list[1][1] = 'n' then  //['n',x,y,un_id,0,0,0]
                                                  continue;

                                        un1 = Attacks(i);
                                        if un1 > 0 and GetType(un1) = unit_human then
                                             begin
                                                  val = true;
                                                  if sopo_cooldown >= i then
                                                       if sopo_cooldown[i] > 0$0 then
                                                            val = false;

                                                  if val then
                                                       begin
                                                            ComAttackSoporific(i,un1);
                                                            sopo_cooldown = Replace(sopo_cooldown,i,0$10);
                                                       end;
                                             end;
                                   end;
               end;

          until false;
     end;

//Make defending bazookers shoot time shifting rockets at their targets.
Every 0$1+0$0.1 do
     var side, base, i, temp_list, un1, temp_list_2, temp_value, val, lapsers;
     begin


          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    if base in [1,3] then
                         continue;

                    side = GetBaseSide(base);

                    //Find time lapsers
                    lapsers = [];

                    for i in ai_bunkers[base] ^ ai_turrets[base] do
                        if GetBase(i) > 0 then
                           if GetBWeapon(i) = ru_time_lapser and IsOk(i) and ( UnitsInside(i) > 0 or GetBType(i) = b_turret ) and GetEnergy( GetBase(i) )[4] > 0 then
                              lapsers = lapsers ^ i;



                    //Control bazookers
                    for i in ai_soldiers[base] diff ai_heal_these_humans[base] do
                              if GetClass(i) = class_bazooker then
                                   begin
                                        //Don't bother the bazooker if he/she is about to fire a time shifting or space shifting rocket.
                                        temp_list = GetTaskList(i);
                                        if temp_list > 0 then
                                             if temp_list[1][1] = '&' or temp_list[1][1] = '%' then
                                                  continue;

                                        un1 = Attacks(i);
                                        if un1 > 0 and DangerousUnits([un1]) > 0 then
                                             begin
                                                  temp_list_2 = [GetX(un1),GetY(un1)];
                                                  temp_value = false;

                                                  for val in ai_time_shift_hexes[base] ^ ai_time_shift_hexes_underway[base] do  //don't send a rocket where someone already have or (probably) soon will
                                                       if GetDistXY(temp_list_2[1],temp_list_2[2],val[1],val[2]) <= ai_time_shift_data[side][2] then
                                                            begin
                                                                 temp_value = true;
                                                                 break;
                                                            end;

                                                  //Don't shoot rockets in areas permanently time shiftet by time lapsers.
                                                  //Time lapsers affect an area with about 11 hexes radius at max level of space time technology
                                                  //and it is not affected by height. The radius is affected by stacking lapsers close to each other, though,
                                                  //but the effect is not very predictable so we will not take that into consideration here.
                                                  if not temp_value then
                                                       for val in lapsers do
                                                            if GetDistXY(temp_list_2[1],temp_list_2[2],GetX(val),GetY(val)) <= 11 then
                                                                 begin
                                                                      temp_value = true;
                                                                      break;
                                                                 end;

                                                  if not temp_value then  //not inside a time shifted area
                                                       begin
                                                            ComTimeShift(i,temp_list_2[1],temp_list_2[2]);

                                                            //The bazooker could die before he/she fires the rocket
                                                            //so we store the hex temporarily and check if the rocket actually is fired later.
                                                            temp_list = Insert(ai_time_shift_hexes_underway[base],1,[temp_list_2[1],temp_list_2[2],i]);
                                                            ai_time_shift_hexes_underway = Replace(ai_time_shift_hexes_underway,base,temp_list);
                                                       end;
                                             end;
                                   end;
               end;

          until false;
     end;

//Make defending bazookers shoot space shifting rockets at their targets.
//Doing this intelligently is extremely difficult so we just shoot one rocket from time
//to time behind a target hoping we push the target closer to our base instead of
//pushing it away.
//Only bazookers inside barrackses.
Every 0$1+0$0.2 do
     var base, i, temp_list, un1, temp_list_2, temp_value;
     var shooting_delay;
     begin
          shooting_delay = [0$0,0$0,0$0,0$0];

          repeat
          wait(0$1);

          if difficulty = 1 then
               exit;

          for base in ai_bases do
               begin
                    if base in [1,3] then
                         continue;

                    if shooting_delay[base] > 0$0 then
                         begin
                              shooting_delay = Replace(shooting_delay,base, shooting_delay[base] - 0$1 );
                              continue;
                         end;

                    if Rand(1,10) > 1 then
                         continue;

                    temp_list = [];
                    for i in ai_soldiers[base] diff ai_heal_these_humans[base] do
                         if IsInUnit(i) in ai_armouries[base] then
                              temp_list = temp_list ^ i;

                    for i in temp_list do
                              if GetClass(i) = class_bazooker then
                                   begin
                                        //Don't bother the bazooker if he/she is about to fire a time shifting or space shifting rocket.
                                        temp_list = GetTaskList(i);
                                        if temp_list > 0 then
                                             if temp_list[1][1] = '&' or temp_list[1][1] = '%' then
                                                  continue;

                                        un1 = Attacks(i);
                                        if un1 > 0 and not IsInArea(un1,GetBaseArea(base)) then
                                             begin
                                                  //Shoot just behind the target. We are higher elevated so this should be possible
                                                  temp_list_2 = [GetX(un1),GetY(un1)];
                                                  temp_value = AI_GetTurnDirection(GetX(i),GetY(i),temp_list_2[1],temp_list_2[2]);
                                                  ComSpaceShift(i, ShiftX(temp_list_2[1],temp_value,1), ShiftY(temp_list_2[2],temp_value,1) );

                                                  shooting_delay = Replace(shooting_delay,base,0$10);

                                                  break;
                                             end;
                                   end;
               end;

          until false;
     end;

//Determine which bazookers have successfully fired their time shifting rocket.
//We need an extremely short update time on this update to prevent the situation where
//a bazooker has shot a time shifting rocket but is brought to red life before the
//update runs (in which case we do not detect the time shifting rocket as fired).
Every 0$1 do
     var base, side, val, temp_value, temp_list;
     begin

          repeat
          wait(1);

          for base in ai_bases do
               begin
                    if base in [1,3] then
                         continue;

                    side = GetBaseSide(base);

                    val = 1;
                    while val <= ai_time_shift_hexes_underway[base] do
                         begin
                              temp_value = false;
                              temp_list = GetTaskList(ai_time_shift_hexes_underway[base][val][3]);

                              if IsOk(ai_time_shift_hexes_underway[base][val][3]) then  //Task list is reset upon going to red life
                                   begin
                                        if temp_list = 0 then
                                             temp_value = true
                                        else
                                             if not temp_list[1][1] = '&' then
                                                  temp_value = true;
                                   end
                              else
                                   begin
                                        temp_list = Delete(ai_time_shift_hexes_underway[base],val);
                                        ai_time_shift_hexes_underway = Replace(ai_time_shift_hexes_underway,base,temp_list);

                                        continue;
                                   end;

                              if temp_value then
                                   begin
                                        temp_list = Insert(ai_time_shift_hexes[base],1,[ai_time_shift_hexes_underway[base][val][1],ai_time_shift_hexes_underway[base][val][2],ai_time_shift_data[side][1]]);
                                        ai_time_shift_hexes = Replace(ai_time_shift_hexes,base,temp_list);

                                        temp_list = Delete(ai_time_shift_hexes_underway[base],val);
                                        ai_time_shift_hexes_underway = Replace(ai_time_shift_hexes_underway,base,temp_list);

                                        continue;
                                   end;

                              val = val + 1;
                         end;
               end;

          until false;
     end;

//Update time shifted areas (determine when they have faded away).
Every 0$1+0$0.3 do
     var base, side, val, temp_list, time;
     begin

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    if base in [3,4] then
                         continue;

                    side = GetBaseSide(base);

                    val = 1;
                    while val <= ai_time_shift_hexes[base] do
                         begin
                              time = ai_time_shift_hexes[base][val][3]-0$1;

                              if time <= 0$0 then
                                   begin
                                        temp_list = Delete(ai_time_shift_hexes[base],val);
                                        ai_time_shift_hexes = Replace(ai_time_shift_hexes,base,temp_list);

                                        continue;
                                   end
                              else
                                   begin
                                        temp_list = Replace(ai_time_shift_hexes[base][val],3,time);
                                        temp_list = Replace(ai_time_shift_hexes[base],val,temp_list);
                                        ai_time_shift_hexes = Replace(ai_time_shift_hexes,base,temp_list);
                                   end;

                              val = val + 1;
                         end;
               end;

          until false;
     end;


//Function which sends humans to buildings, distributing them equally and changing their class (if specified).
//The humans there wasn't space for will stay near the pullback hex.
//base - the base calling the function.
//human_list - list of humans
//building_list - list of buildings
//change_to_this_class - class to change to when the human has entered the building (false if none)
//building_capacity - the number of humans the building can handle
//help_building - boolean. If true then units which could not enter a building will help building the building under
//construction (if any).
//aggressive_pullback - boolean. True if movement to pullback hex should be aggressive (else just normal move)
Function DistributeHumansToBuildings(base,human_list,building_list,change_to_this_class,building_capacity,help_building,aggressive_pullback);
     var i, temp_list, val, temp_unit, area, special_un_count, counter, k, under_attack;
     begin
          if human_list = 0 then
               exit;

          area = GetBaseArea(base);
          under_attack = BaseUnderAttack(base,-1);

          //If this is soldiers going to armouries then special units
          //should be distributed equally among the armouries.
          if not GetClass(human_list[1]) in [class_engineer,class_apeman_engineer,class_mechanic,class_scientistic] and building_list > 0 then
               begin
                    val = 0;
                    for i in human_list do
                         if GetClass(i) in [class_sniper,class_mortar,class_bazooker] then
                              val = val + 1;

                    special_un_count = val div (building_list+0);
               end
          else
               special_un_count = 0;

          val = building_list+0;
          while val > 0 and human_list > 0 do
               begin
                    //Rearrange "human_list" so humans already inside this building goes
                    //first in the list. Else this algorithm could pick 6 people for a barracks
                    //let's say 2 outside and 4 actually in the barracks but there is a 5. unit
                    //inside the barracks already which is further down "human_list"- the result is
                    //one human can't get in because there isn't space.
                    temp_list = [];
                    for i in human_list do
                         if IsInUnit(i) = building_list[val] then
                              temp_list = temp_list ^ i;
                    human_list = temp_list ^ (human_list diff temp_list);

                    //Distribute humans equally to the buildings
                    counter = 0;
                    temp_list = [];
                    for i = 1 to human_list div val do
                         begin
                              if i > building_capacity then
                                   break;

                              if special_un_count = 0 then
                                   begin
                                        temp_list = temp_list ^ human_list[1];
                                        human_list = Delete(human_list,1);
                                   end
                              else
                                   if counter = special_un_count then
                                        begin
                                             //Search for a non-special unit in the list.
                                             temp_unit = 0;
                                             for k = 1 to human_list do
                                                  if not GetClass(human_list[k]) in [class_sniper,class_mortar,class_bazooker] then
                                                       begin
                                                            temp_unit = k;
                                                            break;
                                                       end;

                                             if temp_unit = 0 then
                                                  temp_unit = 1;

                                             temp_list = temp_list ^ human_list[temp_unit];
                                             human_list = Delete(human_list,temp_unit);
                                        end
                                   else
                                        begin
                                             counter = counter + 1;

                                             //Search for a special unit in the list.
                                             temp_unit = 0;
                                             for k = 1 to human_list do
                                                  if GetClass(human_list[k]) in [class_sniper,class_mortar,class_bazooker] then
                                                       begin
                                                            temp_unit = k;
                                                            break;
                                                       end;

                                             if temp_unit = 0 then
                                                  temp_unit = 1;

                                             temp_list = temp_list ^ human_list[temp_unit];
                                             human_list = Delete(human_list,temp_unit);
                                        end;
                         end;

                    for i in temp_list do
                         begin
                              temp_unit = IsInUnit(i);
                              if temp_unit <> building_list[val] then
                                   case GetType(IsInUnit(i)) of
                                        unit_vehicle: ComExitVehicle(i);
                                        unit_building: ComExitBuilding(i);
                                        else
                                             begin
                                                  if IsInArea(i,area) or not aggressive_pullback then
                                                       ComEnterUnit(i,building_list[val])
                                                  else
                                                       ComAgressiveMove(i,GetX(building_list[val]),GetY(building_list[val]));

                                                  if change_to_this_class > 0 then
                                                       begin
                                                            if GetClass(i) <> change_to_this_class and GetNation(i) <> nation_nature then  //ignore apemen
                                                                 if not ( change_to_this_class in [class_sniper,class_mortar,class_bazooker] and not GetBType(building_list[val]) in [b_barracks,b_fort] ) then  //Will change class to sniper/mortar/bazooker even if the building is only an armoury
                                                                      AddComChangeProfession(i,change_to_this_class);
                                                       end
                                                  else
                                                       begin
                                                            //If the building is a barracks then always change to the special combat class the barracks allows.
                                                            if GetBType(building_list[val]) in [b_barracks,b_fort] then
                                                                 case GetNation(building_list[val]) of
                                                                      nation_american: AddComChangeProfession(i,class_sniper);
                                                                      nation_arabian: AddComChangeProfession(i,class_mortar);
                                                                      nation_russian: AddComChangeProfession(i,class_bazooker);
                                                                 end;
                                                       end;
                                             end;
                                   end;
                         end;

                    val = val - 1;
               end;

          if human_list > 0 then
               if ai_building_under_construction[base] > 0 and help_building and not under_attack then
                    begin
                         for i in GetHumansOutOfUnits(human_list) do
                              SetTaskList(i,[['h',0,0,ai_building_under_construction[base],0,0,0]]);  //'h' is "help building building"
                    end
               else
                    for i in GetHumansOutOfUnits(human_list) do
                         if GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 4 then
                              if aggressive_pullback then
                                   ComAgressiveMove(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2])
                              else
                                   ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
     end;


//Engineers and Apemen Engineers
//These are the priorities (descending order):
//- If an engineer is hurt, them pull him/her back for healing.
//- Reparation of red buildings
//- Reparation of any building
//- Reconstruct destroyed buildings if necessary, but only if the base is not under attack (only engineers)
//- Gather crates in the vicinity of the base, but for engineers only if the base is not under attack.
//- Return to and stay inside the depot (if possible).
Every 0$1+0$0.3 do
     var side, i, engineers_list, temp_list, buildings_list, temp_unit, away_dist, temp_list_2, base, apemen_engineers_list, temp;
     var humans_list, crane_usable, b_value, engineers_not_allowed_to_repair_area, crane_not_allowed_to_repair_area, workers_list;
     var k, repairing_buildings, under_attack, is_dismantling;
     var crane_is_refueling, try_rebuild_again_time;
     begin
          crane_is_refueling = [false,false,false,false];

          try_rebuild_again_time = [];
          for base in ai_bases do
               try_rebuild_again_time = Replace(try_rebuild_again_time,base,0$0);

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));
                    side = GetBaseSide(base);
                    under_attack := BaseUnderAttack(base,-1);

                    //Reset "move empty manual vehicles so we can build our building"-variables if we are under attack so we can use our vehicles freely.
                    if under_attack then
                         begin
                              ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);
                              ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,[]);
                         end;

                    //Check if we can rebuild some of the buildings we couldn't before.
                    if ai_cannot_rebuild_these_buildings[base] > 0 and ( ai_engineers[base] > 0 or try_rebuild_again_time[base] >= 0$20 ) then
                         begin
                              ai_cannot_rebuild_these_buildings = Replace(ai_cannot_rebuild_these_buildings,base,[]);
                              try_rebuild_again_time = Replace(try_rebuild_again_time,base,0$0);
                         end
                    else
                         try_rebuild_again_time = Replace(try_rebuild_again_time,base, try_rebuild_again_time[base] + 0$1 );


                    engineers_list = ai_engineers[base] diff ai_heal_these_humans[base];
                    apemen_engineers_list = ai_apemen_engineers[base] diff ai_heal_these_humans[base];


                    //Identify engineers who need healing
                    temp_list = ai_heal_these_humans[base];
                    humans_list = engineers_list ^ apemen_engineers_list;
                    i = 1;
                    while i <= humans_list do
                         begin
                              if GetLives(humans_list[i]) <= 700 then
                                   begin
                                        temp_list = temp_list ^ humans_list[i];
                                        engineers_list = engineers_list diff humans_list[i];
                                        apemen_engineers_list = apemen_engineers_list diff humans_list[i];
                                        humans_list = Delete(humans_list,i);

                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Crane
                    crane_usable = false;
                    if ai_crane[base] > 0 then
                         begin
                              if GetControl(ai_crane[base]) = control_manual and not ai_crane[base] = ai_vehicle_being_moved[base] then
                                   begin
                                        temp_list = UnitsInside(ai_crane[base]);
                                        if temp_list > 0 then
                                             if temp_list[1] <> ai_crane_driver[base] then
                                                  ComExitVehicle(temp_list[1]);
                                   end;

                              if GetLives(ai_crane[base]) <= 500 or ( ai_crane_driver[base] > 0 and GetLives(ai_crane_driver[base]) <= 500 ) or ( ai_crane_is_being_repaired[base] and ( GetLives(ai_crane[base]) < 1000 or ( ai_crane_driver[base] > 0 and GetLives(ai_crane_driver[base]) < 1000 ) ) ) then
                                   begin
                                        ai_crane_is_being_repaired = Replace(ai_crane_is_being_repaired,base,true);

                                        //Code for defending mechanics below will take care of repairing the crane
                                        if GetDistUnitXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 6 then
                                             ComMoveXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                                   end
                              else
                                   begin
                                        ai_crane_is_being_repaired = Replace(ai_crane_is_being_repaired,base,false);

                                        //Refuel if necessary
                                        if GetEngine(ai_crane[base]) = engine_combustion then
                                             begin
                                                  i = GetFuel(ai_crane[base]);
                                                  temp = NearestUnitToUnit( unitfilter(ai_depots[base],[f_ok]), ai_crane[base]);

                                                  if i > 90 or temp = 0 then
                                                       crane_is_refueling = Replace(crane_is_refueling,base,false)
                                                  else
                                                       if i < 25 or crane_is_refueling[base] then
                                                            begin
                                                                 ComMoveUnit(ai_crane[base],temp);
                                                                 AddComRefuel(ai_crane[base],temp);
                                                                 crane_is_refueling = Replace(crane_is_refueling,base,true);
                                                            end;
                                             end;

                                        if not crane_is_refueling[base] then
                                             crane_usable = true;
                                   end;
                         end;

                    if engineers_list = 0 and apemen_engineers_list = 0 and not crane_usable then
                         continue;

                    //Recapture buildings if necessary. Depots first. Here we assume the player hasn't changed the base
                    //of the captured building.
                    //Apemen engineers and cranes can't capture buildings.
                    temp_list_2 = UnitFilter(engineers_list,[f_class,class_engineer]);
                    if ai_captured_buildings[base] > 0 and temp_list_2 > 0 then
                         begin
                              temp_list = [];
                              for i in ai_captured_buildings[base] do
                                   if GetBType(i) in [b_depot,b_warehouse] then
                                        temp_list = temp_list ^ 1
                                   else
                                        temp_list = temp_list ^ 0;

                              temp_list = SortListByListDesc(ai_captured_buildings[base],temp_list);

                              //Normal "ComEnterUnit" for capturing doesn't work for buildings which can't be entered (e.g. power plants).
                              temp_list_2 = GetHumansOutOfUnits(temp_list_2);
                              if temp_list_2 > 0 then
                                   begin
                                        temp_list_2 = SortListByListDesc(temp_list_2, temp_list_2);  //To ensure we take the same unit each time
                                        SetTaskList(temp_list_2[1],[['e',GetX(temp_list[1]),GetY(temp_list[1]),temp_list[1],0,0,0]]);
                                        engineers_list = engineers_list diff temp_list_2[1];
                                   end;

                              if engineers_list = 0 and apemen_engineers_list = 0 and not crane_usable then
                                   continue;
                         end;

                    //Find buildings which need to be repaired. At least one engineer for each if possible.
                    //If the base is under attack human (not including apemen) engineers may not be allowed
                    //to repair certain buildings.
                    //The crane may not be allowed to repair certain buildings at all (e.g. because it can't reach
                    //them).
                    case base of
                         1: begin
                              engineers_not_allowed_to_repair_area = 0;
                              crane_not_allowed_to_repair_area = 0;
                         end;
                         2: begin
                              engineers_not_allowed_to_repair_area = 0;
                              crane_not_allowed_to_repair_area = 0;
                         end;
                         3: begin
                              engineers_not_allowed_to_repair_area = 0;
                              crane_not_allowed_to_repair_area = 0;
                         end;
                         4: begin
                              engineers_not_allowed_to_repair_area = 0;
                              crane_not_allowed_to_repair_area = 0;
                         end;
                    end;

                    repairing_buildings = [false,false,false];  //True if group is repairing a building

                    for k = 1 to 3 do begin

                    //1 = apemen engineers
                    //2 = human engineers
                    //3 = crane

                    i = 1;
                    buildings_list = [];
                    repeat
                         case i of
                              1: buildings_list = UnitFilter(ai_all_buildings[base] diff ai_dismantle_these_buildings[base],[f_not,[f_ok]]);  //If building is dead then it won't be part of ai_all_buildings
                              2: buildings_list = UnitFilter(ai_all_buildings[base] diff ai_dismantle_these_buildings[base],[f_not,[f_lives,1000]]);
                         end;

                         case k of
                              2: begin
                                   if under_attack and engineers_not_allowed_to_repair_area > 0 then
                                        buildings_list = UnitFilter(buildings_list,[f_not,[f_inarea,engineers_not_allowed_to_repair_area]]);
                              end;
                              3: begin
                                   if crane_not_allowed_to_repair_area > 0 then
                                        buildings_list = UnitFilter(buildings_list,[f_not,[f_inarea,crane_not_allowed_to_repair_area]]);
                              end;
                         end;

                         i = i + 1;
                    until buildings_list > 0 or i > 2;


                    //if a building is affected by radiation (by artifact tech) then engs shouldn't come near it
                    buildings_list = buildings_list diff ai_units_irradiated;


                    if buildings_list > 0 then
                         begin
                              case k of
                                   1: begin
                                        if apemen_engineers_list > 0 then
                                             repairing_buildings = Replace(repairing_buildings,k,true);

                                        workers_list = GetHumansOutOfUnits(apemen_engineers_list);
                                   end;
                                   2: begin
                                        if engineers_list > 0 then
                                             repairing_buildings = Replace(repairing_buildings,k,true);

                                        workers_list = GetHumansOutOfUnits(engineers_list);
                                   end;
                                   3: begin
                                        if ai_crane[base] > 0 then
                                             repairing_buildings = Replace(repairing_buildings,k,true);

                                        if ai_crane[base] > 0 and crane_usable then
                                             begin
                                                  workers_list = [ai_crane[base]];
                                                  crane_usable = false;
                                             end
                                        else
                                             workers_list = [];
                                   end;
                              end;

                              repeat
                                   i = 1;
                                   while i <= buildings_list do
                                        begin
                                             if workers_list = 0 then
                                                  break;

                                             temp_unit = NearestUnitToUnit(workers_list,buildings_list[i]);
                                             ComRepairBuilding(temp_unit,buildings_list[i]);

                                             workers_list = workers_list diff temp_unit;
                                             engineers_list = engineers_list diff temp_unit;
                                             apemen_engineers_list = apemen_engineers_list diff temp_unit;

                                             i = i + 1;
                                        end;

                              until workers_list = 0;
                         end;
                    end;

                    if true in repairing_buildings then
                         begin
                              //Humans and/or apemen could possibly not be repairing anything. Make them go
                              //to the depot in that case

                              temp_list = [];
                              if not repairing_buildings[1] then
                                   temp_list = temp_list ^ apemen_engineers_list;

                              if not repairing_buildings[2] then
                                   temp_list = temp_list ^ engineers_list;

                              //!!!!!!!!!!!!!!!!
                              //CAPACITY 5 BECAUSE OF LEADERS
                              //!!!!!!!!!!!!!!!!

                              DistributeHumansToBuildings(base,temp_list, UnitFilter(ai_depots[base],[[f_ok],[f_not,[f_constructed]]]),
                                   class_engineer,[5,5,5][base],false,false);

                              continue;
                         end;


                    if not under_attack then
                         begin
                              //Reconstruct buildings if any has been destroyed.
                              //First check if a building is already being constructed - then build that one first.
                              //Upgrading buildings can be hard if the building is working or something, so check if the
                              //building is actually under construction (or being upgraded) - if not then reset the
                              //relevant variables.
                              if ai_building_under_construction[base] > 0 then
                                   if BuildingStatus(ai_building_under_construction[base]) = bs_build then
                                        begin
                                             temp_list_2 = GetHumansOutOfUnits(engineers_list ^ apemen_engineers_list);

                                             if crane_usable and not IsInArea(ai_building_under_construction[base],crane_not_allowed_to_repair_area) then
                                                  temp_list_2 = temp_list_2 ^ ai_crane[base];

                                             for i in temp_list_2 do
                                                  ComRepairBuilding(i,ai_building_under_construction[base]);

                                             continue;
                                        end
                                   else
                                        begin
                                             ComCancel(ai_building_under_construction[base]);  //To make sure upgrade of building is possible
                                             ai_building_under_construction = Replace(ai_building_under_construction,base,0);
                                        end;

                              //Dismantle buildings. This goes before constructing buildings because we may have to construct a building
                              //on the spot where a building to dismantle is now. If we are already constructing a building we wait, though.
                              //Only engineers can dismantle buildings (apemen engineers and cranes cannot).
                              if ai_dismantle_these_buildings[base] > 0 and engineers_list > 0 then
                                   begin
                                        is_dismantling = true;

                                        //Find someone to dismantle, preferably the building constructor
                                        if ai_building_constructor[base] in engineers_list then
                                             k = ai_building_constructor[base]
                                        else
                                             k = BestFromListByList(engineers_list, engineers_list);  //Make sure we take the same unit each time

                                        engineers_list = engineers_list diff k;

                                        case GetType(IsInUnit(k)) of
                                             unit_vehicle: ComExitVehicle(k);
                                             unit_building: ComExitBuilding(k);
                                             else
                                                  ComDismantle(k,ai_dismantle_these_buildings[base][1]);
                                        end;
                                   end
                              else
                                   is_dismantling = false;

                              if ( ai_all_buildings[base] - ai_excepted_buildings[base] < ai_buildings_locations[base] or ai_upcoming_building_data[base] > 0 ) and not is_dismantling then
                                   begin
                                        //Decide which building to construct. We take the first building in the location list which is
                                        //arranged in prioritated order.
                                        if ai_upcoming_building_data[base] = 0 then
                                             begin
                                                  temp_list = [];
                                                  for i in ai_buildings_locations[base] do
                                                       if GetBType(HexInfo(i[1],i[2])) = -1 and not i in ai_cannot_rebuild_these_buildings[base] then  //no building on the spot
                                                            begin
                                                                 temp_list = i;
                                                                 break;
                                                            end;

                                                  if temp_list > 0 then  //Not necessarily the case (one of our buildings could have been captured)
                                                       begin
                                                            //If the building is a bunker then check if we have enough soldiers
                                                            //to occupy it. If not then build a turret instead.
                                                            if temp_list[4] = b_bunker and GetBaseNation(base) in [nation_american,nation_russian] then
                                                                 begin
                                                                      k = 0;

                                                                      for i in ai_buildings_locations[base] do
                                                                           if i[4] in [b_breastwork,b_bunker,b_armoury,b_barracks,b_fort] then
                                                                                k = k + 1;

                                                                      if k > ai_soldiers[base] then
                                                                           begin
                                                                                //Permanently change this to a turret. It would be nice if it would still be built as a
                                                                                //bunker if soldiers are added later but that's a rare case and adds unnecessary complexity.
                                                                                for i = 1 to ai_buildings_locations[base] do
                                                                                     if ai_buildings_locations[base][i] = temp_list then
                                                                                          begin
                                                                                               temp_list_2 = Replace(ai_buildings_locations[base][i],4,b_turret);
                                                                                               temp_list_2 = Replace(ai_buildings_locations[base],i,temp_list_2);
                                                                                               ai_buildings_locations = Replace(ai_buildings_locations,base,temp_list_2);

                                                                                               break;
                                                                                          end;

                                                                                temp_list = Replace(temp_list,4,b_turret);
                                                                           end;
                                                                 end;

                                                            ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,temp_list);
                                                       end;
                                             end;

                                        if ai_upcoming_building_data[base] > 0 then
                                             begin
                                                  //Find the best engineer to construct the building
                                                  if ai_building_constructor[base] = 0 then
                                                       begin
                                                            temp_list_2 = UnitFilter(ai_engineers[base],[f_class,class_engineer]);

                                                            if temp_list_2 > 0 then
                                                                 begin
                                                                      temp_list = [];
                                                                      for i in temp_list_2 do
                                                                           temp_list = temp_list ^ GetSkill(i,skill_engineering);
                                                                      ai_building_constructor = Replace(ai_building_constructor,base, BestFromListByList(temp_list_2,temp_list) );
                                                                 end
                                                            else
                                                                 if ai_engineers[base] = 0 and ai_crane[base] > 0 and crane_usable then
                                                                      begin
                                                                           if InArea(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],crane_not_allowed_to_repair_area) then
                                                                                begin
                                                                                     //Can't build this building with a crane.
                                                                                     temp_list = ai_cannot_rebuild_these_buildings[base] ^ [ai_upcoming_building_data[base]];
                                                                                     ai_cannot_rebuild_these_buildings = Replace(ai_cannot_rebuild_these_buildings,base,temp_list);

                                                                                     ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);
                                                                                end
                                                                           else
                                                                                ai_building_constructor = Replace(ai_building_constructor,base,ai_crane[base]);
                                                                      end;
                                                       end;

                                                  if ai_building_constructor[base] > 0 and ( ai_building_constructor[base] in engineers_list or ( ai_building_constructor[base] = ai_crane[base] and crane_usable ) ) then
                                                       begin
                                                            engineers_list = engineers_list diff ai_building_constructor[base];

                                                            if ai_building_constructor[base] = ai_crane[base] then
                                                                 crane_usable = false;

                                                            //Move vehicles away from the building site.
                                                            away_dist = 7; //Max distance needed for a workshop
                                                            if ai_vehicle_being_moved[base] = 0 then
                                                                 begin
                                                                      temp_list = UnitFilter(ai_vehicles_defend[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_control_tower_vehicles[base] ^ ai_crane[base] ^ ai_cargo_bay[base] ^ ai_sib_bomb_vehicles[base],
                                                                                             [[f_control,control_manual],[f_empty],[f_distxy,ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],away_dist]]);  //Don't consider "ai_vehicles_attack" - they will soon move by themselves
                                                                      if temp_list > 0 then
                                                                           begin
                                                                                if ai_building_constructor[base] = ai_crane[base] then
                                                                                     begin
                                                                                          //Can't build this building with a crane.
                                                                                          temp_list = ai_cannot_rebuild_these_buildings[base] ^ [ai_upcoming_building_data[base]];
                                                                                          ai_cannot_rebuild_these_buildings = Replace(ai_cannot_rebuild_these_buildings,base,temp_list);

                                                                                          ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);
                                                                                          ai_building_constructor = Replace(ai_building_constructor,base,0);
                                                                                     end
                                                                                else
                                                                                     begin
                                                                                          ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,temp_list[1]);
                                                                                          temp_list_2 = ai_vehicles_having_been_moved[base] ^ temp_list[1];
                                                                                          ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,temp_list_2);
                                                                                     end;
                                                                           end
                                                                      else
                                                                           //Build/upgrade the building
                                                                           case GetType(IsInUnit(ai_building_constructor[base])) of
                                                                                unit_building: ComExitBuilding(ai_building_constructor[base]);
                                                                                unit_vehicle: ComExitVehicle(ai_building_constructor[base]);
                                                                                else
                                                                                case GetBType(HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2])) of
                                                                                     -1: begin
                                                                                          case ai_upcoming_building_data[base][4] of
                                                                                               b_warehouse: i = b_depot;
                                                                                               b_factory: i = b_workshop;
                                                                                               b_lab_half,b_lab_full: i = b_lab;
                                                                                               b_barracks: i = b_armoury;
                                                                                               else i = ai_upcoming_building_data[base][4];
                                                                                          end;

                                                                                          //ComBuild(ai_building_constructor[base],i,ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],ai_upcoming_building_data[base][3]);
                                                                                          //ComBuild doesn't work with cranes even though their task list looks the same after having been given the order.
                                                                                          //The task list order looks like this:
                                                                                          {
                                                                                          SetTaskList(crane,[['B',x,y,0,value_from_below,dir,0]]);
                                                                                          b_depot (0) = (ru) 64, (am) 1, (ar) 34
                                                                                          b_workshop (2) = (ru) 68, (am) 5, (ar) 38
                                                                                          b_armoury (4) = (ru) 66, (am) 3, (ar) 36
                                                                                          b_lab (6) = (ru) 77, (am) 17, (ar) 48
                                                                                          b_oil_power (26) = (ru) 85, (am) 25, (ar) 56
                                                                                          b_solar_power (27) = (am) 26, (ar) 57
                                                                                          b_siberite_power (28) = (ru) 86, (am) 27, (ar) 58
                                                                                          b_oil_mine (29) = (ru) 87, (am) 28, (ar) 59
                                                                                          b_siberite_mine (30) = (ru) 88, (am) 29, (ar) 60
                                                                                          b_breastwork (31) = (ru) 89, (am) 30, (ar) 61
                                                                                          b_bunker (32) = (ru) 90, (am) 31, (ar) 62
                                                                                          b_turret (33) = (ru) 91, (am) 32
                                                                                          b_teleport (34) = (ru) 92
                                                                                          b_control_tower (36) = (am) 94
                                                                                          b_ext_track (16) = (ru) 70, (am) 7, (ar) 40
                                                                                          b_ext_gun (17) = (ru) 71, (am) 8, (ar) 41
                                                                                          b_ext_rocket (18) = (ru) 72, (am) 9, (ar) 42
                                                                                          b_ext_noncombat (19) = (ru) 73, (am) 10
                                                                                          b_ext_radar (20) = (am) 11, (ar) 44
                                                                                          b_ext_siberium (21) = (ru) 75, (am) 12, (ar) 45
                                                                                          b_ext_stitch (23) = (ar) 43
                                                                                          b_ext_computer (24) = (ru) 76, (am) 15
                                                                                          b_ext_laser (25) = (am) 16
                                                                                          }
                                                                                          case i of
                                                                                               b_depot: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 64;
                                                                                                         nation_american: b_value = 1;
                                                                                                         nation_arabian: b_value = 34;
                                                                                                    end;
                                                                                               end;
                                                                                               b_workshop: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 68;
                                                                                                         nation_american: b_value = 5;
                                                                                                         nation_arabian: b_value = 38;
                                                                                                    end;
                                                                                               end;
                                                                                               b_armoury: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 66;
                                                                                                         nation_american: b_value = 3;
                                                                                                         nation_arabian: b_value = 36;
                                                                                                    end;
                                                                                               end;
                                                                                               b_lab: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 77;
                                                                                                         nation_american: b_value = 17;
                                                                                                         nation_arabian: b_value = 48;
                                                                                                    end;
                                                                                               end;
                                                                                               b_oil_power: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 85;
                                                                                                         nation_american: b_value = 25;
                                                                                                         nation_arabian: b_value = 56;
                                                                                                    end;
                                                                                               end;
                                                                                               b_solar_power: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = 26;
                                                                                                         nation_arabian: b_value = 57;
                                                                                                    end;
                                                                                               end;
                                                                                               b_siberite_power: begin
                                                                                                   case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 86;
                                                                                                         nation_american: b_value = 27;
                                                                                                         nation_arabian: b_value = 58;
                                                                                                    end;
                                                                                               end;
                                                                                               b_oil_mine: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 87;
                                                                                                         nation_american: b_value = 28;
                                                                                                         nation_arabian: b_value = 59;
                                                                                                    end;
                                                                                               end;
                                                                                               b_siberite_mine: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 88;
                                                                                                         nation_american: b_value = 29;
                                                                                                         nation_arabian: b_value = 60;
                                                                                                    end;
                                                                                               end;
                                                                                               b_breastwork: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 89;
                                                                                                         nation_american: b_value = 30;
                                                                                                         nation_arabian: b_value = 61;
                                                                                                    end;
                                                                                               end;
                                                                                               b_bunker: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 90;
                                                                                                         nation_american: b_value = 31;
                                                                                                         nation_arabian: b_value = 62;
                                                                                                    end;
                                                                                               end;
                                                                                               b_turret: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 91;
                                                                                                         nation_american: b_value = 32;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_teleport: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 92;
                                                                                                         nation_american: b_value = -7;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_control_tower: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = 94;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_track: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 70;
                                                                                                         nation_american: b_value = 7;
                                                                                                         nation_arabian: b_value = 40;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_gun: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 71;
                                                                                                         nation_american: b_value = 8;
                                                                                                         nation_arabian: b_value = 41;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_rocket: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 72;
                                                                                                         nation_american: b_value = 9;
                                                                                                         nation_arabian: b_value = 42;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_noncombat: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 73;
                                                                                                         nation_american: b_value = 10;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_radar: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = 11;
                                                                                                         nation_arabian: b_value = 44;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_siberium: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 75;
                                                                                                         nation_american: b_value = 12;
                                                                                                         nation_arabian: b_value = 45;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_stitch: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = -7;
                                                                                                         nation_arabian: b_value = 43;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_computer: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 76;
                                                                                                         nation_american: b_value = 15;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_laser: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = 16;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               else
                                                                                                    b_value = -42;
                                                                                          end;
                                                                     

                                                                                          if ai_upcoming_building_data[base][1] > 0 and ai_upcoming_building_data[base][2] > 0 and b_value >= 0 and ai_upcoming_building_data[base][3] in [0,1,2,3,4,5] then
                                                                                             SetTaskList(ai_building_constructor[base],[['B',ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],0,b_value,ai_upcoming_building_data[base][3],0]]);
                                                                                     end;
                                                                                     b_depot: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_workshop: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_lab,b_lab_half: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);

                                                                                          if ai_upcoming_building_data[base][5] <> b_lab_basic and not ai_upcoming_building_data[base][5] in [GetLabKind(temp_unit,1),GetLabKind(temp_unit,2)] then
                                                                                               begin
                                                                                                    ComUpgradeLab(temp_unit,ai_upcoming_building_data[base][5]);


                                                                                               end
                                                                                          else
                                                                                               if ai_upcoming_building_data[base][6] <> b_lab_basic then
                                                                                                    begin
                                                                                                         ComUpgradeLab(temp_unit,ai_upcoming_building_data[base][6]);


                                                                                                    end
                                                                                               else  //should never happen
                                                                                                    begin
                                                                                                         ai_building_constructor = Replace(ai_building_constructor,base,0);
                                                                                                         ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);
                                                                                                    end;

                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_armoury: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                end;
                                                                           end;
                                                                 end
                                                            else
                                                                 if UnitsInside(ai_vehicle_being_moved[base]) > 0 then
                                                                      begin
                                                                           if GetDistUnitXY(ai_vehicle_being_moved[base],ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]) <= away_dist then
                                                                                AI_GetAwayFromXY(ai_vehicle_being_moved[base],ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],away_dist+2,false)
                                                                           else
                                                                                ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);
                                                                      end
                                                                 else
                                                                      case GetType(IsInUnit(ai_building_constructor[base])) of
                                                                           unit_building: ComExitBuilding(ai_building_constructor[base]);
                                                                           unit_vehicle: ComExitVehicle(ai_building_constructor[base]);
                                                                           else
                                                                                ComEnterUnit(ai_building_constructor[base],ai_vehicle_being_moved[base]);
                                                                      end;
                                                       end;
                                             end;
                                   end;


                              //Gather crates in the vicinity of the base (engineers).
                              //Everyone go after the same bunch of crates.
                              if (engineers_list ^ apemen_engineers_list) > 0 and ai_depots[base][1] > 0 then
                                   begin
                                        temp_list = GetListOfCratesInArea(GetBaseArea(base));
                                        while temp_list > 0 do
                                             begin
                                                  if GetResourceTypeXY(temp_list[1],temp_list[2]) = mat_artifact then
                                                       begin
                                                            temp_list = Delete(temp_list,1);
                                                            temp_list = Delete(temp_list,1);
                                                            continue;
                                                       end;

                                                  ComCollect(GetHumansOutOfUnits(engineers_list ^ apemen_engineers_list),temp_list[1],temp_list[2]);
                                                  engineers_list = [];
                                                  apemen_engineers_list = [];

                                                  break;
                                             end;
                                   end;
                         end;


                    //Return to and stay inside the depot (if possible)
                    //!!!!!!!!!!!!!!!!
                    //CAPACITY 5 BECAUSE OF LEADERS
                    //!!!!!!!!!!!!!!!!
                    DistributeHumansToBuildings(base,engineers_list ^ apemen_engineers_list, UnitFilter(ai_depots[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_engineer,[5,5,5][base],false,false);

                    if crane_usable then
                         if not IsInArea(ai_crane[base],GetBaseArea(base)) then
                              ComMoveXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2])
                         else
                              if GetLives(ai_crane[base]) < 1000 and not under_attack then
                                   ai_crane_is_being_repaired = Replace(ai_crane_is_being_repaired,base,true);
               end;

          until false;
     end;
On BuildingStarted(building,builder) do
     var side, temp_list, base, i;
     begin
          side = GetSide(building);
          if side = you then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          ai_building_constructor = Replace(ai_building_constructor,base,0);
          ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,[]);

          //ONLY 1 building is under construction at a time!
          ai_building_under_construction = Replace(ai_building_under_construction,base,building);

          if GetSide(building) = 1 then
             DoNotAttack(4,building);
     end;
On BuildingComplete(building) do
     var side, temp_list, temp_unit, base, i, hex;
     begin
          side = GetSide(building);
          if side = you then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          if ai_sib_bomb_fact_location[base] > 0 then
               if ai_upcoming_building_data[base][1] = ai_sib_bomb_fact_location[base][1] and ai_upcoming_building_data[base][2] = ai_sib_bomb_fact_location[base][2] then
                    ai_sib_bomb_fact = Replace(ai_sib_bomb_fact,base,building);

          hex = [GetX(building),GetY(building)];
          if hex in ai_fact_extension_replace_locations[base] then
               begin
                    for i in ai_facts[base] do
                         if ai_facts_with_ext_rebuild_map >= i then
                              begin
                                   temp_list = ai_facts_with_ext_rebuild_map[i] diff [hex];
                                   ai_facts_with_ext_rebuild_map = Replace(ai_facts_with_ext_rebuild_map,i,temp_list);
                              end;
               end;

          BuildUpgradeCommon(base,building);

          temp_list = ai_all_buildings[base] ^ building;
          ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

          UpdateBuildingBasicVariables(base,building,true);


          if Base = 2 then
          begin
               if GetBType(building) = b_depot then
                  if IsInArea(building, ru_scan1) then
                     RuDepot1 = building
                  else
                      RuDepot2 = building;


               if IsInArea(building, ru_scan1) then
                  AddComLinkToBase(RuDepot1, building)
               else
                   AddComLinkToBase(RuDepot2, building);
          end;
     end;
On UpgradeComplete(building) do
     var side, temp_list, base;
     begin
          side = GetSide(building);
          if side = you then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          BuildUpgradeCommon(base,building);
     end;
Function BuildUpgradeCommon(base,building);
     begin
          //Some buildings require upgrade - e.g. workshop -> factory
          if GetBType(building) = ai_upcoming_building_data[base][4] then
               ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);

          ai_building_under_construction = Replace(ai_building_under_construction,base,0);
     end;
On BuildingCaptured(captured_building,building_former_side,capturing_unit) do
     var temp_list, base, i;
     begin
          if IsInArea(captured_building, base_legion) then
             base = 1
          else
              if IsInArea(captured_building, base_russians) then
                 base = 2
              else
                  if IsInArea(captured_building, base_us) then
                     base = 3
                  else base = 0;


          if GetBType(captured_building) in [b_depot,b_warehouse] then
             case base of
                  0: begin
                          SetResourceType(GetBase(captured_building),mat_cans,0);
                          SetResourceType(GetBase(captured_building),mat_oil,150);
                          SetResourceType(GetBase(captured_building),mat_siberit,0);
                     end;
                  1: begin
                          SetResourceType(GetBase(captured_building),mat_cans,100);
                          SetResourceType(GetBase(captured_building),mat_oil,200);
                          SetResourceType(GetBase(captured_building),mat_siberit,0);
                     end;
                  2: begin
                          SetResourceType(GetBase(captured_building),mat_cans,200);
                          SetResourceType(GetBase(captured_building),mat_oil,200);
                          SetResourceType(GetBase(captured_building),mat_siberit,1000 + Rand(500, 4000));
                     end;
                  3: begin
                          if building_former_side = 4 then
                          begin
                               SetResourceType(GetBase(captured_building),mat_cans,0);
                               SetResourceType(GetBase(captured_building),mat_oil,0);
                               SetResourceType(GetBase(captured_building),mat_siberit,0);
                          end
                          else
                          begin
                               SetResourceType(GetBase(captured_building),mat_cans,100);
                               SetResourceType(GetBase(captured_building),mat_oil,200);
                               SetResourceType(GetBase(captured_building),mat_siberit,[300,240,160][difficulty]);
                          end;
                     end;
             end;

          if base = 0 then
               exit;

          if building_former_side = GetBaseSide(base) then
               begin
                    //Someone captured one of our buildings!
                    RemoveBuildingFromVariables(base,captured_building);

                    temp_list = ai_captured_buildings[base] ^ captured_building;
                    ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
               end
          else
               begin
                    if GetSide(captured_building) = GetBaseSide(base) then
                         begin
                              //Ha! We captured it back again!
                              temp_list = ai_all_buildings[base] ^ captured_building;
                              ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

                              UpdateBuildingBasicVariables(base,captured_building,true);

                              temp_list = ai_captured_buildings[base] diff captured_building;
                              ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
                         end;
               end;
     end;


//Function which orders human units inside other units to exit them. Returns a list with the units which weren't inside other units.
Export Function GetHumansOutOfUnits(un_list);
     var i;
     begin
          result = [];
          for i in un_list do
               case GetType(IsInUnit(i)) of
                    unit_building: ComExitBuilding(i);
                    unit_vehicle: ComExitVehicle(i);
                    else result = result ^ i;
               end;
     end;


//Function which tells if a base is under attack.
//attack_side - side which is attacking def_side's base. -1 if any enemy side of the base's side.
Export Function BaseUnderAttack(base,attack_side);
     var area, i, val, def_side, temp_list, temp;
     begin
          result = false;

          def_side = GetBaseSide(base);
          area = GetBaseArea(base);

          if attack_side = def_side then
               exit;

          if attack_side = -1 then
               begin
                    for i = 1 to 8 do
                         if ai_sib_bomb_used_time_matrix[base][i] > -1 and ai_sib_bomb_used_time_matrix[base][i] + ai_sib_bomb_contamination_duration >= tick then
                              begin
                                   result = true;
                                   exit;
                              end;


                    temp_list = FilterAllUnits([[f_enemy,def_side],[f_inarea,area]]);

                    if def_side = Americans then
                       temp_list = temp_list diff FilterAllUnits([f_side,americans_alt]);  //The two American sides have to be set as enemy, but shouldn't attack each other

                    if temp_list > 0 then
                    begin
                         result = true;
                         exit;
                    end;


                    val = true;
                    for i in ai_contact_time[def_side] do
                         if i < 0$10 then
                              begin
                                   val = false;
                                   break;
                              end;

                    if ContactTime(def_side) >= 0$10 and val then
                         exit;

                    {
                    //if ListFilterNearArea( FilterAllUnits([f_enemy,def_side]) ,area) = 0 then
                    //     exit;
                    //The above was the former way of checking if enemy units was nearby but this implied looping through
                    //a lot of units on the map (in function ListFilterNearArea). This caused laggs. Filter-functions like
                    //FilterAllUnits are much much faster than loops with function calls. All we need is to assume that no
                    //unit inside another base's area will ever attack another base which seems reasonable.
                    temp_list = [];
                    for i in (ai_bases diff base) do
                         temp_list = Insert(temp_list,1,[f_not,[f_inarea,GetBaseArea(i)]]);

                    temp_list = FilterAllUnits([[f_enemy,def_side],[f_not,[f_type,unit_building]]] ^ temp_list);
                    if not AnyNearBaseArea(temp_list,base) then
                         exit;
                     }

                    temp = [le_attack_detection,ru_attack_detection,us_attack_detection][base];
                    if FilterUnitsInArea(temp, [[f_enemy,def_side],[f_not,[f_side,4]]]) = 0 then
                       exit;
               end
          else
               begin
                    if ai_sib_bomb_used_time_matrix[base][attack_side] > -1 and ai_sib_bomb_used_time_matrix[base][attack_side] + ai_sib_bomb_contamination_duration >= tick then
                         begin
                              result = true;
                              exit;
                         end;

                    if FilterAllUnits([[f_side,attack_side],[f_inarea,area]]) > 0 then
                         begin
                              result = true;
                              exit;
                         end;

                    if ContactTime([def_side,attack_side]) >= 0$10 and ai_contact_time[def_side][attack_side] >= 0$10 then
                         exit;

                    //if ListFilterNearArea( FilterAllUnits([f_side,attack_side]) ,area) = 0 then
                    //     exit;
                    temp_list = [];
                    for i in (ai_bases diff base) do
                         temp_list = Insert(temp_list,1,[f_not,[f_inarea,GetBaseArea(i)]]);

                    temp_list = FilterAllUnits([[f_side,attack_side],[f_not,[f_type,unit_building]]] ^ temp_list);
                    if not AnyNearBaseArea(temp_list,base) then
                         exit;
               end;

          result = true;    
     end;
Export Function ListFilterNearArea(list,area);
     var i;
     begin
          result = [];

          for i in list do
               if GetDistUnitArea(i,area) <= ai_near_base_dist then
                    result = result ^ i;
     end;
Function AnyNearBaseArea(list,base);
     var i, area;
     begin
          result = false;
          area = GetBaseArea(base);

          for i in list do
               if GetDistUnitArea(i,area) <= ai_near_base_dist then
                    begin
                         result = true;
                         break;
                    end;
     end;

On Command(com) do
     var i, temp_list, hex_list, un, k, target_hex, temp;
     begin

          if com = 74 then       //cargo unload
             for i in FilterAllUnits([[f_side,2],[f_or,[f_weapon,ar_cargo_bay],[f_weapon,ru_cargo_bay],[f_weapon,us_cargo_bay]]]) do
                 if GetTaskList(i) > 0 then
                    if GetTaskList(i)[1][1] = 'm' then
                       if GetCargo(i, mat_artifact) = 40 then
                       begin
                            ArtifactUse(i);
                            break;
                       end;

          if com = 71 then        //contamination
             for i in FilterAllUnits([[f_side,2],[f_class,class_scientistic]]) do
                 if GetTaskList(i) > 0 then
                    if GetTaskList(i)[1][1] = 'G' then
                    begin
                         temp = [GetTaskList(i)[1][2], GetTaskList(i)[1][3]];

                         if not InArea(temp[1], temp[2], ContaminationArea1) and not InArea(temp[1], temp[2], ContaminationArea2) and not InArea(temp[1], temp[2], ContaminationArea3) then
                            SetTaskList(i, []);
                    end;



          if com = 124 then  //attack ground
               begin
                    //Find one of the unit which were given the command
                    for i in FilterAllUnits([f_side,you]) do
                         if IsSelected(i) and HasTask(i) then
                              begin
                                   target_hex = [];
                                   for k in GetTaskList(i) do
                                        if k[1] = '|' then  //Attack ground is ['|',x,y,0,0,0,0]
                                             begin
                                                  target_hex = [k[2],k[3]];
                                                  break;
                                             end;

                                   if target_hex > 0 then
                                             begin
                                                  hex_list = target_hex;

                                                  //Units within distance 1 of the hex will take damage. Find all units within that distance.
                                                  temp_list = [];
                                                  for k = 0 to 5 do
                                                       temp_list = Insert(temp_list,1,[ShiftX(hex_list[1],k,1),ShiftY(hex_list[2],k,1)]);

                                                  hex_list = [hex_list] ^ temp_list;

                                                  temp_list = [];
                                                  for k in hex_list do
                                                       begin
                                                            un = HexInfo(k[1],k[2]);

                                                            if un > 0 and not un in temp_list then
                                                                 begin
                                                                      ai_attack_ground_info_initial = Insert(ai_attack_ground_info_initial,1,[i,un,GetSide(un),target_hex[1],target_hex[2]]);
                                                                      temp_list = temp_list ^ un;
                                                                 end;
                                                       end;
                                             end;
                              end;
               end;
     end;
//Every updating "ai_contact_time", "ai_attack_ground_info_initial" and "ai_attack_ground_info_sustain".
Every 0$1+0$0.1 do
     var a, b, temp_list, temp_list_2, yup, i, t;
     begin
          repeat
          wait(0$0.5);

          //Check if some of the units, that were going to attack ground, gave up before
          //doing so.
          i = 1;
          while i <= ai_attack_ground_info_initial do
               begin
                    yup = false;
                    for t in GetTaskList(ai_attack_ground_info_initial[i][1]) do
                         if t[1] = '|' then  //Attack ground is ['|',x,y,0,0,0,0]
                              if t[2] = ai_attack_ground_info_initial[i][4] and t[3] = ai_attack_ground_info_initial[i][5] then
                                   begin
                                        yup = true;
                                        break;
                                   end;

                    if not yup then
                         begin
                              ai_attack_ground_info_initial = Delete(ai_attack_ground_info_initial,i);
                              continue;
                         end;

                    i = i + 1;
               end;

          //Check if some of the units attacking ground has stopped.
          i = 1;
          while i <= ai_attack_ground_info_sustain do
               begin
                    yup = false;
                    for t in GetTaskList(ai_attack_ground_info_sustain[i][1]) do
                         if t[1] = '|' then  //Attack ground is ['|',x,y,0,0,0,0]
                              if t[2] = ai_attack_ground_info_sustain[i][4] and t[3] = ai_attack_ground_info_sustain[i][5] then
                                   begin
                                        yup = true;
                                        break;
                                   end;

                    if not yup then
                         begin
                              ai_attack_ground_info_sustain = Delete(ai_attack_ground_info_sustain,i);
                              continue;
                         end;

                    i = i + 1;
               end;

          //Update all times
          temp_list = ai_contact_time;
          for a = 1 to temp_list do
               for b = 1 to temp_list[a] do
                    if temp_list[a][b] < 100000 then
                         begin
                              temp_list_2 = Replace(ai_contact_time[a],b, temp_list[a][b] + 0$0.5 );
                              ai_contact_time = Replace(ai_contact_time,a,temp_list_2);
                         end;

          //New attacks?
          //Function SideShoot and UnitShoot does detect damage from attacking ground.
          for a in ai_attack_ground_info_initial do
               begin
                         if IsDead(a[2]) or UnitShoot(a[2]) = a[1] then
                              begin
                                   temp_list = Replace(ai_contact_time[you],a[3],0);
                                   ai_contact_time = Replace(ai_contact_time,you,temp_list);

                                   temp_list = Replace(ai_contact_time[a[3]],you,0);
                                   ai_contact_time = Replace(ai_contact_time,a[3],temp_list);

                                   ai_attack_ground_info_initial = ai_attack_ground_info_initial diff [a];
                                   ai_attack_ground_info_sustain = Insert(ai_attack_ground_info_sustain,1,a);
                              end;
               end;

          //Sustained attacks?
          for a in ai_attack_ground_info_sustain do
               begin
                    temp_list = Replace(ai_contact_time[you],a[3],0);
                    ai_contact_time = Replace(ai_contact_time,you,temp_list);

                    temp_list = Replace(ai_contact_time[a[3]],you,0);
                    ai_contact_time = Replace(ai_contact_time,a[3],temp_list);
               end;

          until false;
     end;

//Check for siberite rocket launches.
{On SiberiteRocketExploded(vehicle,x,y) do
     var side, base, i, temp_list;
     begin
          if InArea(x,y,south_motherlode_area) or InArea(x,y,Ru_base) then
               begin
                    ExclusiveOn;
                    wait(0$4);
                    YouLost('SibChain');
               end;
          
          if IsDead(vehicle) then  //Siberite rocket vehicle can die before rocket explodes
               exit;

          side = GetSide(vehicle);

          if side = you then
               player_fired_siberite_bomb = true;

          base = -1;
          for i in ai_bases do
               if InArea(x,y,GetBaseArea(i)) then  //Could explode right outside the base but there is no function to check distance between a hex and an area (only unit to area).
                    begin
                         base = i;
                         break;
                    end;

          if base = -1 then
               exit;

          temp_list = Replace(ai_sib_bomb_used_time_matrix[base],side,tick);
          ai_sib_bomb_used_time_matrix = Replace(ai_sib_bomb_used_time_matrix,base,temp_list);
     end;
}

//Mechanics (defending, i.e. in the base)
//Priorities if base is under attack (descending):
//- If a mechanic is hurt, pull him back for healing.
//- Repair war vehicles defending the base.
//- Stay in factory.
//Priorites if not under attack (decending):
//- If a mechanic is hurt, pull him back for healing.
//- Refuel vehicles
//- Repair damaged war vehicles within the base
//- Stay in factory (and possibly construct a vehicle or weapon)
//When it comes to American remote control we pick some mechanics to control
//specific vehicles. Their priorities are (descending):
//- If a mechanic is hurt, pull him back for healing.
//- Repair war vehicles defending the base (if all vehicles you control are burning or dead)
//- Stay in control tower and link to vehicles.
//Priorites if not under attack (decending):
//- If a mechanic is hurt, pull him back for healing.
//- Repair damaged war vehicles within the base (if all remote vehicles are inside the base)
//- Stay in control tower and link to vehicles.
Every 0$1+0$0.4 do
     var side, i, j, mechanics_list, temp_list, temp_list_3, temp_unit, temp, vehicles_list, allowed_to_repair_vehicles;
     var under_attack, free_parking_spots, k, base, area, temp_list_2, remote_mechanics, parked_vehicles, n, a;
     var temp_list_4, temp_list_5, num_control_stations, free_behemoth_parking_spots, parked_behemoths, already_inside_mecs;
     var vehicles_to_consider, vehicles_allowed_to_park, human_pullback_hex_max_dist, vehicles_to_park;
     var vehicles_drivers, remote_driver_vehicles, pullback_hex, pullback_hex_patrol, patrol_units, pullback_hex_hovercrafts;
     begin
          //Index is vehicle id, value is driver id.                                                         
          //For use to ensure the driver first chosen to drive the
          //vehicle goes for it (doesn't change to another driver).
          vehicles_drivers = [];
                                                                                                                   
          remote_driver_vehicles = [[],[],[]];  //For remote control. [driver_id,[veh1,veh2,veh3]]

          repeat                                                                                                      
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    side = GetBaseSide(base);
                    area = GetBaseArea(base);
                    under_attack = BaseUnderAttack(base,-1);  //Base under attack


                    //Update vehicles drivers so vehicles with a driver no longer has that driver assigned
                    //so a possible new driver can be assigned next time.
                    for i in ai_vehicles_defend[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] do
                         if vehicles_drivers >= i then
                              if vehicles_drivers[i] > 0 then
                                   if IsInUnit(vehicles_drivers[i]) = i or IsDead(vehicles_drivers[i]) then
                                        vehicles_drivers = Replace(vehicles_drivers,i,0);


                    //Find a driver for the (manual) crane if necessary.
                    if ai_crane[base] > 0 and GetControl(ai_crane[base]) = control_manual and ai_crane_driver[base] = 0 and ai_mechanics_defend[base] > 0 then
                         begin
                              ai_crane_driver = Replace(ai_crane_driver,base, FindBestCraneDriver(base) );

                              for i = 1 to remote_driver_vehicles[base]+0 do
                                   if remote_driver_vehicles[base][i][1] = ai_crane_driver[base] then
                                        begin
                                             temp_list = Delete(remote_driver_vehicles[base],i);
                                             remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list);

                                             break;
                                        end;
                         end;

                    //Clear crane driver from vehicles drivers
                    {if ai_crane_driver[base] > 0 and ai_crane_driver[base] in vehicles_drivers then
                         begin
                              for i = 1 to vehicles_drivers do
                                   if vehicles_drivers[i] = ai_crane_driver[base] then
                                        begin
                                             vehicles_drivers = Replace(vehicles_drivers,i,0);
                                             break;
                                        end;
                         end; -> if not crane driver is in mechanics_list then another driver will be found, cf. function "FindDriverHelper"}


                    mechanics_list = UnitFilter(ai_mechanics_defend[base] diff (ai_heal_these_humans[base] ^ ai_crane_driver[base]),[f_not,[f_driving]]);
                    if ai_crane_driver[base] > 0 and not IsOk(ai_crane[base]) then
                         mechanics_list = mechanics_list ^ ai_crane_driver[base];

                    remote_mechanics = [];


                    //Identify mechanics who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= mechanics_list do
                         begin
                              if GetLives(mechanics_list[i]) <= 900 then
                                   begin
                                        temp_list = temp_list ^ mechanics_list[i];
                                        mechanics_list = Delete(mechanics_list,i);
                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Remote control.
                    if ai_control_tower[base] > 0 or ai_control_tower_vehicles[base] > 0 then
                         begin
                              //Sort away dead vehicles and vehicles controlled by dead mechanics.
                              //Demote remote mechanics if there aren't enough control stations for everyone.
                              //Find vehicles currently connected to a mechanic.
                              temp_list = remote_driver_vehicles[base];
                              vehicles_list = [];

                              i = 1;
                              while i <= temp_list do
                                   begin
                                        if IsDead(temp_list[i][1]) then
                                             begin
                                                  temp_list = Delete(temp_list,i);
                                                  continue;
                                             end
                                        else
                                             begin
                                                  temp_list_3 = temp_list[i][2];

                                                  k = 1;
                                                  while k <= temp_list_3 do
                                                       begin
                                                            if IsDead(temp_list_3[k]) then
                                                                 begin
                                                                      temp_list_3 = Delete(temp_list_3,k);
                                                                      continue;
                                                                 end;

                                                            k = k + 1;
                                                       end;

                                                  if temp_list_3 > 0 then
                                                       begin
                                                            temp_list_2 = Replace(temp_list[i],2,temp_list_3);
                                                            temp_list = Replace(temp_list,i,temp_list_2);
                                                       end
                                                  else
                                                       begin
                                                            temp_list = Delete(temp_list,i);
                                                            continue;
                                                       end;
                                             end;

                                        vehicles_list = vehicles_list ^ temp_list[i][2];

                                        i = i + 1;
                                   end;

                              num_control_stations = [7{ai_control_tower_vehicles[base]}, 0, ai_control_tower[base]*3][base];

                              while temp_list > num_control_stations do
                                   begin
                                        vehicles_list = vehicles_list diff temp_list[temp_list+0][2];
                                        temp_list = Delete(temp_list,temp_list+0);
                                   end;

                              remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list);



                              if base = 1 then
                                 patrol_units = ai_patrol[1] diff -1 ^ 0
                              else if base = 3 then
                                      patrol_units = ai_patrol[2] diff -1 ^ 0
                                   else patrol_units = [];

                              if base = 1 then
                                 i = ai_hovercrafts diff 0 ^ -1;


                              //Connect remote vehicles to mechanics.
                              temp_list = UnitFilter((ai_vehicles_defend[base] ^ (ai_cargo_bay[base] diff 0) ^ (ai_crane[base] diff 0) ^ (patrol_units) ^ (i) ^
                                                      ai_vehicles_attack[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_sib_bomb_vehicles[base])
                                                      diff vehicles_list,[f_control,control_remote]);


                              if temp_list > 0 then
                                   begin
                                        //By omitting some mechanics here (e.g. those being healed) we may end up assigning more vehicles to a single
                                        //mechanic than we should. And those will not be reassigned. It's rare, though, and not so simple to fix
                                        //so let's just omit those lines of code.
                                        //Always leave at least one mechanic to work in the factory.
                                        temp_list_3 = mechanics_list;
                                        for i in remote_driver_vehicles[base] do
                                             temp_list_3 = temp_list_3 diff i[1];

                                        if temp_list_3 > 0 then
                                             temp_list_3 = temp_list_3 diff FindMinSkill(temp_list_3,skill_mechanical);

                                        i = 1;
                                        while i <= temp_list do
                                             begin
                                                            //Find a suitable mechanic already controlling other vehicles.
                                                            //We want two vehicles per mechanic (it can be mathematically proven that this is the
                                                            //best number to pick given that no vehicles block another vehicle so it can't attack during a fight).
                                                            //If all have 2 or more vehicles then take the one controlling the least vehicles.
                                                            a = 1;
                                                            while a <= remote_driver_vehicles[base] do
                                                                 begin
                                                                      if remote_driver_vehicles[base][a][2] < 2 and GetSkill(remote_driver_vehicles[base][a][1],skill_mechanical) >= 2 then
                                                                           break;

                                                                      a = a + 1;
                                                                 end;

                                                            if a > remote_driver_vehicles[base] then
                                                                 begin
                                                                      if remote_driver_vehicles[base] >= num_control_stations then
                                                                           begin
                                                                                //Not enough control stations for another remote mechanic.
                                                                                temp_list_3 = [];
                                                                           end;

                                                                      if temp_list_3 > 0 then
                                                                           begin
                                                                                //Assign a new remote mechanic.
                                                                                //Take the best mechanic
                                                                                temp_unit = FindMaxSkill(temp_list_3,skill_mechanical);
                                                                                temp_list_3 = temp_list_3 diff temp_unit;

                                                                                temp_list_2 = remote_driver_vehicles[base] ^ [[temp_unit,[temp_list[i]]]];
                                                                                remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list_2);

                                                                                i = i + 1;
                                                                                continue;
                                                                           end;

                                                                      //Sort away drivers who cannot control more vehicles.
                                                                      temp_list_4 = [];
                                                                      for a in remote_driver_vehicles[base] do
                                                                           if GetSkill(a[1],skill_mechanical) > a[2] then
                                                                                temp_list_4 = temp_list_4 ^ [a];

                                                                      if temp_list_4 = 0 then
                                                                           break;

                                                                      temp_list_2 = [];
                                                                      for a in temp_list_4 do
                                                                           temp_list_2 = temp_list_2 ^ (a[2]+0);

                                                                      temp_list_2 = WorstFromListByList(temp_list_4,temp_list_2);

                                                                      for a = 1 to remote_driver_vehicles[base] do
                                                                           if remote_driver_vehicles[base][a][1] = temp_list_2[1] then
                                                                                break;
                                                                 end;

                                                            temp_list_2 = remote_driver_vehicles[base][a][2] ^ temp_list[i];
                                                            temp_list_2 = Replace(remote_driver_vehicles[base][a],2,temp_list_2);
                                                            temp_list_2 = Replace(remote_driver_vehicles[base],a,temp_list_2);
                                                            remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list_2);

                                                            i = i + 1;
                                             end;
                                   end;
                                                                   
                              //Find all remote mechanics
                              for i in remote_driver_vehicles[base] do
                                   remote_mechanics = remote_mechanics ^ i[1];

                              mechanics_list = mechanics_list diff remote_mechanics;
                              remote_mechanics = remote_mechanics diff ai_heal_these_humans[base];

                              //There must always be at least one mechanic to work in the factory.
                              if mechanics_list = 0 and remote_driver_vehicles[base] > 0 then
                                   begin
                                        //Release the mechanic controlling the least vehicles.
                                        n = 0;
                                        a = 9999;
                                        for i = 1 to (remote_driver_vehicles[base]+0) do
                                             begin
                                                  if remote_driver_vehicles[base][i][2]+0 < a then
                                                       begin
                                                            a = remote_driver_vehicles[base][i][2]+0;
                                                            n = i;
                                                       end;
                                             end;

                                        mechanics_list = mechanics_list ^ remote_driver_vehicles[base][n][1];
                                        remote_mechanics = remote_mechanics diff remote_driver_vehicles[base][n][1];
                                        temp_list_2 = Delete(remote_driver_vehicles[base],n);
                                        remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list_2);
                                   end;
                         end
                    else
                         begin
                              remote_driver_vehicles = Replace(remote_driver_vehicles,base,[]);
                         end;
     

                    //Build behemoths. Always leave some people in the factory to work there.
                    if base = 2 and ai_behemoths[base] + UnitFilter(ai_vehicles_attack[base],[[f_ok],[f_weapon,59]]) < MaxNumBehemoths(base) and mechanics_list > 2 and tick > ai_behemoth_build_tick + [5$0,4$0,3$0][difficulty] then  //"59" identifiers behemoths
                         begin
                              temp_list = [];
                              for i = 3 to mechanics_list+0 do
                                   begin
                                        temp_list = temp_list ^ mechanics_list[1];
                                        mechanics_list = Delete(mechanics_list,1);
                                   end;

                              temp_unit = HexInfo(ai_behemoth_construction_hex[base][1],ai_behemoth_construction_hex[base][2]);

                              if HexInfo(ai_behemoth_construction_hex[base][1],ai_behemoth_construction_hex[base][2]) = 0 then
                                 ComBuildBehemoth(temp_list,b_behemoth,ai_behemoth_construction_hex[base][1],ai_behemoth_construction_hex[base][2],0)
                              else
                                  if GetBType(temp_unit) = b_behemoth then
                                     ComRepairBuilding(temp_list,temp_unit);
                         end;


                    //Find vehicles which no longer need to be repaired (fully repaired).
                    temp_list = [];
                    for i in ai_vehicles_being_repaired[base] do
                         if GetLives(i) < 1000 then
                              temp_list = temp_list ^ i;
                    ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);


                    //Find vehicles which do no longer need to retreat (they have been fully repaired)
                    temp_list = [];
                    for i in ai_retreating_vehicles_defend[base] do//diff ai_vehicles_being_repaired[base] do  -> Don't want them to move to the enemy with a team of mechanics following it to repair it
                         if GetLives(i) < 1000 then
                              temp_list = temp_list ^ i;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);


                    //Identify defending vehicles which need to retreat.
                    //Make vehicles retreat if they exceed a certain threshold of damage. Works for any amount of health
                    //(except full health) but is only used when the vehicles are burning. Defend the base at all costs!
                    temp_list = ai_retreating_vehicles_defend[base];
                    for i in ai_vehicles_defend[base] diff ai_retreating_vehicles_defend[base] do// ^ ai_vehicles_being_repaired[base]) do
                         if GetLives(i) <= 250 then
                              temp_list = temp_list ^ i;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);


                    //Find vehicles which no longer need to refuel.
                    //If a vehicles was scheduled to refuel but didn't make it before the base was attacked
                    //and was added to retreating vehicles during the attack it must be removed from
                    //refueling vehicles.
                    //Clear pending refuels if we are under attack.
                    if not under_attack then
                         begin
                              temp_list = [];
                              for i in ai_refuel_vehicles_list[base] diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) do
                                   if GetFuel(i) < 95 then
                                        temp_list = temp_list ^ i;
                              ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);
                         end
                    else
                         ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,[]);


                    //The following part of the code only has to consider these vehicles. Other vehicles are handled elsewhere.
                    vehicles_to_consider = ai_vehicles_defend[base] ^ ai_control_tower_vehicles[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ patrol_units;


                    if under_attack then                                                                         
                         begin
                              //Find the vehicles which need a driver and get them a driver (take the
                              //nearest available mechanic).
                              vehicles_list = ai_vehicles_defend[base] diff (ai_refuel_vehicles_list[base] ^ ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]);

                              temp_list = UnitFilter(vehicles_list,[[f_control,control_manual],[f_ok],[f_empty]]);
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];

                              //Order the vehicles to attack an enemy unit near the base.
                              case base of
                                   1: temp_list = [];
                                   2: temp_list = [];
                                   3: temp_list = [];
                                   4: temp_list = []; //DangerousUnits(FilterAllUnits([[f_enemy,side],[f_inarea,am_vehicle_defend_area]]));
                              end;

                              //temp_list = DangerousUnits(ListFilterNearArea( FilterAllUnits([f_enemy,side]),GetBaseArea(base)));

                              if temp_list > 0 then
                                   ComAgressiveMove(vehicles_list ,GetX(temp_list[1]),GetY(temp_list[1]))
                              else
                                   begin
                                        temp_list = FilterAllUnits([[f_enemy,side],[f_inarea,area]]);
                                        if base = 3 then
                                           temp_list = temp_list diff FilterAllUnits([f_side,americans_alt]);  


                                        if temp_list > 0 then
                                             begin
                                                  temp_list_2 = DangerousUnits(temp_list);

                                                  if temp_list_2 = 0 then
                                                       ComAttackUnit(vehicles_list,temp_list[1]);  //Destroy e.g. empty manual vehicles so they won't block.
                                             end;
                                   end;
                         end
                    else
                         begin
                              if unitfilter(ai_depots[base], [f_ok]) > 0 then
                                   begin
                                        //If some vehicles need to refuel then make 'em refuel.
                                        temp_list = ai_refuel_vehicles_list[base];
                                        for i in vehicles_to_consider diff ai_refuel_vehicles_list[base] do
                                             if GetFuel(i) < 70 and GetEngine(i) = engine_combustion then
                                                  temp_list = temp_list ^ i;
                                        temp_list = temp_list diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]);
                                        ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);

                                        temp_list = UnitFilter(ai_refuel_vehicles_list[base],[[f_control,control_manual],[f_empty],[f_ok]]) diff ai_control_tower_vehicles[base];  //Remote mechanics are assigned to control tower vehicles
                                        temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                                        mechanics_list = temp_list[1];
                                        vehicles_drivers = temp_list[2];

                                        for i in ai_refuel_vehicles_list[base] do
                                             begin
                                                  if IsInArea(i,area) then
                                                       begin
                                                            temp = NearestUnitToUnit(ai_depots[base], i);

                                                            ComMoveUnit(i,temp);
                                                            AddComRefuel(i,temp);
                                                       end
                                                  else
                                                       ComAgressiveMove(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                                             end;
                                   end;

                              //Keep vehicle groups contained in particular areas
                              pullback_hex = [[94,177], [202,197], [232,170]];          // for defending vehicles
                              pullback_hex_patrol = [[84,159], [], [210,141]];
                              pullback_hex_hovercrafts = [116, 149];

                              for i in UnitFilter(vehicles_to_consider,[f_not,[f_control,control_manual]]) ^ patrol_units diff (ai_refuel_vehicles_list[base] ^ ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) do
                                  if i in ai_vehicles_defend[base] then
                                  begin
                                       if GetDistUnitXY(i,pullback_hex[base][1],pullback_hex[base][2]) > 10 then
                                          ComMoveXy(i,pullback_hex[base][1],pullback_hex[base][2]);
                                  end
                                  else
                                      if (base = 1 and not 1 in ai_patrol_out) or (base = 3 and not 2 in ai_patrol_out) then    //check if a patrol is in base or went out
                                         if GetDistUnitXY(i,pullback_hex_patrol[base][1],pullback_hex_patrol[base][2]) > 6 then
                                            ComMoveXy(i,pullback_hex_patrol[base][1],pullback_hex_patrol[base][2]);

                              if not 2 in mb_bases and base = 2 then
                                 for i = 1 to 2 do
                                     if mb_vehicles[2][i] > 0 then
                                        if GetDistUnitXY(mb_vehicles[2][i], [169,172][i], 171) > 5 then
                                           ComMoveXY(mb_vehicles[2][i], [169,172][i], 171);

                              if base = 1 and ai_hovercrafts_out = 0 then
                                 for i in ai_hovercrafts diff 0 ^ -1 do
                                     if GetDistUnitXY(i, pullback_hex_hovercrafts[1], pullback_hex_hovercrafts[2]) > 7 then
                                        ComMoveXY(i, pullback_hex_hovercrafts[1], pullback_hex_hovercrafts[2]);

                              {//Move non-manual vehicles outside the base inside (not behemoths, though)
                              for i in UnitFilter(vehicles_to_consider,[f_not,[f_control,control_manual]]) diff (ai_refuel_vehicles_list[base] ^ ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) do
                                   if not IsInArea(i,area) then
                                        ComAgressiveMove(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                              }
                         end;


                    //Park vehicles.
                    free_parking_spots = [];  //Keeps track of the pullback hexes available
                    parked_vehicles = [];  //Keeps track of vehicles on pullback hexes

                    //Only these vehicles will need to be parked on a parking spot. Other vehicles either don't need to or are parking somewhere else.
                    vehicles_allowed_to_park = UnitFilter(vehicles_to_consider,[f_control,control_manual]);

                    //Non-manual vehicles pull back to the human pullback hex when retreating when under attack. The max distance they should have to the human pullback hex
                    //is determined by how many vehicles we have of that kind.
                    case (vehicles_to_consider diff vehicles_allowed_to_park)+0 of
                         0..1: human_pullback_hex_max_dist = 4;
                         2: human_pullback_hex_max_dist = 5;
                         3..4: human_pullback_hex_max_dist = 6;
                         else human_pullback_hex_max_dist = 7;
                    end;

                    for i in ai_vehicle_pullback_hexes[base] do
                         begin
                              temp_unit = HexInfo(i[1],i[2]);

                              if temp_unit in vehicles_allowed_to_park then
                                   begin
                                        parked_vehicles = parked_vehicles ^ temp_unit;
                                   end
                              else
                                   if temp_unit = 0 or not ( GetType(temp_unit) = unit_building or ( GetType(temp_unit) = unit_vehicle and ( ( GetControl(temp_unit) = control_manual and IsDrivenBy(temp_unit) = 0 ) or ( GetControl(temp_unit) = control_remote and IsControledBy(temp_unit) = 0 ) ) ) ) then
                                        free_parking_spots = Insert(free_parking_spots,1,i);
                         end;

                    //Find free parking spots for behemoths.
                    free_behemoth_parking_spots = [];
                    parked_behemoths = [];
                    for i in ai_behemoth_parking_hexes[base] do
                         begin
                              temp_unit = HexInfo(i[1],i[2]);
                              if temp_unit > 0 and GetType(temp_unit) = unit_vehicle and GetWeapon(temp_unit) = 59 then  //"59" identifiers behemoths
                                   begin
                                        parked_behemoths = parked_behemoths ^ temp_unit;
                                   end
                              else
                                   if temp_unit = 0 or not ( GetType(temp_unit) = unit_building or ( GetType(temp_unit) = unit_vehicle and ( ( GetControl(temp_unit) = control_manual and IsDrivenBy(temp_unit) = 0 ) or ( GetControl(temp_unit) = control_remote and IsControledBy(temp_unit) = 0 ) ) ) ) then
                                        free_behemoth_parking_spots = Insert(free_behemoth_parking_spots,1,i);
                         end;


                    if under_attack then
                         begin
                              vehicles_to_park = (ai_vehicles_being_repaired[base] union ai_retreating_vehicles_defend[base]) isect vehicles_allowed_to_park; //We take ai_vehicles_being_repaired[base] and ai_retreating_vehicles_defend[base] because these vehicles are not fighting or have other tasks.
                              vehicles_to_park = UnitFilter(vehicles_to_park diff parked_vehicles,[f_ok]);
                              vehicles_to_park = vehicles_to_park union UnitFilter(ai_control_tower_vehicles[base] diff (parked_vehicles ^ ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]),[f_ok]);

                              //Man retreating/(under repair) vehicles which are parked on a parking spot and ( are under attack
                              //or where mechanics are under attack nearby (i.e. the enemy is near) ).
                              //Else use your time on repairing the vehicles.
                              //UnitShoot resets after 10 seconds and detects all kinds of contact (direct hit, bombs, attack ground etc.).
                              temp_list = [];
                              temp_list_3 = (ai_vehicles_being_repaired[base] union ai_retreating_vehicles_defend[base]) isect parked_vehicles;
                              temp_list_3 = UnitFilter(temp_list_3,[f_ok]) diff ai_control_tower_vehicles[base];  //Remote mechanics are assigned to control tower vehicles
                              for i in temp_list_3 do
                                   if UnitShoot(i) > 0 then
                                        if GetSide(UnitShoot(i)) <> side then
                                             temp_list = temp_list ^ i;

                              for i in ai_mechanics_defend[base] do
                                   if UnitShoot(i) > 0 then
                                        if GetSide(UnitShoot(i)) <> side then
                                             temp_list = temp_list union UnitFilter(temp_list_3,[f_dist,i,5]);

                              for i in temp_list_3 diff temp_list do
                                   begin
                                        if not i in (ai_refuel_vehicles_list[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) then
                                             begin
                                                  k = IsDrivenBy(i);
                                                  if k > 0 then
                                                       ComExitVehicle(k);
                                             end;
                                   end;

                              temp_list = UnitFilter(temp_list ^ vehicles_to_park,[[f_control,control_manual],[f_empty]]) diff ai_control_tower_vehicles[base];  //Remote mechanics are assigned to control tower vehicles
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];
                         end
                    else
                         begin
                              vehicles_to_park = UnitFilter(vehicles_allowed_to_park diff (parked_vehicles ^ ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]),[f_ok]);

                              for i in parked_vehicles do
                                   begin
                                        if not i in (ai_refuel_vehicles_list[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) then
                                             begin
                                                  k = IsDrivenBy(i);
                                                  if k > 0 and not ( k in remote_mechanics and i in ai_control_tower_vehicles[base] ) then  //Remote mechanics are assigned to control tower vehicles
                                                       begin
                                                            ComExitVehicle(k);
                                                       end;
                                             end;
                                   end;

                              //Find drivers for the vehicles which aren't parked correctly
                              temp_list = UnitFilter(vehicles_to_park,[[f_control,control_manual],[f_empty]]) diff ai_control_tower_vehicles[base];  //Remote mechanics are assigned to control tower vehicles
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];
                         end;

                    //Command vehicles to park on the pullback hexes.
                    //If no pullback hexes are available then the vehicle won't park anywhere.
                    while vehicles_to_park > 0 do
                         begin
                              if free_parking_spots = 0 then
                                   break;

                              //Take the closest spot
                              temp_list = [];
                              for k in free_parking_spots do
                                   temp_list = temp_list ^ GetDistUnitXY(vehicles_to_park[1],k[1],k[2]);
                              temp_list = WorstFromListByList(free_parking_spots,temp_list);

                              ComMoveXY(vehicles_to_park[1],temp_list[1],temp_list[2]);
                              AddComHold(vehicles_to_park[1]);

                              free_parking_spots = free_parking_spots diff [temp_list];
                              vehicles_to_park = Delete(vehicles_to_park,1);
                         end;


                    //Behemoths - approach closest player unit if they get inside the base
                    temp_list_2 = FilterUnitsInArea(BehemothDefend, [f_side,2]);

                    if temp_list_2 > 0 then
                    begin
                         for i in ai_behemoths[base] diff ArtUse_Beh_damaged do
                             ComMoveUnit(i, NearestUnitToUnit(temp_list_2, i) );
                    end
                       else
                           begin
                                //otherwise park a behemoth if it isin't being repaired
                                for i in ai_behemoths[base] diff ai_behemoth_damaged[base] ^ parked_behemoths ^ ArtUse_Beh_damaged do
                                    if free_behemoth_parking_spots > 0 then
                                    begin
                                         //Take the closest spot
                                         temp_list = [];
                                         for k in free_behemoth_parking_spots do
                                             temp_list = temp_list ^ GetDistUnitXY(i,k[1],k[2]);

                                         temp_list = WorstFromListByList(free_behemoth_parking_spots,temp_list);

                                         ComMoveXY(i,temp_list[1],temp_list[2]);
                                         AddComHold(i);

                                         free_behemoth_parking_spots = free_behemoth_parking_spots diff [temp_list];
                                    end
                                       else
                                           break;
                        
                                for i in ai_behemoths[base] diff ai_behemoth_damaged[base] do
                                    if GetLives(i) < 600 then
                                       ai_behemoth_damaged = Replace(ai_behemoth_damaged, base, ai_behemoth_damaged[base] ^ i);

                                //move a behemoth back to be repaired
                                for i in ai_behemoth_damaged[base] diff ArtUse_Beh_damaged do
                                begin
                                     if GetLives(i) = 1000 then
                                     begin
                                          ai_behemoth_damaged = Replace(ai_behemoth_damaged, base, ai_behemoth_damaged[base] diff i);
                                          break;
                                     end;

                                     temp_list = 999;
                                     temp = 1;

                                     for j = 1 to ai_behemoth_retreat_hexes[base] do
                                         if GetDistUnitXY(i, ai_behemoth_retreat_hexes[base][j][1], ai_behemoth_retreat_hexes[base][j][2]) < temp_list then
                                         begin
                                              temp_list = GetDistUnitXY(i, ai_behemoth_retreat_hexes[base][j][1], ai_behemoth_retreat_hexes[base][j][2]);
                                              temp = j;
                                         end;

                                     if HexInfo(ai_behemoth_retreat_hexes[base][temp][1], ai_behemoth_retreat_hexes[base][temp][2]) = 0 then
                                        ComMoveXY(i, ai_behemoth_retreat_hexes[base][temp][1], ai_behemoth_retreat_hexes[base][temp][2])
                                     else
                                         if GetDistUnitXY(i, ai_behemoth_retreat_hexes[base][temp][1], ai_behemoth_retreat_hexes[base][temp][2]) > 4 then
                                            ComMoveXY(i, ai_behemoth_retreat_hexes[base][temp][1], ai_behemoth_retreat_hexes[base][temp][2]);
                                end;

                           end;


                    //When under attack, the retreating vehicles and vehicles being repaired, which are not allowed to park on the vehicle parking hexes,
                    //pull back to the human pullback hex instead.
                    if under_attack then
                         begin
                              for i in UnitFilter((ai_retreating_vehicles_defend[base] union ai_vehicles_being_repaired[base]) diff vehicles_allowed_to_park ^ ai_behemoth_damaged[base],[f_ok]) do
                                   begin
                                        if GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > human_pullback_hex_max_dist then
                                             ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                                   end;
                         end;


                    //Repair vehicles.
                    //All mechanics go for the same vehicle.
                    if under_attack then
                         begin
                              allowed_to_repair_vehicles = parked_vehicles ^ UnitFilter(vehicles_to_consider diff vehicles_allowed_to_park,[f_distxy,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2],human_pullback_hex_max_dist]);
                              allowed_to_repair_vehicles = allowed_to_repair_vehicles diff (ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]);  //Trying to repair a vehicle in one of these states could cause caos. Wait for it to finish.
                         end
                    else
                         begin
                              allowed_to_repair_vehicles = vehicles_to_consider diff (ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]);  //Trying to repair a vehicle in one of these states could cause caos. Wait for it to finish.
                              allowed_to_repair_vehicles = allowed_to_repair_vehicles ^ UnitFilter(ai_cargo_bay[base] diff 0,[f_inarea,area]);

                              allowed_to_repair_vehicles = allowed_to_repair_vehicles ^ ai_behemoth_damaged[base] diff ai_units_irradiated;


                              //Don't go near burning vehicles too far away from the base - could be dangerous if the
                              //enemy has set up an ambush.
                              i = 1;
                              while i <= allowed_to_repair_vehicles do
                                   begin
                                        if not IsOk(allowed_to_repair_vehicles[i]) and GetDistUnitArea(allowed_to_repair_vehicles[i],area) > 7 then
                                             begin
                                                  allowed_to_repair_vehicles = Delete(allowed_to_repair_vehicles,i);
                                                  continue;
                                             end;

                                        i = i + 1;
                                   end;
                         end;

                    allowed_to_repair_vehicles = UnitFilter(allowed_to_repair_vehicles,[[f_not,[f_lives,1000]],[f_or,[f_not,[f_ok]],[f_inarea,area]]]);  //Only repair a vehicle outside the base area if it can't move inside. Else wait for it to move inside.

                    if ai_crane[base] > 0 then
                         begin
                              k = false;

                              if ai_crane_is_being_repaired[base] and ( GetDistUnitXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) <= 6 or ( IsInArea(ai_crane[base],area) and not under_attack ) ) then
                                   begin
                                        if GetLives(ai_crane[base]) < 1000 then
                                             allowed_to_repair_vehicles = ai_crane[base] ^ allowed_to_repair_vehicles;

                                        if ai_crane_driver[base] > 0 then
                                             begin
                                                  if GetLives(ai_crane_driver[base]) = 1000 then
                                                       begin
                                                            mechanics_list = mechanics_list ^ ai_crane_driver[base];  //Help repairing
                                                       end
                                                  else
                                                       begin
                                                            if GetDistUnitXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) <= 6 then
                                                                 begin
                                                                      if GetHumansOutOfUnits([ai_crane_driver[base]]) > 0 and not ai_crane_driver[base] in ai_heal_these_humans[base] then
                                                                           begin
                                                                                temp_list = ai_heal_these_humans[base] ^ ai_crane_driver[base];
                                                                                ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
                                                                           end;
                                                                 end
                                                            else
                                                                 k = true;
                                                       end;
                                             end;
                                   end
                              else
                                   k = true;

                              if k then
                                   begin
                                        if IsOk(ai_crane[base]) and ai_crane_driver[base] > 0 and not ai_crane_driver[base] in mechanics_list and not ai_crane_driver[base] in ai_heal_these_humans[base] then
                                             begin
                                                  if IsInUnit(ai_crane_driver[base]) <> ai_crane[base] then
                                                       case GetType(IsInUnit(ai_crane_driver[base])) of
                                                            unit_building: ComExitBuilding(ai_crane_driver[base]);
                                                            unit_vehicle: ComExitVehicle(ai_crane_driver[base]);
                                                            else
                                                                 ComEnterUnit(ai_crane_driver[base],ai_crane[base]);
                                                       end;
                                             end;
                                   end;
                         end;

                    if mechanics_list = 0 and remote_mechanics = 0 then
                         continue;

                    allowed_to_repair_vehicles = allowed_to_repair_vehicles diff ai_vehicles_being_repaired[base];
                    if allowed_to_repair_vehicles > 0 or ai_vehicles_being_repaired[base] > 0 then
                         begin
                              if remote_mechanics > 0 then
                                   begin
                                        if under_attack or UnitFilter(ai_vehicles_attack[base],[[f_control,control_remote],[f_ok]]) > 0 then
                                             begin
                                                  //Repair vehicles if all vehicles you control are burning or dead
                                                  for i in remote_driver_vehicles[base] do
                                                       if UnitFilter(i[2],[f_ok]) = 0 and i[1] in remote_mechanics then
                                                            begin
                                                                 mechanics_list = mechanics_list ^ i[1];
                                                                 remote_mechanics = remote_mechanics diff i[1];
                                                            end;
                                             end;
                                        {else
                                             begin
                                                  //All help repair vehicles if all vehicles are inside the base
                                                  //(to prevent a lot of destination unreachable messages from other vehicles
                                                  //all must be inside the base).
                                                  //Perhaps it's not so smart if we have a remotely controlled cargo bay but hopefully the
                                                  //repair won't take long now that everybody is helping.
                                                  //Remember some remote vehicles may not be controlled by anyone.
                                                  temp_unit = true;
                                                  for i in vehicles_to_consider do
                                                       if not IsInArea(i,area) then
                                                            begin
                                                                 temp_unit = false;
                                                                 break;
                                                            end;

                                                  if temp_unit then
                                                       begin
                                                            mechanics_list = mechanics_list ^ remote_mechanics;
                                                            remote_mechanics = [];
                                                       end;
                                             end;
                                         }
                                   end;

                              if allowed_to_repair_vehicles > 0 then
                                   begin
                                        k = false;
                                        if ai_vehicles_being_repaired[base] = 0 then
                                             k = true
                                        else
                                             if IsOk(ai_vehicles_being_repaired[base][1]) then
                                                  begin
                                                       allowed_to_repair_vehicles = UnitFilter(allowed_to_repair_vehicles,[f_not,[f_ok]]);
                                                       k := allowed_to_repair_vehicles > 0;
                                                  end;

                                        if k then
                                             begin
                                                  temp_list = [];
                                                  for i in allowed_to_repair_vehicles do
                                                       temp_list = temp_list ^ GetLives(i);
                                                  temp_unit = WorstFromListByList(allowed_to_repair_vehicles,temp_list);

                                                  temp_list = temp_unit ^ ai_vehicles_being_repaired[base];
                                                  ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);

                                                  //temp_list = ai_retreating_vehicles_defend[base] diff temp_unit;
                                                  //ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);  -> The vehicle stays in "retreating" until the code managing retreating vehicles pulls it out of that state
                                             end;
                                   end;

                              ComRepairVehicle( GetHumansOutOfUnits(mechanics_list) , ai_vehicles_being_repaired[base][1]);
                         end
                    else
                         begin
                              //Rest mechanics stay inside the factory (if possible).
                              //Change class if necessary
                              DistributeHumansToBuildings(base,mechanics_list, UnitFilter(ai_facts[base] diff ai_sib_bomb_fact[base],[[f_ok],[f_not,[f_constructed]]]),
                                   class_mechanic,6,true,false);
                         end;


                    //Connect remote driver and vehicles
                    if remote_driver_vehicles[base] > 0 then
                         begin
                              if unitfilter(ai_control_tower[base],[f_ok])=0 and UnitFilter(ai_control_tower_vehicles[base],[f_ok]) = 0 then
                                   begin
                                        //Just go to factory
                                        DistributeHumansToBuildings(base,remote_mechanics, UnitFilter(ai_facts[base] diff ai_sib_bomb_fact[base],[[f_ok],[f_not,[f_constructed]]]),
                                             class_mechanic,6,true,false);
                                   end
                              else
                                   begin
                                        temp_list_3 = [[],0];  //[The control tower vehicles mecs have been sent to, Number of mecs sent to control tower]
                                        temp_list_2 = [];  //Remote mechanics who should just go to the factory
                                        already_inside_mecs = [];  //Remote mechanics already inside a control tower or control tower vehicle.

                                        for i in remote_driver_vehicles[base] do
                                             begin
                                                  if GetClass(i[1]) <> class_mechanic then
                                                       continue;

                                                  k = IsInUnit(i[1]);

                                                  if k > 0 and ( k in ai_control_tower_vehicles[base] or k in ai_control_tower[base] ) then
                                                       begin
                                                            already_inside_mecs = already_inside_mecs ^ i[1];

                                                            if k in ai_control_tower_vehicles[base] then
                                                                 begin
                                                                      temp_list = temp_list_3[1] ^ k;
                                                                      temp_list_3 = Replace(temp_list_3,1,temp_list);
                                                                 end
                                                            else
                                                                 temp_list_3 = Replace(temp_list_3,2,temp_list_3[2]+1);
                                                       end;
                                             end;
               
                                        for i in remote_driver_vehicles[base] do
                                             begin
                                                  if not i[1] in remote_mechanics then
                                                       continue;

                                                  //Class must be mechanic
                                                  if GetClass(i[1]) <> class_mechanic then
                                                       begin
                                                            temp_unit = 0;
                                                            for k in ai_facts[base] do
                                                                 if IsOk(k) and UnitsInside(k) < 6 then
                                                                      begin
                                                                           temp_unit = k;
                                                                           break;
                                                                      end;

                                                            if temp_unit > 0 then
                                                                 begin
                                                                      if IsInUnit(i[1]) = temp_unit then
                                                                           ComChangeProfession(i[1],class_mechanic)
                                                                      else
                                                                           begin
                                                                                case GetType(IsInUnit(i[1])) of
                                                                                     unit_building: ComExitBuilding(i[1]);
                                                                                     unit_vehicle: ComExitVehicle(i[1]);
                                                                                     else
                                                                                          ComEnterUnit(i[1],temp_unit);
                                                                                end;
                                                                           end;
                                                                 end;
                                                       end
                                                  else
                                                       begin
                                                            //Send to control tower vehicles as first priority (so empty manual vehicles won't block). Then control tower.
                                                            temp_unit = 0;

                                                            if i[1] in already_inside_mecs then
                                                                 begin
                                                                      temp_unit = IsInUnit(i[1]);  //just stay where you are pall
                                                                 end
                                                            else
                                                                 begin
                                                                      if (ai_control_tower_vehicles[base] diff temp_list_3[1]) > 0 then
                                                                           begin
                                                                                //temp_unit = AllNearestUnitToUnit(ai_control_tower_vehicles[base] diff temp_list_3[1],i[1]);  -> doesn't work if the mechanic is inside another unit
                                                                                temp_list = [GetX(i[1]),GetY(i[1])];
                                                                                temp_list_4 = [];
                                                                                temp_list_5 = ai_control_tower_vehicles[base] diff temp_list_3[1];
                                                                                for k in temp_list_5 do
                                                                                     temp_list_4 = temp_list_4 ^ GetDistUnitXY(k,temp_list[1],temp_list[2]);

                                                                                temp_unit = WorstFromListByList(temp_list_5,temp_list_4);

                                                                                temp_list = temp_list_3[1] ^ temp_unit;
                                                                                temp_list_3 = Replace(temp_list_3,1,temp_list);
                                                                           end
                                                                      else
                                                                           if UnitFilter(ai_control_tower[base],[f_ok])>0 and temp_list_3[2] < 6 then
                                                                                begin
                                                                                     if UnitsInside(ai_control_tower[base][1]) < 3 then  //there are two control towers in this mission
                                                                                        temp_unit = ai_control_tower[base][1]
                                                                                     else temp_unit = ai_control_tower[base][2];    

                                                                                     temp_list_3 = Replace(temp_list_3,2,temp_list_3[2]+1);
                                                                                end
                                                                           else
                                                                                temp_list_2 = temp_list_2 ^ i;
                                                                 end;

                                                            if temp_unit > 0 then
                                                                 begin
                                                                      k = IsInUnit(i[1]);
                                                                      if k <> temp_unit then
                                                                           begin
                                                                                case GetType(k) of
                                                                                     unit_building: ComExitBuilding(i[1]);
                                                                                     unit_vehicle: ComExitVehicle(i[1]);
                                                                                     else
                                                                                          ComEnterUnit(i[1],temp_unit);
                                                                                end;
                                                                           end
                                                                      else
                                                                           for k in i[2] do
                                                                                if IsOk(k) and IsControledBy(k) <> i[1] then
                                                                                     ComLinkTo(k,i[1])
                                                                                else
                                                                                     if not IsOk(k) and IsControledBy(k) > 0 then  //Unlink to improve performance of other vehicles controlled by the mechanic
                                                                                          ComUnlink(k);
                                                                 end;
                                                       end;     
                                             end;

                                        DistributeHumansToBuildings(base,temp_list_2, UnitFilter(ai_facts[base] diff ai_sib_bomb_fact[base],[[f_ok],[f_not,[f_constructed]]]),
                                             class_mechanic,6,true,false);                                                                                                          
                                   end;
                         end;    
               end;
               //display_strings=['mechanics_list',mechanics_list,'remote_mechanics',remote_mechanics,'remote_driver_vehicles',remote_driver_vehicles,'num_control_stations',num_control_stations];
          until false;
     end;
Function FindDriverHelper(vehicles_list,mechanics_list,vehicles_drivers);
     var i, k, temp_unit;
     begin
          for i in vehicles_list do
               begin
                    if mechanics_list = 0 then
                         break;

                    k = false;
                    if vehicles_drivers < i then
                         k = true
                    else
                         if not vehicles_drivers[i] in mechanics_list then
                              k = true;

                    if k then
                         vehicles_drivers = Replace(vehicles_drivers,i,AllNearestUnitToUnit(mechanics_list,i));

                    if vehicles_drivers[i] > 0 then
                        begin
                             temp_unit = IsInUnit(vehicles_drivers[i]);

                             if temp_unit <> i then
                                  case GetType(temp_unit) of
                                       unit_vehicle: ComExitVehicle(vehicles_drivers[i]);  //could sit in a vehicle which is now parked correctly
                                       unit_building: ComExitBuilding(vehicles_drivers[i]);
                                       else ComEnterUnit(vehicles_drivers[i],i);
                                  end;

                             mechanics_list = mechanics_list diff vehicles_drivers[i];
                        end;
               end;

          result = [mechanics_list,vehicles_drivers];
     end;
//The funny thing about a crane is that it repairs buildings faster the higher mechanic skill the driver has,
//but when constructing buildings the building's level will correspond to the driver's engineering skill.
//Therefore the crane driver should be the mechanic with the highest engineering and mechanical skill combined.
Function FindBestCraneDriver(base);
     var i, temp_list;
     begin
          if ai_mechanics_defend[base] = 0 then
               begin
                    result = 0;
                    exit;
               end;

          temp_list = [];
          for i in ai_mechanics_defend[base] do
               temp_list = temp_list ^ (GetSkill(i,skill_engineering)+GetSkill(i,skill_mechanical));

          result = BestFromListByList(ai_mechanics_defend[base],temp_list);
     end;

{//Make special mechanics go to the factory producing the siberite bomb.
//Fire the siberite bomb if we have one. Recycle afterwards.
//If there are less mechanics than we started with and the base hasn't been under attack
//for a while then spawn some new mecs.
Every 0$1.1 do
     var i, base, temp_list, veh, mechanics_list, un, bomb_sent;
     var orig_mec_num, last_attack_time_tick, going_to_be_recycled_bomb, bomb_talk_map;
     begin
          orig_mec_num = [];
          for base in ai_bases do
               orig_mec_num = Replace(orig_mec_num,base,ai_sib_bomb_mechanics[base]+0);

          last_attack_time_tick = [0,0,0,0];  //The tick when the base was last attacked
          going_to_be_recycled_bomb = [0,0,0,0];  //Identifier of the siberite bomb remainder we are going to recycle
          bomb_talk_map = [];  //index is siberite rocket id, value is boolean (false if leader hasn't spoken, true if has).

          repeat
          wait(0$1);

          if not 1 in ai_bases and not 4 in ai_bases then
               exit;

          for base in [1,4] do
               begin
                    if not base in ai_bases then
                         continue;

                    //Update variables if a bomb has been recycled.
                    if going_to_be_recycled_bomb[base] > 0 then
                         if IsDead(going_to_be_recycled_bomb[base]) then
                              begin
                                   temp_list = ai_sib_bomb_vehicles[base] diff going_to_be_recycled_bomb[base];
                                   ai_sib_bomb_vehicles = Replace(ai_sib_bomb_vehicles,base,temp_list);

                                   going_to_be_recycled_bomb = Replace(going_to_be_recycled_bomb,base,0);
                              end;

                    //Respawn
                    if ai_sib_bomb_mechanics[base] < orig_mec_num[base] and difficulty = 3 and ( ( base = 1 and IsLive(Platonov) ) or ( base = 4 and IsLive(Powell) ) ) then
                         begin
                              if BaseUnderAttack(base,-1) then
                                   last_attack_time_tick = Replace(last_attack_time_tick,base,tick)
                              else
                                   if last_attack_time_tick[base] + 3$0 <= tick then
                                        begin
                                             temp_list = CreateUnitsWithClass(orig_mec_num[base] - ai_sib_bomb_mechanics[base], class_mechanic, base);
                                             for i in temp_list do
                                                  SetSkill(i,skill_mechanical,10);

                                             for i in temp_list do
                                                  if not PlaceUnitXYR(i,108,196,2,false) then
                                                       begin
                                                            DestroyUnit(i);
                                                            temp_list = temp_list diff i;
                                                       end;

                                             temp_list = ai_sib_bomb_mechanics[base] ^ temp_list;
                                             ai_sib_bomb_mechanics = Replace(ai_sib_bomb_mechanics,base,temp_list);
                                        end;
                         end;

                    mechanics_list = ai_sib_bomb_mechanics[base] diff ai_heal_these_humans[base];

                    //Control siberite bomb
                    for i in mechanics_list do
                         begin
                              veh = IsInUnit(i);

                              if veh > 0 and GetType(veh) = unit_vehicle then
                                   begin
                                        mechanics_list = mechanics_list diff i;

                                        case GetWeapon(veh) of
                                             us_siberium_rocket,ru_siberium_rocket: begin
                                                  //Both Russians and Americans can hit pretty much everything on the map from their bases.
                                                  bomb_sent = true;

                                                  case base of
                                                       1: begin
                                                            if IsLive(Powell) then  //probably not since Am develops the bomb earlier than Ru
                                                                 ComAttackPlace(veh,ai_human_pullback_hex[4][1],ai_human_pullback_hex[4][2])
                                                            else
                                                                 begin
                                                                      //Send the bomb to the player's main base.
                                                                      un = FindPlayerMainBase;

                                                                      if un > 0 then
                                                                           ComAttackPlace(veh,GetX(un),GetY(un))
                                                                      else
                                                                           bomb_sent = false;
                                                                 end;
                                                       end;
                                                       4: begin
                                                            if 2 in ai_bases and alliance_deal_status = 2 then
                                                                 ComAttackPlace(veh,ai_human_pullback_hex[2][1],ai_human_pullback_hex[2][2])
                                                            else
                                                                 if IsLive(Platonov) then  //the player is gonna lose - bomb starts chain reaction
                                                                      ComAttackPlace(veh,ai_human_pullback_hex[1][1],ai_human_pullback_hex[1][2])
                                                                 else
                                                                      begin
                                                                           //Send the bomb to the player's main base.
                                                                           un = FindPlayerMainBase;

                                                                           if un > 0 then
                                                                                ComAttackPlace(veh,GetX(un),GetY(un))
                                                                           else
                                                                                bomb_sent = false;
                                                                      end;
                                                       end;
                                                  end;

                                                  if bomb_sent then
                                                       begin
                                                            if bomb_talk_map < veh then
                                                                 bomb_talk_map = Replace(bomb_talk_map,veh,false);

                                                            if not bomb_talk_map[veh] then  //also true if bomb_talk_map[veh] is empty
                                                                 begin
                                                                      bomb_talk_map = Replace(bomb_talk_map,veh,true);

                                                                      case base of
                                                                           1: un = Platonov;
                                                                           4: un = Powell;
                                                                      end;

                                                                      if IsLive(un) then
                                                                           begin
                                                                                DialogueOn;

                                                                                case un of
                                                                                     Platonov: ForceSay(un,'D25-Pla-1');
                                                                                     Powell: ForceSay(un,'D25-Po-1');
                                                                                end;

                                                                                DialogueOff;
                                                                           end;
                                                                 end;
                                                       end;
                                             end;
                                             us_siberium_rocket_remainder, ru_siberium_rocket_remainder: begin
                                                  if IsOk(ai_sib_bomb_fact[base]) and IsIdle(ai_sib_bomb_fact[base]) then
                                                       begin
                                                            ComRecycle(veh,ai_sib_bomb_fact[base]);
                                                            going_to_be_recycled_bomb = Replace(going_to_be_recycled_bomb,base,veh);
                                                       end;
                                             end;
                                             else begin
                                                  ComExitVehicle(i);
                                             end;
                                        end;
                                   end;
                         end;

                    //Identify mechanics who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= mechanics_list do
                         begin
                              if GetLives(mechanics_list[i]) <= 900 then
                                   begin
                                        temp_list = temp_list ^ mechanics_list[i];
                                        mechanics_list = Delete(mechanics_list,i);
                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);

                    DistributeHumansToBuildings(base,mechanics_list, UnitFilter(ai_sib_bomb_fact[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_mechanic,6,true,false);
               end;

          until false;
     end;
}

{
Function FindPlayerMainBase;
     var dep_list, map_num, map_base, i, b, temp_list;
     begin
          //The player's main base is the base with the most buildings connected to it.
          dep_list = FilterAllUnits([[f_side,you],[f_or,[f_btype,b_depot],[f_btype,b_warehouse]]]);

          if dep_list = 0 then
               result = 0
          else
               if dep_list = 1 then
                    result = dep_list[1]
               else
                    begin
                         map_num = [];
                         map_base = [];

                         for i in dep_list do
                              begin
                                   map_num = Replace(map_num,i,0);
                                   map_base = Replace(map_base,GetBase(i),i);
                              end;

                         for i in FilterAllUnits([[f_side,you],[f_type,unit_building]]) diff dep_list do
                              begin
                                   b = GetBase(i);
                                   if map_base >= b then
                                        if map_base[b] > 0 then
                                             begin
                                                  map_num = Replace(map_num,map_base[b], map_num[map_base[b]] + 1 );
                                             end;
                              end;

                         temp_list = [];
                         for i in dep_list do
                              temp_list = temp_list ^ map_num[i];

                         result = BestFromListByList(dep_list,temp_list);
                    end;
     end;
}
{
Function MaxNumWarVehiclesDefend(base);
     var time;
     begin
          case base of
               1: result = [3,4,5][difficulty];
               2: result = [3,4,5][difficulty];
               3: result = [3,4,5][difficulty];

          end;

          //If we are soon going to attack then create enough vehicle for the attack.
          //Worst case time for building a vehicle is about 45 seconds (usually).
          time = ai_vehicle_attack_delay[base];

   //       if (MaxNumWarVehiclesAttack(base) - result) * 0$45 >= time then
   //            result = MaxNumWarVehiclesAttack(base);
     end;
}
{
Function MaxNumWarVehiclesAttack(base);
     begin
          case base of
               1: begin
                    result = [2,3,4][difficulty];

                    if attacked_times[base]+0 >= 2 then
                         result = result + 1;

                    if attacked_times[base]+0 >= 5 then
                         result = result + 1;
               end;
               2: result = 0;
               3:
               4: result = 6;
          end;
     end;
}

Function MaxNumTaufieldVehicles(base);
     var t;
     begin
          case base of
               1: result = 0;
               2: result = 0;
               3: result = 0;
          end;
     end;
Function MaxNumImplosionVehicles(base);
     begin
          case base of
               1: result = 0;
               2: result = 0;
               3: result = 0;
          end;
     end;
Function MaxNumBehemoths(base);
     var i, j;
     begin
          case base of
               1: result = 0;

               2: begin
                       i = 0;
                       for j in RuDefences do
                           i = i + j;

                       if i < 8 then
                          result = 0
                       else
                           if i < 16 then
                              result = 1
                           else
                               if i < 24 then
                                  result = 2
                               else
                                   result = 3;
                  end;

               3: result = 0;
          end;
     end;
//Construct combat vehicles and weapons for bunkers. Weapons for bunkers have highest priority.
//Construct a crane if we don't have one.
//Construct a cargo bay if we don't have one (but not if we are under attack).
//Since we do not build new buildings while under attack, don't try to build weapons that requires other factory
//extensions than the ones we have while under attack.
Every 0$1+0$0.6 do
     var i, temp_value, temp_unit, temp_list, base, idle_factories, fact, b, construct_list;
     var vehicle_prod_delay, saved_construct_list, under_attack;
     var temp, temp2, chassis, engine, control, weapon, factory;
     begin
          vehicle_prod_delay = [0$0,0$0,0$0,0$0];
          saved_construct_list = [[],[],[],[]];


          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    under_attack = BaseUnderAttack(base,-1);

                    if under_attack and ai_vehicles_defend[base] >= [0,1,2][difficulty] then
                         begin
                              vehicle_prod_delay = Replace(vehicle_prod_delay,base,[1$15,0$45,0$30][difficulty]);
                         end;

                    idle_factories = [];
                    for i in ai_facts[base] diff ai_sib_bomb_fact[base] do
                         if BuildingStatus(i) = bs_idle and IsOk(i) and GetBType(i) = b_factory then
                              begin
                                   b = true;
                                   if ai_facts_with_ext_rebuild_map >= i then
                                        if ai_facts_with_ext_rebuild_map[i] > 0 then
                                             b = false;

                                   if b then
                                        idle_factories = idle_factories ^ i;
                              end;




                    if idle_factories = 0 then
                         continue;


                    //Check if any bunker needs a weapon
                    temp_value = false;
                    for i in ai_buildings_locations[base] do
                         if i[4] in [b_bunker,b_turret] then
                              begin
                                   temp_unit = HexInfo(i[1],i[2]);

                                   if GetBType(temp_unit) in [b_bunker,b_turret] and not IsConstructed(temp_unit) and GetBWeapon(temp_unit) = 0 {<> i[7]} then  //Alliance rebuilds Russian bunkers/turrets as American
                                        //If there are multiple weapon factories and more than one or another factory than
                                        //the factory getting the job invokes this part of the function the bunker/turret may
                                        //get the weapon placed several times, but since factories don't have a task list
                                        //there is no simple way to stop this. Better several times than never.
                                        begin
                                             b = false;
                                             if not under_attack then
                                                  b = true
                                             else
                                                  begin
                                                       if CanFactConstructThis(idle_factories[1],i[7],false) = 1 then  //Only build it if we can build it right now
                                                            b = true;
                                                  end;

                                             if b then
                                                  begin
                                                       if FactConstruct(base,[idle_factories[1]],[temp_unit,-1,-1,i[7]],false) in [0,1] then
                                                            begin
                                                                 temp_value = true;
                                                                 break;
                                                            end;
                                                  end;
                                        end;
                              end;

                    if temp_value then
                         continue;


                    //Construct additional control towers (Arabians) if needed.
                    if base = 1 then
                         begin
                              b = CheckAndFixArControlTowerAmount(base,idle_factories,false);

                              if b <> -1 then
                                   begin
                                        if b in [0,1] then
                                             continue;
                                   end;
                         end;


                   { //Construct cargo bay if we have none.
                    if not under_attack then
                         begin
                              if ai_cargo_bay[base] = 0 and not ai_cargo_bay_under_construction[base] and tick - ai_cargo_bay_destroy_tick[base] >= [6$0,4$30,3$0][difficulty] then
                                   begin
                                        case GetBaseNation(base) of
                                             nation_american: begin
                                                  b = false;
                                                  temp_list = [us_medium_tracked,engine_siberite,control_computer,us_cargo_bay];

                                                  if base = 2 then
                                                       temp_list = Replace(temp_list,1,us_medium_wheeled);  //Haven't got track extension
                                             end;
                                             nation_arabian: begin
                                                  b = true;
                                                  temp_list = [ar_half_tracked,engine_siberite,control_remote,ar_cargo_bay];
                                             end;
                                             nation_russian: begin
                                                  b = false;
                                                  temp_list = [ru_medium_tracked,engine_siberite,control_computer,ru_cargo_bay];
                                             end;
                                        end;

                                        b = FactConstruct(base,idle_factories,temp_list,b);
                                        if b in [0,1] then
                                             begin
                                                  if b = 1 then
                                                       ai_cargo_bay_under_construction = Replace(ai_cargo_bay_under_construction,base,true);

                                                  continue;
                                             end;
                                   end;
                         end;
                   }

                    //Construct a crane if we have none.
                    if base in [2,3] and difficulty > 1 then
                         begin                                                                                                                  
                              if ai_crane[base] = 0 and not ai_crane_under_construction[base] and tick - ai_crane_destroy_tick[base] >= [8$0,6$0,4$0][difficulty] then
                                   begin
                                        temp_list = [];

                                        case GetBaseNation(base) of
                                             nation_american: begin
                                                  temp_list = [us_medium_tracked,engine_siberite,control_remote,us_crane];

                                                  if ai_mechanics_defend[base] + ai_mechanics_attack[base] = 1 then  //We need someone to work in the factory
                                                       temp_list = Replace(temp_list,3,control_computer);

                                             end;
                                             nation_russian: begin
                                                  temp_list = [ru_medium_tracked,engine_combustion,control_manual,ru_crane];

                                                  if ai_mechanics_defend[base] + ai_mechanics_attack[base] = 1 then  //We need someone to work in the factory
                                                       temp_list = Replace(temp_list,3,control_computer);
                                             end;
                                        end;

                                        if temp_list > 0 then
                                             begin
                                                  b = 0;

                                                  temp = [0, ru_fact_2, us_fact_2][base];  //consider only the second factory for crane

                                                  if IsIdle(temp) then
                                                     if CanBeConstructed(temp, temp_list[1], temp_list[2], temp_list[3], temp_list[4]) then
                                                     begin
                                                          ComConstruct(temp, temp_list[1], temp_list[2], temp_list[3], temp_list[4]);
                                                          ai_crane_under_construction = Replace(ai_crane_under_construction,base,true);
                                                          continue;
                                                     end;


                                                  {for i = 1 to idle_factories do
                                                      if CanFactConstructThis(idle_factories[i],temp_list[4],true) = 1 then   //Only build it if we can build it right now, and choose factory
                                                         b = i;
                                                  }
                                                  {
                                                  if idle_factories > 0 and CanFactConstructThis(idle_factories[1],temp_list[4],true) = 1 then
                                                       begin
                                                            i = FactConstruct(base,[idle_factories[1]],temp_list,false);
                                                            if i in [0,1] then
                                                                 begin
                                                                      if i = 1 then
                                                                           ai_crane_under_construction = Replace(ai_crane_under_construction,base,true);

                                                                      continue;
                                                                 end;
                                                       end;
                                                  }
                                             end;
                                   end;
                         end;


                    //Construct war vehicles.
                    //If we are under attack then make sure we produce something we can construct without replacing
                    //factory extensions.
                    temp = 0;

                    if vehicle_prod_delay[base] > 0$0 then
                         begin
                              vehicle_prod_delay = Replace(vehicle_prod_delay,base, vehicle_prod_delay[base] - 0$1 );
                              temp = 1;
                         end;

                    if ai_vehicles_defend[base] + UnitFilter(ai_vehicles_attack[base],[[f_ok],[f_not,[f_weapon,59]],[f_not,[f_weapon,ar_selfpropelled_bomb]],[f_not,[f_weapon,ru_time_lapser]]]) < MaxNumWarVehicles[base] and temp = 0 then  //"59" identifies behemoths
                         begin
                              if saved_construct_list[base] > 0 and not under_attack then
                                   begin
                                        construct_list = saved_construct_list[base];
                                   end
                              else begin
                              construct_list = [];


                              idle_factories = idle_factories diff [ru_fact_2,us_fact_2];
                              if idle_factories = 0 then
                                 continue;

                              case base of
                                   2: begin
                                        //It's rather annoying that AvailableEngineList (and the other related functions) only work correctly if the required technology is also invented.

                                        temp_list = [ru_gun,ru_heavy_gun,ru_rocket_launcher,ru_rocket,ru_gatling_gun];

                                        if difficulty = 2 then
                                             temp_list = temp_list ^ ru_heavy_gun;  //Greater chance

                                        if difficulty = 3 then
                                             begin
                                                  temp_list = Replace(temp_list,1,ru_heavy_gun);
                                                  temp_list = Delete(temp_list,3);
                                             end;
                                        {if under_attack then
                                             temp_list = temp_list isect AvailableWeaponList(idle_factories[1]);

                                        if temp_list > 0 then
                                             temp_value = temp_list[Rand(1,temp_list+0)]
                                        else
                                             temp_value = ru_heavy_machine_gun;}  //You can always at least make ru_heavy_machine_gun
                                        temp_value = temp_list[Rand(1,temp_list+0)];

                                        {if difficulty = 1 and temp_value = ru_heavy_gun and Rand(1,2) = 1 then
                                             temp_value = ru_gun;}

                                        if under_attack then
                                             if CanFactConstructThis(idle_factories[1],temp_value,false) <> 1 then
                                                  temp_value = ru_heavy_machine_gun;  //You can always at least make ru_heavy_machine_gun

                                        if Rand(1,[2,3,4][difficulty]) = 1 and not temp_value in [ru_heavy_gun,ru_rocket] then
                                             i = ru_medium_tracked
                                        else
                                             i = ru_heavy_tracked;

                                        {if under_attack and ( not i in AvailableChassisList(idle_factories[1]) or not engine_siberite in AvailableEngineList(idle_factories[1]) or not control_computer in AvailableControlList(idle_factories[1]) ) then
                                             construct_list = []
                                        else}
                                        construct_list = [i,engine_siberite,control_computer,temp_value];
                                   end;
                                   1: begin
                                        temp_list = [ar_gun,ar_rocket_launcher,ar_gatling_gun];
                                        temp_value = temp_list[Rand(1,temp_list+0)];

                                        if under_attack then
                                             if CanFactConstructThis(idle_factories[1],temp_value,false) <> 1 then
                                                  temp_value = ar_double_machine_gun;  //You can always at least make ar_double_machine_gun

                                        construct_list = [ar_half_tracked,engine_siberite,control_remote,temp_value];
                                   end;
                                   3: begin
                                        temp_list = [us_double_gun,us_heavy_gun,us_rocket_launcher,us_gatling_gun];  //No laser. Causes too many rebuilds of factory extensions + isn't very effective against anything but vehicles and Americans mostly assault bases

                                        if difficulty = 2 then
                                             temp_list = temp_list ^ us_heavy_gun;  //Greater chance

                                        if difficulty = 3 then
                                             temp_list = Replace(temp_list,1,us_heavy_gun);

                                        temp_value = temp_list[Rand(1,temp_list+0)];

                                        {if difficulty = 1 and temp_value = us_heavy_gun and Rand(1,2) = 1 then
                                             temp_value = us_double_gun;}

                                        if under_attack then
                                             if CanFactConstructThis(idle_factories[1],temp_value,false) <> 1 then
                                                  temp_value = us_machine_gun;  //You can always at least make us_machine_gun

                                        if Rand(1,[2,3,4][difficulty]) = 1 and not temp_value = us_heavy_gun then
                                             i = us_medium_tracked
                                        else
                                             if Rand(1,3) = 1 and difficulty < 3 then
                                                  i = us_heavy_tracked
                                             else
                                                  i = us_morphling;

                                             construct_list = [i,engine_siberite,control_remote,temp_value];
                                   end;
                              end;
                              end;

                              if construct_list > 0 then
                                   begin

                                        b = FactConstruct(base,[idle_factories[1]],construct_list,base = 3);

                                        case b of
                                             0: saved_construct_list = Replace(saved_construct_list,base,construct_list);
                                             1,2: saved_construct_list = Replace(saved_construct_list,base,[]);
                                        end;
                                   end;

                              //vehicle_prod_delay = Replace(vehicle_prod_delay,base,[1$0,0$30,0$15][difficulty]);  -> Disrupts the planned attack time
                              continue;
                         end

                         //if there are enough normal defending vehicles, make the patrol units
                         else
                             begin
                                  if base = 3 then       //the ai lists differ: 3 bases in this ai, but ai_patrol contains only 2
                                     temp2 = 2           //hence base[3] = ai patrol[2]
                                  else
                                      if base = 2 then   //Russians don't make any patrol squads. Only replace 2 of the mb_vehicles
                                      begin
                                           if not 2 in mb_bases then
                                           begin
                                                for i = 1 to 2 do
                                                    if IsOk(mb_vehicles[2][i]) = 0 then
                                                    begin
                                                         chassis = ru_medium_tracked;
                                                         engine = engine_combustion;
                                                         control = control_computer;                   
                                                         weapon = ru_gun;
                                                         factory = ru_fact_1;

                                                         ComConstruct(factory,chassis,engine,control,weapon);

                                                         temp = mb_vehicles[2];
                                                         temp = Replace(temp, i, -1);
                                                         mb_vehicles = Replace(mb_vehicles, 2, temp);
                                                    end;
                                           end;

                                           continue;
                                      end
                                      else
                                          temp2 = 1;




                                  temp_list = ai_patrol_weapons[temp2];

                                  if temp_list > 0 then
                                  if not -1 in ai_patrol[temp2] and not temp2 in ai_patrol_out and not ai_patrol_status[temp2] = -1 then
                                     for i=1 to ai_patrol[temp2] do
                                         if ai_patrol[temp2][i]=0 or IsDead(ai_patrol[temp2][i]) then
                                         begin
                                              engine = engine_siberite;
                                              control = control_remote;
                                              weapon = temp_list[i];

                                              if base = 1 then
                                                 chassis = ar_half_tracked
                                              else
                                                  if temp_list[i] in [us_double_laser, us_laser, us_heavy_gun, us_rocket_launcher] then
                                                     chassis = us_morphling
                                                  else
                                                      chassis = us_medium_tracked;


                                              case base of
                                                   1: begin
                                                           factory = le_fact_1;

                                                           if CanFactConstructThis(factory,weapon,true) <> 1 then
                                                              continue;

                                                           {if weapon = ar_flame_thrower then               //switching extensions just for the flamer is too bothersome for Legion. They will make a flamer in the minor base if it exists, otherwise a gatling in the main base
                                                              if 1 in mb_bases and IsOk( HexInfo(22,31) ) then
                                                                 factory = HexInfo(22,31)
                                                              else
                                                                  weapon = ar_gatling_gun;  }
                                                      end;
                                                   3: if weapon in [us_double_laser, us_laser] then factory = us_fact_2
                                                         else factory = us_fact_1;
                                              end;

                                              ComConstruct(factory,chassis,engine,control,weapon);

                                              temp=ai_patrol[temp2];
                                              temp=Replace(temp,i,-1);
                                              ai_patrol=Replace(ai_patrol,temp2,temp);

                                              break;

                                         end;

                                  //////////////////////////////Hovercrafts for Legion////////////////////////////////
                                  if temp2 = 1 and ai_hovercrafts_out = 0 and not -1 in ai_patrol[temp2] and not -1 in ai_hovercrafts and not ai_hovercrafts_status = -1 then
                                     for i = 1 to ai_hovercrafts do
                                         if ai_hovercrafts[i] = 0 or IsDead(ai_hovercrafts[i]) then
                                         begin
                                              chassis = ar_hovercraft;
                                              engine = engine_combustion;
                                              control = control_remote;
                                              weapon = [ar_light_gun,ar_double_machine_gun][rand(1,2)];

                                              //if i = 6 then
                                              //   weapon = ar_radar;

                                              factory = le_fact_1;

                                              ComConstruct(factory,chassis,engine,control,weapon);

                                              ai_hovercrafts = Replace(ai_hovercrafts, i, -1);

                                              break;
                                         end;
                             end;
                        
                    //Taufield vehicles
                    if base = 2 and ai_taufield_vehicles[base] + UnitFilter(ai_vehicles_attack[base],[[f_ok],[f_weapon,ru_time_lapser]]) < MaxNumTaufieldVehicles(base) then
                         begin
                              b = FactConstruct(base,idle_factories,[ru_medium_tracked,engine_siberite,control_computer,ru_time_lapser],false);
                              if b in [0,1] then
                                   continue;
                         end;


                    //Siberite implosion vehicles
                    if base = 1 and ai_implosion_vehicles[base] + UnitFilter(ai_vehicles_attack[base],[[f_ok],[f_weapon,ar_selfpropelled_bomb]]) < MaxNumImplosionVehicles(base) then
                         begin
                              FactConstruct(base,idle_factories,[ar_half_tracked,engine_siberite,control_remote,ar_selfpropelled_bomb],true);
                         end;
               end;
                                                                                                       
          until false;
     end;
Function FactConstruct(base,fact_list,construct_list,check_ar_control_tower_amount);
     var i, temp_list, map_list, val;
     begin
          if fact_list = 0 then
               begin
                    result = 2;
                    exit;
               end;

          {if check_ar_control_tower_amount then
               begin
                    if UnitFilter(ai_vehicles_defend[base] ^ ai_vehicles_attack[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_cargo_bay[base] ^ ai_crane[base],[f_control,control_remote]) >= ai_control_tower_vehicles[base] * 2  //2 vehicles per control tower if possible
                      and ai_control_tower_vehicles[base] < ai_vehicle_pullback_hexes[base]  //We have to be able to park them
                      and ai_control_tower_vehicles[base] < ((ai_mechanics_defend[base] ^ ai_mechanics_attack[base]) diff ai_crane_driver[base]) - 1 then  //There must be a mechanic available. At least one in factory to produce
                         begin
                              result = FactConstruct(base,fact_list,[ar_half_tracked,engine_siberite,control_manual,ar_control_tower],false);

                              if result = 1 then
                                   result = 0;  //We didn't deliver what was expected. We made a control tower instead so the original "order" is still on hold.

                              exit;
                         end;

                    result = CheckAndFixArControlTowerAmount(base,fact_list,true);

                    if result <> -1 then
                         begin
                              if result = 1 then
                                   result = 0;  //We didn't deliver what was expected. We made a control tower instead so the original "order" is still on hold.

                              exit;
                         end;
               end;
          }
          result = CanFactConstructThis(fact_list[1],construct_list[4],true);
          if result = 1 then
               begin
                    if construct_list[2] = -1 then
                    begin
                         if IsInArea(construct_list[1], ru_scan1) then
                            AddComLinkToBase(RuDepot1, fact_list[1])
                         else
                             AddComLinkToBase(RuDepot2, fact_list[1]);

                         ComPlaceWeapon(construct_list[1],construct_list[4]);
                    end
                    else
                         ComConstruct(fact_list[1],construct_list[1],construct_list[2],construct_list[3],construct_list[4]);
               end;

          {
          This is generic code for handling if there actually are more factories to choose among
          but CanFactConstructThis is a tough function and causes laggs so we won't call it more
          than strictly necessary.

          temp_list = [];
          map_list = [];
          for i in fact_list do
               begin
                    case CanFactConstructThis(i,construct_list[4],false) of
                         0: val = 2;
                         1: val = 1;
                         2: val = 3;
                    end;

                    temp_list = temp_list ^ val;
                    map_list = Replace(map_list,i,val);
               end;

          fact_list = SortListByListAsc(fact_list,temp_list);

          case map_list[fact_list[1]] of
               1: begin
                    if construct_list[2] = -1 then
                         ComPlaceWeapon(construct_list[1],construct_list[4])
                    else
                         ComConstruct(fact_list[1],construct_list[1],construct_list[2],construct_list[3],construct_list[4]);
               end;
               2: begin
                    CanFactConstructThis(fact_list[1],construct_list[4],true);
               end;
               3: begin
                    result = 2;
               end;
          end;}
     end;
Function CheckAndFixArControlTowerAmount(base,fact_list,going_to_build_a_vehicle_after_this_check);
     var temp_list;
     begin
          temp_list = UnitFilter(ai_vehicles_defend[base] ^ ai_vehicles_attack[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_cargo_bay[base] ^ ai_crane[base],[f_control,control_remote]);

          if ai_control_tower_vehicles[base] < 7 or       //Make sure nothing is produced if there's no control tower at all
            ( temp_list+0 > ai_control_tower_vehicles[base] * 2 or ( temp_list+0 >= ai_control_tower_vehicles[base] * 2 and going_to_build_a_vehicle_after_this_check ) ) //2 vehicles per control tower if possible
            and ai_control_tower_vehicles[base] < ai_vehicle_pullback_hexes[base]  //We have to be able to park them
            and ai_control_tower_vehicles[base] < ((ai_mechanics_defend[base] ^ ai_mechanics_attack[base]) diff ai_crane_driver[base]) - 1 then  //There must be a mechanic available. At least one in factory to produce
               begin
                    result = FactConstruct(base,fact_list,[ar_half_tracked,engine_siberite,control_manual,ar_control_tower],false);
               end
          else
               result = -1;
     end;
//Function to test if a factory can build a specified weapon and if not then possibly doing something about it
//(dismantling existing not necessary factory extensions and building requires one(s)).
//0 -> can't build it but we are gonna do something about it.
//1 -> can build it. Go ahead.
//2 -> can't built it and we can't do anything about it.
Function CanFactConstructThis(fact,weapon,do_something_about_it);
     var base, i, temp_list, un, loc_list, btype_list_planned, btype_list_exists, temp_list_2, temp_list_3, all_needed, currently_needed;
     var fact_ext_replace_loc_list;
     begin
          base = FindBase(fact);
          if base = 0 then
               begin
                    result = 2;
                    exit;
               end;

          btype_list_planned = [];
          temp_list = [GetX(fact),GetY(fact)];

          for i = 1 to ai_buildings_locations[base]+0 do
               if ai_buildings_locations[base][i][4] in [b_ext_computer,b_ext_gun,b_ext_noncombat,b_ext_laser,b_ext_radar,b_ext_radio,b_ext_rocket,b_ext_siberium,b_ext_stitch,b_ext_track] then
                    if GetDistXY(ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2],temp_list[1],temp_list[2]) <= 4 then
                         begin
                              btype_list_planned = btype_list_planned ^ ai_buildings_locations[base][i][4];

                              un = HexInfo(ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2]);
                              if un > 0 and GetType(un) = unit_building and not IsConstructed(un) then
                                   btype_list_exists = btype_list_exists ^ GetBType(un);
                         end;

          currently_needed = [];

          case weapon of
               ar_cargo_bay,ru_cargo_bay,us_cargo_bay,ru_crane,us_crane,ru_bulldozer,us_bulldozer: begin //siberium extension for siberite engine
                    if ( ( b_ext_noncombat in btype_list_exists and (b_ext_computer in btype_list_exists or b_ext_radar in btype_list_exists) ) or ( GetBaseNation(base) = nation_arabian and b_ext_stitch in btype_list_exists ) ) and b_ext_siberium in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if GetBaseNation(base) = nation_arabian then
                                   begin
                                        if not b_ext_stitch in btype_list_planned then
                                             currently_needed = [b_ext_stitch];

                                        all_needed = [b_ext_stitch];
                                   end
                              else
                                   begin
                                        if not b_ext_noncombat in btype_list_planned then
                                             currently_needed = currently_needed ^ b_ext_noncombat;

                                        if not b_ext_computer in btype_list_planned then
                                             currently_needed = currently_needed ^ b_ext_computer;

                                        all_needed = [b_ext_noncombat,b_ext_computer];
                                   end;

                              if not b_ext_siberium in btype_list_planned then
                                   currently_needed = currently_needed ^ b_ext_siberium;

                              all_needed = all_needed ^ b_ext_siberium;
                         end;
               end;
               us_rocket_launcher,ru_rocket_launcher,ru_rocket,ar_rocket_launcher: begin
                    if b_ext_rocket in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_rocket in btype_list_planned then
                                   currently_needed = [b_ext_rocket];

                              all_needed = [b_ext_rocket];
                         end;
               end;
               us_light_gun,us_double_gun,us_heavy_gun,ru_gun,ru_heavy_gun,ar_light_gun,ar_gun: begin
                    if b_ext_gun in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_gun in btype_list_planned then
                                   currently_needed = [b_ext_gun];

                              all_needed = [b_ext_gun];
                         end;
               end;
               us_laser,us_double_laser: begin
                    if b_ext_laser in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_laser in btype_list_planned then
                                   currently_needed = [b_ext_laser];

                              all_needed = [b_ext_laser];
                         end;
               end;
               us_radar,ar_radar,ar_control_tower: begin
                    if b_ext_radar in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_radar in btype_list_planned then
                                   currently_needed = [b_ext_radar];

                              all_needed = [b_ext_radar];
                         end;
               end;
               ar_flame_thrower: begin
                    if b_ext_stitch in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_stitch in btype_list_planned then
                                   currently_needed = [b_ext_stitch];

                              all_needed = [b_ext_stitch];
                         end;
               end;
               ar_selfpropelled_bomb,ru_time_lapser: begin
                    if b_ext_siberium in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_siberium in btype_list_planned then
                                   currently_needed = [b_ext_siberium];

                              all_needed = [b_ext_siberium];
                         end;
               end;
               else begin
                    //No requirements
                    result = 1;
                    exit;
               end;
          end;

          if currently_needed = 0 then
               begin
                    result = 0;
               end
          else
               begin
                    if ai_engineers[base] = 0 then  //Only engineers can dismantle
                         begin
                              result = 2;
                              exit;
                         end;

                    //Determine the factory extension replace locations for this factory (if there are any).
                    fact_ext_replace_loc_list = [];
                    for i in ai_fact_extension_replace_locations[base] do
                         if GetDistUnitXY(fact,i[1],i[2]) <= 4 then
                              fact_ext_replace_loc_list = fact_ext_replace_loc_list ^ [i];

                    if fact_ext_replace_loc_list = 0 then
                         begin
                              result = 2;
                              exit;
                         end;

                    if not do_something_about_it then
                         exit;

                    temp_list_2 = [];
                    for i = 1 to ai_buildings_locations[base]+0 do
                         if [ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2]] in fact_ext_replace_loc_list then
                              temp_list_2 = temp_list_2 ^ i;

                    for i in temp_list_2 do
                         begin
                              if currently_needed = 0 then
                                   break;

                              if not ai_buildings_locations[base][i][4] in all_needed then
                                   begin
                                        //Dismantle the old factory extension and replace it with the right one.
                                        //Only dismantle finished buildings not to interfere with rebuild process.
                                        un = HexInfo(ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2]);
                                        if un > 0 and GetType(un) = unit_building and not IsConstructed(un) then
                                             begin
                                                  temp_list = Replace(ai_buildings_locations[base][i],4,currently_needed[1]);
                                                  temp_list = Replace(ai_buildings_locations[base],i,temp_list);
                                                  ai_buildings_locations = Replace(ai_buildings_locations,base,temp_list);

                                                  temp_list = ai_dismantle_these_buildings[base] ^ un;
                                                  ai_dismantle_these_buildings = Replace(ai_dismantle_these_buildings,base,temp_list);

                                                  if ai_facts_with_ext_rebuild_map < fact then
                                                       ai_facts_with_ext_rebuild_map = Replace(ai_facts_with_ext_rebuild_map,fact,[]);

                                                  temp_list = ai_facts_with_ext_rebuild_map[fact] ^ [[ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2]]];
                                                  ai_facts_with_ext_rebuild_map = Replace(ai_facts_with_ext_rebuild_map,fact,temp_list);
                                             end;

                                        currently_needed = Delete(currently_needed,1);
                                   end;
                         end;

                    //If there are more factory extensions that may be replaced with other extensions then swap the building locations around
                    //for those locations in ai_buildings_locations so number 1 becomes the last, number 2 number 1, number 3 number 2 etc.
                    //This is to ensure that it isn't the factory extension on the same spot that is rebuild every time.
                    //In this particular mission it is useful since the Americans replace a lot of factory extensions. If both rebuild spots
                    //are replaced with computer ext and noncombat ext then only one of those will be rebuild over and over again each
                    //time they want to build a new weapon (laser/gun/rocket launcher). Not very optimal.
                    if temp_list_2 >= 2 then
                         begin
                              temp_list_3 = ai_buildings_locations[base];
                              temp_list = ai_buildings_locations[base][temp_list_2[1]];

                              for i = 2 to temp_list_2+0 do
                                   begin
                                        temp_list_3 = Replace(temp_list_3,temp_list_2[i-1], temp_list_3[temp_list_2[i]] );
                                   end;

                              temp_list_3 = Replace(temp_list_3,temp_list_2[temp_list_2+0],temp_list);
                              ai_buildings_locations = Replace(ai_buildings_locations,base,temp_list_3);

                              //SortBuildingLocationsListInCorrectOrder(base);  //Just to make sure we don't screw something up. There should be no danger but just to be sure.
                         end;

                    if currently_needed = 0 then  //should be the case
                         result = 0
                    else
                         result = 2;
               end;
     end;
//If the player captures one of the computer's vehicles, then remove it from our variables-system.
On VehicleCaptured(new_identifier,old_identifier,old_side,capturing_unit) do
     var temp_list, base;
     begin
          if old_side = you then
               exit;

          for base in ai_bases do
               RemoveVehicleFromVariables(base,old_identifier);
     end;
//When a vehicle is constructed
On VehicleConstructed(vehicle,factory) do
     var side, temp_list, base, un, i, j, temp;
     begin
          side = GetSide(vehicle);
          if side = you then
               begin
                    exit;
               end;

          //for minor bases
          if GetEngine(vehicle)=engine_combustion and not GetWeapon(vehicle) in [ru_crane,us_crane] then
             if GetChassis(vehicle) = ar_hovercraft then
             begin
                  for j = 1 to ai_hovercrafts do
                      if ai_hovercrafts[j] = -1 then
                      begin
                           if Rand(1,100) <= [20, 40, 60][difficulty] then
                              SetTag(vehicle, 1);

                           ai_hovercrafts = Replace(ai_hovercrafts, j, vehicle);
                           exit;
                      end;
             end
             else
                 begin
                      i=[3,0,2,0,0,0,0,1][side];

                      for j=1 to mb_vehicles[i] do
                          if mb_vehicles[i][j] = -1 then
                          begin
                               temp_list=mb_vehicles[i];
                               temp_list=Replace(temp_list,j,vehicle);
                               mb_vehicles=Replace(mb_vehicles,i,temp_list);

                               exit;
                          end;
                 end;

          base = FindBase(vehicle);
          if base = 0 then
               exit;


          if GetSide(vehicle) = 1 then
             DoNotAttack(4,vehicle);

          //for patrol - vehicles will be included only if the normal vehicles defences are full, otherwise will be added to normal defences
          //unless it's the SPBomb. those always go into patrol
          if base = 3 then
             temp = 2
          else
              if base = 2 then
                 temp = 0
              else temp = 1;

          if temp > 0 then
             if -1 in ai_patrol[temp] and not GetWeapon(vehicle) in [us_crane, ru_siberium_rocket] then  //Legion doesn't have crane and Russians don't make patrol units
                for j=1 to ai_patrol[temp] do
                    if ai_patrol[temp][j] = -1 then
                       if ai_vehicles_defend[base] >= MaxNumWarVehicles[base] or GetWeapon(vehicle) = ar_selfpropelled_bomb then
                       begin
                            temp_list=ai_patrol[temp];
                            temp_list=Replace(temp_list,j,vehicle);
                            ai_patrol=Replace(ai_patrol,temp,temp_list);

                            exit;
                     
                       end
                       else
                           begin
                                temp_list=ai_patrol[temp];
                                temp_list=Replace(temp_list,j,0); //reset the value if the vehicle is added to normal defence
                                ai_patrol=Replace(ai_patrol,temp,temp_list);

                                break;
                           end;
         

          case GetWeapon(vehicle) of
               us_cargo_bay,ar_cargo_bay,ru_cargo_bay: begin
                    ai_cargo_bay = Replace(ai_cargo_bay,base,vehicle);
                    ai_cargo_bay_under_construction = Replace(ai_cargo_bay_under_construction,base,false);
               end;
               us_crane,ru_crane: begin
                    ai_crane = Replace(ai_crane,base,vehicle);
                    ai_crane_under_construction = Replace(ai_crane_under_construction,base,false);
               end;
               ar_control_tower: begin
                    temp_list = ai_control_tower_vehicles[base] ^ vehicle;
                    ai_control_tower_vehicles = Replace(ai_control_tower_vehicles,base,temp_list);
               end;
               ar_selfpropelled_bomb: begin
                    temp_list = ai_implosion_vehicles[base] ^ vehicle;
                    ai_implosion_vehicles = Replace(ai_implosion_vehicles,base,temp_list);
               end;
               ru_time_lapser: begin
                    temp_list = ai_taufield_vehicles[base] ^ vehicle;
                    ai_taufield_vehicles = Replace(ai_taufield_vehicles,base,temp_list);
               end;
               ru_siberium_rocket,us_siberium_rocket: begin
                    temp_list = ai_sib_bomb_vehicles[base] ^ vehicle;
                    ai_sib_bomb_vehicles = Replace(ai_sib_bomb_vehicles,base,temp_list);
               end;
               else begin
                    temp_list = ai_vehicles_defend[base] ^ vehicle;
                    ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
               end;
          end;
     end;
On BehemothConstructed(behe) do
     var side, base, temp_list, i;
     begin
          side = GetSide(behe);
          if side = you then
               exit;

          base = 0;
          for i in ai_bases do
              if i = 2 then
                 if GetX(behe) = ai_behemoth_construction_hex[i][1] and GetY(behe) = ai_behemoth_construction_hex[i][2] then
                    begin
                         base = i;
                         break;
                    end;

          if base = 0 then
               exit;

          temp_list = ai_behemoths[base] ^ behe;
          ai_behemoths = Replace(ai_behemoths,base,temp_list);

          ai_behemoth_build_tick = tick;
     end;


Export Function ResetVehicleAttackDelay(base);
     var time;
     begin
          time = [5$15,4$30,3$45][difficulty];



          ai_vehicle_attack_delay = Replace(ai_vehicle_attack_delay,base, Rand(time,time+0$30) );
     end;
Export Function ResetHumanAttackDelay(base);
     begin
          //ai_human_attack_delay = Replace(ai_human_attack_delay,base, Rand(6$30,8$30) - 0$45 * difficulty );
          //Not used in this mission
     end;


Export Function FindNonhumansNearUnit(side,un,dist,only_dangerous);
     var weapon_list, temp_list, i, btype, b, val;
     begin
          temp_list = FilterAllUnits([[f_enemy,side],[f_not,[f_type,unit_human]],[f_dist,un,dist],[f_see,side]]);

          if only_dangerous then
               begin
                    result = DangerousUnits(temp_list);
               end
          else
               result = temp_list
     end;


//The computers's vehicles never seem to run completely out of fuel...
Every 0$5 do
     var base, i;
     begin
          for base in ai_bases do
               for i in (ai_vehicles_attack[base] ^ ai_vehicles_defend[base] ^ ai_cargo_bay[base] ^ ai_crane[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_control_tower_vehicles[base] ^ ai_sib_bomb_vehicles[base]) diff 0 do
                    if GetFuel(i) < 10 and GetEngine(i) = engine_combustion then
                         SetFuel(i,10);

          enable;
     end;



//Scientists
//If a scientist is wounded them pull him/her back. Else heal what people needs healing. Else stay inside a lab (if no lab is Ok then help
//construct buildings).
Every 0$1+0$0.7 do
     var side, i, scientists_list, temp_list, temp_unit, base, k, temp_list_3, area;
     begin

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    side = GetBaseSide(base);

                    scientists_list = ai_scientists[base] diff ai_heal_these_humans[base];


                    //Identify scientists who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= scientists_list do
                         begin
                              if GetLives(scientists_list[i]) <= 700 then
                                   begin
                                        temp_list = temp_list ^ scientists_list[i];
                                        scientists_list = Delete(scientists_list,i);
                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Update people who need healing. People at full HP or people inside a unit (relevant for soldiers and mechanics)
                    //will not receive healing.
                    temp_list = [];
                    for i in ai_heal_these_humans[base] do
                         if GetLives(i) < 1000 and IsInUnit(i) = 0 then
                              temp_list = temp_list ^ i;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Control people who need healing. Make 'em retreat to the human pullback hex.
                    for i in ai_heal_these_humans[base] do
                         begin
                              if GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 4 then
                                   ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                         end;


                    if scientists_list = 0 then
                         continue;


                    //Heal people. At least one scientist for each human if possible.
                    //Only heal people inside the base.
                    if ai_heal_these_humans[base] > 0 then
                         begin
                              area = GetBaseArea(base);
                              temp_list = UnitFilter(ai_heal_these_humans[base],[f_inarea,area]);

                              if temp_list > 0 then
                                   begin
                                        scientists_list = GetHumansOutOfUnits(scientists_list);

                                        repeat
                                             i = 1;
                                             while i <= temp_list do
                                                  begin
                                                       if scientists_list = 0 then
                                                            break;

                                                       temp_unit = NearestUnitToUnit(scientists_list,temp_list[i]);
                                                       ComHeal(temp_unit,temp_list[i]);
                                                       scientists_list = scientists_list diff temp_unit;

                                                       i = i + 1;
                                                  end;

                                        until scientists_list = 0;

                                        scientists_list = temp_list_3;
                                   end;
                         end;


                    //Enter and stay in lab
                    DistributeHumansToBuildings(base,scientists_list, UnitFilter(ai_labs[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_scientistic,6,true,false);
               end;

          until false;
     end;




//Preparation for attack.
Every 0$1 do
var i, j, un_list, temp_list, temp_list2, base;
var le_path, ru_path, us_path, special_attack, hold, temp, temp2;
begin
     //Attacks just for appearances, between the main bases
     //Doesn't require as extensive attack module, are supposed to be simple and insignificant
     //Then make a few vehicles and attack
     //In case of breaching the Russian defences by the player, other enemies intensify their attacks

     Randomize;

     //paths:
     //Legion - attacks Russians accross the river
     //Russians - attack Legion lowest entry
     //         - attack Legion through the swamp
     //         - teleport up the map and attack Legion right entrance
     //         - attack Americans directly
     //         - attack Americans upper part of the base
     //Americans- attack Russians directly
     //         - attack Russian minor base from the bottom
     //         - attack Russian bse from the top


     le_path = [ [[108,199],[122,205],[133,210],[142,210],[150,210],[166,217],[168,206],[172,201],[186,205]]
                ];
     ru_path = [ [[185,203],[167,199],[167,211],[163,218],[144,216],[130,216],[117,213],[107,202],[93,165]],
                 [[185,203],[167,199],[167,211],[163,218],[144,216],[142,204],[150,197],[151,184],[148,173],[143,161],[138,150],[128,137],[116,148]],
                 [[200,232],[193,228],[120,110],[120,118],[122,125],[122,131],[117,131],[112,132],[114,140],[117,149]],
                 [[204,175],[217,176],[230,180],[232,166]],
                 [[195,170],[185,163],[174,148],[174,137],[187,136],[188,127],[195,119],[214,138]]
                ];
     us_path = [ [[242,193],[232,192],[221,193],[223,204],[211,205]],
                 [[230,184],[218,175],[209,165],[197,153],[186,152],[178,151],[172,153],[165,139],[167,130]],
                 [[214,130],[204,116],[192,114],[184,115],[169,114]]
                ];


     temp_list = [RussianDefences1, RussianDefences2, RussianDefences3, RussianDefences4];
     special_attack = [];

     for i = 1 to temp_list do
         if FilterUnitsInArea(temp_list[i], [f_btype,b_barracks]) = 0 then
         begin
              temp_list2 = FilterUnitsInArea(temp_list[i], [[f_or,[f_btype,b_bunker],[f_btype,b_turret]],[f_ok]]);

              for j in temp_list2 do
                  if GetBase(j) = 0 then
                     temp_list2 = temp_list2 diff j;
                  {else
                      if GetEnergy( GetBase(j) )[4] = 0 then
                         temp_list2 = temp_list2 diff j; }

              if temp_list2 < 3 and PlayerEnteredRussianBase then
                 special_attack = special_attack ^ i;
         end;

     if special_attack > 0 then
     begin
          FinalAttack = 1;
          {
          if AttackStatus <> 2 then
          begin
               FinalAttack = 1;
               AttackStatus = 3;
          end;
              }
          FAttackType = special_attack;

          if AttackStatus = 3 and PowellAttack = 0 and special_attack[1] < 4 then
             PowellAttack = 1;
     end;

     if special_attack = 0 {and AttackStatus > 2} then
     begin
          FinalAttack = 0;
          //AttackStatus = 0;
     end;

     for base = 1 to AttackStatus do
     case AttackStatus[base] of
          0: begin       
                  if not FinalAttack then
                     AttackTimer = Replace(AttackTimer, base, AttackTimer[base] - 0$1);

                  if AttackTimer[base] <= 0 then
                  begin
                       AttackStatus = Replace(AttackStatus, base, 1);
                       MaxNumWarVehicles = Replace(MaxNumWarVehicles, base, 6);
                  end;
             end;

          1: begin
                  if FinalAttack then
                     AttackStatus = Replace(AttackStatus, base, 0)
                  else
                  begin
                       temp_list = ai_vehicles_defend[base];

                       for i in temp_list do
                           if IsControledBy(i) = 0 and GetControl(i) = control_remote then
                              temp_list = temp_list diff i;

                       if temp_list = ai_vehicles_defend[base] and temp_list >= MaxNumWarVehicles[base] then
                       begin
                            AttackStatus = Replace(AttackStatus, base, 2);
                            MaxNumWarVehicles = Replace(MaxNumWarVehicles, base, 0);
                            AttackHexCount = Replace(AttackHexCount, base, 1);

                            case base of
                                 1: AttackPath = Replace(AttackPath, base, le_path[1]);

                                 2: begin
                                         temp_list = [1,2];

                                         if 1 in BasesDestroyed then
                                            temp_list = temp_list diff 1;
                                         if 3 in BasesDestroyed then
                                            temp_list = temp_list diff 2;

                                         if temp_list = [] then
                                         begin
                                              AttackStatus = Replace(AttackStatus, base, 0);
                                              AttackTimer = Replace(AttackTimer, base, 999$0);
                                         end
                                         else
                                             if temp_list[Rand(1,temp_list)] = 1 then
                                             begin
                                                  case Rand(1,3) of
                                                       1: AttackPath = Replace(AttackPath, base, ru_path[1]);
                                                       2: AttackPath = Replace(AttackPath, base, ru_path[2]);
                                                       3: begin
                                                               AttackPath = Replace(AttackPath, base, ru_path[3]);

                                                               for i = 1 to ai_vehicles_defend[base] do       //splitting the group between two teleports
                                                                   if (i div 2) = (i/2) then
                                                                      SetTag(ai_vehicles_defend[base][i],1)
                                                                   else
                                                                       SetTag(ai_vehicles_defend[base][i],2);
                                                          end;
                                                  end;
                                             end
                                             else
                                                 if Rand(1,2) = 1 then
                                                    AttackPath = Replace(AttackPath, base, ru_path[4])
                                                 else
                                                     AttackPath = Replace(AttackPath, base, ru_path[5]);
                                    end;

                                 3: if not 2 in mb_bases then
                                       AttackPath = Replace(AttackPath, base, us_path[1])
                                    else
                                        case Rand(1,3) of
                                             1: AttackPath = Replace(AttackPath, base, us_path[1]);
                                             2: AttackPath = Replace(AttackPath, base, us_path[2]);
                                             3: AttackPath = Replace(AttackPath, base, us_path[3]);
                                        end;
                            end;

                            AttackUnits = Replace(AttackUnits, base, ai_vehicles_defend[base]);

                            for i in ai_vehicles_defend[base] do
                                RemoveVehicleFromVariables(base,i);
                       end;
                  end;
             end;

          2: begin
                  //if teleported
                  if GetBType(HexInfo(AttackPath[base][2][1], AttackPath[base][2][2])) = b_teleport then
                  begin
                       hold = 1;
                       temp_list = UnitFilter(AttackUnits[base], [f_inarea,base_russians]);

                       for i in AttackUnits[base] diff temp_list do
                           if GetTaskList(i) > 0 then
                              ComFree(i);

                       if temp_list = [] then
                       begin
                            hold = 0;

                            if AttackHexCount[base] < 3 then
                               AttackHexCount = Replace(AttackHexCount, base, 3);
                       end
                       else
                           if unitfilter(temp_list, [[f_not,[f_distxy,AttackPath[base][1][1],AttackPath[base][1][2],11]]]) > 0 then
                           begin
                                for i in temp_list do
                                    if GetDistUnitXY(i,AttackPath[base][1][1],AttackPath[base][1][2]) > 8 then
                                       ComMoveXY(i,AttackPath[base][1][1],AttackPath[base][1][2]);
                           end
                           else
                               begin
                                    temp_list2 = FilterAllUnits([f_btype,b_teleport]);

                                    if temp_list2 < 2 then
                                       AttackPath = Replace(AttackPath, base, ru_path[2])
                                    else
                                        begin
                                             for i in temp_list do
                                                 if GetTag(i) = 1 then
                                                 begin
                                                      SetTaskList(i, [['q',0,0,temp_list2[1],0,0,0]]);
                                                      break;
                                                 end;

                                             for i in temp_list do
                                                 if GetTag(i) = 2 then
                                                 begin
                                                      SetTaskList(i, [['q',0,0,temp_list2[2],0,0,0]]);
                                                      break;
                                                 end;
                                        end;
                               end;
                  end;



                  if not hold then
                  begin
                       if unitfilter(AttackUnits[base], [[f_not,[f_distxy,AttackPath[base][AttackHexCount][1],AttackPath[base][AttackHexCount][2],12]],[f_ok]]) = 0 then
                          if AttackHexCount[base] < AttackPath[base] then
                             AttackHexCount = Replace(AttackHexCount, base, AttackHexCount[base] + 1);

                       if AttackHexCount[base] >= AttackPath[base] then
                       begin
                            temp_list = UnitFilter(AttackUnits[base], [f_ok]);
                            if temp_list > 0 then
                               ComAttackUnit(temp_list, NearestUnitToUnit(FilterAllUnits([f_enemy,GetSide(temp_list[1])]), temp_list[1]) );
                       end
                       else
                           for i in AttackUnits[base] do
                           begin
                                case GetWeapon(i) of
                                     ru_rocket,ru_rocket_launcher,us_rocket_launcher,ar_rocket_launcher: temp = 15;
                                     ru_heavy_gun,us_heavy_gun: temp = 12;
                                     else temp = 10;
                                end;

                                temp2 = FilterAllUnits([[f_enemy,GetSide(i)],[f_dist,i,temp]]);

                                if temp2 > 0 then
                                   ComAttackUnit(i, temp2[1])
                                else
                                    ComMoveXY(i,AttackPath[base][AttackHexCount][1],AttackPath[base][AttackHexCount][2]);
                           end;

 

                       if UnitFilter(AttackUnits[base], [f_ok]) = 0 and not FinalAttack then
                       begin
                            AttackStatus = Replace(AttackStatus, base, 0);
                            AttackTimer = Replace(AttackTimer, base, 0$30);
                       end;
                  end;
          end;

     end;

enable;
end;

//add vehs to attack only after the remote control
//trigger prematurely if attaacked first
//limit range of detection for player units
every 0$1 trigger FinalAttack do
var i, j, temp, path, hex, temp_list, temp_list2, c, un, val, dist;
begin
     for i in [1,3] do
         if MaxNumWarVehicles[i] = 0 then
            MaxNumWarVehicles = Replace(MaxNumWarVehicles, i, [4,5,6][difficulty]);

     path = [[[231,178],[225,180],[216,173]],
             [[231,178],[236,187],[241,194],[238,201]],
             [[231,178],[236,187],[246,200],[252,210],[254,217],[254,227],[257,236]],
             [[108,195],[118,201],[129,207],[138,210],[148,211]],
             ];

     hex = [[148,211]];

     case FAttackType[1] of
          1: hex = hex ^ [[216,173]];
          2: hex = hex ^ [[238,201]];
          3: hex = hex ^ [[257,236]];
     end;

     temp_list = ai_vehicles_defend[1];
     for i in temp_list do
         if IsControledBy(i) = 0 then
            temp_list = temp_list diff i;

     if 4 in FAttackType and temp_list = MaxNumWarVehicles[1] and FinalVehs[1] = 0 then
     begin
          FinalVehs = Replace(FinalVehs, 1, ai_vehicles_defend[1]);
          Fcount = Replace(Fcount,1, 1);

          for i in ai_vehicles_defend[1] do
              RemoveVehicleFromVariables(1,i);

          //for j in path[4] do
          //    AddComMoveXY(FinalVehs[1], j[1], j[2]);
     end;

     temp_list = ai_vehicles_defend[3];
     for i in temp_list do
         if IsControledBy(i) = 0 then
            temp_list = temp_list diff i;

     if FAttackType[1] < 4 and temp_list = MaxNumWarVehicles[3] and FinalVehs[2] = 0 then
     begin
          temp = FAttackType[1];

          FinalVehs = Replace(FinalVehs, 2, ai_vehicles_defend[3]);
          Fcount = Replace(Fcount,2, 1);

          for i in ai_vehicles_defend[3] do
              RemoveVehicleFromVariables(3,i);

          if PowellAttack = 1 then
          begin
               temp_list = Powell;
               RemoveHumanFromVariables(3,Powell, false);

               for i = 1 to 9 do
               begin
                    if i < 5 then
                       c = class_sniper
                    else
                        c = class_soldier;

                    temp_list2 = UnitFilter(ai_soldiers[3], [f_class,c]);
                    un = BestOfSkill(temp_list2, skill_combat);

                    temp_list = temp_list ^ un;
                    RemoveHumanFromVariables(3,un, false);

                    ComExitBuilding(un);
               end;

               FinalVehs = Replace(FinalVehs, 2, FinalVehs[2] ^ temp_list);
               PowellAttack = 2;
          end;

          //for j in path[temp] do
          //    AddComMoveXY(FinalVehs[2], j[1], j[2]);

     end;



     for i = 1 to 2 do
         if FinalVehs[i] > 0 then
            if Fattacking[i] = 0 then
            begin
                 
                 temp = Fcount[i];
                 val = FAttackType[1];
                 {
                 for j in FinalVehs[i] do
                     if GetDistUnitXY(j, path[val][temp][1], path[val][temp][2]) > 6 and HasTask(j) = 0 then
                        ComMoveXY(j, path[val][temp][1], path[val][temp][2]);

                 if UnitFilter(FinalVehs[i], [f_not,[f_distxy, path[val][temp][1], path[val][temp][2], 10]]) = 0 then
                    Fcount = Replace(Fcount, i, Fcount[i] + 1);
                 }

                 if Fcount[i] = 1 then
                 begin
                      for j in path[val] do
                          AddComMoveXY(FinalVehs[i], j[1], j[2]);
                      Fcount = Replace(Fcount, i, 2);
                 end
                    else
                        for j in FinalVehs[i] do
                            if Hastask(j) = 0 and GetDistUnitXY(j, hex[i][1], hex[i][2]) > 6 then
                               ComMoveXY(j, hex[i][1], hex[i][2]);



                 if UnitFilter(FinalVehs[i], [[f_not,[f_distxy,hex[i][1], hex[i][2],6]],[f_ok]]) = 0 then
                    Fattacking = Replace(Fattacking, i, 1);

                 for j in FilterAllUnits([f_or,[f_side,2],[f_side,3]]) do
                     if Attacks(j) in FinalVehs[i] then
                        Fattacking = Replace(Fattacking, i, 1);
            end
            else
                begin
                     for j in FinalVehs[i] do
                         if not IsOk(j) then
                            FinalVehs = Replace(FinalVehs, i, FinalVehs[i] diff j);

                     if FinalVehs[i] = 0 then
                     begin
                          Fattacking = Replace(Fattacking, i, 0);
                          continue;
                     end;


                     temp_list = [];
                     for j in FilterAllUnits([f_side,2]) do
                         if GetDistUnitArea(j, base_russians) <=10 then
                            temp_list = temp_list ^ j;

                     if temp_list = 0 then
                     begin
                          temp = NearestUnitToUnit( FilterAllUnits([f_side,3]), FinalVehs[i][1]);
                          ComAttackUnit(FinalVehs[i], temp);
                     end
                        else
                            for j in FinalVehs[i] do
                            begin
                                 if GetType(j) = unit_human or GetWeapon(j) in [us_gatling_gun,us_rocket_launcher,ar_gatling_gun,ar_flame_thrower,ar_rocket_launcher] then
                                    temp = [unit_human, unit_vehicle]
                                 else
                                     temp = [unit_vehicle, unit_human];

                                 temp_list2 = UnitFilter(temp_list, [f_type, temp[1]]) ^ UnitFilter(temp_list, [f_type, temp[2]]);
                                 temp = NearestUnitToUnit( temp_list2, FinalVehs[i][1]);

                                 //check if there's a behemoth closer than the closest player unit
                                 un = NearestUnitToUnit( FilterAllUnits([[f_weapon,59],[f_ok]]), FinalVehs[i][1]);

                                 if GetDistUnits(un, FinalVehs[i][1]) < GetDistUnits(temp, FinalVehs[i][1]) then
                                    temp = un;

                                 if See(GetSide(j), temp) then
                                    ComAttackUnit(j, temp)
                                 else
                                     ComMoveUnit(j, temp);
                            end;
                end;

     if Fdlg = 0 then
        if PowellAttack > 0 and not IsInArea(Powell, base_us) and See(2, Powell) then
        begin
             Fdlg = 1;
             Say(Powell, 'PowellCharge');
        end;

enable;
end;

Export PlayerEnteredRussianBase;
every 0$1 trigger FilterUnitsInArea(InRussianBase, [f_side,2]) > 0 do
PlayerEnteredRussianBase = 1;




//Function DistributeHumansToBuildings - base = 2 won't change soldier class to special class in barracks (sniper,bazooker,mortar).
//Scientist control code - Exception for Alliance main characters (base = 2).
//ai_buildings_locations is modified in module "Events_Alliance".

//Known "bug" - if a factory is having an extension rebuilt and the base comes under attack that factory will not produce vehicles
//while under attack even if it should.


//The computer has unlimited resources
Every 0$1.5 do
     var i, base, val;
     begin
          for i = 1 to ai_depot do
               if IsOk(ai_depot[i]) and GetSide(ai_depot[i]) <> you then  //IsOk -> no sib spawn if depot is destroyed. See UnitGoesToRed.
                    begin
                         base = GetBase(ai_depot[i]);

                         if i = 2 and alli_sib_needed > 0 then
                              begin
                                   val = GetResourceType(base,mat_siberit) + alli_sib_usage - 500;
                                   if val > 0 then
                                        alli_sib_needed = alli_sib_needed - val;

                                   alli_sib_usage = 0;
                                   if alli_sib_needed < 0 then
                                        alli_sib_needed = 0;

                                   if alli_sib_needed > 0 then
                                        display_strings = ['#Ar15a-AlliSibGather',alli_sib_needed]
                                   else
                                        display_strings = [];
                              end;

                         SetResourceType(base,mat_cans,500);
                         SetResourceType(base,mat_oil,500);
                         SetResourceType(base,mat_siberit,500);
                    end;

          enable;
     end;


On UnitGoesToRed(un) do
     var base;
     begin
          //Leaders saying their last words
          if un = Powell and not Powell in last_dialogue_leaders then
               begin
                    last_dialogue_leaders = last_dialogue_leaders ^ Powell;
                    DialogueOn;
                    ForceSay(Powell,'D21-Po-1');
                    DialogueOff;
               end;

          if un = Platonov and not Platonov in last_dialogue_leaders then
               begin
                    last_dialogue_leaders = last_dialogue_leaders ^ Platonov;
                    DialogueOn;
                    ForceSay(Platonov,'D21-Pla-1');
                    DialogueOff;
               end;

          if un = Omar and not Omar in last_dialogue_leaders then
               begin
                    last_dialogue_leaders = last_dialogue_leaders ^ Omar;
                    DialogueOn;
                    ForceSay(Omar,'D21-Om-1');
                    DialogueOff;
               end;

          if un = Joan and not Joan in last_dialogue_leaders then
               begin
                    last_dialogue_leaders = last_dialogue_leaders ^ Joan;
                    DialogueOn;
                    ForceSay(Joan,'D21-Jo-1');
                    DialogueOff;
               end;

          if GetSide(un) = you then
               exit;

          base = FindBase(un);
          if base = 0 then
               exit;

          //Russian teleporter exit is reset when teleporter goes to red.
          if un = ai_teleporter[base] then
               ai_teleporter_exit_placed = Replace(ai_teleporter_exit_placed,base,false);

          //If the player destroys a depot no siberite shall spawn. This cannot be set in UnitDestroyed but works fine
          //here in UnitGoesToRed even if the depot goes from yellow to destroyed in one go.
          if GetType(un) = unit_building then
               if GetBType(un) in [b_depot,b_warehouse] then
                    begin
                         //Should be same amounts as if depot was captured (except siberite).
                         SetResourceType(GetBase(un),mat_cans,[100,50,0][difficulty] + Rand(0,3)*10);
                         SetResourceType(GetBase(un),mat_oil,[200,150,100][difficulty] + Rand(0,100));
                         SetResourceType(GetBase(un),mat_siberit,0);
                    end;

          if base = 2 and GetType(un) in [unit_human,unit_building] and SideShoot(un) = you then
               player_alliance_uns_red = player_alliance_uns_red union un;
     end;
Every 0$1 do
     var i;
     begin
          for i in player_alliance_uns_red do
               if GetLives(i) > 250 then
                    player_alliance_uns_red = player_alliance_uns_red diff i;

          enable;
     end;

On UnitDestroyed(un) do
     var side, temp_list, base, temp_value, i;
     begin
          if un = Heike then
               begin
                    ExclusiveOn;
                    Wait(0$1);
                    YouLost('HeikeDead');
                    ExclusiveOff;
               end;

          if un = player_sib_bomb_prod_fact then
               player_sib_bomb_prod_fact = 0;

          if un = player_sib_bomb_res_lab then
               player_sib_bomb_res_lab = 0;

          if un in player_alliance_uns_red then
               begin
                    if GetType(un) = unit_human then
                         player_alliance_uns_destroy = Replace(player_alliance_uns_destroy,1, player_alliance_uns_destroy[1] ^ GetClass(un) )
                    else  //building
                         player_alliance_uns_destroy = Replace(player_alliance_uns_destroy,2, player_alliance_uns_destroy[2] ^ GetBType(un) );

                    player_alliance_uns_red = player_alliance_uns_red diff un;
               end;

          for base in ai_bases do
               begin
                    temp_list = ai_captured_buildings[base] diff un;
                    ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
               end;

          side = GetSide(un);

          if side = you then
               exit;


          //Update computer variables
          case GetType(un) of
               unit_human:
                    for base in ai_bases do
                         begin
                              if base = 2 and RemoveHumanFromVariables(base,un,true) and not am_going_to_destroy_alli and alliance_deal_status <> 2 and (ai_sib_bomb_used_time_matrix[base] diff -1) = 0 then
                                   begin
                                        if SideShoot(un) <> you then  //works even if the unit which last shot at "un" is now dead
                                             temp_value = GetClass(un)
                                        else
                                             temp_value = 0;
                                                   
                                        //Create new unit to compensate?
                                        if temp_value > 0 then
                                             begin
                                                  if temp_value in [class_apeman_engineer,class_apeman_soldier] then
                                                       temp_list = CreateApemenWithClass(1,temp_value,base)
                                                  else
                                                       if temp_value in [class_soldier,class_engineer,class_mechanic,class_scientistic,class_bazooker,class_sniper,class_mortar] then
                                                            temp_list = CreateUnitsWithClass(1,temp_value,base)
                                                       else
                                                            temp_list = 0;

                                                  if temp_list > 0 then
                                                       begin
                                                            temp_list = ai_spawn_people[base] ^ temp_list;
                                                            ai_spawn_people = Replace(ai_spawn_people,base,temp_list);
                                                       end;
                                             end;
                                   end;
                         end;
               unit_vehicle:
                    for base in ai_bases do
                         RemoveVehicleFromVariables(base,un);
               unit_building:
                    for base in ai_bases do
                         RemoveBuildingFromVariables(base,un);
          end;
     end;
//Annoyingly siberite implosion vehicles and kamikaze apes don't trigger event UnitDestroyed.
//Self destruction (Arab tech) does trigger event UnitDestroyed, though.
Every 0$0.5 do
     var base, i;
     begin
          for base in ai_bases do
               begin
                    for i in ai_implosion_vehicles[base] do
                         if IsDead(i) then
                              RemoveVehicleFromVariables(base,i);
                    
                    for i in ai_vehicles_attack[base] do  //Can't do a filter on implosion vehicles because if the vehicle is dead no info about it can be fetched
                         if IsDead(i) then
                              RemoveVehicleFromVariables(base,i);
               end;

          enable;
     end;
Export Function RemoveBuildingFromVariables(base,building);
     var temp_list;
     begin
          temp_list = ai_all_buildings[base] diff building;
          ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

          temp_list = ai_excepted_buildings[base] diff building;
          ai_excepted_buildings = Replace(ai_excepted_buildings,base,temp_list);

          temp_list = ai_dismantle_these_buildings[base] diff building;
          ai_dismantle_these_buildings = Replace(ai_dismantle_these_buildings,base,temp_list);

          if building = ai_building_under_construction[base] then
               ai_building_under_construction = Replace(ai_building_under_construction,base,0);

          if building = ai_sib_bomb_fact[base] then
               ai_sib_bomb_fact = Replace(ai_sib_bomb_fact,base,0);

          UpdateBuildingBasicVariables(base,building,false);
     end;
Function RemoveVehicleFromVariables(base,vehicle);
     var temp_list;
     begin
          //Global "basis" lists of vehicles. If a vehicle belong to this base it will be in one
          //and only one of these lists.
          if vehicle in ai_vehicles_defend[base] then
               begin
                    temp_list = ai_vehicles_defend[base] diff vehicle;
                    ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
               end;

          if vehicle in ai_vehicles_attack[base] then
               begin
                    temp_list = ai_vehicles_attack[base] diff vehicle;
                    ai_vehicles_attack = Replace(ai_vehicles_attack,base,temp_list);
               end;

          if vehicle in ai_taufield_vehicles[base] then
               begin
                    temp_list = ai_taufield_vehicles[base] diff vehicle;
                    ai_taufield_vehicles = Replace(ai_taufield_vehicles,base,temp_list);
               end;

          if vehicle in ai_implosion_vehicles[base] then
               begin
                    temp_list = ai_implosion_vehicles[base] diff vehicle;
                    ai_implosion_vehicles = Replace(ai_implosion_vehicles,base,temp_list);
               end;

          if vehicle in ai_control_tower_vehicles[base] then
               begin
                    temp_list = ai_control_tower_vehicles[base] diff vehicle;
                    ai_control_tower_vehicles = Replace(ai_control_tower_vehicles,base,temp_list);
               end;

          if vehicle = ai_cargo_bay[base] then
               begin
                    ai_cargo_bay = Replace(ai_cargo_bay,base,0);
                    ai_cargo_bay_destroy_tick = Replace(ai_cargo_bay_destroy_tick,base,tick);
               end;

          if vehicle = ai_crane[base] then
               begin
                    ai_crane = Replace(ai_crane,base,0);
                    ai_crane_destroy_tick = Replace(ai_crane_destroy_tick,base,tick);
                    ai_crane_driver = Replace(ai_crane_driver,base,0);
                    ai_crane_is_being_repaired = Replace(ai_crane_is_being_repaired,base,false);

                    if vehicle = ai_building_constructor[base] then
                         ai_building_constructor = Replace(ai_building_constructor,base,0);
               end;

          if vehicle in ai_sib_bomb_vehicles[base] then
               begin
                    temp_list = ai_sib_bomb_vehicles[base] diff vehicle;
                    ai_sib_bomb_vehicles = Replace(ai_sib_bomb_vehicles,base,temp_list);
               end;

          if vehicle in ai_behemoths[base] then
               begin
                    temp_list = ai_behemoths[base] diff vehicle;
                    ai_behemoths = Replace(ai_behemoths,base,temp_list);
               end;


          //Global "transient" lists of vehicles. Vehicles belonging to this base may be in one or more of these lists if
          //it performs a special or temporary job (you could say that the vehicle is in a special state).
          if vehicle in ai_retreating_vehicles_defend[base] then
               begin
                    temp_list = ai_retreating_vehicles_defend[base] diff vehicle;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);
               end;

          if vehicle in ai_vehicles_being_repaired[base] then
               begin
                    temp_list = ai_vehicles_being_repaired[base] diff vehicle;
                    ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);
               end;

          if vehicle in ai_refuel_vehicles_list[base] then
               begin
                    temp_list = ai_refuel_vehicles_list[base] diff vehicle;
                    ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);
               end;

          if vehicle = ai_vehicle_being_moved[base] then
               ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);

          if vehicle in ai_vehicles_having_been_moved[base] then
               begin
                    temp_list = ai_vehicles_having_been_moved[base] diff vehicle;
                    ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,temp_list);
               end;

          if vehicle = ar_mast then
               begin
                    temp_list = ai_heal_these_humans[base] diff vehicle;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
               end;
     end;
Export Function RemoveHumanFromVariables(base,human,check_if_base_is_dead);
     var temp_list, i;
     begin                
          result = false;

          //Global "basis" lists of humans. If a human belong to this base he/she will be in one
          //and only one of these lists.
          if human in ai_soldiers[base] then
               begin
                    temp_list = ai_soldiers[base] diff human;
                    ai_soldiers = Replace(ai_soldiers,base,temp_list);
                    result = true;
               end;

          if human in ai_attacking_soldiers[base] then
               begin
                    temp_list = ai_attacking_soldiers[base] diff human;
                    ai_attacking_soldiers = Replace(ai_attacking_soldiers,base,temp_list);
                    result = true;
               end;

          if human in ai_engineers[base] then
               begin
                    temp_list = ai_engineers[base] diff human;
                    ai_engineers = Replace(ai_engineers,base,temp_list);
                    result = true;
               end;

          if human in ai_apemen_engineers[base] then
               begin
                    temp_list = ai_apemen_engineers[base] diff human;
                    ai_apemen_engineers = Replace(ai_apemen_engineers,base,temp_list);
                    result = true;
               end;

          if human in ai_mechanics_defend[base] then
               begin
                    temp_list = ai_mechanics_defend[base] diff human;
                    ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
                    result = true;
               end;

          if human in ai_mechanics_attack[base] then
               begin
                    temp_list = ai_mechanics_attack[base] diff human;
                    ai_mechanics_attack = Replace(ai_mechanics_attack,base,temp_list);
                    result = true;
               end;

          if human in ai_sib_bomb_mechanics[base] then
               begin
                    temp_list = ai_sib_bomb_mechanics[base] diff human;
                    ai_sib_bomb_mechanics = Replace(ai_sib_bomb_mechanics,base,temp_list);
                    result = true;

                    {if ai_mechanics_defend[base] > 0 then
                         begin
                              temp_list = ai_sib_bomb_mechanics[base] ^ ai_mechanics_defend[base][1];
                              ai_sib_bomb_mechanics = Replace(ai_sib_bomb_mechanics,base,temp_list);

                              temp_list = Delete(ai_mechanics_defend[base],1);
                              ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
                         end;} //Dangerous - what if the picked mechanic is doing a job where he/she is also in other global variables?
               end;

          if human in ai_scientists[base] then
               begin
                    temp_list = ai_scientists[base] diff human;
                    ai_scientists = Replace(ai_scientists,base,temp_list);
                    result = true;
               end;

          if human in ai_attacking_scientists[base] then
               begin
                    temp_list = ai_attacking_scientists[base] diff human;
                    ai_attacking_scientists = Replace(ai_attacking_scientists,base,temp_list);
                    result = true;
               end;


          //Global "transient" lists of humans. Humans belonging to this base may be in one or more of these lists if
          //he/she performs a special or temporary job (you could say that the human is in a special state).
          if human in ai_heal_these_humans[base] then
               begin
                    temp_list = ai_heal_these_humans[base] diff human;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
               end;

          if human = ai_building_constructor[base] then
               ai_building_constructor = Replace(ai_building_constructor,base,0);

          if human in ai_retreating_attacking_humans[base] then
               begin
                    temp_list = ai_retreating_attacking_humans[base] diff human;
                    ai_retreating_attacking_humans = Replace(ai_retreating_attacking_humans,base,temp_list);
               end;

          if human = ai_crane_driver[base] then
               ai_crane_driver = Replace(ai_crane_driver,base,0);

          //If there are no human units left the base is "dead"
          if check_if_base_is_dead then
               if ((ai_soldiers[base] ^ ai_attacking_soldiers[base] ^ ai_engineers[base] ^ ai_apemen_engineers[base] ^ ai_mechanics_defend[base] ^ ai_mechanics_attack[base] ^ ai_sib_bomb_mechanics[base] ^ ai_scientists[base] ^
                   ai_attacking_scientists[base]) diff 0) = 0 then
                    begin
                         ai_bases = ai_bases diff base;

                         elimination_order = elimination_order ^ base;

                         if base = 2 then
                              AllianceObjectivesReset;

                         if base = 1 then
                              begin
                                   temp_list = ai_bases;
                                   if alliance_deal_status = 2 then
                                        temp_list = temp_list diff 2;

                                   if temp_list > 0 then
                                        ChangeMissionObjectives('M3');
                              end;

                         for i in ai_spawn_people[base] do
                              DestroyUnit(i);
                         ai_spawn_people = Replace(ai_spawn_people,base,[]);
                    end;
     end;


Export Function GetBaseArea(base);
     begin
          case base of
               1: result = Ru_base;
               2: result = Alliance_base;
               3: result = Ar_base;
               4: result = Am_base;
          end;
     end;
Export Function GetBaseSide(base);
     begin
          case base of
               1: result = russians;
               2: result = alliance;
               3: result = arabians;
               4: result = americans;
          end;
     end;
Export Function GetBaseNation(base);
     begin
          case base of
               1: result = nation_russian;
               2: result = nation_american;  //With respect to buildings and vehicles Alliance is American
               3: result = nation_arabian;
               4: result = nation_american;
          end;
     end;
Export Function FindBase(un);
     var base;
     begin
          result = 0;

          for base in ai_bases do
               if IsInArea(un,GetBaseArea(base)) then
                    begin
                         result = base;
                         exit;
                    end;
     end;


//Every which tries to spawn new units for AI.
Every 0$2+0$0.1 do
     var base, i, temp_unit, temp_list, away, buildings_list, b, cl;
     begin

          repeat
          wait(0$2);

          for base in ai_bases do
               begin
                    if base in [1,3,4] then
                         continue;  //Only spawning for Alliance

                    if am_going_to_destroy_alli then
                         begin
                              for i in ai_spawn_people[base] do
                                   DestroyUnit(i);

                              ai_spawn_people = Replace(ai_spawn_people,base,[]);
                              exit;
                         end;

                    if BaseUnderAttack(base,-1) then
                         continue;

                    i = 1;
                    while i <= ai_spawn_people[base] do
                         begin
                              temp_unit = 0;
                              cl = GetClass(ai_spawn_people[base][i]);

                              case cl of
                                   class_soldier, class_apeman_soldier, class_sniper, class_mortar, class_bazooker: buildings_list = ai_armouries[base];
                                   class_engineer,class_apeman_engineer: buildings_list = [ai_depot[base]];
                                   class_mechanic: buildings_list = ai_facts[base];
                                   class_scientistic: buildings_list = ai_labs[base];
                              end;

                              away = false;
                              for b in buildings_list do
                                   begin
                                        //Spawn engineers at human pullback hex if there are no depot.
                                        if ( IsOk(b) and UnitsInside(b) < 6 ) or cl = class_engineer then
                                             begin
                                                  if IsOk(b) and UnitsInside(b) < 6 then
                                                       PlaceHumanInUnit(ai_spawn_people[base][i],b)
                                                  else
                                                       PlaceUnitXYR(ai_spawn_people[base][i],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2],7,false);

                                                  case cl of
                                                       class_soldier, class_apeman_soldier, class_sniper, class_mortar, class_bazooker: begin
                                                            temp_list = ai_soldiers[base] ^ ai_spawn_people[base][i];
                                                            ai_soldiers = Replace(ai_soldiers,base,temp_list);
                                                       end;
                                                       class_engineer: begin
                                                            temp_list = ai_engineers[base] ^ ai_spawn_people[base][i];
                                                            ai_engineers = Replace(ai_engineers,base,temp_list);
                                                       end;
                                                       class_apeman_engineer: begin
                                                            temp_list = ai_apemen_engineers[base] ^ ai_spawn_people[base][i];
                                                            ai_apemen_engineers = Replace(ai_apemen_engineers,base,temp_list);
                                                       end;
                                                       class_mechanic: begin
                                                            temp_list = ai_mechanics_defend[base] ^ ai_spawn_people[base][i];
                                                            ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
                                                       end;
                                                       class_scientistic: begin
                                                            temp_list = ai_scientists[base] ^ ai_spawn_people[base][i];
                                                            ai_scientists = Replace(ai_scientists,base,temp_list);
                                                       end;
                                                  end;

                                                  away = true;
                                                  break;
                                             end;
                                   end;

                              if away then
                                   begin
                                        temp_list = Delete(ai_spawn_people[base],i);
                                        ai_spawn_people = Replace(ai_spawn_people,base,temp_list);

                                        continue;
                                   end;

                              i = i + 1;
                         end;
               end;

          until false;
     end;


//Soldiers
//Keep them in bunkers/armouries. If that's not possible due to structure restrictions then help construct buildings. Else retreat to
//the center of the base.
Every 0$1+0$0.1 do
     var side, i, temp_list, buildings_list, soldiers_list, temp_unit, base, val, special_units, bunkers, under_attack, j;
     var temp_list_2, special_defenders;
     begin

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    side = GetBaseSide(base);

                    soldiers_list = ai_soldiers[base] diff (ai_excepted_soldiers[base] ^ [Platonov,Omar,Powell]);
                    under_attack := BaseUnderAttack(base,-1);


                    //Control leaders (Powell, Platonov, Omar). Stay in depot.
                    case base of
                         1: val = Platonov;
                         2: val = 0;
                         3: begin
                              //Omar rides his mastodont. If it dies he goes to the depot.
                              if IsLive(ar_mast) and IsLive(Omar) then
                                   begin
                                        j = GetLives(ar_mast);

                                        if j <= 250 then
                                             val = Omar
                                        else
                                             begin
                                                  val = 0;

                                                  if IsInUnit(Omar) <> ar_mast then
                                                       if IsInUnit(Omar) > 0 then
                                                            begin
                                                                 case GetType(IsInUnit(Omar)) of
                                                                      unit_vehicle: ComExitVehicle(Omar);
                                                                      unit_building: ComExitBuilding(Omar);
                                                                 end;
                                                            end
                                                       else
                                                            ComEnterUnit(Omar,ar_mast);
                                             end;

                                        if j < 1000 and not under_attack then
                                             begin
                                                  if not ar_mast in ai_heal_these_humans[base] then
                                                       begin //Yeah believe it or not, mastodonts are healed by scientists
                                                             temp_list = ai_heal_these_humans[base] ^ ar_mast;
                                                             ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
                                                       end;
                                             end;
                                                  
                                        if val = 0 and IsInUnit(Omar) = ar_mast then
                                             begin
                                                  if under_attack then
                                                       begin
                                                            temp_unit = UnitShoot(ar_mast);
                                                            if temp_unit > 0 then
                                                                 ComAgressiveMove(ar_mast,GetX(temp_unit),GetY(temp_unit));
                                                       end
                                                  else
                                                       if GetDistUnitXY(ar_mast,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 5 then
                                                            ComMoveXY(ar_mast,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                                             end;
                                   end
                              else
                                   val = Omar;
                         end;
                         4: val = Powell;
                    end;

                    if val > 0 and IsLive(val) and not val in ai_heal_these_humans[base] then
                         begin
                              if ( val <> Omar and GetLives(val) <= 500 ) or ( GetLives(val) < 1000 and not under_attack ) then
                                   begin
                                        temp_list = ai_heal_these_humans[base] ^ val;
                                        ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
                                   end
                              else
                                   if not ( val = Omar and under_attack ) then  //Fight, fight, fight, fight!!
                                        DistributeHumansToBuildings(base,[val], UnitFilter(ai_depot[base],[[f_ok],[f_not,[f_constructed]]]),
                                        0,6,true,true);
                         end;


                    if base in [1,3,4] and under_attack then
                         begin
                              special_defenders = UnitFilter(soldiers_list,[f_not,[f_inside]]);

                              for i in ai_armouries[base] do
                                   begin
                                        temp_list = UnitFilter(UnitsInside(i),[f_or,[f_class,class_sniper],[f_class,class_mortar],[f_class,class_bazooker]]);
                                        for j = 1 to temp_list - [5,4,3][difficulty] do  //leave some units inside
                                             special_defenders = special_defenders ^ temp_list[j];
                                   end;
                         end
                    else
                         special_defenders = [];

                    //Identify soldiers who need healing.
                    temp_list = ai_heal_these_humans[base];
                    for i in soldiers_list diff ai_heal_these_humans[base] do
                         if GetLives(i) <= 500 or ( GetLives(i) < 800 and not i in special_defenders ) then
                              temp_list = temp_list ^ i;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Make soldiers needing healing go outside (else they won't be healed, cf. the healing
                    //code (controlling scientists) below.
                    if not under_attack then  //Soldiers don't care if they are wounded if the base is under attack
                         begin
                              for i in ai_heal_these_humans[base] do
                                   if i in soldiers_list then
                                        if IsInUnit(i) > 0 then
                                             case GetType(IsInUnit(i)) of
                                                  unit_vehicle: ComExitVehicle(i);
                                                  unit_building: ComExitBuilding(i);
                                             end;

                              soldiers_list = soldiers_list diff ai_heal_these_humans[base];
                              special_defenders = special_defenders diff ai_heal_these_humans[base];
                         end;
                         

                    if soldiers_list = 0 then
                         continue;


                    //Special defenders charge towards attackers.
                    if special_defenders > 0 then
                         begin
                              case base of
                                   1: begin
                                        temp_list_2 = FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_inarea,ru_bazooker_defend_area]]);
                                   end;
                                   2: begin
                                        temp_list_2 = [];
                                   end;
                                   3: begin
                                        temp_list_2 = FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_inarea,ar_mortar_defend_area]]);
                                   end;
                                   4: begin
                                        temp_list_2 = FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_inarea,am_sniper_defend_area]]);
                                   end;
                              end;

                              if temp_list_2 > 0 then
                                   begin
                                        soldiers_list = soldiers_list diff special_defenders;

                                        //Charge!
                                        ComAgressiveMove(GetHumansOutOfUnits(special_defenders),GetX(temp_list_2[1]),GetY(temp_list_2[1]));
                                   end;
                         end;


                    //Find the bunkers which need to be occupied.
                    //Remember which soldiers are already inside a building.
                    //Don't occupy b_bunker if there is no power.
                    i = false;
                    if IsOk(ai_depot[base]) then
                         if GetEnergy(GetBase(ai_depot[base]))[4] > 0 then
                              i = true;
                    
                    if i or ( base = 1 and difficulty = 1 ) or ( base = 4 and difficulty = 1 ) then
                         bunkers = ai_bunkers[base]
                    else
                         begin
                              bunkers = [];
                              for i in ai_bunkers[base] do
                                   if GetBType(i) = b_breastwork then
                                        bunkers = bunkers ^ i;
                         end;

                    buildings_list = [];
                    for i in UnitFilter(bunkers,[f_ok]) do
                         begin
                              temp_unit = UnitsInside(i);
                              if temp_unit = 0 then
                                   buildings_list = buildings_list ^ i
                              else soldiers_list = soldiers_list diff temp_unit;
                         end;
                     

                    //The best soldiers should go to the bunkers. The rest in the armouries.
                    //If the base is under attack then just the nearest soldier.
                    if buildings_list > 0 then
                         begin
                              if not under_attack then
                                   begin
                                        temp_list = [];
                                        for i in soldiers_list do
                                             temp_list = temp_list ^ GetSkill(i,skill_combat);
                                        soldiers_list = SortListByListDesc(soldiers_list,temp_list);
                                   end;

                              //Bazookers/snipers/mortar in armouries or breastworks if possible.
                              special_units = UnitFilter(soldiers_list,[f_or,[f_class,class_bazooker],[f_class,class_sniper],[f_class,class_mortar]]);
                              soldiers_list = soldiers_list diff special_units;

                              for i = 1 to buildings_list do
                                   begin
                                        if soldiers_list = 0 then
                                             begin
                                                  if special_units = 0 then
                                                       break;

                                                  soldiers_list = special_units;
                                                  special_units = [];
                                             end;

                                        if not under_attack then
                                             begin
                                                  if GetBType(buildings_list[i]) = b_breastwork and special_units > 0 then
                                                       temp_unit = special_units[1]
                                                  else
                                                       temp_unit = soldiers_list[1];
                                             end
                                        else
                                             begin
                                                  if GetBType(buildings_list[i]) = b_breastwork and special_units > 0 then
                                                       temp_list_2 = special_units
                                                  else
                                                       temp_list_2 = soldiers_list;

                                                  temp_list = [];
                                                  for j in temp_list_2 do
                                                       temp_list = temp_list ^ GetDistUnits(j,buildings_list[i]);

                                                  temp_unit = WorstFromListByList(temp_list_2,temp_list);
                                             end;

                                        if IsOk(buildings_list[i]) then
                                             ComEnterUnit(temp_unit,buildings_list[i])
                                        else
                                             if GetDistUnits(temp_unit,buildings_list[i]) > 4 then
                                                  ComAgressiveMove(temp_unit,GetX(buildings_list[i]),GetY(buildings_list[i]));

                                        soldiers_list = soldiers_list diff temp_unit;
                                        special_units = special_units diff temp_unit;
                                   end;
                         end
                    else
                         special_units = [];


                    //The rest enter armouries (if possible)
                    DistributeHumansToBuildings(base,soldiers_list ^ special_units, UnitFilter(ai_armouries[base],[[f_ok],[f_not,[f_constructed]]]),
                         false,6,true,true);  

                    //For Russians: The bazookers in the southern barracks should shoot at siberite mines they can see.
                    if base = 1 then
                         begin
                              if ai_armouries[1] > 0 then
                                   temp_unit = ai_armouries[1][1]
                              else
                                   temp_unit = 0;

                              if temp_unit > 0 then
                                if GetBType(temp_unit) = b_barracks then
                                   begin
                                        temp_list = [HexInfo(67,61),HexInfo(77,56)];
                                        temp_list = UnitFilter(temp_list,[f_btype,b_siberite_mine]);
                                        if temp_list > 0 then
                                             begin
                                                  temp_list_2 = UnitsInside(temp_unit);
                                                  temp_list_2 = UnitFilter(temp_list_2,[f_class,class_bazooker]);

                                                  ComAttackUnit(temp_list_2,temp_list[1]);
                                             end;
                                   end;
                         end;
               end;

          until false;
     end;

//Russian rocket launchers shoot at siberite mines they can see.
Every 0$1+0$0.2 do
     var temp_unit, i;
     begin
          repeat
          wait(0$2);

          if not 1 in ai_bases then
               exit;

          temp_unit = HexInfo(38,57);
          if temp_unit <= 0 then
               continue;

          if GetType(temp_unit) <> unit_building then
               continue;

          if GetBType(temp_unit) <> b_siberite_mine then
               continue;

          for i in ai_bunkers[1] ^ ai_turrets[1] do
               if GetBWeapon(i) in [ru_rocket_launcher,ru_rocket] then
                    if IsOk(i) and GetY(i) > 34 and GetY(i) < 43 then
                         ComAttackUnit(i,temp_unit);

          until false;
     end;

//Omar should always use his sabre and not his carabine. He switches to carabine whenever he mounts his mastodont.
//Tell him to use sabre when he is forced off the mastodont.
on EvacuateVehicle(driver, abandoned_vehicle, unknown1, unknown2) do
     begin
          if driver = Omar then
               ComSabre(driver);
     end;

//Replace defensive mines in front of the computer's base as necessary.
Every 0$1+0$0.3 do
     var base, center_hexes, i, temp_list, k, guy, temp_list_2;
     var under_attack, target_hex, num_mines_being_placed;
     begin
          target_hex = [];  //unit id is index, value is hex [x,y]
          num_mines_being_placed = [0,0,0,0];

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));
          
          for base in ai_bases do
          begin
          wait(0$1 div (ai_bases+0));

          temp_list = [];
          for i in ai_mine_guys[base] do
               begin
                    if target_hex+0 < i then
                         target_hex = Replace(target_hex,i,[]);

                    if IsLive(i) then
                         temp_list = temp_list ^ i
                    else
                         if target_hex[i] > 0 then  //died while placing a mine
                              begin
                                   target_hex = Replace(target_hex,i,[]);
                                   num_mines_being_placed = Replace(num_mines_being_placed,base, num_mines_being_placed[base]-1 );
                              end;
               end;
          ai_mine_guys = Replace(ai_mine_guys,base,temp_list);

          if ai_mine_guys[base] = 0 then
               continue;

          under_attack = BaseUnderAttack(base,-1);
          
          for guy in ai_mine_guys[base] do
          begin

          if GetLives(guy) < 900 and guy in ai_excepted_soldiers[base] and not guy in ai_heal_these_humans[base] then
               begin
                    temp_list = ai_heal_these_humans[base] ^ guy;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
               end;

          if ( ai_defence_replace_mines_hexes[base] + num_mines_being_placed[base] >= ai_defence_max_num_replace_mines[base] and target_hex[guy] = 0 ) or under_attack or guy in ai_heal_these_humans[base] then
               begin
                    if guy in ai_excepted_soldiers[base] then
                         begin
                              temp_list = ai_excepted_soldiers[base] diff guy;
                              ai_excepted_soldiers = Replace(ai_excepted_soldiers,base,temp_list);
                         end;

                    if target_hex[guy] > 0 then
                         begin
                              target_hex = Replace(target_hex,guy,[]);
                              num_mines_being_placed = Replace(num_mines_being_placed,base, num_mines_being_placed[base]-1 );
                         end;

                    continue;
               end;
          
          if target_hex[guy] = 0 then
               begin
                    //Determine free centerhexes.
                    center_hexes = ai_defence_replace_mines_centerhexes[base];

                    for i in ai_defence_replace_mines_hexes[base] do
                         begin
                              temp_list = [];
                              for k in center_hexes do
                                   temp_list = temp_list ^ GetDistXY(i[1],i[2],k[1],k[2]);

                              center_hexes = center_hexes diff [WorstFromListByList(center_hexes,temp_list)];
                         end;

                    if center_hexes = 0 then
                         continue;  //should never happen

                    //Pick one and find a hex therein.
                    k = Rand(1,center_hexes);
                    k = center_hexes[k];
                    temp_list = GetHexesNearHex(k[1],k[2],1);

                    repeat
                    k = Rand(1,temp_list);
                    if not temp_list[k] in ai_defence_mines_hexes[base] and not temp_list[k] in target_hex then
                         break;

                    temp_list = Delete(temp_list,k);
                    until temp_list = 0;

                    if temp_list > 0 then
                         begin
                              target_hex = Replace(target_hex,guy,temp_list[k]);
                              num_mines_being_placed = Replace(num_mines_being_placed,base, num_mines_being_placed[base]+1 );
                         end;
               end;
          
          if target_hex[guy] = 0 then
               continue;

          if not guy in ai_excepted_soldiers[base] then
               begin
                    temp_list = ai_excepted_soldiers[base] ^ guy;
                    ai_excepted_soldiers = Replace(ai_excepted_soldiers,base,temp_list);
               end;

          if GetClass(guy) <> class_soldier then
               begin
                    if IsInUnit(guy) > 0 then begin
                         case GetType(IsInUnit(guy)) of
                              unit_vehicle: ComExitVehicle(guy);
                              unit_building: begin
                                   if GetBType(IsInUnit(guy)) in [b_armoury,b_barracks] then
                                        ComChangeProfession(guy,class_soldier)
                                   else
                                        ComExitBuilding(guy);
                              end;
                          end
                     end
                         else begin
                              //Find a barracks with enough space to fit one more person.
                              k = 0;
                              for i in ai_armouries[base] do
                                   if UnitsInside(i) < 6 then
                                        begin
                                             k = i;
                                             break;
                                        end;

                              if k = 0 then
                                   SetClass(guy,class_soldier)  //cheating a little
                              else
                                   ComEnterUnit(guy,k);
                         end;
               end
          else
               begin
                    temp_list = MineOfUnit(guy);
                    if temp_list = 0 then
                         begin
                              if GetDistUnitXY(guy,target_hex[guy][1],target_hex[guy][2]) > 1 then
                                   ComAgressiveMove(guy,target_hex[guy][1],target_hex[guy][2])
                              else
                                   ComPlaceRemoteCharge(guy,target_hex[guy][1],target_hex[guy][2],0);
                         end
                    else
                         begin
                              PlaceMine(temp_list[1],temp_list[2],mines_side,0);

                              temp_list_2 = Insert(ai_defence_mines_hexes[base],1,temp_list);
                              ai_defence_mines_hexes = Replace(ai_defence_mines_hexes,base,temp_list_2);

                              temp_list_2 = Insert(ai_defence_replace_mines_hexes[base],1,temp_list);
                              ai_defence_replace_mines_hexes = Replace(ai_defence_replace_mines_hexes,base,temp_list_2);

                              RemoveMineOfUnit(guy);

                              target_hex = Replace(target_hex,guy,[]);
                              num_mines_being_placed = Replace(num_mines_being_placed,base, num_mines_being_placed[base]-1 );
                         end;
               end;
          end;
          end;

          until false;
     end;

//When someone steps on a landmine.
Every 0$1+0$0.2 do
     var i, un, base, temp_list, temp_list_2;
     var mine_dialogue_played;
     begin
          mine_dialogue_played = false;

          repeat
          wait(0$0.5);

          for base in ai_bases do
          begin

          i = 1;
          while i <= ai_defence_mines_hexes[base] do
               begin
                    un = HexInfo(ai_defence_mines_hexes[base][i][1],ai_defence_mines_hexes[base][i][2]);

                    if un <= 0 then
                         begin
                              i = i + 1;
                              continue;
                         end;

                    if GetAttitude(GetBaseSide(base),GetSide(un)) = att_enemy then
                         begin
                              LaunchMineAtPos(ai_defence_mines_hexes[base][i][1],ai_defence_mines_hexes[base][i][2],mines_side);

                              //These mines just don't hurt very much so we have to add some extra
                              //power manually.
                              if difficulty > 1 then
                                   begin
                                        if GetLives(un) > [-1,150,300][difficulty] then
                                             SetLives(un,GetLives(un)-[-1,150,300][difficulty])
                                        else
                                             KillUnit(un);
                                   end;

                              temp_list_2 = [ai_defence_mines_hexes[base][i][1],ai_defence_mines_hexes[base][i][2]];

                              temp_list = Delete(ai_defence_mines_hexes[base],i);
                              ai_defence_mines_hexes = Replace(ai_defence_mines_hexes,base,temp_list);

                              temp_list = ai_defence_replace_mines_hexes[base] diff [temp_list_2];
                              ai_defence_replace_mines_hexes = Replace(ai_defence_replace_mines_hexes,base,temp_list);

                              if not mine_dialogue_played and base = 4 and GetSide(un) = you then
                                   begin
                                        mine_dialogue_played = true;
                                        wait(0$0.5);  //wait for explosion. Delays all explosions of mines but it's ok
                                        CenterOnXY(temp_list_2[1],temp_list_2[2]);
                                        DialogueOn;

                                        ForceSay(Heike,'D17-H-1');

                                        if IsOk(Rolf) then
                                             begin
                                                  SayRadio(Rolf,'D17-Rolf-1');
                                                  ForceSay(Heike,'D17-H-2');

                                                  if LoadVariable('UPF_deserter_exiled_13a_cont',false) or LoadVariable('UPF_deserter_killed_13a_cont',false) then  //Exiled or killed but got away
                                                       begin
                                                            SayRadio(Rolf,'D17-Rolf-2a');
                                                       end
                                                  else
                                                       begin
                                                            SayRadio(Rolf,'D17-Rolf-2b');
                                                            ForceSay(Heike,'D17-H-3b');
                                                            SayRadio(Rolf,'D17-Rolf-3b');
                                                       end;
                                             end;

                                        DialogueOff;
                                   end;

                              continue;
                         end;

                    i = i + 1;
               end;
          end;

          until false;
     end;

//Make defending snipers use soporific ammo.
Every 0$1+0$0.4 do
     var side, base, i, temp_list, un1, temp_list_2, temp_value, val;
     var sopo_cooldown;
     begin
          //Index is unit id, value is cooldown. So the same sniper won't use soporific ammo all the time.
          //Sleeping time is about 10 seconds.
          sopo_cooldown = [];

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    if base in [1,3] then
                         continue;

                    side = GetBaseSide(base);

                    for i in ai_soldiers[base] do
                         if sopo_cooldown >= i then
                              if sopo_cooldown[i] > 0$0 then
                                   sopo_cooldown = Replace(sopo_cooldown,i,sopo_cooldown[i]-0$0.5);

                    for i in ai_soldiers[base] diff ai_heal_these_humans[base] do
                              if GetClass(i) = class_sniper then
                                   begin
                                        //Don't bother the sniper if he/she is about to use the sopo ammo.
                                        temp_list = GetTaskList(i);
                                        if temp_list > 0 then
                                             if temp_list[1][1] = 'n' then  //['n',x,y,un_id,0,0,0]
                                                  continue;

                                        un1 = Attacks(i);
                                        if un1 > 0 then
                                             if GetType(un1) = unit_human then
                                                  begin
                                                       val = true;
                                                       if sopo_cooldown >= i then
                                                            if sopo_cooldown[i] > 0$0 then
                                                                 val = false;

                                                       if val then
                                                            begin
                                                                 ComAttackSoporific(i,un1);
                                                                 sopo_cooldown = Replace(sopo_cooldown,i,0$10);
                                                            end;
                                                  end;
                                   end;
               end;

          until false;
     end;

//Make defending bazookers shoot time shifting rockets at their targets.
Every 0$1+0$0.1 do
     var side, base, i, temp_list, un1, temp_list_2, temp_value, val, lapsers;
     begin


          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    if base in [2,3,4] then
                         continue;

                    side = GetBaseSide(base);

                    //Find time lapsers
                    lapsers = [];
                    val = false;
                    if IsOk(ai_depot[base]) then
                         if GetEnergy(GetBase(ai_depot[base]))[4] > 0 then
                              val = true;

                    if val then
                         for i in ai_bunkers[base] ^ ai_turrets[base] do
                              if GetBWeapon(i) = ru_time_lapser and IsOk(i) and ( UnitsInside(i) > 0 or GetBType(i) = b_turret ) then
                                   lapsers = lapsers ^ i;

                    //Control bazookers
                    for i in ai_soldiers[base] diff ai_heal_these_humans[base] do
                              if GetClass(i) = class_bazooker then
                                   begin
                                        //Don't bother the bazooker if he/she is about to fire a time shifting or space shifting rocket.
                                        temp_list = GetTaskList(i);
                                        if temp_list > 0 then
                                             if temp_list[1][1] = '&' or temp_list[1][1] = '%' then
                                                  continue;

                                        un1 = Attacks(i);
                                        if un1 > 0 and DangerousUnits([un1]) > 0 then
                                             begin
                                                  temp_list_2 = [GetX(un1),GetY(un1)];
                                                  temp_value = false;

                                                  for val in ai_time_shift_hexes[base] ^ ai_time_shift_hexes_underway[base] do  //don't send a rocket where someone already have or (probably) soon will
                                                       if GetDistXY(temp_list_2[1],temp_list_2[2],val[1],val[2]) <= ai_time_shift_data[side][2] then
                                                            begin
                                                                 temp_value = true;
                                                                 break;
                                                            end;

                                                  //Don't shoot rockets in areas permanently time shiftet by time lapsers.
                                                  //Time lapsers affect an area with about 11 hexes radius at max level of space time technology
                                                  //and it is not affected by height. The radius is affected by stacking lapsers close to each other, though,
                                                  //but the effect is not very predictable so we will not take that into consideration here.
                                                  if not temp_value then
                                                       for val in lapsers do
                                                            if GetDistXY(temp_list_2[1],temp_list_2[2],GetX(val),GetY(val)) <= 11 then
                                                                 begin
                                                                      temp_value = true;
                                                                      break;
                                                                 end;

                                                  if not temp_value then  //not inside a time shifted area
                                                       begin
                                                            ComTimeShift(i,temp_list_2[1],temp_list_2[2]);

                                                            //The bazooker could die before he/she fires the rocket
                                                            //so we store the hex temporarily and check if the rocket actually is fired later.
                                                            temp_list = Insert(ai_time_shift_hexes_underway[base],1,[temp_list_2[1],temp_list_2[2],i]);
                                                            ai_time_shift_hexes_underway = Replace(ai_time_shift_hexes_underway,base,temp_list);
                                                       end;
                                             end;
                                   end;
               end;

          until false;
     end;

//Make defending bazookers shoot space shifting rockets at their targets.
//Doing this intelligently is extremely difficult so we just shoot one rocket from time
//to time behind a target hoping we push the target closer to our base instead of
//pushing it away.
//Only bazookers inside barrackses.
Every 0$1+0$0.2 do
     var base, i, temp_list, un1, temp_list_2, temp_value;
     var shooting_delay;
     begin
          shooting_delay = [0$0,0$0,0$0,0$0];

          repeat
          wait(0$1);

          if difficulty = 1 then
               exit;

          for base in ai_bases do
               begin
                    if base in [2,3,4] then
                         continue;

                    if shooting_delay[base] > 0$0 then
                         begin
                              shooting_delay = Replace(shooting_delay,base, shooting_delay[base] - 0$1 );
                              continue;
                         end;

                    if Rand(1,10) > 1 then
                         continue;

                    temp_list = [];
                    for i in ai_soldiers[base] diff ai_heal_these_humans[base] do
                         if IsInUnit(i) in ai_armouries[base] then
                              temp_list = temp_list ^ i;

                    for i in temp_list do
                              if GetClass(i) = class_bazooker then
                                   begin
                                        //Don't bother the bazooker if he/she is about to fire a time shifting or space shifting rocket.
                                        temp_list = GetTaskList(i);
                                        if temp_list > 0 then
                                             if temp_list[1][1] = '&' or temp_list[1][1] = '%' then
                                                  continue;

                                        un1 = Attacks(i);
                                        if un1 > 0 and not IsInArea(un1,GetBaseArea(base)) then
                                             begin
                                                  //Shoot just behind the target. We are higher elevated so this should be possible
                                                  temp_list_2 = [GetX(un1),GetY(un1)];
                                                  temp_value = AI_GetTurnDirection(GetX(i),GetY(i),temp_list_2[1],temp_list_2[2]);
                                                  ComSpaceShift(i, ShiftX(temp_list_2[1],temp_value,1), ShiftY(temp_list_2[2],temp_value,1) );

                                                  shooting_delay = Replace(shooting_delay,base,0$10);

                                                  break;
                                             end;
                                   end;
               end;

          until false;
     end;

//Determine which bazookers have successfully fired their time shifting rocket.
//We need an extremely short update time on this update to prevent the situation where
//a bazooker has shot a time shifting rocket but is brought to red life before the
//update runs (in which case we do not detect the time shifting rocket as fired).
Every 0$1 do
     var base, side, val, temp_value, temp_list;
     begin

          repeat
          wait(1);

          for base in ai_bases do
               begin
                    if base in [3,4] then
                         continue;

                    side = GetBaseSide(base);

                    val = 1;
                    while val <= ai_time_shift_hexes_underway[base] do
                         begin
                              temp_value = false;
                              temp_list = GetTaskList(ai_time_shift_hexes_underway[base][val][3]);

                              if IsOk(ai_time_shift_hexes_underway[base][val][3]) then  //Task list is reset upon going to red life
                                   begin
                                        if temp_list = 0 then
                                             temp_value = true
                                        else
                                             if not temp_list[1][1] = '&' then
                                                  temp_value = true;
                                   end
                              else
                                   begin
                                        temp_list = Delete(ai_time_shift_hexes_underway[base],val);
                                        ai_time_shift_hexes_underway = Replace(ai_time_shift_hexes_underway,base,temp_list);

                                        continue;
                                   end;

                              if temp_value then
                                   begin
                                        temp_list = Insert(ai_time_shift_hexes[base],1,[ai_time_shift_hexes_underway[base][val][1],ai_time_shift_hexes_underway[base][val][2],ai_time_shift_data[side][1]]);
                                        ai_time_shift_hexes = Replace(ai_time_shift_hexes,base,temp_list);

                                        temp_list = Delete(ai_time_shift_hexes_underway[base],val);
                                        ai_time_shift_hexes_underway = Replace(ai_time_shift_hexes_underway,base,temp_list);

                                        continue;
                                   end;

                              val = val + 1;
                         end;
               end;

          until false;
     end;

//Update time shifted areas (determine when they have faded away).
Every 0$1+0$0.3 do
     var base, side, val, temp_list, time;
     begin

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    if base in [3,4] then
                         continue;

                    side = GetBaseSide(base);

                    val = 1;
                    while val <= ai_time_shift_hexes[base] do
                         begin
                              time = ai_time_shift_hexes[base][val][3]-0$1;

                              if time <= 0$0 then
                                   begin
                                        temp_list = Delete(ai_time_shift_hexes[base],val);
                                        ai_time_shift_hexes = Replace(ai_time_shift_hexes,base,temp_list);

                                        continue;
                                   end
                              else
                                   begin
                                        temp_list = Replace(ai_time_shift_hexes[base][val],3,time);
                                        temp_list = Replace(ai_time_shift_hexes[base],val,temp_list);
                                        ai_time_shift_hexes = Replace(ai_time_shift_hexes,base,temp_list);
                                   end;

                              val = val + 1;
                         end;
               end;

          until false;
     end;


//Function which sends humans to buildings, distributing them equally and changing their class (if specified).
//The humans there wasn't space for will stay near the pullback hex.
//base - the base calling the function.
//human_list - list of humans
//building_list - list of buildings
//change_to_this_class - class to change to when the human has entered the building (false if none)
//building_capacity - the number of humans the building can handle
//help_building - boolean. If true then units which could not enter a building will help building the building under
//construction (if any).
//aggressive_pullback - boolean. True if movement to pullback hex should be aggressive (else just normal move)
Function DistributeHumansToBuildings(base,human_list,building_list,change_to_this_class,building_capacity,help_building,aggressive_pullback);
     var i, temp_list, val, temp_unit, area, special_un_count, counter, k, under_attack;
     begin
          if human_list = 0 then
               exit;

          area = GetBaseArea(base);
          under_attack = BaseUnderAttack(base,-1);

          //If this is soldiers going to armouries then special units
          //should be distributed equally among the armouries.
          if not GetClass(human_list[1]) in [class_engineer,class_apeman_engineer,class_mechanic,class_scientistic] and building_list > 0 then
               begin
                    val = 0;
                    for i in human_list do
                         if GetClass(i) in [class_sniper,class_mortar,class_bazooker] then
                              val = val + 1;

                    special_un_count = val div (building_list+0);
               end
          else
               special_un_count = 0;

          val = building_list+0;
          while val > 0 and human_list > 0 do
               begin
                    //Rearrange "human_list" so humans already inside this building goes
                    //first in the list. Else this algorithm could pick 6 people for a barracks
                    //let's say 2 outside and 4 actually in the barracks but there is a 5. unit
                    //inside the barracks already which is further down "human_list"- the result is
                    //one human can't get in because there isn't space.
                    temp_list = [];
                    for i in human_list do
                         if IsInUnit(i) = building_list[val] then
                              temp_list = temp_list ^ i;
                    human_list = temp_list ^ (human_list diff temp_list);

                    //Distribute humans equally to the buildings
                    counter = 0;
                    temp_list = [];
                    for i = 1 to human_list div val do
                         begin
                              if i > building_capacity then
                                   break;

                              if special_un_count = 0 then
                                   begin
                                        temp_list = temp_list ^ human_list[1];
                                        human_list = Delete(human_list,1);
                                   end
                              else
                                   if counter = special_un_count then
                                        begin
                                             //Search for a non-special unit in the list.
                                             temp_unit = 0;
                                             for k = 1 to human_list do
                                                  if not GetClass(human_list[k]) in [class_sniper,class_mortar,class_bazooker] then
                                                       begin
                                                            temp_unit = k;
                                                            break;
                                                       end;

                                             if temp_unit = 0 then
                                                  temp_unit = 1;

                                             temp_list = temp_list ^ human_list[temp_unit];
                                             human_list = Delete(human_list,temp_unit);
                                        end
                                   else
                                        begin
                                             counter = counter + 1;

                                             //Search for a special unit in the list.
                                             temp_unit = 0;
                                             for k = 1 to human_list do
                                                  if GetClass(human_list[k]) in [class_sniper,class_mortar,class_bazooker] then
                                                       begin
                                                            temp_unit = k;
                                                            break;
                                                       end;

                                             if temp_unit = 0 then
                                                  temp_unit = 1;

                                             temp_list = temp_list ^ human_list[temp_unit];
                                             human_list = Delete(human_list,temp_unit);
                                        end;
                         end;

                    for i in temp_list do
                         begin
                              temp_unit = IsInUnit(i);
                              if temp_unit <> building_list[val] then
                                   if temp_unit > 0 then begin
                                        case GetType(temp_unit) of
                                             unit_vehicle: ComExitVehicle(i);
                                             unit_building: ComExitBuilding(i);
                                        end;
                                   end
                                        else
                                             begin
                                                  if IsInArea(i,area) or not aggressive_pullback then
                                                       ComEnterUnit(i,building_list[val])
                                                  else
                                                       ComAgressiveMove(i,GetX(building_list[val]),GetY(building_list[val]));

                                                  if change_to_this_class > 0 then
                                                       begin
                                                            if GetClass(i) <> change_to_this_class and GetNation(i) <> nation_nature then  //ignore apemen
                                                                 if not ( change_to_this_class in [class_sniper,class_mortar,class_bazooker] and not GetBType(building_list[val]) in [b_barracks,b_fort] ) then  //Will change class to sniper/mortar/bazooker even if the building is only an armoury
                                                                      AddComChangeProfession(i,change_to_this_class);
                                                       end
                                                  else
                                                       begin
                                                            //If the building is a barracks then always change to the special combat class the barracks allows.
                                                            if GetBType(building_list[val]) in [b_barracks,b_fort] then
                                                                 case GetNation(building_list[val]) of
                                                                      nation_american: AddComChangeProfession(i,class_sniper);
                                                                      nation_arabian: AddComChangeProfession(i,class_mortar);
                                                                      nation_russian: AddComChangeProfession(i,class_bazooker);
                                                                 end;
                                                       end;
                                             end;
                         end;

                    val = val - 1;
               end;

          if human_list > 0 then
               if ai_building_under_construction[base] > 0 and help_building and not under_attack then
                    begin
                         for i in GetHumansOutOfUnits(human_list) do
                              SetTaskList(i,[['h',0,0,ai_building_under_construction[base],0,0,0]]);  //'h' is "help building building"
                    end
               else
                    for i in GetHumansOutOfUnits(human_list) do
                         if GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 4 then
                              if aggressive_pullback then
                                   ComAgressiveMove(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2])
                              else
                                   ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
     end;


//Engineers and Apemen Engineers
//These are the priorities (descending order):
//- If an engineer is hurt, them pull him/her back for healing.
//- Reparation of red buildings
//- Reparation of any building
//- Reconstruct destroyed buildings if necessary, but only if the base is not under attack (only engineers)
//- Gather crates in the vicinity of the base, but for engineers only if the base is not under attack.
//- Return to and stay inside the depot (if possible).
Every 0$1+0$0.3 do
     var side, i, engineers_list, temp_list, buildings_list, temp_unit, away_dist, temp_list_2, base, apemen_engineers_list;
     var humans_list, crane_usable, b_value, engineers_not_allowed_to_repair_area, crane_not_allowed_to_repair_area, workers_list;
     var k, repairing_buildings, under_attack, is_dismantling;
     var crane_is_refueling, try_rebuild_again_time;
     begin
          crane_is_refueling = [false,false,false,false];

          try_rebuild_again_time = [];
          for base in ai_bases do
               try_rebuild_again_time = Replace(try_rebuild_again_time,base,0$0);

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));
                    side = GetBaseSide(base);
                    under_attack := BaseUnderAttack(base,-1);

                    //Reset "move empty manual vehicles so we can build our building"-variables if we are under attack so we can use our vehicles freely.
                    if under_attack then
                         begin
                              ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);
                              ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,[]);
                         end;

                    //Check if we can rebuild some of the buildings we couldn't before.
                    if ai_cannot_rebuild_these_buildings[base] > 0 and ( ai_engineers[base] > 0 or try_rebuild_again_time[base] >= 0$20 ) then
                         begin
                              ai_cannot_rebuild_these_buildings = Replace(ai_cannot_rebuild_these_buildings,base,[]);
                              try_rebuild_again_time = Replace(try_rebuild_again_time,base,0$0);
                         end
                    else
                         try_rebuild_again_time = Replace(try_rebuild_again_time,base, try_rebuild_again_time[base] + 0$1 );


                    engineers_list = ai_engineers[base] diff ai_heal_these_humans[base];
                    apemen_engineers_list = ai_apemen_engineers[base] diff ai_heal_these_humans[base];


                    //Identify engineers who need healing
                    temp_list = ai_heal_these_humans[base];
                    humans_list = engineers_list ^ apemen_engineers_list;
                    i = 1;
                    while i <= humans_list do
                         begin
                              if GetLives(humans_list[i]) <= 700 then
                                   begin
                                        temp_list = temp_list ^ humans_list[i];
                                        engineers_list = engineers_list diff humans_list[i];
                                        apemen_engineers_list = apemen_engineers_list diff humans_list[i];
                                        humans_list = Delete(humans_list,i);

                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Crane
                    crane_usable = false;
                    if ai_crane[base] > 0 then
                         begin
                              if GetControl(ai_crane[base]) = control_manual and not ai_crane[base] = ai_vehicle_being_moved[base] then
                                   begin
                                        temp_list = UnitsInside(ai_crane[base]);
                                        if temp_list > 0 then
                                             if temp_list[1] <> ai_crane_driver[base] then
                                                  ComExitVehicle(temp_list[1]);
                                   end;
                              
                              if GetLives(ai_crane[base]) <= 500 or ( ai_crane_driver[base] > 0 and GetLives(ai_crane_driver[base]) <= 500 ) or ( ai_crane_is_being_repaired[base] and ( GetLives(ai_crane[base]) < 1000 or ( ai_crane_driver[base] > 0 and GetLives(ai_crane_driver[base]) < 1000 ) ) ) then
                                   begin
                                        ai_crane_is_being_repaired = Replace(ai_crane_is_being_repaired,base,true);

                                        //Code for defending mechanics below will take care of repairing the crane
                                        if GetDistUnitXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 6 then
                                             ComMoveXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                                   end
                              else
                                   begin
                                        ai_crane_is_being_repaired = Replace(ai_crane_is_being_repaired,base,false);

                                        //Refuel if necessary
                                        if GetEngine(ai_crane[base]) = engine_combustion then
                                             begin
                                                  i = GetFuel(ai_crane[base]);
                                                  if i > 90 or not IsOk(ai_depot[base]) then
                                                       crane_is_refueling = Replace(crane_is_refueling,base,false)
                                                  else
                                                       if i < 25 or crane_is_refueling[base] then
                                                            begin
                                                                 ComMoveUnit(ai_crane[base],ai_depot[base]);
                                                                 AddComRefuel(ai_crane[base],ai_depot[base]);
                                                                 crane_is_refueling = Replace(crane_is_refueling,base,true);
                                                            end;
                                             end;

                                        if not crane_is_refueling[base] then
                                             crane_usable = true;
                                   end;
                         end;

                    if engineers_list = 0 and apemen_engineers_list = 0 and not crane_usable then
                         continue;

                    //Recapture buildings if necessary. Depots first. Here we assume the player hasn't changed the base
                    //of the captured building.
                    //Apemen engineers and cranes can't capture buildings.
                    temp_list_2 = UnitFilter(engineers_list,[f_class,class_engineer]);
                    if ai_captured_buildings[base] > 0 and temp_list_2 > 0 then
                         begin
                              temp_list = [];
                              for i in ai_captured_buildings[base] do
                                   if GetBType(i) in [b_depot,b_warehouse] then
                                        temp_list = temp_list ^ 1
                                   else
                                        temp_list = temp_list ^ 0;

                              temp_list = SortListByListDesc(ai_captured_buildings[base],temp_list);

                              //Normal "ComEnterUnit" for capturing doesn't work for buildings which can't be entered (e.g. power plants).
                              temp_list_2 = GetHumansOutOfUnits(temp_list_2);
                              if temp_list_2 > 0 then
                                   begin
                                        temp_list_2 = SortListByListDesc(temp_list_2, temp_list_2);  //To ensure we take the same unit each time
                                        SetTaskList(temp_list_2[1],[['e',GetX(temp_list[1]),GetY(temp_list[1]),temp_list[1],0,0,0]]);
                                        engineers_list = engineers_list diff temp_list_2[1];
                                   end;

                              if engineers_list = 0 and apemen_engineers_list = 0 and not crane_usable then
                                   continue;
                         end;

                    //Find buildings which need to be repaired. At least one engineer for each if possible.
                    //If the base is under attack human (not including apemen) engineers may not be allowed
                    //to repair certain buildings.
                    //The crane may not be allowed to repair certain buildings at all (e.g. because it can't reach
                    //them).
                    case base of
                         1: begin
                              engineers_not_allowed_to_repair_area = ru_no_engineer_repair_area;
                              crane_not_allowed_to_repair_area = ru_no_crane_repair_area;
                         end;
                         2: begin
                              engineers_not_allowed_to_repair_area = alli_no_engineer_repair_area;
                              crane_not_allowed_to_repair_area = 0;
                         end;
                         3: begin
                              engineers_not_allowed_to_repair_area = 0;
                              crane_not_allowed_to_repair_area = 0;
                         end;
                         4: begin
                              engineers_not_allowed_to_repair_area = 0;
                              crane_not_allowed_to_repair_area = 0;
                         end;
                    end;

                    repairing_buildings = [false,false,false];  //True if group is repairing a building

                    for k = 1 to 3 do begin

                    //1 = apemen engineers
                    //2 = human engineers
                    //3 = crane

                    i = 1;
                    buildings_list = [];
                    repeat
                         case i of
                              1: buildings_list = UnitFilter(ai_all_buildings[base] diff ai_dismantle_these_buildings[base],[f_not,[f_ok]]);  //If building is dead then it won't be part of ai_all_buildings
                              2: buildings_list = UnitFilter(ai_all_buildings[base] diff ai_dismantle_these_buildings[base],[f_not,[f_lives,1000]]);
                         end;

                         case k of
                              2: begin
                                   if under_attack and engineers_not_allowed_to_repair_area > 0 then
                                        buildings_list = UnitFilter(buildings_list,[f_not,[f_inarea,engineers_not_allowed_to_repair_area]]);
                              end;
                              3: begin
                                   if crane_not_allowed_to_repair_area > 0 then
                                        buildings_list = UnitFilter(buildings_list,[f_not,[f_inarea,crane_not_allowed_to_repair_area]]);
                              end;
                         end;

                         i = i + 1;
                    until buildings_list > 0 or i > 2;

                    if buildings_list > 0 then
                         begin
                              case k of
                                   1: begin
                                        if apemen_engineers_list > 0 then
                                             repairing_buildings = Replace(repairing_buildings,k,true);

                                        workers_list = GetHumansOutOfUnits(apemen_engineers_list);
                                   end;
                                   2: begin
                                        if engineers_list > 0 then
                                             repairing_buildings = Replace(repairing_buildings,k,true);

                                        workers_list = GetHumansOutOfUnits(engineers_list);
                                   end;
                                   3: begin
                                        if ai_crane[base] > 0 then
                                             repairing_buildings = Replace(repairing_buildings,k,true);

                                        if ai_crane[base] > 0 and crane_usable then
                                             begin
                                                  workers_list = [ai_crane[base]];
                                                  crane_usable = false;
                                             end
                                        else
                                             workers_list = [];
                                   end;
                              end;

                              repeat
                                   i = 1;
                                   while i <= buildings_list do
                                        begin
                                             if workers_list = 0 then
                                                  break;

                                             temp_unit = NearestUnitToUnit(workers_list,buildings_list[i]);
                                             ComRepairBuilding(temp_unit,buildings_list[i]);

                                             workers_list = workers_list diff temp_unit;
                                             engineers_list = engineers_list diff temp_unit;
                                             apemen_engineers_list = apemen_engineers_list diff temp_unit;

                                             i = i + 1;
                                        end;

                              until workers_list = 0;
                         end;
                    end;

                    if true in repairing_buildings then
                         begin
                              //Humans and/or apemen could possibly not be repairing anything. Make them go
                              //to the depot in that case

                              temp_list = [];
                              if not repairing_buildings[1] then
                                   temp_list = temp_list ^ apemen_engineers_list;

                              if not repairing_buildings[2] then
                                   temp_list = temp_list ^ engineers_list;

                              //!!!!!!!!!!!!!!!!
                              //CAPACITY 5 BECAUSE OF LEADERS
                              //!!!!!!!!!!!!!!!!
                              DistributeHumansToBuildings(base,temp_list, UnitFilter(ai_depot[base],[[f_ok],[f_not,[f_constructed]]]),
                                   class_engineer,[5,6,5,5][base],false,false);

                              continue;
                         end;


                    if not under_attack then
                         begin
                              //Reconstruct buildings if any has been destroyed.
                              //First check if a building is already being constructed - then build that one first.
                              //Upgrading buildings can be hard if the building is working or something, so check if the
                              //building is actually under construction (or being upgraded) - if not then reset the
                              //relevant variables.
                              if ai_building_under_construction[base] > 0 then
                                   if BuildingStatus(ai_building_under_construction[base]) = bs_build then
                                        begin
                                             temp_list_2 = GetHumansOutOfUnits(engineers_list ^ apemen_engineers_list);

                                             if crane_usable and not IsInArea(ai_building_under_construction[base],crane_not_allowed_to_repair_area) then
                                                  temp_list_2 = temp_list_2 ^ ai_crane[base];

                                             for i in temp_list_2 do
                                                  ComRepairBuilding(i,ai_building_under_construction[base]);

                                             continue;
                                        end
                                   else
                                        begin
                                             ComCancel(ai_building_under_construction[base]);  //To make sure upgrade of building is possible
                                             ai_building_under_construction = Replace(ai_building_under_construction,base,0);
                                        end;

                              //Dismantle buildings. This goes before constructing buildings because we may have to construct a building
                              //on the spot where a building to dismantle is now. If we are already constructing a building we wait, though.
                              //Only engineers can dismantle buildings (apemen engineers and cranes cannot).
                              if ai_dismantle_these_buildings[base] > 0 and engineers_list > 0 then
                                   begin
                                        is_dismantling = true;

                                        //Find someone to dismantle, preferably the building constructor
                                        if ai_building_constructor[base] in engineers_list then
                                             k = ai_building_constructor[base]
                                        else
                                             k = BestFromListByList(engineers_list, engineers_list);  //Make sure we take the same unit each time

                                        engineers_list = engineers_list diff k;

                                        if IsInUnit(k) > 0 then
                                             case GetType(IsInUnit(k)) of
                                                  unit_vehicle: ComExitVehicle(k);
                                                  unit_building: ComExitBuilding(k);
                                             end
                                        else
                                             ComDismantle(k,ai_dismantle_these_buildings[base][1]);
                                   end
                              else
                                   is_dismantling = false;

                              if ( ai_all_buildings[base] - ai_excepted_buildings[base] < ai_buildings_locations[base] or ai_upcoming_building_data[base] > 0 ) and not is_dismantling then
                                   begin
                                        //Decide which building to construct. We take the first building in the location list which is
                                        //arranged in prioritated order.
                                        if ai_upcoming_building_data[base] = 0 then
                                             begin
                                                  temp_list = [];
                                                  for i in ai_buildings_locations[base] do
                                                       begin
                                                            k = false;
                                                            if HexInfo(i[1],i[2]) <= 0 then
                                                                 k = true
                                                            else
                                                                 if GetType(HexInfo(i[1],i[2])) <> unit_building then
                                                                      k = true;

                                                            //if GetBType(HexInfo(i[1],i[2])) = -1 and not i in ai_cannot_rebuild_these_buildings[base] then  //no building on the spot
                                                            if k and not i in ai_cannot_rebuild_these_buildings[base] then  //no building on the spot
                                                                 begin
                                                                      temp_list = i;
                                                                      break;
                                                                 end;
                                                       end;

                                                  if temp_list > 0 then  //Not necessarily the case (one of our buildings could have been captured)
                                                       begin
                                                            //If the building is a bunker then check if we have enough soldiers
                                                            //to occupy it. If not then build a turret instead.
                                                            if temp_list[4] = b_bunker and GetBaseNation(base) in [nation_american,nation_russian] then
                                                                 begin
                                                                      k = 0;

                                                                      for i in ai_buildings_locations[base] do
                                                                           if i[4] in [b_breastwork,b_bunker,b_armoury,b_barracks,b_fort] then
                                                                                k = k + 1;

                                                                      if k > ai_soldiers[base] then
                                                                           begin
                                                                                //Permanently change this to a turret. It would be nice if it would still be built as a
                                                                                //bunker if soldiers are added later but that's a rare case and adds unnecessary complexity.
                                                                                for i = 1 to ai_buildings_locations[base] do
                                                                                     if ai_buildings_locations[base][i] = temp_list then
                                                                                          begin
                                                                                               temp_list_2 = Replace(ai_buildings_locations[base][i],4,b_turret);
                                                                                               temp_list_2 = Replace(ai_buildings_locations[base],i,temp_list_2);
                                                                                               ai_buildings_locations = Replace(ai_buildings_locations,base,temp_list_2);

                                                                                               break;
                                                                                          end;

                                                                                temp_list = Replace(temp_list,4,b_turret);
                                                                           end;
                                                                 end;

                                                            ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,temp_list);
                                                       end;
                                             end;

                                        if ai_upcoming_building_data[base] > 0 then
                                             begin
                                                  //Find the best engineer to construct the building
                                                  if ai_building_constructor[base] = 0 then
                                                       begin
                                                            temp_list_2 = UnitFilter(ai_engineers[base],[f_class,class_engineer]);

                                                            if temp_list_2 > 0 then
                                                                 begin
                                                                      temp_list = [];
                                                                      for i in temp_list_2 do
                                                                           temp_list = temp_list ^ GetSkill(i,skill_engineering);
                                                                      ai_building_constructor = Replace(ai_building_constructor,base, BestFromListByList(temp_list_2,temp_list) );
                                                                 end
                                                            else
                                                                 if ai_engineers[base] = 0 and ai_crane[base] > 0 and crane_usable then
                                                                      begin
                                                                           if InArea(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],crane_not_allowed_to_repair_area) then
                                                                                begin
                                                                                     //Can't build this building with a crane.
                                                                                     temp_list = ai_cannot_rebuild_these_buildings[base] ^ [ai_upcoming_building_data[base]];
                                                                                     ai_cannot_rebuild_these_buildings = Replace(ai_cannot_rebuild_these_buildings,base,temp_list);

                                                                                     ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);
                                                                                end
                                                                           else
                                                                                ai_building_constructor = Replace(ai_building_constructor,base,ai_crane[base]);
                                                                      end;
                                                       end;

                                                  if ai_building_constructor[base] > 0 and ( ai_building_constructor[base] in engineers_list or ( ai_building_constructor[base] = ai_crane[base] and crane_usable ) ) then
                                                       begin
                                                            engineers_list = engineers_list diff ai_building_constructor[base];

                                                            if ai_building_constructor[base] = ai_crane[base] then
                                                                 crane_usable = false;

                                                            //Move vehicles away from the building site.
                                                            away_dist = 7; //Max distance needed for a workshop
                                                            if ai_vehicle_being_moved[base] = 0 then
                                                                 begin
                                                                      temp_list = UnitFilter(ai_vehicles_defend[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_control_tower_vehicles[base] ^ ai_crane[base] ^ ai_cargo_bay[base] ^ ai_sib_bomb_vehicles[base],
                                                                                             [[f_control,control_manual],[f_empty],[f_distxy,ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],away_dist]]);  //Don't consider "ai_vehicles_attack" - they will soon move by themselves
                                                                      if temp_list > 0 then
                                                                           begin
                                                                                if ai_building_constructor[base] = ai_crane[base] then
                                                                                     begin
                                                                                          //Can't build this building with a crane.
                                                                                          temp_list = ai_cannot_rebuild_these_buildings[base] ^ [ai_upcoming_building_data[base]];
                                                                                          ai_cannot_rebuild_these_buildings = Replace(ai_cannot_rebuild_these_buildings,base,temp_list);

                                                                                          ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);
                                                                                          ai_building_constructor = Replace(ai_building_constructor,base,0);
                                                                                     end
                                                                                else
                                                                                     begin
                                                                                          ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,temp_list[1]);
                                                                                          temp_list_2 = ai_vehicles_having_been_moved[base] ^ temp_list[1];
                                                                                          ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,temp_list_2);
                                                                                     end;
                                                                           end
                                                                      else
                                                                           //Build/upgrade the building
                                                                           if IsInUnit(ai_building_constructor[base]) > 0 then
                                                                                case GetType(IsInUnit(ai_building_constructor[base])) of
                                                                                     unit_building: ComExitBuilding(ai_building_constructor[base]);
                                                                                     unit_vehicle: ComExitVehicle(ai_building_constructor[base]);
                                                                                end
                                                                           else begin
                                                                                     k = false;
                                                                                     if HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]) <= 0 then
                                                                                          k = true
                                                                                     else
                                                                                          if GetType(HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2])) <> unit_building then
                                                                                               k = true;

                                                                                //case GetBType(HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2])) of
                                                                                //     -1: begin
                                                                                     if k then
                                                                                     begin
                                                                                          case ai_upcoming_building_data[base][4] of
                                                                                               b_warehouse: i = b_depot;
                                                                                               b_factory: i = b_workshop;
                                                                                               b_lab_half,b_lab_full: i = b_lab;
                                                                                               b_barracks: i = b_armoury;
                                                                                               else i = ai_upcoming_building_data[base][4];
                                                                                          end;

                                                                                          //ComBuild(ai_building_constructor[base],i,ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],ai_upcoming_building_data[base][3]);
                                                                                          //ComBuild doesn't work with cranes even though their task list looks the same after having been given the order.
                                                                                          //The task list order looks like this:
                                                                                          {
                                                                                          SetTaskList(crane,[['B',x,y,0,value_from_below,dir,0]]);
                                                                                          b_depot (0) = (ru) 64, (am) 1, (ar) 34
                                                                                          b_workshop (2) = (ru) 68, (am) 5, (ar) 38
                                                                                          b_armoury (4) = (ru) 66, (am) 3, (ar) 36
                                                                                          b_lab (6) = (ru) 77, (am) 17, (ar) 48
                                                                                          b_oil_power (26) = (ru) 85, (am) 25, (ar) 56
                                                                                          b_solar_power (27) = (am) 26, (ar) 57
                                                                                          b_siberite_power (28) = (ru) 86, (am) 27, (ar) 58
                                                                                          b_oil_mine (29) = (ru) 87, (am) 28, (ar) 59
                                                                                          b_siberite_mine (30) = (ru) 88, (am) 29, (ar) 60
                                                                                          b_breastwork (31) = (ru) 89, (am) 30, (ar) 61
                                                                                          b_bunker (32) = (ru) 90, (am) 31, (ar) 62
                                                                                          b_turret (33) = (ru) 91, (am) 32
                                                                                          b_teleport (34) = (ru) 92
                                                                                          b_control_tower (36) = (am) 94
                                                                                          b_ext_track (16) = (ru) 70, (am) 7, (ar) 40
                                                                                          b_ext_gun (17) = (ru) 71, (am) 8, (ar) 41
                                                                                          b_ext_rocket (18) = (ru) 72, (am) 9, (ar) 42
                                                                                          b_ext_noncombat (19) = (ru) 73, (am) 10
                                                                                          b_ext_radar (20) = (am) 11, (ar) 44
                                                                                          b_ext_siberium (21) = (ru) 75, (am) 12, (ar) 45
                                                                                          b_ext_stitch (23) = (ar) 43
                                                                                          b_ext_computer (24) = (ru) 76, (am) 15
                                                                                          b_ext_laser (25) = (am) 16
                                                                                          }
                                                                                          case i of
                                                                                               b_depot: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 64;
                                                                                                         nation_american: b_value = 1;
                                                                                                         nation_arabian: b_value = 34;
                                                                                                    end;
                                                                                               end;
                                                                                               b_workshop: begin
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 68;
                                                                                                         nation_american: b_value = 5;
                                                                                                         nation_arabian: b_value = 38;
                                                                                                    end;
                                                                                               end;
                                                                                               b_armoury: begin             
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 66;
                                                                                                         nation_american: b_value = 3;
                                                                                                         nation_arabian: b_value = 36;
                                                                                                    end;
                                                                                               end;
                                                                                               b_lab: begin            
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 77;
                                                                                                         nation_american: b_value = 17;
                                                                                                         nation_arabian: b_value = 48;
                                                                                                    end;
                                                                                               end;
                                                                                               b_oil_power: begin          
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 85;
                                                                                                         nation_american: b_value = 25;
                                                                                                         nation_arabian: b_value = 56;
                                                                                                    end;
                                                                                               end;
                                                                                               b_solar_power: begin         
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = 26;
                                                                                                         nation_arabian: b_value = 57;
                                                                                                    end;
                                                                                               end;
                                                                                               b_siberite_power: begin       
                                                                                                   case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 86;
                                                                                                         nation_american: b_value = 27;
                                                                                                         nation_arabian: b_value = 58;
                                                                                                    end;
                                                                                               end;
                                                                                               b_oil_mine: begin           
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 87;
                                                                                                         nation_american: b_value = 28;
                                                                                                         nation_arabian: b_value = 59;
                                                                                                    end;
                                                                                               end;
                                                                                               b_siberite_mine: begin      
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 88;
                                                                                                         nation_american: b_value = 29;
                                                                                                         nation_arabian: b_value = 60;
                                                                                                    end;
                                                                                               end;
                                                                                               b_breastwork: begin         
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 89;
                                                                                                         nation_american: b_value = 30;
                                                                                                         nation_arabian: b_value = 61;
                                                                                                    end;
                                                                                               end;
                                                                                               b_bunker: begin       
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 90;
                                                                                                         nation_american: b_value = 31;
                                                                                                         nation_arabian: b_value = 62;
                                                                                                    end;
                                                                                               end;
                                                                                               b_turret: begin       
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 91;
                                                                                                         nation_american: b_value = 32;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_teleport: begin      
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 92;
                                                                                                         nation_american: b_value = -7;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_control_tower: begin   
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = 94;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_track: begin     
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 70;
                                                                                                         nation_american: b_value = 7;
                                                                                                         nation_arabian: b_value = 40;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_gun: begin  
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 71;
                                                                                                         nation_american: b_value = 8;
                                                                                                         nation_arabian: b_value = 41;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_rocket: begin       
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 72;
                                                                                                         nation_american: b_value = 9;
                                                                                                         nation_arabian: b_value = 42;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_noncombat: begin      
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 73;
                                                                                                         nation_american: b_value = 10;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_radar: begin        
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = 11;
                                                                                                         nation_arabian: b_value = 44;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_siberium: begin     
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 75;
                                                                                                         nation_american: b_value = 12;
                                                                                                         nation_arabian: b_value = 45;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_stitch: begin  
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = -7;
                                                                                                         nation_arabian: b_value = 43;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_computer: begin             
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = 76;
                                                                                                         nation_american: b_value = 15;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               b_ext_laser: begin          
                                                                                                    case GetNation(ai_building_constructor[base]) of
                                                                                                         nation_russian: b_value = -7;
                                                                                                         nation_american: b_value = 16;
                                                                                                         nation_arabian: b_value = -7;
                                                                                                    end;
                                                                                               end;
                                                                                               else
                                                                                                    b_value = -42;
                                                                                          end;

                                                                                          SetTaskList(ai_building_constructor[base],[['B',ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],0,b_value,ai_upcoming_building_data[base][3],0]]);
                                                                                     end
                                                                                     else
                                                                                     case GetBType(HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2])) of
                                                                                     b_depot: begin
                                                                                          ComUpgrade(ai_depot[base]);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,ai_depot[base]);
                                                                                     end;
                                                                                     b_workshop: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_lab,b_lab_half: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);

                                                                                          if ai_upcoming_building_data[base][5] <> b_lab_basic and not ai_upcoming_building_data[base][5] in [GetLabKind(temp_unit,1),GetLabKind(temp_unit,2)] then
                                                                                               begin
                                                                                                    ComUpgradeLab(temp_unit,ai_upcoming_building_data[base][5]);

                                                                                                    if base = 2 and alli_sib_needed > 0 and ai_upcoming_building_data[base][5] = b_lab_siberium then
                                                                                                         alli_sib_usage = alli_sib_usage + 5;
                                                                                               end
                                                                                          else
                                                                                               if ai_upcoming_building_data[base][6] <> b_lab_basic then
                                                                                                    begin
                                                                                                         ComUpgradeLab(temp_unit,ai_upcoming_building_data[base][6]);

                                                                                                         if base = 2 and alli_sib_needed > 0 and ai_upcoming_building_data[base][6] = b_lab_siberium then
                                                                                                              alli_sib_usage = alli_sib_usage + 5;
                                                                                                    end
                                                                                               else  //should never happen
                                                                                                    begin
                                                                                                         ai_building_constructor = Replace(ai_building_constructor,base,0);
                                                                                                         ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);
                                                                                                    end;

                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_armoury: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     end;
                                                                                end;
                                                                 end
                                                            else
                                                                 if UnitsInside(ai_vehicle_being_moved[base]) > 0 then
                                                                      begin
                                                                           if GetDistUnitXY(ai_vehicle_being_moved[base],ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]) <= away_dist then
                                                                                AI_GetAwayFromXY(ai_vehicle_being_moved[base],ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],away_dist+2,false)
                                                                           else
                                                                                ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);
                                                                      end
                                                                 else
                                                                      if IsInUnit(ai_building_constructor[base]) > 0 then
                                                                           case GetType(IsInUnit(ai_building_constructor[base])) of
                                                                                unit_building: ComExitBuilding(ai_building_constructor[base]);
                                                                                unit_vehicle: ComExitVehicle(ai_building_constructor[base]);
                                                                           end
                                                                      else
                                                                           ComEnterUnit(ai_building_constructor[base],ai_vehicle_being_moved[base]);
                                                       end;
                                             end;
                                   end;


                              //Gather crates in the vicinity of the base (engineers).
                              //Everyone go after the same bunch of crates.
                              if (engineers_list ^ apemen_engineers_list) > 0 and ai_depot[base] > 0 then
                                   begin
                                        temp_list = GetListOfCratesInArea(GetBaseArea(base));
                                        while temp_list > 0 do
                                             begin
                                                  if GetResourceTypeXY(temp_list[1],temp_list[2]) = mat_artifact then
                                                       begin
                                                            temp_list = Delete(temp_list,1);
                                                            temp_list = Delete(temp_list,1);
                                                            continue;
                                                       end;

                                                  ComCollect(GetHumansOutOfUnits(engineers_list ^ apemen_engineers_list),temp_list[1],temp_list[2]);
                                                  engineers_list = [];
                                                  apemen_engineers_list = [];

                                                  break;
                                             end;
                                   end;
                         end;


                    //Return to and stay inside the depot (if possible)
                    //!!!!!!!!!!!!!!!!
                    //CAPACITY 5 BECAUSE OF LEADERS
                    //!!!!!!!!!!!!!!!!
                    DistributeHumansToBuildings(base,engineers_list ^ apemen_engineers_list, UnitFilter(ai_depot[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_engineer,[5,6,5,5][base],false,false);

                    if crane_usable then
                         if not IsInArea(ai_crane[base],GetBaseArea(base)) then
                              ComMoveXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2])
                         else
                              if GetLives(ai_crane[base]) < 1000 and not under_attack then
                                   ai_crane_is_being_repaired = Replace(ai_crane_is_being_repaired,base,true);
               end;

          until false;
     end;
On BuildingStarted(building,builder) do
     var side, temp_list, base, i;
     begin
          side = GetSide(building);
          if side = you then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          ai_building_constructor = Replace(ai_building_constructor,base,0);
          ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,[]);

          //ONLY 1 building is under construction at a time!
          ai_building_under_construction = Replace(ai_building_under_construction,base,building);

          if base = 2 and alli_sib_needed > 0 then
               begin
                    case GetBType(building) of
                         b_siberite_power: alli_sib_usage = alli_sib_usage + 20;
                         b_ext_siberium: alli_sib_usage = alli_sib_usage + 10;
                    end;
               end;
     end;
On BuildingComplete(building) do
     var side, temp_list, temp_unit, base, i, hex;
     begin
          side = GetSide(building);
          if side = you then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          if ai_sib_bomb_fact_location[base] > 0 then
               if ai_upcoming_building_data[base][1] = ai_sib_bomb_fact_location[base][1] and ai_upcoming_building_data[base][2] = ai_sib_bomb_fact_location[base][2] then
                    ai_sib_bomb_fact = Replace(ai_sib_bomb_fact,base,building);

          hex = [GetX(building),GetY(building)];
          if hex in ai_fact_extension_replace_locations[base] then
               begin
                    for i in ai_facts[base] do
                         if ai_facts_with_ext_rebuild_map >= i then
                              begin
                                   temp_list = ai_facts_with_ext_rebuild_map[i] diff [hex];
                                   ai_facts_with_ext_rebuild_map = Replace(ai_facts_with_ext_rebuild_map,i,temp_list);
                              end;
               end;

          BuildUpgradeCommon(base,building);

          temp_list = ai_all_buildings[base] ^ building;
          ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

          UpdateBuildingBasicVariables(base,building,true);
     end;
On UpgradeComplete(building) do
     var side, temp_list, base;
     begin
          side = GetSide(building);
          if side = you then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          BuildUpgradeCommon(base,building);
     end;
Function BuildUpgradeCommon(base,building);
     begin
          //Some buildings require upgrade - e.g. workshop -> factory
          if GetBType(building) = ai_upcoming_building_data[base][4] then
               ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);

          ai_building_under_construction = Replace(ai_building_under_construction,base,0);
     end;
On BuildingCaptured(captured_building,building_former_side,capturing_unit) do
     var temp_list, base, i;
     begin
          if captured_building = ai_depot[2] and alliance_deal_status = 2 then
               AllianceDealBreakdown;

          if captured_building in ai_depot then
               begin
                    //Should be the same amounts as if depot was destroyed (except siberite amount).
                    SetResourceType(GetBase(captured_building),mat_cans,[100,50,0][difficulty] + Rand(0,3)*10);
                    SetResourceType(GetBase(captured_building),mat_oil,[200,150,100][difficulty] + Rand(0,100));
                    SetResourceType(GetBase(captured_building),mat_siberit,[20,10,0][difficulty]);
               end;

          if building_former_side = alliance and difficulty > 1 and GetBType(captured_building) = b_factory then
               begin
                    //It's too easy if the player can get Alliance's noncombat extension
                    //early in game.
                    for i in FilterAllUnits([[f_dist,captured_building,4],[f_btype,b_ext_noncombat]]) do
                         KillUnit(i);
               end;

          if GetSide(capturing_unit) = you and GetBType(captured_building) in [b_lab,b_lab_half,b_lab_full] then
               begin
                    //Player has captured an enemy lab. Gain some techs.
                    case GetNation(captured_building) of
                         nation_american: begin
                              if GetTech(tech_lassight,you) = state_disabled then  //If the player has not researched it
                                   SetTech(tech_lassight,you,state_enabled);

                              if GetTech(tech_advmet,you) = state_disabled then
                                   SetTech(tech_advmet,you,state_enabled);
                         end;
                         nation_russian: begin
                              if GetTech(tech_bazooka,you) = state_disabled then
                                   SetTech(tech_bazooka,you,state_enabled);

                              if GetTech(tech_advmet,you) = state_disabled then
                                   SetTech(tech_advmet,you,state_enabled);
                         end;
                    end;
               end;

          base = FindBase(captured_building);

          if base = 0 then
               exit;

          if building_former_side = GetBaseSide(base) then
               begin
                    if captured_building in ai_all_buildings[base] then
                         begin
                              //Someone captured one of our buildings!
                              RemoveBuildingFromVariables(base,captured_building);

                              temp_list = ai_captured_buildings[base] ^ captured_building;
                              ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
                         end;
               end
          else
               begin
                    if GetSide(captured_building) = GetBaseSide(base) then
                         begin
                              //Ha! We captured it back again!
                              temp_list = ai_all_buildings[base] ^ captured_building;
                              ai_all_buildings = Replace(ai_all_buildings,base,temp_list);
                             
                              UpdateBuildingBasicVariables(base,captured_building,true);

                              temp_list = ai_captured_buildings[base] diff captured_building;
                              ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
                         end;
               end;
     end;


//Function which orders human units inside other units to exit them. Returns a list with the units which weren't inside other units.
Export Function GetHumansOutOfUnits(un_list);
     var i;
     begin
          result = [];
          for i in un_list do
               if IsInUnit(i) > 0 then
                    case GetType(IsInUnit(i)) of
                         unit_building: ComExitBuilding(i);
                         unit_vehicle: ComExitVehicle(i);
                    end
               else result = result ^ i;
     end;


//Function which tells if a base is under attack.
//attack_side - side which is attacking def_side's base. -1 if any enemy side of the base's side.
Export Function BaseUnderAttack(base,attack_side);
     var area, i, val, def_side, temp_list;
     begin
          result = false;

          def_side = GetBaseSide(base);
          area = GetBaseArea(base);

          if attack_side = def_side then
               exit;

          if attack_side = -1 then
               begin
                    for i = 1 to 8 do
                         if ai_sib_bomb_used_time_matrix[base][i] > -1 and ai_sib_bomb_used_time_matrix[base][i] + ai_sib_bomb_contamination_duration >= tick then
                              begin
                                   result = true;
                                   exit;
                              end;

                    if FilterAllUnits([[f_enemy,def_side],[f_inarea,area]]) > 0 then
                         begin
                              result = true;
                              exit;
                         end;

                    val = true;
                    for i in ai_contact_time[def_side] do
                         if i < 0$10 then
                              begin
                                   val = false;
                                   break;
                              end;

                    if ContactTime(def_side) >= 0$10 and val then
                         exit;

                    //if ListFilterNearArea( FilterAllUnits([f_enemy,def_side]) ,area) = 0 then
                    //     exit;
                    //The above was the former way of checking if enemy units was nearby but this implied looping through
                    //a lot of units on the map (in function ListFilterNearArea). This caused laggs. Filter-functions like
                    //FilterAllUnits are much much faster than loops with function calls. All we need is to assume that no
                    //unit inside another base's area will ever attack another base which seems reasonable.
                    temp_list = [];
                    for i in (ai_bases diff base) do
                         temp_list = Insert(temp_list,1,[f_not,[f_inarea,GetBaseArea(i)]]);

                    temp_list = FilterAllUnits([[f_enemy,def_side],[f_not,[f_type,unit_building]]] ^ temp_list);
                    if not AnyNearBaseArea(temp_list,base) then
                         exit;
               end
          else
               begin
                    if ai_sib_bomb_used_time_matrix[base][attack_side] > -1 and ai_sib_bomb_used_time_matrix[base][attack_side] + ai_sib_bomb_contamination_duration >= tick then
                         begin
                              result = true;
                              exit;
                         end;

                    if FilterAllUnits([[f_side,attack_side],[f_inarea,area]]) > 0 then
                         begin
                              result = true;
                              exit;
                         end;

                    if ContactTime([def_side,attack_side]) >= 0$10 and ai_contact_time[def_side][attack_side] >= 0$10 then
                         exit;

                    //if ListFilterNearArea( FilterAllUnits([f_side,attack_side]) ,area) = 0 then
                    //     exit;
                    temp_list = [];
                    for i in (ai_bases diff base) do
                         temp_list = Insert(temp_list,1,[f_not,[f_inarea,GetBaseArea(i)]]);

                    temp_list = FilterAllUnits([[f_side,attack_side],[f_not,[f_type,unit_building]]] ^ temp_list);
                    if not AnyNearBaseArea(temp_list,base) then
                         exit;
               end;

          result = true;
     end;
Export Function ListFilterNearArea(list,area);
     var i;
     begin
          result = [];

          for i in list do
               if GetDistUnitArea(i,area) <= ai_near_base_dist then
                    result = result ^ i;
     end;
Function AnyNearBaseArea(list,base);
     var i, area;
     begin
          result = false;
          area = GetBaseArea(base);

          for i in list do
               if GetDistUnitArea(i,area) <= ai_near_base_dist then
                    begin
                         result = true;
                         break;
                    end;
     end;

On Command(com) do
     var i, temp_list, hex_list, un, k, target_hex;
     begin
          OnCommand_Steal(com);

          OnCommand_CrateDropDetection(com);

          if com = 124 then  //attack ground
               begin
                    //Find one of the unit which were given the command
                    for i in FilterAllUnits([f_side,you]) do
                         if IsSelected(i) and HasTask(i) then
                              begin
                                   target_hex = [];
                                   for k in GetTaskList(i) do
                                        if k[1] = '|' then  //Attack ground is ['|',x,y,0,0,0,0]
                                             begin
                                                  target_hex = [k[2],k[3]];
                                                  break;
                                             end;

                                   if target_hex > 0 then
                                             begin
                                                  hex_list = target_hex;

                                                  //Units within distance 1 of the hex will take damage. Find all units within that distance.
                                                  temp_list = [];
                                                  for k = 0 to 5 do
                                                       temp_list = Insert(temp_list,1,[ShiftX(hex_list[1],k,1),ShiftY(hex_list[2],k,1)]);
                                                  
                                                  hex_list = [hex_list] ^ temp_list;

                                                  temp_list = [];
                                                  for k in hex_list do
                                                       begin
                                                            un = HexInfo(k[1],k[2]);

                                                            if un > 0 and not un in temp_list then
                                                                 begin
                                                                      ai_attack_ground_info_initial = Insert(ai_attack_ground_info_initial,1,[i,un,GetSide(un),target_hex[1],target_hex[2]]);
                                                                      temp_list = temp_list ^ un;
                                                                 end;
                                                       end;
                                             end;
                              end;
               end;
     end;
//Every updating "ai_contact_time", "ai_attack_ground_info_initial" and "ai_attack_ground_info_sustain".
Every 0$1+0$0.1 do
     var a, b, temp_list, temp_list_2, yup, i, t;
     begin
          repeat
          wait(0$0.5);

          //Check if some of the units, that were going to attack ground, gave up before
          //doing so.
          i = 1;
          while i <= ai_attack_ground_info_initial do
               begin
                    yup = false;
                    for t in GetTaskList(ai_attack_ground_info_initial[i][1]) do
                         if t[1] = '|' then  //Attack ground is ['|',x,y,0,0,0,0]
                              if t[2] = ai_attack_ground_info_initial[i][4] and t[3] = ai_attack_ground_info_initial[i][5] then
                                   begin
                                        yup = true;
                                        break;
                                   end;

                    if not yup then
                         begin
                              ai_attack_ground_info_initial = Delete(ai_attack_ground_info_initial,i);
                              continue;
                         end;

                    i = i + 1;
               end;

          //Check if some of the units attacking ground has stopped.
          i = 1;
          while i <= ai_attack_ground_info_sustain do
               begin
                    yup = false;
                    for t in GetTaskList(ai_attack_ground_info_sustain[i][1]) do
                         if t[1] = '|' then  //Attack ground is ['|',x,y,0,0,0,0]
                              if t[2] = ai_attack_ground_info_sustain[i][4] and t[3] = ai_attack_ground_info_sustain[i][5] then
                                   begin
                                        yup = true;
                                        break;
                                   end;

                    if not yup then
                         begin
                              ai_attack_ground_info_sustain = Delete(ai_attack_ground_info_sustain,i);
                              continue;
                         end;

                    i = i + 1;
               end;

          //Update all times
          temp_list = ai_contact_time;
          for a = 1 to temp_list do
               for b = 1 to temp_list[a] do
                    if temp_list[a][b] < 100000 then
                         begin
                              temp_list_2 = Replace(ai_contact_time[a],b, temp_list[a][b] + 0$0.5 );
                              ai_contact_time = Replace(ai_contact_time,a,temp_list_2);
                         end;

          //New attacks?
          //Function SideShoot and UnitShoot does detect damage from attacking ground.
          for a in ai_attack_ground_info_initial do
               begin
                         if IsDead(a[2]) or UnitShoot(a[2]) = a[1] then
                              begin
                                   temp_list = Replace(ai_contact_time[you],a[3],0);
                                   ai_contact_time = Replace(ai_contact_time,you,temp_list);

                                   temp_list = Replace(ai_contact_time[a[3]],you,0);
                                   ai_contact_time = Replace(ai_contact_time,a[3],temp_list);

                                   ai_attack_ground_info_initial = ai_attack_ground_info_initial diff [a];
                                   ai_attack_ground_info_sustain = Insert(ai_attack_ground_info_sustain,1,a);
                              end;
               end;

          //Sustained attacks?
          for a in ai_attack_ground_info_sustain do
               begin
                    temp_list = Replace(ai_contact_time[you],a[3],0);
                    ai_contact_time = Replace(ai_contact_time,you,temp_list);

                    temp_list = Replace(ai_contact_time[a[3]],you,0);
                    ai_contact_time = Replace(ai_contact_time,a[3],temp_list);
               end;

          until false;
     end;

//Check for siberite rocket launches.
On SiberiteRocketExploded(vehicle,x,y) do
     var side, base, i, temp_list;
     begin
          if InArea(x,y,south_motherlode_area) or InArea(x,y,Ru_base) then
               begin
                    ExclusiveOn;
                    wait(0$4);
                    YouLost('SibChain');
               end;

          if IsDead(vehicle) then  //Siberite rocket vehicle can die before rocket explodes
               exit;

          side = GetSide(vehicle);

          if side = you then
               player_fired_siberite_bomb = true;

          base = -1;
          for i in ai_bases do
               if InArea(x,y,GetBaseArea(i)) then  //Could explode right outside the base but there is no function to check distance between a hex and an area (only unit to area).
                    begin
                         base = i;
                         break;
                    end;

          if base = -1 then
               exit;
          
          temp_list = Replace(ai_sib_bomb_used_time_matrix[base],side,tick);
          ai_sib_bomb_used_time_matrix = Replace(ai_sib_bomb_used_time_matrix,base,temp_list);
     end;


//Mechanics (defending, i.e. in the base)
//Priorities if base is under attack (descending):
//- If a mechanic is hurt, pull him back for healing.
//- Repair war vehicles defending the base.
//- Stay in factory.
//Priorites if not under attack (decending):
//- If a mechanic is hurt, pull him back for healing.
//- Refuel vehicles
//- Repair damaged war vehicles within the base
//- Stay in factory (and possibly construct a vehicle or weapon)
//When it comes to American remote control we pick some mechanics to control
//specific vehicles. Their priorities are (descending):
//- If a mechanic is hurt, pull him back for healing.
//- Repair war vehicles defending the base (if all vehicles you control are burning or dead)
//- Stay in control tower and link to vehicles.
//Priorites if not under attack (decending):
//- If a mechanic is hurt, pull him back for healing.
//- Repair damaged war vehicles within the base (if all remote vehicles are inside the base)
//- Stay in control tower and link to vehicles.
Every 0$1+0$0.4 do
     var side, i, mechanics_list, temp_list, temp_list_3, temp_unit, vehicles_list, allowed_to_repair_vehicles;
     var under_attack, free_parking_spots, k, base, area, temp_list_2, remote_mechanics, parked_vehicles, n, a;
     var temp_list_4, temp_list_5, num_control_stations, free_behemoth_parking_spots, parked_behemoths, already_inside_mecs;
     var vehicles_to_consider, vehicles_allowed_to_park, human_pullback_hex_max_dist, vehicles_to_park;
     var vehicles_drivers, remote_driver_vehicles;
     begin
          //Index is vehicle id, value is driver id.
          //For use to ensure the driver first chosen to drive the
          //vehicle goes for it (doesn't change to another driver).
          vehicles_drivers = [];

          remote_driver_vehicles = [[],[],[],[]];  //For remote control. [driver_id,[veh1,veh2,veh3]]

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));
                    
                    side = GetBaseSide(base);
                    area = GetBaseArea(base);
                    under_attack = BaseUnderAttack(base,-1);  //Base under attack
                    

                    //Update vehicles drivers so vehicles with a driver no longer has that driver assigned
                    //so a possible new driver can be assigned next time.
                    for i in ai_vehicles_defend[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] do
                         if vehicles_drivers >= i then
                              if vehicles_drivers[i] > 0 then
                                   if IsInUnit(vehicles_drivers[i]) = i or IsDead(vehicles_drivers[i]) then
                                        vehicles_drivers = Replace(vehicles_drivers,i,0);


                    //Find a driver for the (manual) crane if necessary.
                    if ai_crane[base] > 0 and GetControl(ai_crane[base]) = control_manual and ai_crane_driver[base] = 0 and ai_mechanics_defend[base] > 0 then
                         begin
                              ai_crane_driver = Replace(ai_crane_driver,base, FindBestCraneDriver(base) );

                              for i = 1 to remote_driver_vehicles[base]+0 do
                                   if remote_driver_vehicles[base][i][1] = ai_crane_driver[base] then
                                        begin
                                             temp_list = Delete(remote_driver_vehicles[base],i);
                                             remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list);

                                             break;
                                        end;
                         end;

                    //Clear crane driver from vehicles drivers
                    {if ai_crane_driver[base] > 0 and ai_crane_driver[base] in vehicles_drivers then
                         begin
                              for i = 1 to vehicles_drivers do
                                   if vehicles_drivers[i] = ai_crane_driver[base] then
                                        begin
                                             vehicles_drivers = Replace(vehicles_drivers,i,0);
                                             break;
                                        end;
                         end; -> if not crane driver is in mechanics_list then another driver will be found, cf. function "FindDriverHelper"}


                    mechanics_list = UnitFilter(ai_mechanics_defend[base] diff (ai_heal_these_humans[base] ^ ai_crane_driver[base]),[f_not,[f_driving]]);
                    if ai_crane_driver[base] > 0 and not IsOk(ai_crane[base]) then
                         mechanics_list = mechanics_list ^ ai_crane_driver[base];

                    remote_mechanics = [];


                    //Identify mechanics who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= mechanics_list do
                         begin
                              if GetLives(mechanics_list[i]) <= 900 then
                                   begin
                                        temp_list = temp_list ^ mechanics_list[i];
                                        mechanics_list = Delete(mechanics_list,i);
                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Remote control.
                    if ai_control_tower[base] > 0 or ai_control_tower_vehicles[base] > 0 then
                         begin
                              //Sort away dead vehicles and vehicles controlled by dead mechanics.
                              //Demote remote mechanics if there aren't enough control stations for everyone.
                              //Find vehicles currently connected to a mechanic.
                              temp_list = remote_driver_vehicles[base];
                              vehicles_list = [];

                              i = 1;
                              while i <= temp_list do
                                   begin
                                        if IsDead(temp_list[i][1]) then
                                             begin
                                                  temp_list = Delete(temp_list,i);
                                                  continue;
                                             end
                                        else
                                             begin
                                                  temp_list_3 = temp_list[i][2];

                                                  k = 1;
                                                  while k <= temp_list_3 do
                                                       begin
                                                            if IsDead(temp_list_3[k]) then
                                                                 begin
                                                                      temp_list_3 = Delete(temp_list_3,k);
                                                                      continue;
                                                                 end;

                                                            k = k + 1;
                                                       end;

                                                  if temp_list_3 > 0 then
                                                       begin
                                                            temp_list_2 = Replace(temp_list[i],2,temp_list_3);
                                                            temp_list = Replace(temp_list,i,temp_list_2);
                                                       end
                                                  else
                                                       begin
                                                            temp_list = Delete(temp_list,i);
                                                            continue;
                                                       end;
                                             end;

                                        vehicles_list = vehicles_list ^ temp_list[i][2];

                                        i = i + 1;
                                   end;

                              num_control_stations = ai_control_tower_vehicles[base] + (ai_control_tower[base] > 0)*3;
                              while temp_list > num_control_stations do
                                   begin
                                        vehicles_list = vehicles_list diff temp_list[temp_list+0][2];
                                        temp_list = Delete(temp_list,temp_list+0);
                                   end;

                              remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list);

                              //Connect remote vehicles to mechanics.
                              temp_list = UnitFilter((ai_vehicles_defend[base] ^ (ai_cargo_bay[base] diff 0) ^ (ai_crane[base] diff 0) ^
                                                      ai_vehicles_attack[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_sib_bomb_vehicles[base])
                                                      diff vehicles_list,[f_control,control_remote]);
                              if temp_list > 0 then
                                   begin
                                        //By omitting some mechanics here (e.g. those being healed) we may end up assigning more vehicles to a single
                                        //mechanic than we should. And those will not be reassigned. It's rare, though, and not so simple to fix
                                        //so let's just omit those lines of code.
                                        //Always leave at least one mechanic to work in the factory.
                                        temp_list_3 = mechanics_list;
                                        for i in remote_driver_vehicles[base] do
                                             temp_list_3 = temp_list_3 diff i[1];

                                        if temp_list_3 > 0 then
                                             temp_list_3 = temp_list_3 diff FindMinSkill(temp_list_3,skill_mechanical);

                                        i = 1;
                                        while i <= temp_list do    
                                             begin
                                                            //Find a suitable mechanic already controlling other vehicles.
                                                            //We want two vehicles per mechanic (it can be mathematically proven that this is the
                                                            //best number to pick given that no vehicles block another vehicle so it can't attack during a fight).
                                                            //If all have 2 or more vehicles then take the one controlling the least vehicles.
                                                            a = 1;
                                                            while a <= remote_driver_vehicles[base] do
                                                                 begin
                                                                      if remote_driver_vehicles[base][a][2] < 2 and GetSkill(remote_driver_vehicles[base][a][1],skill_mechanical) >= 2 then
                                                                           break;

                                                                      a = a + 1;
                                                                 end;

                                                            if a > remote_driver_vehicles[base] then
                                                                 begin
                                                                      if remote_driver_vehicles[base] >= num_control_stations then
                                                                           begin
                                                                                //Not enough control stations for another remote mechanic.
                                                                                temp_list_3 = [];
                                                                           end;

                                                                      if temp_list_3 > 0 then
                                                                           begin
                                                                                //Assign a new remote mechanic.
                                                                                //Take the best mechanic
                                                                                temp_unit = FindMaxSkill(temp_list_3,skill_mechanical);
                                                                                temp_list_3 = temp_list_3 diff temp_unit;
                                                                                
                                                                                temp_list_2 = remote_driver_vehicles[base] ^ [[temp_unit,[temp_list[i]]]];
                                                                                remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list_2);

                                                                                i = i + 1;
                                                                                continue;
                                                                           end;

                                                                      //Sort away drivers who cannot control more vehicles.
                                                                      temp_list_4 = [];
                                                                      for a in remote_driver_vehicles[base] do
                                                                           if GetSkill(a[1],skill_mechanical) > a[2] then
                                                                                temp_list_4 = temp_list_4 ^ [a];

                                                                      if temp_list_4 = 0 then
                                                                           break;

                                                                      temp_list_2 = [];
                                                                      for a in temp_list_4 do
                                                                           temp_list_2 = temp_list_2 ^ (a[2]+0);

                                                                      temp_list_2 = WorstFromListByList(temp_list_4,temp_list_2);

                                                                      for a = 1 to remote_driver_vehicles[base] do
                                                                           if remote_driver_vehicles[base][a][1] = temp_list_2[1] then
                                                                                break;
                                                                 end;

                                                            temp_list_2 = remote_driver_vehicles[base][a][2] ^ temp_list[i];
                                                            temp_list_2 = Replace(remote_driver_vehicles[base][a],2,temp_list_2);
                                                            temp_list_2 = Replace(remote_driver_vehicles[base],a,temp_list_2);
                                                            remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list_2);

                                                            i = i + 1;
                                             end;
                                   end;

                              //Find all remote mechanics
                              for i in remote_driver_vehicles[base] do
                                   remote_mechanics = remote_mechanics ^ i[1];

                              mechanics_list = mechanics_list diff remote_mechanics;
                              remote_mechanics = remote_mechanics diff ai_heal_these_humans[base];

                              //There must always be at least one mechanic to work in the factory.
                              if mechanics_list = 0 and remote_driver_vehicles[base] > 0 then
                                   begin
                                        //Release the mechanic controlling the least vehicles.
                                        n = 0;
                                        a = 9999;
                                        for i = 1 to (remote_driver_vehicles[base]+0) do
                                             begin
                                                  if remote_driver_vehicles[base][i][2]+0 < a then
                                                       begin
                                                            a = remote_driver_vehicles[base][i][2]+0;
                                                            n = i;
                                                       end;
                                             end;

                                        mechanics_list = mechanics_list ^ remote_driver_vehicles[base][n][1];
                                        remote_mechanics = remote_mechanics diff remote_driver_vehicles[base][n][1];
                                        temp_list_2 = Delete(remote_driver_vehicles[base],n);
                                        remote_driver_vehicles = Replace(remote_driver_vehicles,base,temp_list_2);
                                   end;
                         end
                    else
                         begin
                              remote_driver_vehicles = Replace(remote_driver_vehicles,base,[]);
                         end;


                    //Build behemoths. Always leave some people in the factory to work there.
                    if base = 1 and ai_behemoths[base] + UnitFilter(ai_vehicles_attack[base],[[f_ok],[f_weapon,59]]) < MaxNumBehemoths(base) and mechanics_list > 2 then  //"59" identifiers behemoths
                         begin
                              temp_list = [];
                              for i = 3 to mechanics_list+0 do
                                   begin
                                        temp_list = temp_list ^ mechanics_list[1];
                                        mechanics_list = Delete(mechanics_list,1);
                                   end;

                              temp_unit = HexInfo(ai_behemoth_construction_hex[base][1],ai_behemoth_construction_hex[base][2]);
                              k = false;
                              if temp_unit > 0 then
                                   if GetType(temp_unit) = unit_building then
                                        if GetBType(temp_unit) = b_behemoth then
                                             k = true;

                              if not k then
                                   begin
                                        ComBuildBehemoth(temp_list,b_behemoth,ai_behemoth_construction_hex[base][1],ai_behemoth_construction_hex[base][2],0);
                                   end
                              else
                                   begin
                                        ComRepairBuilding(temp_list,temp_unit);
                                   end;
                         end;


                    //Find vehicles which no longer need to be repaired (fully repaired).
                    temp_list = [];
                    for i in ai_vehicles_being_repaired[base] do
                         if GetLives(i) < 1000 then
                              temp_list = temp_list ^ i;
                    ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);


                    //Find vehicles which do no longer need to retreat (they have been fully repaired)
                    temp_list = [];
                    for i in ai_retreating_vehicles_defend[base] do//diff ai_vehicles_being_repaired[base] do  -> Don't want them to move to the enemy with a team of mechanics following it to repair it
                         if GetLives(i) < 1000 then
                              temp_list = temp_list ^ i;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);


                    //Identify defending vehicles which need to retreat.
                    //Make vehicles retreat if they exceed a certain threshold of damage. Works for any amount of health
                    //(except full health) but is only used when the vehicles are burning. Defend the base at all costs!
                    temp_list = ai_retreating_vehicles_defend[base];
                    for i in ai_vehicles_defend[base] diff ai_retreating_vehicles_defend[base] do// ^ ai_vehicles_being_repaired[base]) do
                         if GetLives(i) <= 250 then
                              temp_list = temp_list ^ i;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);


                    //Find vehicles which no longer need to refuel.
                    //If a vehicles was scheduled to refuel but didn't make it before the base was attacked
                    //and was added to retreating vehicles during the attack it must be removed from
                    //refueling vehicles.
                    //Clear pending refuels if we are under attack.
                    if not under_attack then
                         begin
                              temp_list = [];
                              for i in ai_refuel_vehicles_list[base] diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) do
                                   if GetFuel(i) < 95 then
                                        temp_list = temp_list ^ i;
                              ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);
                         end
                    else
                         ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,[]);


                    //The following part of the code only has to consider these vehicles. Other vehicles are handled elsewhere.
                    vehicles_to_consider = ai_vehicles_defend[base] ^ ai_control_tower_vehicles[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base];

                    if under_attack and base <> 2 then  //Alliance have no war vehicles
                         begin
                              //Find the vehicles which need a driver and get them a driver (take the
                              //nearest available mechanic).
                              vehicles_list = ai_vehicles_defend[base] diff (ai_refuel_vehicles_list[base] ^ ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]);

                              temp_list = UnitFilter(vehicles_list,[[f_control,control_manual],[f_ok],[f_empty],[f_inarea,area]]);
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];

                              //Order the vehicles to attack an enemy unit near the base.
                              case base of
                                   1: temp_list = DangerousUnits(FilterAllUnits([[f_enemy,side],[f_inarea,ru_vehicle_defend_area]]));
                                   2: temp_list = [];
                                   3: temp_list = DangerousUnits(FilterAllUnits([[f_enemy,side],[f_inarea,ar_vehicle_defend_area]]));
                                   4: temp_list = DangerousUnits(FilterAllUnits([[f_enemy,side],[f_inarea,am_vehicle_defend_area]]));
                              end;

                              //temp_list = DangerousUnits(ListFilterNearArea( FilterAllUnits([f_enemy,side]),GetBaseArea(base)));

                              if temp_list > 0 then
                                   ComAgressiveMove(vehicles_list ^ ai_behemoths[base],GetX(temp_list[1]),GetY(temp_list[1]))
                              else
                                   begin
                                        temp_list = FilterAllUnits([[f_enemy,side],[f_inarea,area]]);

                                        if temp_list > 0 then
                                             begin
                                                  temp_list_2 = DangerousUnits(temp_list);

                                                  if temp_list_2 = 0 then
                                                       ComAttackUnit(vehicles_list,temp_list[1]);  //Destroy e.g. empty manual vehicles so they won't block.
                                             end;
                                   end;
                         end
                    else
                         begin
                              if IsOk(ai_depot[base]) then
                                   begin
                                        //If some vehicles need to refuel then make 'em refuel.
                                        temp_list = ai_refuel_vehicles_list[base];
                                        for i in vehicles_to_consider diff ai_refuel_vehicles_list[base] do
                                             if GetFuel(i) < 70 and GetEngine(i) = engine_combustion then
                                                  temp_list = temp_list ^ i;
                                        temp_list = temp_list diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]);
                                        ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);

                                        temp_list = UnitFilter(ai_refuel_vehicles_list[base],[[f_control,control_manual],[f_empty],[f_ok]]) diff ai_control_tower_vehicles[base];  //Remote mechanics are assigned to control tower vehicles
                                        temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                                        mechanics_list = temp_list[1];
                                        vehicles_drivers = temp_list[2];

                                        for i in ai_refuel_vehicles_list[base] do
                                             begin
                                                  if IsInArea(i,area) then
                                                       begin
                                                            ComMoveUnit(i,ai_depot[base]);
                                                            AddComRefuel(i,ai_depot[base]);
                                                       end
                                                  else
                                                       ComAgressiveMove(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                                             end;
                                   end;

                              //Move non-manual vehicles outside the base inside (not behemoths, though)
                              for i in UnitFilter(vehicles_to_consider,[f_not,[f_control,control_manual]]) diff (ai_refuel_vehicles_list[base] ^ ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) do
                                   if not IsInArea(i,area) then
                                        ComAgressiveMove(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]); 
                         end;


                    //Park vehicles.
                    free_parking_spots = [];  //Keeps track of the pullback hexes available
                    parked_vehicles = [];  //Keeps track of vehicles on pullback hexes

                    //Only these vehicles will need to be parked on a parking spot. Other vehicles either don't need to or are parking somewhere else.
                    vehicles_allowed_to_park = UnitFilter(vehicles_to_consider,[f_control,control_manual]);

                    //Non-manual vehicles pull back to the human pullback hex when retreating when under attack. The max distance they should have to the human pullback hex
                    //is determined by how many vehicles we have of that kind.
                    case (vehicles_to_consider diff vehicles_allowed_to_park)+0 of
                         0..1: human_pullback_hex_max_dist = 4;
                         2: human_pullback_hex_max_dist = 5;
                         3..4: human_pullback_hex_max_dist = 6;
                         else human_pullback_hex_max_dist = 7;
                    end;

                    for i in ai_vehicle_pullback_hexes[base] do
                         begin
                              temp_unit = HexInfo(i[1],i[2]);

                              if temp_unit in vehicles_allowed_to_park then
                                   begin
                                        parked_vehicles = parked_vehicles ^ temp_unit;
                                   end
                              else
                                   if temp_unit = 0 then
                                        free_parking_spots = Insert(free_parking_spots,1,i)
                                   else
                                        if temp_unit > 0 then
                                             if not ( GetType(temp_unit) = unit_building or ( GetType(temp_unit) = unit_vehicle and ( ( GetControl(temp_unit) = control_manual and IsDrivenBy(temp_unit) = 0 ) or ( GetControl(temp_unit) = control_remote and IsControledBy(temp_unit) = 0 ) ) ) ) then
                                                  free_parking_spots = Insert(free_parking_spots,1,i);
                         end;

                    //Find free parking spots for behemoths.
                    free_behemoth_parking_spots = [];
                    parked_behemoths = [];
                    for i in ai_behemoth_parking_hexes[base] do
                         begin
                              temp_unit = HexInfo(i[1],i[2]);
                              k = false;
                              if temp_unit > 0 then
                                   if GetType(temp_unit) = unit_vehicle and GetWeapon(temp_unit) = 59 then  //"59" identifiers behemoths
                                        k = true;

                              if temp_unit > 0 and k then
                                   begin
                                        parked_behemoths = parked_behemoths ^ temp_unit;
                                   end
                              else
                                   if temp_unit = 0 then
                                        free_behemoth_parking_spots = Insert(free_behemoth_parking_spots,1,i)
                                   else
                                        if temp_unit > 0 then
                                             if not ( GetType(temp_unit) = unit_building or ( GetType(temp_unit) = unit_vehicle and ( ( GetControl(temp_unit) = control_manual and IsDrivenBy(temp_unit) = 0 ) or ( GetControl(temp_unit) = control_remote and IsControledBy(temp_unit) = 0 ) ) ) ) then
                                                  free_behemoth_parking_spots = Insert(free_behemoth_parking_spots,1,i);
                         end;

                    //Since behemoths are always outside the base don't repair them at all. The player can use a hit-and-run tactic
                    //to slowly kill all mechanics.
                    if under_attack then
                         begin
                              vehicles_to_park = (ai_vehicles_being_repaired[base] union ai_retreating_vehicles_defend[base]) isect vehicles_allowed_to_park; //We take ai_vehicles_being_repaired[base] and ai_retreating_vehicles_defend[base] because these vehicles are not fighting or have other tasks.
                              vehicles_to_park = UnitFilter(vehicles_to_park diff parked_vehicles,[f_ok]);
                              vehicles_to_park = vehicles_to_park union UnitFilter(ai_control_tower_vehicles[base] diff (parked_vehicles ^ ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]),[f_ok]);

                              //Man retreating/(under repair) vehicles which are parked on a parking spot and ( are under attack
                              //or where mechanics are under attack nearby (i.e. the enemy is near) ).
                              //Else use your time on repairing the vehicles.
                              //UnitShoot resets after 10 seconds and detects all kinds of contact (direct hit, bombs, attack ground etc.).
                              temp_list = [];
                              temp_list_3 = (ai_vehicles_being_repaired[base] union ai_retreating_vehicles_defend[base]) isect parked_vehicles;
                              temp_list_3 = UnitFilter(temp_list_3,[f_ok]) diff ai_control_tower_vehicles[base];  //Remote mechanics are assigned to control tower vehicles
                              for i in temp_list_3 do
                                   if UnitShoot(i) > 0 then
                                        if GetSide(UnitShoot(i)) <> side then
                                             temp_list = temp_list ^ i;

                              for i in ai_mechanics_defend[base] do
                                   if UnitShoot(i) > 0 then
                                        if GetSide(UnitShoot(i)) <> side then
                                             temp_list = temp_list union UnitFilter(temp_list_3,[f_dist,i,5]);

                              for i in temp_list_3 diff temp_list do
                                   begin
                                        if not i in (ai_refuel_vehicles_list[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) then
                                             begin
                                                  k = IsDrivenBy(i);
                                                  if k > 0 then
                                                       ComExitVehicle(k);
                                             end;
                                   end;

                              temp_list = UnitFilter(temp_list ^ vehicles_to_park,[[f_control,control_manual],[f_empty]]) diff ai_control_tower_vehicles[base];  //Remote mechanics are assigned to control tower vehicles
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];
                         end
                    else
                         begin
                              vehicles_to_park = UnitFilter(vehicles_allowed_to_park diff (parked_vehicles ^ ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]),[f_ok]);

                              for i in parked_vehicles do
                                   begin
                                        if not i in (ai_refuel_vehicles_list[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) then
                                             begin
                                                  k = IsDrivenBy(i);
                                                  if k > 0 and not ( k in remote_mechanics and i in ai_control_tower_vehicles[base] ) then  //Remote mechanics are assigned to control tower vehicles
                                                       begin
                                                            ComExitVehicle(k);
                                                       end;
                                             end;
                                   end;

                              //Find drivers for the vehicles which aren't parked correctly
                              temp_list = UnitFilter(vehicles_to_park,[[f_control,control_manual],[f_empty]]) diff ai_control_tower_vehicles[base];  //Remote mechanics are assigned to control tower vehicles
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];
                         end;

                    //Command vehicles to park on the pullback hexes.
                    //If no pullback hexes are available then the vehicle won't park anywhere.
                    while vehicles_to_park > 0 do
                         begin
                              if free_parking_spots = 0 then
                                   break;

                              //Take the closest spot
                              temp_list = [];
                              for k in free_parking_spots do
                                   temp_list = temp_list ^ GetDistUnitXY(vehicles_to_park[1],k[1],k[2]);
                              temp_list = WorstFromListByList(free_parking_spots,temp_list);

                              ComMoveXY(vehicles_to_park[1],temp_list[1],temp_list[2]);
                              AddComHold(vehicles_to_park[1]);

                              free_parking_spots = free_parking_spots diff [temp_list];
                              vehicles_to_park = Delete(vehicles_to_park,1);
                         end;

                     //If we are not under attack then command behemoths to park nicely.
                     if not under_attack then
                          begin
                               for i in ai_behemoths[base] diff parked_behemoths do
                                    begin
                                         if free_behemoth_parking_spots > 0 then
                                              begin
                                                   //Take the closest spot
                                                   temp_list = [];
                                                   for k in free_behemoth_parking_spots do
                                                        temp_list = temp_list ^ GetDistUnitXY(i,k[1],k[2]);
                                                   temp_list = WorstFromListByList(free_behemoth_parking_spots,temp_list);

                                                   ComMoveXY(i,temp_list[1],temp_list[2]);
                                                   AddComHold(i);

                                                   free_behemoth_parking_spots = free_behemoth_parking_spots diff [temp_list];
                                              end
                                         else
                                              break;
                                    end;
                          end;

                    //When under attack, the retreating vehicles and vehicles being repaired, which are not allowed to park on the vehicle parking hexes,
                    //pull back to the human pullback hex instead.
                    if under_attack then
                         begin
                              for i in UnitFilter((ai_retreating_vehicles_defend[base] union ai_vehicles_being_repaired[base]) diff vehicles_allowed_to_park,[f_ok]) do
                                   begin
                                        if GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > human_pullback_hex_max_dist then
                                             ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                                   end;
                         end;


                    //Repair vehicles.
                    //All mechanics go for the same vehicle.
                    if under_attack then
                         begin
                              allowed_to_repair_vehicles = parked_vehicles ^ UnitFilter(vehicles_to_consider diff vehicles_allowed_to_park,[f_distxy,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2],human_pullback_hex_max_dist]);
                              allowed_to_repair_vehicles = allowed_to_repair_vehicles diff (ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]);  //Trying to repair a vehicle in one of these states could cause caos. Wait for it to finish.
                         end
                    else
                         begin
                              allowed_to_repair_vehicles = vehicles_to_consider diff (ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]);  //Trying to repair a vehicle in one of these states could cause caos. Wait for it to finish.
                              allowed_to_repair_vehicles = allowed_to_repair_vehicles ^ UnitFilter(ai_cargo_bay[base] diff 0,[f_inarea,area]);

                              //Don't go near burning vehicles too far away from the base - could be dangerous if the
                              //enemy has set up an ambush.
                              i = 1;
                              while i <= allowed_to_repair_vehicles do
                                   begin
                                        if not IsOk(allowed_to_repair_vehicles[i]) and GetDistUnitArea(allowed_to_repair_vehicles[i],area) > 7 then
                                             begin
                                                  allowed_to_repair_vehicles = Delete(allowed_to_repair_vehicles,i);
                                                  continue;
                                             end;

                                        i = i + 1;
                                   end;
                         end;

                    allowed_to_repair_vehicles = UnitFilter(allowed_to_repair_vehicles,[[f_not,[f_lives,1000]],[f_or,[f_not,[f_ok]],[f_inarea,area]]]);  //Only repair a vehicle outside the base area if it can't move inside. Else wait for it to move inside.

                    if ai_crane[base] > 0 then
                         begin
                              k = false;

                              if ai_crane_is_being_repaired[base] and ( GetDistUnitXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) <= 6 or ( IsInArea(ai_crane[base],area) and not under_attack ) ) then
                                   begin
                                        if GetLives(ai_crane[base]) < 1000 then
                                             allowed_to_repair_vehicles = ai_crane[base] ^ allowed_to_repair_vehicles;

                                        if ai_crane_driver[base] > 0 then
                                             begin
                                                  if GetLives(ai_crane_driver[base]) = 1000 then
                                                       begin
                                                            mechanics_list = mechanics_list ^ ai_crane_driver[base];  //Help repairing
                                                       end
                                                  else
                                                       begin
                                                            if GetDistUnitXY(ai_crane[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) <= 6 then
                                                                 begin
                                                                      if GetHumansOutOfUnits([ai_crane_driver[base]]) > 0 and not ai_crane_driver[base] in ai_heal_these_humans[base] then
                                                                           begin
                                                                                temp_list = ai_heal_these_humans[base] ^ ai_crane_driver[base];
                                                                                ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
                                                                           end;
                                                                 end
                                                            else
                                                                 k = true;
                                                       end;
                                             end;
                                   end
                              else
                                   k = true;

                              if k then
                                   begin
                                        if IsOk(ai_crane[base]) and ai_crane_driver[base] > 0 and not ai_crane_driver[base] in mechanics_list and not ai_crane_driver[base] in ai_heal_these_humans[base] then
                                             begin
                                                  if IsInUnit(ai_crane_driver[base]) <> ai_crane[base] then
                                                       if IsInUnit(ai_crane_driver[base]) > 0 then
                                                            case GetType(IsInUnit(ai_crane_driver[base])) of
                                                                 unit_building: ComExitBuilding(ai_crane_driver[base]);
                                                                 unit_vehicle: ComExitVehicle(ai_crane_driver[base]);
                                                            end
                                                       else
                                                            ComEnterUnit(ai_crane_driver[base],ai_crane[base]);
                                             end;
                                   end;
                         end;

                    if mechanics_list = 0 and remote_mechanics = 0 then
                         continue;

                    allowed_to_repair_vehicles = allowed_to_repair_vehicles diff ai_vehicles_being_repaired[base];
                    if allowed_to_repair_vehicles > 0 or ai_vehicles_being_repaired[base] > 0 then
                         begin
                              if remote_mechanics > 0 then
                                   begin
                                        if under_attack or UnitFilter(ai_vehicles_attack[base],[[f_control,control_remote],[f_ok]]) > 0 then
                                             begin
                                                  //Repair vehicles if all vehicles you control are burning or dead
                                                  for i in remote_driver_vehicles[base] do
                                                       if UnitFilter(i[2],[f_ok]) = 0 and i[1] in remote_mechanics then
                                                            begin
                                                                 mechanics_list = mechanics_list ^ i[1];
                                                                 remote_mechanics = remote_mechanics diff i[1];
                                                            end;
                                             end
                                        else
                                             begin
                                                  //All help repair vehicles if all vehicles are inside the base
                                                  //(to prevent a lot of destination unreachable messages from other vehicles
                                                  //all must be inside the base).
                                                  //Perhaps it's not so smart if we have a remotely controlled cargo bay but hopefully the
                                                  //repair won't take long now that everybody is helping.
                                                  //Remember some remote vehicles may not be controlled by anyone.
                                                  temp_unit = true;
                                                  for i in vehicles_to_consider do
                                                       if not IsInArea(i,area) then
                                                            begin
                                                                 temp_unit = false;
                                                                 break;
                                                            end;

                                                  if temp_unit then
                                                       begin
                                                            mechanics_list = mechanics_list ^ remote_mechanics;
                                                            remote_mechanics = [];
                                                       end;
                                             end;
                                   end;

                              if allowed_to_repair_vehicles > 0 then
                                   begin
                                        k = false;
                                        if ai_vehicles_being_repaired[base] = 0 then
                                             k = true
                                        else
                                             if IsOk(ai_vehicles_being_repaired[base][1]) then
                                                  begin
                                                       allowed_to_repair_vehicles = UnitFilter(allowed_to_repair_vehicles,[f_not,[f_ok]]);
                                                       k := allowed_to_repair_vehicles > 0;
                                                  end;

                                        if k then
                                             begin
                                                  temp_list = [];
                                                  for i in allowed_to_repair_vehicles do
                                                       temp_list = temp_list ^ GetLives(i);
                                                  temp_unit = WorstFromListByList(allowed_to_repair_vehicles,temp_list);

                                                  temp_list = temp_unit ^ ai_vehicles_being_repaired[base];
                                                  ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);

                                                  //temp_list = ai_retreating_vehicles_defend[base] diff temp_unit;
                                                  //ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);  -> The vehicle stays in "retreating" until the code managing retreating vehicles pulls it out of that state
                                             end;
                                   end;

                              ComRepairVehicle( GetHumansOutOfUnits(mechanics_list) , ai_vehicles_being_repaired[base][1]);
                         end
                    else
                         begin
                              //Rest mechanics stay inside the factory (if possible).
                              //Change class if necessary
                              DistributeHumansToBuildings(base,mechanics_list, UnitFilter(ai_facts[base] diff ai_sib_bomb_fact[base],[[f_ok],[f_not,[f_constructed]]]),
                                   class_mechanic,6,true,false);
                         end;


                    //Connect remote driver and vehicles
                    if remote_driver_vehicles[base] > 0 then
                         begin
                              if not IsOk(ai_control_tower[base]) and UnitFilter(ai_control_tower_vehicles[base],[f_ok]) = 0 then
                                   begin
                                        //Just go to factory
                                        DistributeHumansToBuildings(base,remote_mechanics, UnitFilter(ai_facts[base] diff ai_sib_bomb_fact[base],[[f_ok],[f_not,[f_constructed]]]),
                                             class_mechanic,6,true,false);
                                   end
                              else
                                   begin
                                        temp_list_3 = [[],0];  //[The control tower vehicles mecs have been sent to, Number of mecs sent to control tower]
                                        temp_list_2 = [];  //Remote mechanics who should just go to the factory
                                        already_inside_mecs = [];  //Remote mechanics already inside a control tower or control tower vehicle.

                                        for i in remote_driver_vehicles[base] do
                                             begin
                                                  if GetClass(i[1]) <> class_mechanic then
                                                       continue;

                                                  k = IsInUnit(i[1]);

                                                  if k > 0 and ( k in ai_control_tower_vehicles[base] or k = ai_control_tower[base] ) then
                                                       begin
                                                            already_inside_mecs = already_inside_mecs ^ i[1];

                                                            if k in ai_control_tower_vehicles[base] then
                                                                 begin
                                                                      temp_list = temp_list_3[1] ^ k;
                                                                      temp_list_3 = Replace(temp_list_3,1,temp_list);
                                                                 end
                                                            else
                                                                 temp_list_3 = Replace(temp_list_3,2,temp_list_3[2]+1);
                                                       end;
                                             end;

                                        for i in remote_driver_vehicles[base] do
                                             begin
                                                  if not i[1] in remote_mechanics then
                                                       continue;

                                                  //Class must be mechanic
                                                  if GetClass(i[1]) <> class_mechanic then
                                                       begin
                                                            temp_unit = 0;
                                                            for k in ai_facts[base] do
                                                                 if IsOk(k) and UnitsInside(k) < 6 then
                                                                      begin
                                                                           temp_unit = k;
                                                                           break;
                                                                      end;

                                                            if temp_unit > 0 then
                                                                 begin
                                                                      if IsInUnit(i[1]) = temp_unit then
                                                                           ComChangeProfession(i[1],class_mechanic)
                                                                      else
                                                                           begin
                                                                                if IsInUnit(i[1]) > 0 then
                                                                                     case GetType(IsInUnit(i[1])) of
                                                                                          unit_building: ComExitBuilding(i[1]);
                                                                                          unit_vehicle: ComExitVehicle(i[1]);
                                                                                     end
                                                                                else
                                                                                     ComEnterUnit(i[1],temp_unit);
                                                                           end;
                                                                 end;
                                                       end
                                                  else
                                                       begin
                                                            //Send to control tower vehicles as first priority (so empty manual vehicles won't block). Then control tower.
                                                            temp_unit = 0;

                                                            if i[1] in already_inside_mecs then
                                                                 begin
                                                                      temp_unit = IsInUnit(i[1]);  //just stay where you are pall
                                                                 end
                                                            else
                                                                 begin
                                                                      if (ai_control_tower_vehicles[base] diff temp_list_3[1]) > 0 then
                                                                           begin
                                                                                //temp_unit = AllNearestUnitToUnit(ai_control_tower_vehicles[base] diff temp_list_3[1],i[1]);  -> doesn't work if the mechanic is inside another unit
                                                                                temp_list = [GetX(i[1]),GetY(i[1])];
                                                                                temp_list_4 = [];
                                                                                temp_list_5 = ai_control_tower_vehicles[base] diff temp_list_3[1];
                                                                                for k in temp_list_5 do
                                                                                     temp_list_4 = temp_list_4 ^ GetDistUnitXY(k,temp_list[1],temp_list[2]);

                                                                                temp_unit = WorstFromListByList(temp_list_5,temp_list_4);

                                                                                temp_list = temp_list_3[1] ^ temp_unit;
                                                                                temp_list_3 = Replace(temp_list_3,1,temp_list);
                                                                           end
                                                                      else
                                                                           if IsOk(ai_control_tower[base]) and temp_list_3[2] < 3 then
                                                                                begin
                                                                                     temp_unit = ai_control_tower[base];
                                                                                     temp_list_3 = Replace(temp_list_3,2,temp_list_3[2]+1);
                                                                                end
                                                                           else
                                                                                temp_list_2 = temp_list_2 ^ i;
                                                                 end;

                                                            if temp_unit > 0 then
                                                                 begin
                                                                      k = IsInUnit(i[1]);
                                                                      if k <> temp_unit then
                                                                           begin
                                                                                if k > 0 then
                                                                                     case GetType(k) of
                                                                                          unit_building: ComExitBuilding(i[1]);
                                                                                          unit_vehicle: ComExitVehicle(i[1]);
                                                                                     end
                                                                                else
                                                                                     ComEnterUnit(i[1],temp_unit);
                                                                           end
                                                                      else
                                                                           for k in i[2] do
                                                                                if IsOk(k) and IsControledBy(k) <> i[1] then
                                                                                     ComLinkTo(k,i[1])
                                                                                else
                                                                                     if not IsOk(k) and IsControledBy(k) > 0 then  //Unlink to improve performance of other vehicles controlled by the mechanic
                                                                                          ComUnlink(k);
                                                                 end;
                                                       end;
                                             end;

                                        DistributeHumansToBuildings(base,temp_list_2, UnitFilter(ai_facts[base] diff ai_sib_bomb_fact[base],[[f_ok],[f_not,[f_constructed]]]),
                                             class_mechanic,6,true,false);
                                   end;
                         end;
               end;

          until false;
     end;
Function FindDriverHelper(vehicles_list,mechanics_list,vehicles_drivers);
     var i, k, temp_unit;
     begin
          for i in vehicles_list do
               begin
                    if mechanics_list = 0 then
                         break;

                    k = false;
                    if vehicles_drivers < i then
                         k = true
                    else
                         if not vehicles_drivers[i] in mechanics_list then
                              k = true;

                    if k then
                         vehicles_drivers = Replace(vehicles_drivers,i,AllNearestUnitToUnit(mechanics_list,i));

                    if vehicles_drivers[i] > 0 then
                        begin
                             temp_unit = IsInUnit(vehicles_drivers[i]);

                             if temp_unit <> i then
                                  if temp_unit > 0 then
                                       case GetType(temp_unit) of
                                            unit_vehicle: ComExitVehicle(vehicles_drivers[i]);  //could sit in a vehicle which is now parked correctly
                                            unit_building: ComExitBuilding(vehicles_drivers[i]);
                                       end
                                  else ComEnterUnit(vehicles_drivers[i],i);

                             mechanics_list = mechanics_list diff vehicles_drivers[i];
                        end;
               end;

          result = [mechanics_list,vehicles_drivers];
     end;
//The funny thing about a crane is that it repairs buildings faster the higher mechanic skill the driver has,
//but when constructing buildings the building's level will correspond to the driver's engineering skill.
//Therefore the crane driver should be the mechanic with the highest engineering and mechanical skill combined.
Function FindBestCraneDriver(base);
     var i, temp_list;
     begin
          if ai_mechanics_defend[base] = 0 then
               begin
                    result = 0;
                    exit;
               end;

          temp_list = [];
          for i in ai_mechanics_defend[base] do
               temp_list = temp_list ^ (GetSkill(i,skill_engineering)+GetSkill(i,skill_mechanical));

          result = BestFromListByList(ai_mechanics_defend[base],temp_list);
     end;

//Make special mechanics go to the factory producing the siberite bomb.
//Fire the siberite bomb if we have one. Recycle afterwards.
//If there are less mechanics than we started with and the base hasn't been under attack
//for a while then spawn some new mecs.
Every 0$1.1 do
     var i, base, temp_list, veh, mechanics_list, un, bomb_sent;
     var orig_mec_num, last_attack_time_tick, going_to_be_recycled_bomb, bomb_talk_map;
     begin
          orig_mec_num = [];
          for base in ai_bases do
               orig_mec_num = Replace(orig_mec_num,base,ai_sib_bomb_mechanics[base]+0);

          last_attack_time_tick = [0,0,0,0];  //The tick when the base was last attacked
          going_to_be_recycled_bomb = [0,0,0,0];  //Identifier of the siberite bomb remainder we are going to recycle
          bomb_talk_map = [];  //index is siberite rocket id, value is boolean (false if leader hasn't spoken, true if has).

          repeat
          wait(0$1);

          if not 1 in ai_bases and not 4 in ai_bases then
               exit;

          for base in [1,4] do
               begin
                    if not base in ai_bases then
                         continue;

                    //Update variables if a bomb has been recycled.
                    if going_to_be_recycled_bomb[base] > 0 then
                         if IsDead(going_to_be_recycled_bomb[base]) then
                              begin
                                   temp_list = ai_sib_bomb_vehicles[base] diff going_to_be_recycled_bomb[base];
                                   ai_sib_bomb_vehicles = Replace(ai_sib_bomb_vehicles,base,temp_list);

                                   going_to_be_recycled_bomb = Replace(going_to_be_recycled_bomb,base,0);
                              end;

                    //Respawn
                    if ai_sib_bomb_mechanics[base] < orig_mec_num[base] and difficulty = 3 and ( ( base = 1 and IsLive(Platonov) ) or ( base = 4 and IsLive(Powell) ) ) then
                         begin
                              if BaseUnderAttack(base,-1) then
                                   last_attack_time_tick = Replace(last_attack_time_tick,base,tick)
                              else
                                   if last_attack_time_tick[base] + 3$0 <= tick then
                                        begin
                                             temp_list = CreateUnitsWithClass(orig_mec_num[base] - ai_sib_bomb_mechanics[base], class_mechanic, base);
                                             for i in temp_list do
                                                  SetSkill(i,skill_mechanical,10);

                                             for i in temp_list do
                                                  if not PlaceUnitXYR(i,108,196,2,false) then
                                                       begin
                                                            DestroyUnit(i);
                                                            temp_list = temp_list diff i;
                                                       end;

                                             temp_list = ai_sib_bomb_mechanics[base] ^ temp_list;
                                             ai_sib_bomb_mechanics = Replace(ai_sib_bomb_mechanics,base,temp_list);
                                        end;
                         end;

                    mechanics_list = ai_sib_bomb_mechanics[base] diff ai_heal_these_humans[base];

                    //Control siberite bomb
                    for i in mechanics_list do
                         begin
                              veh = IsInUnit(i);

                              if veh > 0 then
                              if GetType(veh) = unit_vehicle then
                                   begin
                                        mechanics_list = mechanics_list diff i;

                                        case GetWeapon(veh) of
                                             us_siberium_rocket,ru_siberium_rocket: begin
                                                  //Both Russians and Americans can hit pretty much everything on the map from their bases.
                                                  bomb_sent = true;

                                                  case base of
                                                       1: begin
                                                            if IsLive(Powell) then  //probably not since Am develops the bomb earlier than Ru
                                                                 ComAttackPlace(veh,ai_human_pullback_hex[4][1],ai_human_pullback_hex[4][2])
                                                            else
                                                                 begin
                                                                      //Send the bomb to the player's main base.
                                                                      un = FindPlayerMainBase;

                                                                      if un > 0 then
                                                                           ComAttackPlace(veh,GetX(un),GetY(un))
                                                                      else
                                                                           bomb_sent = false;
                                                                 end;
                                                       end;
                                                       4: begin
                                                            if 2 in ai_bases and alliance_deal_status = 2 then
                                                                 ComAttackPlace(veh,ai_human_pullback_hex[2][1],ai_human_pullback_hex[2][2])
                                                            else
                                                                 if IsLive(Platonov) then  //the player is gonna lose - bomb starts chain reaction
                                                                      ComAttackPlace(veh,ai_human_pullback_hex[1][1],ai_human_pullback_hex[1][2])
                                                                 else
                                                                      begin
                                                                           //Send the bomb to the player's main base.
                                                                           un = FindPlayerMainBase;

                                                                           if un > 0 then
                                                                                ComAttackPlace(veh,GetX(un),GetY(un))
                                                                           else
                                                                                bomb_sent = false;
                                                                      end;
                                                       end;
                                                  end;

                                                  if bomb_sent then
                                                       begin
                                                            if bomb_talk_map < veh then
                                                                 bomb_talk_map = Replace(bomb_talk_map,veh,false);

                                                            if not bomb_talk_map[veh] then  //also true if bomb_talk_map[veh] is empty
                                                                 begin
                                                                      bomb_talk_map = Replace(bomb_talk_map,veh,true);

                                                                      case base of
                                                                           1: un = Platonov;
                                                                           4: un = Powell;
                                                                      end;

                                                                      if IsLive(un) then
                                                                           begin
                                                                                DialogueOn;

                                                                                case un of
                                                                                     Platonov: ForceSay(un,'D25-Pla-1');
                                                                                     Powell: ForceSay(un,'D25-Po-1');
                                                                                end;

                                                                                DialogueOff;
                                                                           end;
                                                                 end;
                                                       end;
                                             end;
                                             us_siberium_rocket_remainder, ru_siberium_rocket_remainder: begin
                                                  if IsOk(ai_sib_bomb_fact[base]) and IsIdle(ai_sib_bomb_fact[base]) then
                                                       begin
                                                            ComRecycle(veh,ai_sib_bomb_fact[base]);
                                                            going_to_be_recycled_bomb = Replace(going_to_be_recycled_bomb,base,veh);
                                                       end;
                                             end;
                                             else begin
                                                  ComExitVehicle(i);
                                             end;
                                        end;
                                   end;
                         end;

                    //Identify mechanics who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= mechanics_list do
                         begin
                              if GetLives(mechanics_list[i]) <= 900 then
                                   begin
                                        temp_list = temp_list ^ mechanics_list[i];
                                        mechanics_list = Delete(mechanics_list,i);
                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);

                    DistributeHumansToBuildings(base,mechanics_list, UnitFilter(ai_sib_bomb_fact[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_mechanic,6,true,false);
               end;

          until false;
     end;
Function FindPlayerMainBase;
     var dep_list, map_num, map_base, i, b, temp_list;
     begin
          //The player's main base is the base with the most buildings connected to it.
          dep_list = FilterAllUnits([[f_side,you],[f_or,[f_btype,b_depot],[f_btype,b_warehouse]]]);

          if dep_list = 0 then
               result = 0
          else
               if dep_list = 1 then
                    result = dep_list[1]
               else
                    begin
                         map_num = [];
                         map_base = [];

                         for i in dep_list do
                              begin
                                   map_num = Replace(map_num,i,0);
                                   map_base = Replace(map_base,GetBase(i),i);
                              end;

                         for i in FilterAllUnits([[f_side,you],[f_type,unit_building]]) diff dep_list do
                              begin
                                   b = GetBase(i);
                                   if map_base >= b then
                                        if map_base[b] > 0 then
                                             begin
                                                  map_num = Replace(map_num,map_base[b], map_num[map_base[b]] + 1 );
                                             end;
                              end;

                         temp_list = [];
                         for i in dep_list do
                              temp_list = temp_list ^ map_num[i];

                         result = BestFromListByList(dep_list,temp_list);
                    end;
     end;

Function MaxNumWarVehiclesDefend(base);
     var time;
     begin
          case base of
               1: result = [3,4,5][difficulty];
               2: result = 0;
               3: result = [2,3,4][difficulty];
               4: result = [1,2,3][difficulty];
          end;

          //If we are soon going to attack then create enough vehicle for the attack.
          //Worst case time for building a vehicle is about 45 seconds (usually).
          if base = 3 and american_arabian_alliance then
               time = ai_vehicle_attack_delay[4]  //Arabians attack with Americans
          else
               time = ai_vehicle_attack_delay[base];

          if (MaxNumWarVehiclesAttack(base) - result) * 0$45 >= time then
               result = MaxNumWarVehiclesAttack(base);
     end;
Function MaxNumWarVehiclesAttack(base);
     begin
          case base of
               1: begin
                    result = [2,3,4][difficulty];

                    if attacked_times[base]+0 >= 2 then
                         result = result + 1;

                    if attacked_times[base]+0 >= 5 then
                         result = result + 1;
               end;
               2: result = 0;
               3: begin
                    if american_arabian_alliance and am_ar_attack_alli_together then
                         begin
                              result = [1,2,4][difficulty];
                              if num_attacks_ar_on_alli > 0 then
                                   begin
                                        result = result + num_attacks_ar_on_alli;
                                        if result > [2,4,6][difficulty] then
                                             result = [2,4,6][difficulty];
                                   end;
                         end
                    else
                         begin
                              if attacked_times[base]+0 = 0 then
                                   result = 0  //Always only scientists the first time
                              else
                                   begin
                                        result = [1,2,3][difficulty];

                                        if attacked_times[base]+0 >= 2 then
                                             result = result + 1;

                                        if attacked_times[base]+0 >= 5 then
                                             result = result + 1;

                                        if attacked_times[base]+0 >= 6 then
                                             result = result + 1;
                                   end;
                         end;
               end;
               4: result = 6;
          end;
     end;
Function MaxNumTaufieldVehicles(base);
     var t;
     begin
          case base of
               1: begin
                    t = AdjustTimeToDifficulty(35$0);
                    
                    if tick < t then
                         result = 0
                    else
                         begin
                              if attacked_times[base][attacked_times[base]+0] >= t then
                                   result = [1,2,3][difficulty]
                              else
                                   result = 1; //Only 1 the first time
                         end;
               end;
               2: result = 0;
               3: result = 0;
               4: result = 0;
          end;
     end;
Function MaxNumImplosionVehicles(base);
     begin
          case base of
               1: result = 0;
               2: result = 0;
               3: result = 0;
               4: result = 0;
          end;
     end;
Function MaxNumBehemoths(base);
     var t;
     begin
          case base of
               1: begin
                    //It takes about 1 min to build a behemoth with 3 lvl 10 mechanics.
                    //MAX 3 BEHEMOTHS
                    if StratGroupAUsed then
                         t = 60$0
                    else if StratGroupBUsed then
                         t = 65$0
                    else //if StratGroupCUsed then
                         t = 50$0;

                    t = AdjustTimeToDifficulty(t);

                    if tick < t then
                         result = 0
                    else
                         begin
                              //if attacked_times[base][attacked_times[base]+0] >= t then
                                   result = [1,2,3][difficulty];
                              //else
                              //     result = 1; //Only 1 the first time
                         end;
               end;
               2: result = 0;
               3: result = 0;
               4: result = 0;
          end;
     end;
//Construct combat vehicles and weapons for bunkers. Weapons for bunkers have highest priority.
//Construct a crane if we don't have one.
//Construct a cargo bay if we don't have one (but not if we are under attack).
//Since we do not build new buildings while under attack, don't try to build weapons that requires other factory
//extensions than the ones we have while under attack.
Every 0$1+0$0.6 do
     var i, temp_value, temp_unit, temp_list, base, idle_factories, fact, b, construct_list;
     var vehicle_prod_delay, saved_construct_list, under_attack;
     begin
          vehicle_prod_delay = [0$0,0$0,0$0,0$0];
          saved_construct_list = [[],[],[],[]];


          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));
          
          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    under_attack = BaseUnderAttack(base,-1);

                    if under_attack and ai_vehicles_defend[base] >= [0,1,2][difficulty] and not ( base = 1 and rus_enforce_vehicle_prod ) then
                         begin
                              vehicle_prod_delay = Replace(vehicle_prod_delay,base,[1$15,0$45,0$30][difficulty]);
                         end;

                    idle_factories = [];
                    for i in ai_facts[base] diff ai_sib_bomb_fact[base] do
                         if BuildingStatus(i) = bs_idle and IsOk(i) and GetBType(i) = b_factory then
                              begin
                                   b = true;
                                   if ai_facts_with_ext_rebuild_map >= i then
                                        if ai_facts_with_ext_rebuild_map[i] > 0 then
                                             b = false; 

                                   if b then
                                        idle_factories = idle_factories ^ i;
                              end;

                    if idle_factories = 0 then
                         continue;
                    

                    //Check if any bunker needs a weapon
                    temp_value = false;
                    for i in ai_buildings_locations[base] do
                         if i[4] in [b_bunker,b_turret] then
                              begin
                                   temp_unit = HexInfo(i[1],i[2]);

                                   if temp_unit > 0 then
                                   if GetType(temp_unit) = unit_building then
                                   if GetBType(temp_unit) in [b_bunker,b_turret] and not IsConstructed(temp_unit) and GetBWeapon(temp_unit) = 0 {<> i[7]} then  //Alliance rebuilds Russian bunkers/turrets as American
                                        //If there are multiple weapon factories and more than one or another factory than
                                        //the factory getting the job invokes this part of the function the bunker/turret may
                                        //get the weapon placed several times, but since factories don't have a task list
                                        //there is no simple way to stop this. Better several times than never.
                                        begin
                                             b = false;
                                             if not under_attack then
                                                  b = true
                                             else
                                                  begin
                                                       if CanFactConstructThis(idle_factories[1],i[7],false) = 1 then  //Only build it if we can build it right now
                                                            b = true;
                                                  end;
                                             
                                             if b then
                                                  begin
                                                       if FactConstruct(base,[idle_factories[1]],[temp_unit,-1,-1,i[7]],false) in [0,1] then
                                                            begin
                                                                 temp_value = true;
                                                                 break;
                                                            end;
                                                  end;
                                        end;
                              end;

                    if temp_value then
                         continue;

                   
                    //Construct additional control towers (Arabians) if needed.
                    if base = 3 then
                         begin
                              b = CheckAndFixArControlTowerAmount(base,idle_factories,false);

                              if b <> -1 then
                                   begin
                                        if b in [0,1] then
                                             continue;
                                   end;
                         end;


                    //Construct cargo bay if we have none.
                    if not under_attack then
                         begin
                              if ai_cargo_bay[base] = 0 and not ai_cargo_bay_under_construction[base] and tick - ai_cargo_bay_destroy_tick[base] >= [6$0,4$30,3$0][difficulty] then
                                   begin
                                        case GetBaseNation(base) of
                                             nation_american: begin
                                                  b = false;
                                                  temp_list = [us_medium_tracked,engine_siberite,control_computer,us_cargo_bay];

                                                  if base = 2 then
                                                       temp_list = Replace(temp_list,1,us_medium_wheeled);  //Haven't got track extension
                                             end;
                                             nation_arabian: begin
                                                  b = true;
                                                  temp_list = [ar_half_tracked,engine_siberite,control_remote,ar_cargo_bay];
                                             end;
                                             nation_russian: begin
                                                  b = false;
                                                  temp_list = [ru_medium_tracked,engine_siberite,control_computer,ru_cargo_bay];
                                             end;
                                        end;

                                        b = FactConstruct(base,idle_factories,temp_list,b);
                                        if b in [0,1] then
                                             begin
                                                  if b = 1 then
                                                       ai_cargo_bay_under_construction = Replace(ai_cargo_bay_under_construction,base,true);

                                                  continue;
                                             end;
                                   end;
                         end;  

                     
                    //Construct a crane if we have none.
                    if base in [1,2,4] and difficulty > 1 then
                         begin                                                                                                                 
                              if ai_crane[base] = 0 and not ai_crane_under_construction[base] and tick - ai_crane_destroy_tick[base] >= [8$0,6$0,4$0][difficulty] then
                                   begin
                                        temp_list = [];

                                        case GetBaseNation(base) of
                                             nation_american: begin
                                                  temp_list = [us_medium_tracked,engine_siberite,control_manual,us_crane];

                                                  if ai_mechanics_defend[base] + ai_mechanics_attack[base] = 1 then  //We need someone to work in the factory
                                                       temp_list = Replace(temp_list,3,control_computer);

                                                  if base = 2 then
                                                       begin
                                                            temp_list = Replace(temp_list,1,us_medium_wheeled);  //Haven't got track extension
                                                            temp_list = Replace(temp_list,3,control_computer);  //Else repair is too strong - makes American attacks look futile
                                                       end;
                                             end;
                                             nation_russian: begin
                                                  temp_list = [ru_medium_tracked,engine_siberite,control_manual,ru_crane];

                                                  if ai_mechanics_defend[base] + ai_mechanics_attack[base] = 1 then  //We need someone to work in the factory
                                                       temp_list = Replace(temp_list,3,control_computer);
                                             end;
                                        end;

                                        if temp_list > 0 then
                                             begin
                                                  b = false;
                                                  if not under_attack then
                                                       b = true
                                                  else
                                                       begin
                                                            if CanFactConstructThis(idle_factories[1],temp_list[4],false) = 1 then  //Only build it if we can build it right now
                                                                 b = true;
                                                       end;

                                                  if b then
                                                       begin
                                                            b = FactConstruct(base,[idle_factories[1]],temp_list,false);
                                                            if b in [0,1] then
                                                                 begin
                                                                      if b = 1 then
                                                                           ai_crane_under_construction = Replace(ai_crane_under_construction,base,true);

                                                                      continue;
                                                                 end;
                                                       end;
                                             end;
                                   end;
                         end;  

                     
                    //Construct war vehicles.
                    //If we are under attack then make sure we produce something we can construct without replacing
                    //factory extensions.
                    if vehicle_prod_delay[base] > 0$0 and not ( base = 1 and rus_enforce_vehicle_prod ) then
                         begin
                              vehicle_prod_delay = Replace(vehicle_prod_delay,base, vehicle_prod_delay[base] - 0$1 );
                              continue;
                         end;

                    if ai_vehicles_defend[base] + UnitFilter(ai_vehicles_attack[base],[[f_ok],[f_not,[f_weapon,59]],[f_not,[f_weapon,ar_selfpropelled_bomb]],[f_not,[f_weapon,ru_time_lapser]]]) < MaxNumWarVehiclesDefend(base) then  //"59" identifies behemoths
                         begin
                              if saved_construct_list[base] > 0 and not under_attack then
                                   begin
                                        construct_list = saved_construct_list[base];
                                   end
                              else begin
                              construct_list = [];

                              case base of
                                   1: begin
                                        //It's rather annoying that AvailableEngineList (and the other related functions) only work correctly if the required technology is also invented.

                                        temp_list = [ru_gun,ru_heavy_gun,ru_rocket_launcher,ru_rocket,ru_gatling_gun];

                                        if difficulty = 2 then
                                             temp_list = temp_list ^ ru_heavy_gun;  //Greater chance

                                        if difficulty = 3 then
                                             begin
                                                  temp_list = Replace(temp_list,1,ru_heavy_gun);
                                                  temp_list = Delete(temp_list,3);
                                             end;
                                        {if under_attack then
                                             temp_list = temp_list isect AvailableWeaponList(idle_factories[1]);

                                        if temp_list > 0 then
                                             temp_value = temp_list[Rand(1,temp_list+0)]
                                        else
                                             temp_value = ru_heavy_machine_gun;}  //You can always at least make ru_heavy_machine_gun
                                        temp_value = temp_list[Rand(1,temp_list+0)];
                                        
                                        {if difficulty = 1 and temp_value = ru_heavy_gun and Rand(1,2) = 1 then
                                             temp_value = ru_gun;}

                                        if under_attack then
                                             if CanFactConstructThis(idle_factories[1],temp_value,false) <> 1 then
                                                  temp_value = ru_heavy_machine_gun;  //You can always at least make ru_heavy_machine_gun

                                        if Rand(1,[2,3,4][difficulty]) = 1 and not temp_value in [ru_heavy_gun,ru_rocket] then
                                             i = ru_medium_tracked
                                        else
                                             i = ru_heavy_tracked;
                                        
                                        {if under_attack and ( not i in AvailableChassisList(idle_factories[1]) or not engine_siberite in AvailableEngineList(idle_factories[1]) or not control_computer in AvailableControlList(idle_factories[1]) ) then
                                             construct_list = []
                                        else}
                                             construct_list = [i,engine_siberite,control_computer,temp_value];
                                   end;
                                   2: begin
                                   end;
                                   3: begin
                                        temp_list = [ar_gun,ar_rocket_launcher,ar_gatling_gun];
                                        temp_value = temp_list[Rand(1,temp_list+0)];

                                        if temp_value = ar_gatling_gun and Rand(1,2) = 1 then
                                             temp_value = ar_flame_thrower;

                                        if under_attack then
                                             if CanFactConstructThis(idle_factories[1],temp_value,false) <> 1 then
                                                  temp_value = ar_double_machine_gun;  //You can always at least make ar_double_machine_gun

                                        construct_list = [ar_half_tracked,engine_siberite,control_remote,temp_value];
                                   end;
                                   4: begin
                                        temp_list = [us_double_gun,us_heavy_gun,us_rocket_launcher,us_gatling_gun];  //No laser. Causes too many rebuilds of factory extensions + isn't very effective against anything but vehicles and Americans mostly assault bases

                                        if difficulty = 2 then
                                             temp_list = temp_list ^ us_heavy_gun;  //Greater chance

                                        if difficulty = 3 then
                                             temp_list = Replace(temp_list,1,us_heavy_gun);

                                        temp_value = temp_list[Rand(1,temp_list+0)];

                                        {if difficulty = 1 and temp_value = us_heavy_gun and Rand(1,2) = 1 then
                                             temp_value = us_double_gun;}

                                        if under_attack then
                                             if CanFactConstructThis(idle_factories[1],temp_value,false) <> 1 then
                                                  temp_value = us_machine_gun;  //You can always at least make us_machine_gun

                                        if Rand(1,[2,3,4][difficulty]) = 1 and not temp_value = us_heavy_gun then
                                             i = us_medium_tracked
                                        else
                                             if Rand(1,3) = 1 and difficulty < 3 then
                                                  i = us_heavy_tracked
                                             else
                                                  i = us_morphling;

                                        if alli_destroy_am_objective_status >= 2 then //Alliance destroys siberite engines and siberite power plants - go combustion!
                                             construct_list = [i,engine_combustion,control_remote,temp_value]
                                        else
                                             construct_list = [i,engine_siberite,control_remote,temp_value];
                                   end;
                              end;
                              end;

                              if construct_list > 0 then
                                   begin
                                        b = FactConstruct(base,[idle_factories[1]],construct_list,base = 3);
                                       
                                        case b of
                                             0: saved_construct_list = Replace(saved_construct_list,base,construct_list);
                                             1,2: saved_construct_list = Replace(saved_construct_list,base,[]);
                                        end; 
                                   end;

                              //vehicle_prod_delay = Replace(vehicle_prod_delay,base,[1$0,0$30,0$15][difficulty]);  -> Disrupts the planned attack time
                              continue;
                         end;  

                    
                    //Taufield vehicles
                    if base = 1 and ai_taufield_vehicles[base] + UnitFilter(ai_vehicles_attack[base],[[f_ok],[f_weapon,ru_time_lapser]]) < MaxNumTaufieldVehicles(base) then
                         begin
                              b = FactConstruct(base,idle_factories,[ru_medium_tracked,engine_siberite,control_computer,ru_time_lapser],false);
                              if b in [0,1] then
                                   continue;
                         end;

                    
                    //Siberite implosion vehicles
                    if base = 3 and ai_implosion_vehicles[base] + UnitFilter(ai_vehicles_attack[base],[[f_ok],[f_weapon,ar_selfpropelled_bomb]]) < MaxNumImplosionVehicles(base) then
                         begin
                              FactConstruct(base,idle_factories,[ar_half_tracked,engine_siberite,control_remote,ar_selfpropelled_bomb],true);
                         end;
               end;

          until false;
     end;
Function FactConstruct(base,fact_list,construct_list,check_ar_control_tower_amount);
     var i, temp_list, map_list, val;
     begin 
          if fact_list = 0 then
               begin
                    result = 2;
                    exit;
               end;

          if check_ar_control_tower_amount then
               begin
                    {if UnitFilter(ai_vehicles_defend[base] ^ ai_vehicles_attack[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_cargo_bay[base] ^ ai_crane[base],[f_control,control_remote]) >= ai_control_tower_vehicles[base] * 2  //2 vehicles per control tower if possible
                      and ai_control_tower_vehicles[base] < ai_vehicle_pullback_hexes[base]  //We have to be able to park them
                      and ai_control_tower_vehicles[base] < ((ai_mechanics_defend[base] ^ ai_mechanics_attack[base]) diff ai_crane_driver[base]) - 1 then  //There must be a mechanic available. At least one in factory to produce
                         begin
                              result = FactConstruct(base,fact_list,[ar_half_tracked,engine_siberite,control_manual,ar_control_tower],false);

                              if result = 1 then
                                   result = 0;  //We didn't deliver what was expected. We made a control tower instead so the original "order" is still on hold.

                              exit;
                         end;}

                    result = CheckAndFixArControlTowerAmount(base,fact_list,true);

                    if result <> -1 then
                         begin
                              if result = 1 then
                                   result = 0;  //We didn't deliver what was expected. We made a control tower instead so the original "order" is still on hold.

                              exit;
                         end;
               end;

          result = CanFactConstructThis(fact_list[1],construct_list[4],true);
          if result = 1 then
               begin
                    if construct_list[2] = -1 then
                         ComPlaceWeapon(construct_list[1],construct_list[4])
                    else
                         ComConstruct(fact_list[1],construct_list[1],construct_list[2],construct_list[3],construct_list[4]);
               end;
         
          {
          This is generic code for handling if there actually are more factories to choose among
          but CanFactConstructThis is a tough function and causes laggs so we won't call it more
          than strictly necessary.

          temp_list = [];
          map_list = [];
          for i in fact_list do
               begin
                    case CanFactConstructThis(i,construct_list[4],false) of
                         0: val = 2;
                         1: val = 1;
                         2: val = 3;
                    end;

                    temp_list = temp_list ^ val;
                    map_list = Replace(map_list,i,val);
               end;

          fact_list = SortListByListAsc(fact_list,temp_list);

          case map_list[fact_list[1]] of
               1: begin
                    if construct_list[2] = -1 then
                         ComPlaceWeapon(construct_list[1],construct_list[4])
                    else
                         ComConstruct(fact_list[1],construct_list[1],construct_list[2],construct_list[3],construct_list[4]);
               end;
               2: begin
                    CanFactConstructThis(fact_list[1],construct_list[4],true);
               end;
               3: begin
                    result = 2;
               end;
          end;}
     end;
Function CheckAndFixArControlTowerAmount(base,fact_list,going_to_build_a_vehicle_after_this_check);
     var temp_list;
     begin
          temp_list = UnitFilter(ai_vehicles_defend[base] ^ ai_vehicles_attack[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_cargo_bay[base] ^ ai_crane[base],[f_control,control_remote]);

          if ( temp_list+0 > ai_control_tower_vehicles[base] * 2 or ( temp_list+0 >= ai_control_tower_vehicles[base] * 2 and going_to_build_a_vehicle_after_this_check ) ) //2 vehicles per control tower if possible
            and ai_control_tower_vehicles[base] < ai_vehicle_pullback_hexes[base]  //We have to be able to park them
            and ai_control_tower_vehicles[base] < ((ai_mechanics_defend[base] ^ ai_mechanics_attack[base]) diff ai_crane_driver[base]) - 1 then  //There must be a mechanic available. At least one in factory to produce
               begin
                    result = FactConstruct(base,fact_list,[ar_half_tracked,engine_siberite,control_manual,ar_control_tower],false);
               end
          else
               result = -1;
     end;
//Function to test if a factory can build a specified weapon and if not then possibly doing something about it
//(dismantling existing not necessary factory extensions and building requires one(s)).
//0 -> can't build it but we are gonna do something about it.
//1 -> can build it. Go ahead.
//2 -> can't built it and we can't do anything about it.
Function CanFactConstructThis(fact,weapon,do_something_about_it);
     var base, i, temp_list, un, loc_list, btype_list_planned, btype_list_exists, temp_list_2, temp_list_3, all_needed, currently_needed;
     var fact_ext_replace_loc_list;
     begin
          base = FindBase(fact);
          if base = 0 then
               begin
                    result = 2;
                    exit;
               end;

          btype_list_planned = [];
          temp_list = [GetX(fact),GetY(fact)];

          for i = 1 to ai_buildings_locations[base]+0 do
               if ai_buildings_locations[base][i][4] in [b_ext_computer,b_ext_gun,b_ext_noncombat,b_ext_laser,b_ext_radar,b_ext_radio,b_ext_rocket,b_ext_siberium,b_ext_stitch,b_ext_track] then
                    if GetDistXY(ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2],temp_list[1],temp_list[2]) <= 4 then
                         begin
                              btype_list_planned = btype_list_planned ^ ai_buildings_locations[base][i][4];

                              un = HexInfo(ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2]);
                              if un > 0 then
                                   if GetType(un) = unit_building and not IsConstructed(un) then
                                        btype_list_exists = btype_list_exists ^ GetBType(un);
                         end;

          currently_needed = [];

          case weapon of
               ar_cargo_bay,ru_cargo_bay,us_cargo_bay,ru_crane,us_crane,ru_bulldozer,us_bulldozer: begin //siberium extension for siberite engine
                    if ( ( b_ext_noncombat in btype_list_exists and b_ext_computer in btype_list_exists ) or ( GetBaseNation(base) = nation_arabian and b_ext_stitch in btype_list_exists ) ) and b_ext_siberium in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if GetBaseNation(base) = nation_arabian then
                                   begin
                                        if not b_ext_stitch in btype_list_planned then
                                             currently_needed = [b_ext_stitch];

                                        all_needed = [b_ext_stitch];
                                   end
                              else
                                   begin
                                        if not b_ext_noncombat in btype_list_planned then
                                             currently_needed = currently_needed ^ b_ext_noncombat;

                                        if not b_ext_computer in btype_list_planned then
                                             currently_needed = currently_needed ^ b_ext_computer;

                                        all_needed = [b_ext_noncombat,b_ext_computer];
                                   end;

                              if not b_ext_siberium in btype_list_planned then
                                   currently_needed = currently_needed ^ b_ext_siberium;

                              all_needed = all_needed ^ b_ext_siberium;
                         end;
               end;
               us_rocket_launcher,ru_rocket_launcher,ru_rocket,ar_rocket_launcher: begin
                    if b_ext_rocket in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_rocket in btype_list_planned then
                                   currently_needed = [b_ext_rocket];

                              all_needed = [b_ext_rocket];
                         end;
               end;
               us_light_gun,us_double_gun,us_heavy_gun,ru_gun,ru_heavy_gun,ar_light_gun,ar_gun: begin
                    if b_ext_gun in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_gun in btype_list_planned then
                                   currently_needed = [b_ext_gun];

                              all_needed = [b_ext_gun];
                         end;
               end;
               us_laser,us_double_laser: begin
                    if b_ext_laser in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_laser in btype_list_planned then
                                   currently_needed = [b_ext_laser];

                              all_needed = [b_ext_laser];
                         end;
               end;
               us_radar,ar_radar,ar_control_tower: begin
                    if b_ext_radar in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_radar in btype_list_planned then
                                   currently_needed = [b_ext_radar];

                              all_needed = [b_ext_radar];
                         end;
               end;
               ar_flame_thrower: begin
                    if b_ext_stitch in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_stitch in btype_list_planned then
                                   currently_needed = [b_ext_stitch];

                              all_needed = [b_ext_stitch];
                         end;
               end;
               ar_selfpropelled_bomb,ru_time_lapser: begin
                    if b_ext_siberium in btype_list_exists then
                         begin
                              result = 1;
                              exit;
                         end
                    else
                         begin
                              if not b_ext_siberium in btype_list_planned then
                                   currently_needed = [b_ext_siberium];

                              all_needed = [b_ext_siberium];
                         end;
               end;
               else begin
                    //No requirements
                    result = 1;
                    exit;
               end;
          end;
          
          if currently_needed = 0 then
               begin
                    result = 0;
               end
          else
               begin
                    if ai_engineers[base] = 0 then  //Only engineers can dismantle
                         begin
                              result = 2;
                              exit;
                         end;

                    //Determine the factory extension replace locations for this factory (if there are any).
                    fact_ext_replace_loc_list = [];
                    for i in ai_fact_extension_replace_locations[base] do
                         if GetDistUnitXY(fact,i[1],i[2]) <= 4 then
                              fact_ext_replace_loc_list = fact_ext_replace_loc_list ^ [i];

                    if fact_ext_replace_loc_list = 0 then
                         begin
                              result = 2;
                              exit;
                         end;

                    if not do_something_about_it then
                         exit;

                    temp_list_2 = [];
                    for i = 1 to ai_buildings_locations[base]+0 do
                         if [ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2]] in fact_ext_replace_loc_list then
                              temp_list_2 = temp_list_2 ^ i;

                    for i in temp_list_2 do
                         begin
                              if currently_needed = 0 then
                                   break;

                              if not ai_buildings_locations[base][i][4] in all_needed then
                                   begin
                                        //Dismantle the old factory extension and replace it with the right one.
                                        //Only dismantle finished buildings not to interfere with rebuild process.
                                        un = HexInfo(ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2]);
                                        if un > 0 then
                                             if GetType(un) = unit_building and not IsConstructed(un) then
                                                  begin
                                                       temp_list = Replace(ai_buildings_locations[base][i],4,currently_needed[1]);
                                                       temp_list = Replace(ai_buildings_locations[base],i,temp_list);
                                                       ai_buildings_locations = Replace(ai_buildings_locations,base,temp_list);

                                                       temp_list = ai_dismantle_these_buildings[base] ^ un;
                                                       ai_dismantle_these_buildings = Replace(ai_dismantle_these_buildings,base,temp_list);

                                                       if ai_facts_with_ext_rebuild_map < fact then
                                                            ai_facts_with_ext_rebuild_map = Replace(ai_facts_with_ext_rebuild_map,fact,[]);

                                                       temp_list = ai_facts_with_ext_rebuild_map[fact] ^ [[ai_buildings_locations[base][i][1],ai_buildings_locations[base][i][2]]];
                                                       ai_facts_with_ext_rebuild_map = Replace(ai_facts_with_ext_rebuild_map,fact,temp_list);
                                                  end;

                                        currently_needed = Delete(currently_needed,1);
                                   end;
                         end;

                    //If there are more factory extensions that may be replaced with other extensions then swap the building locations around
                    //for those locations in ai_buildings_locations so number 1 becomes the last, number 2 number 1, number 3 number 2 etc.
                    //This is to ensure that it isn't the factory extension on the same spot that is rebuild every time.
                    //In this particular mission it is useful since the Americans replace a lot of factory extensions. If both rebuild spots
                    //are replaced with computer ext and noncombat ext then only one of those will be rebuild over and over again each
                    //time they want to build a new weapon (laser/gun/rocket launcher). Not very optimal.
                    if temp_list_2 >= 2 then
                         begin
                              temp_list_3 = ai_buildings_locations[base];
                              temp_list = ai_buildings_locations[base][temp_list_2[1]];

                              for i = 2 to temp_list_2+0 do
                                   begin
                                        temp_list_3 = Replace(temp_list_3,temp_list_2[i-1], temp_list_3[temp_list_2[i]] );
                                   end;

                              temp_list_3 = Replace(temp_list_3,temp_list_2[temp_list_2+0],temp_list);
                              ai_buildings_locations = Replace(ai_buildings_locations,base,temp_list_3);

                              //SortBuildingLocationsListInCorrectOrder(base);  //Just to make sure we don't screw something up. There should be no danger but just to be sure.
                         end;

                    if currently_needed = 0 then  //should be the case
                         result = 0
                    else
                         result = 2;
               end;
     end;
//If the player captures one of the computer's vehicles, then remove it from our variables-system.
On VehicleCaptured(new_identifier,old_identifier,old_side,capturing_unit) do
     var temp_list, base;
     begin
          if old_side = you then
               exit;

          for base in ai_bases do
               RemoveVehicleFromVariables(base,old_identifier);
     end;
//When a vehicle is constructed
On VehicleConstructed(vehicle,factory) do
     var side, temp_list, base, un;
     begin
          side = GetSide(vehicle);
          if side = you then
               begin
                    if GetWeapon(vehicle) in [ru_siberium_rocket,us_siberium_rocket] then
                         player_has_built_sib_bomb = true;

                    exit;
               end;

          base = FindBase(vehicle);
          if base = 0 then
               exit;

          case GetWeapon(vehicle) of
               us_cargo_bay,ar_cargo_bay,ru_cargo_bay: begin
                    ai_cargo_bay = Replace(ai_cargo_bay,base,vehicle);
                    ai_cargo_bay_under_construction = Replace(ai_cargo_bay_under_construction,base,false);
               end;
               us_crane,ru_crane: begin     
                    ai_crane = Replace(ai_crane,base,vehicle);
                    ai_crane_under_construction = Replace(ai_crane_under_construction,base,false);
               end;
               ar_control_tower: begin
                    temp_list = ai_control_tower_vehicles[base] ^ vehicle;
                    ai_control_tower_vehicles = Replace(ai_control_tower_vehicles,base,temp_list);
               end;
               ar_selfpropelled_bomb: begin
                    temp_list = ai_implosion_vehicles[base] ^ vehicle;
                    ai_implosion_vehicles = Replace(ai_implosion_vehicles,base,temp_list);
               end;
               ru_time_lapser: begin
                    temp_list = ai_taufield_vehicles[base] ^ vehicle;
                    ai_taufield_vehicles = Replace(ai_taufield_vehicles,base,temp_list);
               end;
               ru_siberium_rocket,us_siberium_rocket: begin
                    temp_list = ai_sib_bomb_vehicles[base] ^ vehicle;
                    ai_sib_bomb_vehicles = Replace(ai_sib_bomb_vehicles,base,temp_list);
               end;
               else begin
                    temp_list = ai_vehicles_defend[base] ^ vehicle;
                    ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
               end;
          end;
     end;
On BehemothConstructed(behe) do
     var side, base, temp_list, i;
     begin
          side = GetSide(behe);
          if side = you then
               exit;

          base = 0;
          for i in ai_bases do
               if GetX(behe) = ai_behemoth_construction_hex[i][1] and GetY(behe) = ai_behemoth_construction_hex[i][2] then
                    begin
                         base = i;
                         break;
                    end;

          if base = 0 then
               exit;

          temp_list = ai_behemoths[base] ^ behe;
          ai_behemoths = Replace(ai_behemoths,base,temp_list);
     end;


//Preparation for attack.
//Arabians and Americans may attack together.
Every 0$1+0$0.3 do
     var val, i, b, temp_list, temp_list_2, temp_list_3, temp_list_4, base_list, base;
     var am_ar_cooperation_determined;
     begin
          am_ar_cooperation_determined = false;

          repeat
          if (ai_bases diff 2) = 0 then  //Alliance never attacks
               exit;

          wait(0$1 mod (ai_bases diff 2));

          for base in (ai_bases diff 2) do
          begin
          wait(0$1 div (ai_bases diff 2));
          
          if american_arabian_alliance and base = 3 then
               continue;

          if UnitFilter(ai_vehicles_attack[base],[f_ok]) > 0 or UnitFilter(ai_mechanics_attack[base],[f_ok]) > 0 or ( base = 4 and american_arabian_alliance and ( UnitFilter(ai_vehicles_attack[3],[f_ok]) > 0 or UnitFilter(ai_mechanics_attack[3],[f_ok]) > 0 ) ) then
               continue;

          if base = 4 and american_arabian_alliance and not am_ar_cooperation_determined then
               begin
                    am_ar_cooperation_determined = true;

                    if not am_ar_attack_alli_together then
                         am_ar_attack_alli_together = true
                    else
                         am_ar_attack_alli_together = [false,false,true][Rand(1,3)];
               end;

          ai_vehicle_attack_delay = Replace(ai_vehicle_attack_delay,base, ai_vehicle_attack_delay[base] - 0$1 );

          if ai_vehicle_attack_delay[base] > 0$0 then
               continue;

          if BaseUnderAttack(base,-1) then  //If Americans and Arabians attack together they will only wait if the Americans are under attack
               continue;

          if ai_vehicles_defend[base] < MaxNumWarVehiclesAttack(base) or ( base = 4 and american_arabian_alliance and ai_vehicles_defend[3] < MaxNumWarVehiclesAttack(3) ) then
               continue;

          if ai_taufield_vehicles[base] < MaxNumTaufieldVehicles(base) and (ai_facts[base] diff ai_sib_bomb_fact[base]) > 0 then
               if CanFactConstructThis((ai_facts[base] diff ai_sib_bomb_fact[base])[1],ru_time_lapser,false) <> 2 then
                    continue;

          if ai_implosion_vehicles[base] < MaxNumImplosionVehicles(base) and (ai_facts[base] diff ai_sib_bomb_fact[base]) > 0 then
               if CanFactConstructThis((ai_facts[base] diff ai_sib_bomb_fact[base])[1],ar_selfpropelled_bomb,false) <> 2 then
                    continue;

          if base = 4 and american_arabian_alliance then
               if ai_implosion_vehicles[3] < MaxNumImplosionVehicles(3) and (ai_facts[3] diff ai_sib_bomb_fact[3]) > 0 then
                    if CanFactConstructThis((ai_facts[3] diff ai_sib_bomb_fact[3])[1],ar_selfpropelled_bomb,false) <> 2 then
                         continue;


          //All are ready to attack.
          //Set attack strategy.
          base_list = [base];
          if base = 4 and american_arabian_alliance then
               base_list = base_list ^ 3;

          for b in base_list do
               begin
                    temp_list = base_in_area_map[b];

                    for i in [Ru_base,Alliance_base,Ar_base,Am_base,north_east_corner_area,player_base_area] do
                         if FilterAllUnits([[f_enemy,GetBaseSide(b)],[f_or,[f_btype,b_depot],[f_btype,b_warehouse]],[f_inarea,i]]) > 0 then
                              temp_list = Replace(temp_list,i,true)
                         else
                              temp_list = Replace(temp_list,i,false);

                    base_in_area_map = Replace(base_in_area_map,b,temp_list);
               end;

          case base of
               1: begin
                    if FilterAllUnits([[f_side,you],[f_type,unit_building],[f_inarea,south_motherlode_area]]) then
                         ai_attack_strategy = Replace(ai_attack_strategy,base,[1,4][Rand(1,2)])  //Don't only go for the buildings on the motherlode - also attack the player's base to stretch his/her defences
                    else
                         if alliance_deal_status = 2 and base_in_area_map[base][Alliance_base] then
                              begin
                                   if russians_dont_attack_player then
                                        continue;

                                   if base_in_area_map[base][Ar_base] or base_in_area_map[base][north_east_corner_area] or base_in_area_map[base][player_base_area] then
                                        ai_attack_strategy = Replace(ai_attack_strategy,base,[1,2,3,3][Rand(1,4)])
                                   else
                                        ai_attack_strategy = Replace(ai_attack_strategy,base,3);
                              end
                         else
                              if not 2 in ai_bases and IsLive(Powell) then  //Am attacks Ru directly - Ru attacks back. Don't check base_in_area_map. The player could have built a base on Alliance base area.
                                   ai_attack_strategy = Replace(ai_attack_strategy,base,3)
                              else
                                   begin
                                        if russians_dont_attack_player then
                                             continue;

                                        if base_in_area_map[base][Ar_base] or base_in_area_map[base][north_east_corner_area] or base_in_area_map[base][player_base_area] then
                                             ai_attack_strategy = Replace(ai_attack_strategy,base,Rand(1,2))
                                        else
                                             if base_in_area_map[base][Alliance_base] then
                                                  ai_attack_strategy = Replace(ai_attack_strategy,base,3)
                                             else
                                                  ai_attack_strategy = Replace(ai_attack_strategy,base,Rand(1,3));
                                   end;
               end;
               2: begin  //Alliance never attacks.
               end;
               3: begin
                    ai_attack_strategy = Replace(ai_attack_strategy,base,Rand(1,2));
               end;
               4: begin
                    if base_in_area_map[base][Alliance_base] then
                         begin
                              if am_ar_attack_alli_together then
                                   ai_attack_strategy = Replace(ai_attack_strategy,base,2)
                              else
                                   ai_attack_strategy = Replace(ai_attack_strategy,base,1);
                         end
                    else  //Alliance has been eliminated
                         //if GetAttitude(you,americans) in [att_neutral,att_friend] and GetAttitude(americans,you) in [att_neutral,att_friend] and not 3 in ai_bases then
                         //     ai_attack_strategy = Replace(ai_attack_strategy,base,[3,4,5,5][Rand(1,4)])
                         //else -> Frontal attack is hopeless. If this is gonna be enabled it should at least be predictable when Am attacks frontal or from the south (for the player's sake)
                              ai_attack_strategy = Replace(ai_attack_strategy,base,Rand(3,4));
               end;   
          end;


          //Pick vehicles and drivers.
          //Picking drivers for the manual vehicles doesn't take remote control into consideration so
          //this will screw up if a base attacks with both manual and remote vehicles.
          //We presume taufield vehicles and implosion vehicles are NOT manually controlled.
          base_list = [base];
          if base = 4 and american_arabian_alliance then
               base_list = base_list ^ 3;

          for b in base_list do
               begin
                    temp_list = [];
                    temp_list_2 = ai_vehicles_defend[b];
                    temp_list_3 = [];
                    temp_list_4 = ai_mechanics_defend[b] diff ai_crane_driver[b];

                    for i = 1 to MaxNumWarVehiclesAttack(b) do
                         begin
                              if temp_list_2 = 0 then
                                   break;

                              if GetControl(temp_list_2[1]) = control_manual then
                                   begin
                                        if temp_list_4 = 0 then
                                             continue;

                                        temp_list_3 = temp_list_3 ^ temp_list_4[1];
                                        RemoveHumanFromVariables(b,temp_list_4[1],false);
                                        temp_list_4 = Delete(temp_list_4,1);
                                   end;

                              temp_list = temp_list ^ temp_list_2[1];
                              RemoveVehicleFromVariables(b,temp_list_2[1]);
                              temp_list_2 = Delete(temp_list_2,1);
                         end;
                    
                    temp_list = temp_list ^ ai_taufield_vehicles[b] ^ ai_implosion_vehicles[b];

                    for i in ai_taufield_vehicles[b] ^ ai_implosion_vehicles[b] do
                         RemoveVehicleFromVariables(b,i);

                    if b = 1 and ai_attack_strategy[b] in [1,2,4] then
                         begin
                              temp_list = temp_list ^ ai_behemoths[b];

                              for i in ai_behemoths[b] do
                                   RemoveVehicleFromVariables(b,i);
                         end;

                    ai_vehicles_attack = Replace(ai_vehicles_attack,b,temp_list);
                    ai_mechanics_attack = Replace(ai_mechanics_attack,b,temp_list_3);

                    for i in ai_vehicles_attack[b] do
                         ai_attacking_unit_hex_index = Replace(ai_attacking_unit_hex_index,i,1);

                    attacked_times = Replace(attacked_times,b, attacked_times[b] ^ tick );
                    ai_new_attack_commencing = Replace(ai_new_attack_commencing,b,true);
               end;


          if base = 4 and american_arabian_alliance then
               am_ar_cooperation_determined = false;

          if base = 4 and american_arabian_alliance and not am_ar_attack_alli_together then  //Arabians and Americans attack at the same time but not together
               ai_attack_strategy = Replace(ai_attack_strategy,3,Rand(1,2));

          if base = 4 and american_arabian_alliance and am_ar_attack_alli_together then
               for i in ai_vehicles_attack[base] do
                    ai_attacking_unit_hex_index = Replace(ai_attacking_unit_hex_index,i,8);  //American vehicles wait for Arabians outside the American base

          if base = 4 and american_arabian_alliance and am_ar_attack_alli_together then
               num_attacks_ar_on_alli = num_attacks_ar_on_alli + 1;

          if base = 3 or ( base = 4 and american_arabian_alliance and not am_ar_attack_alli_together ) then
               ar_attack_commenced = true;


          //Reset attack delay
          ResetVehicleAttackDelay(base);

          end;

          until false;
     end;

Export Function ResetVehicleAttackDelay(base);
     var time;
     begin
          time = [5$15,4$30,3$45][difficulty];

          if base = 1 and Rand(1,3) < 3 and american_deal_status <> 2 and alliance_deal_status <> 2 then
               time = time - 0$30;  //To shift attack time vs. Arabians bit after bit to make things more interesting. If the player made the deal with Alliance or Am to destroy Alliance, defending is impossible if attacks are not predictable

          if base = 4 and not 2 in ai_bases and 1 in ai_bases then
               time = 0$0;  //Attack as often as possible (Powell rage against Russians).

          ai_vehicle_attack_delay = Replace(ai_vehicle_attack_delay,base, Rand(time,time+0$30) );
     end;
Export Function ResetHumanAttackDelay(base);
     begin
          //ai_human_attack_delay = Replace(ai_human_attack_delay,base, Rand(6$30,8$30) - 0$45 * difficulty );
          //Not used in this mission
     end;
           
//Control the attack.
Every 0$1 do
     var base, init_attack_hexes, attack_hexes, k, i, g, temp_list_3, a;
     var temp_unit, temp_list, temp_list_2, dist, temp_value, inside_ok, attacking_vehicles, behe_in_pos, one_nonbehe_in_pos;
     var vehicle_dist, all_are_ready, retreat_vehicles_list, retreat_mechanics_list, behemoth_dist, behemoth_attack_hexes;
     var behemoths_in_position, nonbehemoths_in_position, behemoth_lineup_hexes_indexes;
     var nonbehemoth_wait_for_behemoth_hexes, behemoth_wait_for_nonbehemoth_hexes, in_position_target;
     var vehicle_dist_base;
     begin
          vehicle_dist_base = 7;  //Max dist to attack hex for vehicles before proceeding to the next hex.
          behemoth_dist = 7;  //Max dist to attack hex for behemoths before proceeding to the next hex.

          retreat_vehicles_list = [[],[],[],[]];
          retreat_mechanics_list = [[],[],[],[]];

          all_are_ready = [false,false,false,false];  //True when all vehicles are ready to attack (manual vehicles have been manned).
          behemoths_in_position = [0,0,0,0];  //Tells if the behemoths are in position so nonbehemoth vehicles may move. They are in position if the value equals in_position_target[base].
          nonbehemoths_in_position = [0,0,0,0];  //Tells if the nonbehemoth vehicles are in position so behemoths may move. They are in position if the value equals in_position_target[base].
          in_position_target = [1,1,1,1];
          behemoth_lineup_hexes_indexes = [[],[],[],[]];  //Indexes for the hexes where behemoths line up before an attack (in "behemoth_attack_hexes").
          nonbehemoth_wait_for_behemoth_hexes = [[],[],[],[]];  //The hexes where nonbehemoth vehicles wait for behemoths to line up (hexes must be part of "attack_hexes").
          behemoth_wait_for_nonbehemoth_hexes = [[],[],[],[]];  //Hexes for nonbehemoth vehicles. Behemoths wait until a nonbehemoth vehicle reaches such a hex (hexes must be part of "attack_hexes").
          behemoth_attack_hexes = [];  //Index is behemoth id, value is list with attack hexes. Since behemoths are so bulky and awkward each have their own personal attack hexes.

          //The idea for attacking with behemoths and ordinary vehicles is that first the ordinary
          //vehicles wait in the background on a "nonbehemoth_wait_for_behemoth_hexes" hex
          //until the behemoths have gathered at the hexes defined by "behemoth_lineup_hexes_indexes".
          //Then the behemoths wait until one (and just one) ordinary vehicle reach a hex in
          //"behemoth_wait_for_nonbehemoth_hexes". Then all attack together.

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    if base = 2 then  //Alliance never attacks
                         continue;

                    temp_list = ai_vehicles_attack[base] ^ ai_mechanics_attack[base];
                    if base in [3,4] and american_arabian_alliance and am_ar_attack_alli_together then
                         begin
                              if base = 3 then
                                   k = 4
                              else
                                   k = 3;

                              temp_list = temp_list ^ ai_vehicles_attack[k] ^ ai_mechanics_attack[k];
                         end;

                    //if ai_vehicles_attack[base] = 0 and ai_mechanics_attack[base] = 0 and not ( base = 3 and american_arabian_alliance and am_ar_attack_alli_together and not ( ai_vehicles_attack[4] = 0 and ai_mechanics_attack[4] = 0 ) ) then
                    if temp_list+0 = 0 then
                         continue;

                    if ai_new_attack_commencing[base] then
                         begin
                              all_are_ready = Replace(all_are_ready,base,false);
                              behemoths_in_position = Replace(behemoths_in_position,base,0);
                              nonbehemoths_in_position = Replace(nonbehemoths_in_position,base,0);
                              in_position_target = Replace(in_position_target,base,1);
                              behemoth_lineup_hexes_indexes = Replace(behemoth_lineup_hexes_indexes,base,[]);
                              nonbehemoth_wait_for_behemoth_hexes = Replace(nonbehemoth_wait_for_behemoth_hexes,base,[]);
                              behemoth_wait_for_nonbehemoth_hexes = Replace(behemoth_wait_for_nonbehemoth_hexes,base,[]);

                              if base = 1 then
                                   begin
                                        behemoth_attack_hexes = [];
                                   end;

                              ai_new_attack_commencing = Replace(ai_new_attack_commencing,base,false);
                         end;

                    if not ( base = 3 and american_arabian_alliance and am_ar_attack_alli_together ) then
                    case base of
                         //Attack hexes end outside base so ordinary vehicle control code tells vehicles to go inside
                         1: begin  //Russians
                              //Strategy 1 - Attack the player from northwest/north.
                              //Strategy 2 - Attack the player from northwest/west.
                              //Strategy 3 - Attack Alliance and later Americans.
                              //Strategy 4 - Search south of the Russian base for player buildings (siberite mines especially). Then proceed as strategy 2.
                              //If the player has a base in the north east corner then make a move there and continue as strategy 1 (ignore if we use strategy 3).

                              init_attack_hexes = [[44,17],[72,29],[72,29]];  //Double indended to make vehicles gather at that hex
                              attack_hexes = init_attack_hexes;

                              if ai_attack_strategy[base] = 3 then
                                   begin
                                        attack_hexes = attack_hexes ^ [[69,37],[67,46],[59,55],[56,66],{[56,66],}[64,84],[67,99]];  //Attack Alliance. Double indended to make vehicles gather at that hex

                                        if base_in_area_map[base][Alliance_base] then
                                             attack_hexes = attack_hexes ^ [[62,110],[71,123],[76,113],[89,122]]  //make sure to destroy the entire base
                                        else
                                             attack_hexes = attack_hexes ^ [[76,113],[86,126]];

                                        attack_hexes = attack_hexes ^ [[97,137],[103,144],{[103,144],}[121,163],[134,179],[128,184],[116,183],[100,181]];  //Attack Americans. Double indended to make vehicles gather at that hex
                                        attack_hexes = attack_hexes ^ [[95,159],[95,147],[86,130],[76,113],[67,99],[64,84],[56,66],[59,55],[67,46],[69,37]];
                                   end
                              else
                                   begin
                                        if ai_attack_strategy[base] = 4 then
                                             attack_hexes = attack_hexes ^ [[69,37],[67,46],[61,52],[59,60],[52,68],[37,57],[46,55],[54,54],[61,52],[67,46]]
                                        else
                                             if ai_attack_strategy[base] = 2 and not base_in_area_map[base][north_east_corner_area] then
                                                  attack_hexes = attack_hexes ^ [[69,37]];

                                        if base_in_area_map[base][north_east_corner_area] then
                                             begin
                                                  if ai_attack_strategy[base] = 4 then
                                                       attack_hexes = attack_hexes ^ [[69,37],[72,29]];

                                                  attack_hexes = attack_hexes ^ [[76,21],[84,18],[92,15],[103,14],[115,22],[122,35],[111,34],[105,40]];  //Northeast corner
                                             end
                                        else
                                             if ai_attack_strategy[base] in [2,4] then
                                                  begin
                                                       attack_hexes = attack_hexes ^ [[76,49],[87,62],[105,75]];

                                                       if base_in_area_map[base][player_base_area] then
                                                            attack_hexes = attack_hexes ^ [[118,77],[131,77],[142,72],[125,62],[111,61]];  //Finish off player base
                                                  end
                                             else
                                                  if ai_attack_strategy[base] = 1 then
                                                       attack_hexes = attack_hexes ^ [[82,30],[91,39]];

                                        if ai_attack_strategy[base] = 1 or base_in_area_map[base][north_east_corner_area] then
                                             begin
                                                  attack_hexes = attack_hexes ^ [[100,48],[111,61]];  //Player base

                                                  if base_in_area_map[base][player_base_area] then
                                                       attack_hexes = attack_hexes ^ [[125,62],[142,72],[131,77],[118,77],[105,75]];  //Finish off player base
                                             end;

                                        attack_hexes = attack_hexes ^ [[117,77],[130,93],{[130,93],}[139,104],[148,113],[158,124],[168,141],[177,156],[184,174],[169,160],[157,150],[159,141]];  //Attack Arabians. Double indended to make vehicles gather at that hex
                                        attack_hexes = attack_hexes ^ [[156,129],[142,120],[131,113],[118,102],[104,90],[90,75],[87,62],[76,49],[73,35]];  //Return home
                                   end;

                              //Initialize behemoth attack hexes if necessary
                              if behemoth_attack_hexes = 0 then
                                   begin
                                        temp_list = UnitFilter(ai_vehicles_attack[base],[f_weapon,59]);  //behemoths
                                        if temp_list > 0 then
                                             begin                //|Player base                   | Arab base                                       | Go home
                                                  temp_list_2 = [[[84,26],[98,40],[111,61],[127,77],[123,103],[166,137],[189,166],[159,152],[166,137],[147,122],[127,108],[105,92],[87,69],[75,42]],  //For each "ai_behemoth_parking_hexes"
                                                                 [[80,33],[93,46],[111,61],[127,77],[133,103],[166,137],[189,166],[159,152],[166,137],[147,122],[127,108],[105,92],[87,69],[75,42]],
                                                                 [[75,40],[88,53],[111,61],[127,77],[143,103],[166,137],[189,166],[159,152],[166,137],[147,122],[127,108],[105,92],[87,69],[75,42]]];

                                                  behemoth_lineup_hexes_indexes = Replace(behemoth_lineup_hexes_indexes,base,[1,5]);
                                                  nonbehemoth_wait_for_behemoth_hexes = Replace(nonbehemoth_wait_for_behemoth_hexes,base,[[44,17],[117,77]]);
                                                  behemoth_wait_for_nonbehemoth_hexes = Replace(behemoth_wait_for_nonbehemoth_hexes,base,[attack_hexes[4],[148,113]]);

                                                  //Assign attack paths to behemoths. A behemoth takes the attack path closests to its current position.
                                                  temp_list_3 = ai_behemoth_parking_hexes[base];
                                                  for i in temp_list do
                                                       begin
                                                            if temp_list_3 = 0 then
                                                                 break;

                                                            dist = 9999999;
                                                            temp_unit = 0;
                                                            a = 0;

                                                            for g = 1 to temp_list_3+0 do
                                                                 begin
                                                                      if temp_list_3[g] = 0 then
                                                                           continue;

                                                                      k = GetDistUnitXY(i,temp_list_3[g][1],temp_list_3[g][2]);
                                                                      if k < dist then
                                                                           begin
                                                                                dist = k;
                                                                                temp_unit = i;
                                                                                a = g;
                                                                           end;
                                                                 end;

                                                            behemoth_attack_hexes = Replace(behemoth_attack_hexes,temp_unit,temp_list_2[a]);
                                                            temp_list_3 = Replace(temp_list_3,a,[]);
                                                       end;
                                             end
                                        else
                                             behemoths_in_position = Replace(behemoths_in_position,base,in_position_target[base]);
                                   end;
                         end;
                         2: begin
                         end;
                         3: begin  //Arabians
                              //Strategy 1 - Attack the south-eastern part of the player's base.
                              //Strategy 2 - Attack the south-western part of the player's base.

                              init_attack_hexes = [[170,146]];

                              if ai_attack_strategy[base] = 1 then
                                   init_attack_hexes = init_attack_hexes ^ [[167,135],[167,135]]  //Double indended to make vehicles gather at that hex
                              else
                                   init_attack_hexes = init_attack_hexes ^ [[159,134],[159,134]];  //Double indended to make vehicles gather at that hex

                              attack_hexes = init_attack_hexes;

                              if ai_attack_strategy[base] = 1 then                                                   
                                   begin
                                        attack_hexes = attack_hexes ^ [[164,123],[159,113],[153,100],[142,81]];

                                        if base_in_area_map[base][player_base_area] then
                                             attack_hexes = attack_hexes ^ [[129,64],[116,67],[126,82],[107,76],[93,71],[82,67]]  //Finish off player base
                                        else
                                             attack_hexes = attack_hexes ^ [[129,74],[116,67]];
                                   end
                              else                                                                   
                                   begin
                                        attack_hexes = attack_hexes ^ [[147,122],[140,113],[134,102],[125,84]];

                                        if base_in_area_map[base][player_base_area] then
                                             attack_hexes = attack_hexes ^ [[133,77],[137,65],[122,64],[113,69],[107,76],[93,71],[82,67]]  //Finish off player base
                                        else
                                             attack_hexes = attack_hexes ^ [[116,67]];
                                   end;

                              if base_in_area_map[base][north_east_corner_area] then
                                   begin
                                        if base_in_area_map[base][player_base_area] then
                                             attack_hexes = attack_hexes ^ [[85,56],[89,49],[94,43]]
                                        else
                                             attack_hexes = attack_hexes ^ [[106,56],[94,43]];

                                        attack_hexes = attack_hexes ^ [[105,40],[111,34],[115,22],[103,14],[102,26],[105,40],[106,56],[107,66],[107,76]];
                                   end
                              else
                                   if not base_in_area_map[base][player_base_area] then
                                        attack_hexes = attack_hexes ^ [[107,76]];

                              attack_hexes = attack_hexes ^ [[98,84],[117,101],[130,110],[142,119],[153,127]];  //Return home

                              behemoths_in_position = Replace(behemoths_in_position,base,in_position_target[base]);
                         end;
                         4: begin  //Americans
                              //Strategy 1 - Attack Alliance straight on (and later Russians straight on)
                              //Strategy 2 - Attack Alliance straight on but supported by Arabians (and later Russians straight on)
                              //Strategy 3 - Attack the Russians. Then attack the player from northwest/north (same as Russian strategy 1)
                              //Strategy 4 - Attack the Russians. Then attack the player from northwest/west (same as Russian strategy 2)
                              //Strategy 5 - Attack the Russians from the east passing by the player's base from the south (assumes Americans and the player are at least neutral and the Arabs have been eliminated). Then attack the player from northwest/west (same as Russian strategy 2)

                              case ai_attack_strategy[base] of
                                   1,3,4: begin
                                        attack_hexes = [[117,158],[117,158],[97,137]];  //Double indended to make vehicles gather at that hex
                                        init_attack_hexes = [attack_hexes[1]];
                                   end;
                                   2: begin
                                        attack_hexes = [[168,141],[156,129],[145,129],[138,134],[137,146],[140,158],[128,159],[128,159],[112,148],[97,137]];  //Double indended to make vehicles gather at that hex
                                        init_attack_hexes = [attack_hexes[1],attack_hexes[2]];  //For Arabians
                                   end;
                                   5: begin
                                        attack_hexes = [[128,159],[128,159],[140,158],[137,146],[138,134],[134,118],[119,103],[103,89],[93,72],[91,58],[92,44],[92,30],[87,17],[87,17],[70,15]];  //Doubles indended to make vehicles gather at those hexes
                                        init_attack_hexes = [attack_hexes[1]];
                                   end;
                              end;

                              if ai_attack_strategy[base] in [1,2,3,4] then
                                   begin
                                        if ai_attack_strategy[base] in [1,2] then  //make sure to destroy the entire Alliance base
                                             attack_hexes = attack_hexes ^ [[89,122],[76,113],[71,123],[62,110]]
                                        else
                                             attack_hexes = attack_hexes ^ [[86,126],[76,113]];

                                        attack_hexes = attack_hexes ^ [[68,100],[65,86],[56,67],[56,67],[57,57],[64,52],[70,46],[70,37]];  //Double indended to make vehicles gather at that hex
                                   end;

                              if ai_attack_strategy[base] in [1,2,3,4] then  //attack the Russian base
                                   begin
                                        if base_in_area_map[base][Ru_base] then
                                             attack_hexes = attack_hexes ^ [[63,24],[52,14],[41,15],[46,30],[31,31],[11,11],[27,10],[41,15],[53,18],[72,29]]  //destroy entire Russian base
                                        else
                                             attack_hexes = attack_hexes ^ [[72,29]];
                                   end
                              else
                                   if ai_attack_strategy[base] = 5 then
                                        attack_hexes = attack_hexes ^ [[52,14],[41,15],[46,30],[31,31],[11,11],[27,10],[41,15],[53,18],[72,29]];  //destroy entire Russian base

                              if base_in_area_map[base][north_east_corner_area] then
                                   begin
                                        attack_hexes = attack_hexes ^ [[76,21],[84,18],[92,15],[103,14],[115,22],[122,35],[111,34],[105,40]];  //Northeast corner
                                   end
                              else
                                   if ai_attack_strategy[base] = 4 then
                                        begin
                                             attack_hexes = attack_hexes ^ [[69,37],[76,49],[87,62],[105,75]];

                                             if base_in_area_map[base][player_base_area] then
                                                  attack_hexes = attack_hexes ^ [[117,77],[131,77],[142,72],[125,62],[111,61]];  //Finish off player base
                                        end
                                   else
                                        if ai_attack_strategy[base] in [1,2,3,5] then
                                             attack_hexes = attack_hexes ^ [[82,30],[91,39]];

                              if ai_attack_strategy[base] in [1,2,3,5] or base_in_area_map[base][north_east_corner_area] then
                                   begin
                                        attack_hexes = attack_hexes ^ [[100,48],[111,61]];  //Player base

                                        if base_in_area_map[base][player_base_area] then
                                             attack_hexes = attack_hexes ^ [[125,62],[142,72],[131,77],[117,77],[105,75]];  //Finish off player base
                                   end;

                              attack_hexes = attack_hexes ^ [[117,77],[130,93],[130,93],[139,104],[148,113],[158,124],[168,141],[177,156],[184,174],[169,160],[157,150],[159,141]];  //Attack Arabians. Double indended to make vehicles gather at that hex
                              attack_hexes = attack_hexes ^ [[145,129],[138,134],[137,146],[140,158],[130,161],[120,162]];  //Return home

                              behemoths_in_position = Replace(behemoths_in_position,base,in_position_target[base]);
                         end;
                    end;


                    //Check which vehicles should retreat to base (only manual vehicles).
                    temp_list = UnitFilter(retreat_vehicles_list[base],[f_alive]);
                    k = Researched(GetBaseSide(base),tech_Limteleport);
                    for i in UnitFilter(ai_vehicles_attack[base],[f_control,control_manual]) diff retreat_vehicles_list[base] do
                         if GetLives(i) <= 250 or ( not k and GetLives(i) <= 400 ) then
                              temp_list = temp_list ^ i;

                    retreat_vehicles_list = Replace(retreat_vehicles_list,base,temp_list);


                    //Check which mechanics should retreat to base (on foot) (if they are not inside a vehicle and there are not enough
                    //vehicles for all mechanics then retreat).
                    temp_list = UnitFilter(retreat_mechanics_list[base],[f_alive]);
                    temp_list_2 = ai_mechanics_attack[base] diff retreat_mechanics_list[base];
                    for i = 1 to temp_list_2 - UnitFilter(ai_vehicles_attack[base],[[f_control,control_manual],[f_ok]]) do
                         begin
                              temp_unit = 0;
                              for k in temp_list_2 do
                                   if not IsInUnit(k) in ai_vehicles_attack[base] then
                                        begin
                                             temp_unit = k;
                                             break;
                                        end;

                              if temp_unit > 0 then
                                   begin
                                        temp_list = temp_list ^ temp_unit;
                                   end;
                         end;

                    retreat_mechanics_list = Replace(retreat_mechanics_list,base,temp_list);


                    //Make retreating vehicles and mechanics retreat to base.
                    //When they reach the base then remove them from the attacking variables and add them to the
                    //defending variables so they are taken properly care of (see every for defending mechanics above).
                    for i in retreat_vehicles_list[base] ^ retreat_mechanics_list[base] do
                         if IsInArea(i,GetBaseArea(base)) then
                              begin
                                   if GetType(i) = unit_vehicle then
                                        begin
                                             temp_list = ai_vehicles_attack[base] diff i;
                                             ai_vehicles_attack = Replace(ai_vehicles_attack,base,temp_list);

                                             case GetWeapon(i) of
                                                  ru_time_lapser: begin
                                                       temp_list = ai_taufield_vehicles[base] ^ i;
                                                       ai_taufield_vehicles = Replace(ai_taufield_vehicles,base,temp_list);
                                                  end;
                                                  ar_selfpropelled_bomb: begin
                                                       temp_list = ai_implosion_vehicles[base] ^ i;
                                                       ai_implosion_vehicles = Replace(ai_implosion_vehicles,base,temp_list);
                                                  end;
                                                  59: begin  //behemoth
                                                       temp_list = ai_behemoths[base] ^ i;
                                                       ai_behemoths = Replace(ai_behemoths,base,temp_list);
                                                  end;
                                                  else begin
                                                       temp_list = ai_vehicles_defend[base] ^ i;
                                                       ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
                                                  end;
                                             end;

                                             temp_list = retreat_vehicles_list[base] diff i;
                                             retreat_vehicles_list = Replace(retreat_vehicles_list,base,temp_list);

                                             i = UnitsInside(i);
                                        end;

                                   if i > 0 then
                                        begin
                                             temp_list = ai_mechanics_attack[base] diff i;
                                             ai_mechanics_attack = Replace(ai_mechanics_attack,base,temp_list);

                                             temp_list = ai_mechanics_defend[base] ^ i;
                                             ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);

                                             temp_list = retreat_mechanics_list[base] diff i;
                                             retreat_mechanics_list = Replace(retreat_mechanics_list,base,temp_list);
                                        end;
                              end
                         else
                              ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);


                    //Make sure units inside war vehicles are attacking mechanics
                    inside_ok = true;
                    for i in UnitFilter(ai_vehicles_attack[base] diff retreat_vehicles_list[base],[[f_control,control_manual],[f_not,[f_empty]]]) do
                         begin
                              temp_unit = UnitsInside(i)[1];
                              if not temp_unit in ai_mechanics_attack[base] then
                                   begin
                                        ComExitVehicle(temp_unit);
                                        inside_ok = false;
                                   end;
                         end;


                    //Make sure mechanics are inside vehicles (should only be applicable for initialization)
                    temp_list = UnitFilter(ai_vehicles_attack[base],[[f_control,control_manual],[f_ok],[f_empty]]);
                    if temp_list > 0 then
                         begin
                              temp_list_2 = UnitFilter(ai_mechanics_attack[base] diff retreat_mechanics_list[base],[f_not,[f_driving]]);
                              for i in temp_list do
                                   begin
                                        if temp_list_2 = 0 then
                                             break;  //Should never be applicable

                                        temp_unit = AllNearestUnitToUnit(temp_list_2,i);

                                        k = IsInUnit(temp_unit);
                                        if k <> i then
                                             if k > 0 then
                                                  case GetType(k) of
                                                       unit_vehicle: ComExitVehicle(temp_unit);
                                                       unit_building: ComExitBuilding(temp_unit);
                                                  end
                                             else ComEnterUnit(temp_unit,i);

                                        temp_list_2 = temp_list_2 diff temp_unit;
                                   end;
                         end
                    else
                         if inside_ok then
                              all_are_ready = Replace(all_are_ready,base,true);


                    if not all_are_ready[base] then
                         continue;

                    if base = 3 and american_arabian_alliance and am_ar_attack_alli_together then
                         continue;  //Arabian vehicles are controlled by American attack code

                    if base = 4 and american_arabian_alliance and am_ar_attack_alli_together and not all_are_ready[3] then
                         continue;

                    if base = 4 and american_arabian_alliance and am_ar_attack_alli_together then
                         attacking_vehicles = (ai_vehicles_attack[3] ^ ai_vehicles_attack[4]) diff (retreat_vehicles_list[3] ^ retreat_vehicles_list[4])
                    else
                         attacking_vehicles = ai_vehicles_attack[base] diff retreat_vehicles_list[base];

                    attacking_vehicles = UnitFilter(attacking_vehicles,[f_ok]);

                    if UnitFilter(attacking_vehicles,[f_not,[f_weapon,59]]) > 6 then  //weapon 59 = behemoth
                         vehicle_dist = vehicle_dist_base + 2
                    else
                         vehicle_dist = vehicle_dist_base;


                    //Check which units are ready to go for the next hex.
                    //Don't spread too far.
                    //If we have implosion and/or taufield and/or behemoth vehicles then they should be in front.
                    //Don't wait for ru_rocket vehicles (they have special attack, see below).
                    temp_list_2 = [9999999,9999999,9999999];
                    for i in UnitFilter(attacking_vehicles,[[f_not,[f_weapon,ru_time_lapser]],[f_not,[f_weapon,ar_selfpropelled_bomb],[f_not,[f_weapon,ru_rocket]],[f_not,[f_weapon,59]]]{,[f_ok]}]) do  //check f_ok redundant //weapon 59 = behemoth
                         if ai_attacking_unit_hex_index[i] < temp_list_2[1] then
                              temp_list_2 = Replace(temp_list_2,1,ai_attacking_unit_hex_index[i]);

                    for i in UnitFilter(attacking_vehicles,[[f_or,[f_weapon,ru_time_lapser],[f_weapon,ar_selfpropelled_bomb]]{,[f_ok]}]) do  //check f_ok redundant
                         if ai_attacking_unit_hex_index[i] < temp_list_2[2] then
                              temp_list_2 = Replace(temp_list_2,2,ai_attacking_unit_hex_index[i]);

                    temp_list_3 = [];  //[x,y,dir]
                    if temp_list_2[2] <= attack_hexes and temp_list_2[2] > 1 then
                         begin
                              temp_list = [attack_hexes[temp_list_2[2]-1],attack_hexes[temp_list_2[2]]];
                              k = AI_GetTurnDirection(temp_list[1][1],temp_list[1][2],temp_list[2][1],temp_list[2][2]);

                              dist = -1;
                              for i in UnitFilter(attacking_vehicles,[[f_or,[f_weapon,ru_time_lapser],[f_weapon,ar_selfpropelled_bomb]]{,[f_ok]}]) do  //check f_ok redundant
                                   begin
                                        g = GetDistUnitXY(i,temp_list[2][1],temp_list[2][2]);
                                        if g > dist then
                                             begin
                                                  dist = g;
                                                  temp_list_3 = [GetX(i),GetY(i),k];
                                             end;
                                   end;
                         end;

                    behe_in_pos = true;
                    one_nonbehe_in_pos = false;
                    for i in attacking_vehicles do
                         if GetWeapon(i) = 59 then  //behemoth
                              begin
                                   if ai_attacking_unit_hex_index[i] + 1 <= behemoth_lineup_hexes_indexes[base][in_position_target[base]] or ( behemoths_in_position[base] = in_position_target[base] and nonbehemoths_in_position[base] = in_position_target[base] ) then
                                        begin
                                             if GetDistUnitXY(i,behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][1],behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][2]) <= behemoth_dist then
                                                  begin
                                                       ai_attacking_unit_hex_index = Replace(ai_attacking_unit_hex_index,i, ai_attacking_unit_hex_index[i]+1 );

                                                       if ai_attacking_unit_hex_index[i] > behemoth_attack_hexes[i] then
                                                            begin
                                                                 //End of the line
                                                                 temp_list = ai_vehicles_attack[base] diff i;
                                                                 ai_vehicles_attack = Replace(ai_vehicles_attack,base,temp_list);

                                                                 attacking_vehicles = attacking_vehicles diff i;

                                                                 temp_list = ai_behemoths[base] ^ i;
                                                                 ai_behemoths = Replace(ai_behemoths,base,temp_list);

                                                                 continue;
                                                            end;

                                                       if behemoths_in_position[base] = in_position_target[base] and behemoth_lineup_hexes_indexes[base] >= in_position_target[base] + 1 then
                                                            if ai_attacking_unit_hex_index[i] = behemoth_lineup_hexes_indexes[base][in_position_target[base] + 1] then
                                                                 begin
                                                                      in_position_target = Replace(in_position_target,base, in_position_target[base] + 1 );
                                                                 end;
                                                  end;
                                        end;

                                   if behemoths_in_position[base] <> in_position_target[base] then
                                        begin
                                             if ai_attacking_unit_hex_index[i] <> behemoth_lineup_hexes_indexes[base][in_position_target[base]] then
                                                  behe_in_pos = false
                                             else
                                                  if GetDistUnitXY(i,behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][1],behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][2]) > 2 then
                                                       behe_in_pos = false;
                                        end;
                              end
                         else
                         if ai_attacking_unit_hex_index[i] <= attack_hexes then
                              begin
                                   if behemoths_in_position[base] <> in_position_target[base] then
                                        if attack_hexes[ai_attacking_unit_hex_index[i]][1] = nonbehemoth_wait_for_behemoth_hexes[base][in_position_target[base]][1] and
                                           attack_hexes[ai_attacking_unit_hex_index[i]][2] = nonbehemoth_wait_for_behemoth_hexes[base][in_position_target[base]][2] then
                                             continue;

                                   temp_value = false;
                                   if not temp_value and ai_attacking_unit_hex_index[i] + 1 <= attack_hexes then
                                        if attack_hexes[ai_attacking_unit_hex_index[i]+1] in init_attack_hexes then
                                             temp_value = true;

                                   if not temp_value then
                                        begin
                                             case GetWeapon(i) of
                                                  ru_time_lapser,ar_selfpropelled_bomb: begin
                                                       temp_value := ai_attacking_unit_hex_index[i] + 1 <= temp_list_2[1] + 1 and ai_attacking_unit_hex_index[i] + 1 <= temp_list_2[2] + 1;
                                                  end;
                                                  else begin
                                                       temp_value := ai_attacking_unit_hex_index[i] + 1 <= temp_list_2[1] + 1 and ai_attacking_unit_hex_index[i] + 1 <= temp_list_2[2];

                                                       if temp_value and ai_attacking_unit_hex_index[i] + 1 = temp_list_2[2] and temp_list_3 > 0 then
                                                            begin
                                                                 if not BehindLine(i,temp_list_3[1],temp_list_3[2],temp_list_3[3],4) and
                                                                    not ( attack_hexes[ai_attacking_unit_hex_index[i]][1] = attack_hexes[ai_attacking_unit_hex_index[i] + 1][1] and
                                                                          attack_hexes[ai_attacking_unit_hex_index[i]][2] = attack_hexes[ai_attacking_unit_hex_index[i] + 1][2] ) then
                                                                      temp_value = false;
                                                            end;
                                                  end;
                                             end;
                                        end;

                                   if ai_attacking_unit_hex_index[i] + 1 <= attack_hexes then
                                        if base = 3 and not contaminate_scis_ready and not attack_hexes[ai_attacking_unit_hex_index[i]+1] in init_attack_hexes and ContactTime(GetBaseSide(base)) > 0$2 then
                                             temp_value = false;

                                   if temp_value then
                                        begin
                                             if GetDistUnitXY(i,attack_hexes[ai_attacking_unit_hex_index[i]][1],attack_hexes[ai_attacking_unit_hex_index[i]][2]) <= vehicle_dist then
                                                  begin
                                                       ai_attacking_unit_hex_index = Replace(ai_attacking_unit_hex_index,i, ai_attacking_unit_hex_index[i]+1 );

                                                       if ai_attacking_unit_hex_index[i] > attack_hexes then
                                                            begin
                                                                 //End of the line.
                                                                 if GetType(i) = unit_vehicle then
                                                                      begin
                                                                           temp_list = ai_vehicles_attack[base] diff i;
                                                                           ai_vehicles_attack = Replace(ai_vehicles_attack,base,temp_list);

                                                                           attacking_vehicles = attacking_vehicles diff i;

                                                                           case GetWeapon(i) of
                                                                                ru_time_lapser: begin
                                                                                     temp_list = ai_taufield_vehicles[base] ^ i;
                                                                                     ai_taufield_vehicles = Replace(ai_taufield_vehicles,base,temp_list);
                                                                                end;
                                                                                ar_selfpropelled_bomb: begin
                                                                                     temp_list = ai_implosion_vehicles[base] ^ i;
                                                                                     ai_implosion_vehicles = Replace(ai_implosion_vehicles,base,temp_list);
                                                                                end;
                                                                                else begin
                                                                                     temp_list = ai_vehicles_defend[base] ^ i;
                                                                                     ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
                                                                                end;
                                                                           end;

                                                                           i = UnitsInside(i);
                                                                      end;

                                                                 if i > 0 then
                                                                      begin
                                                                           temp_list = ai_mechanics_attack[base] diff i;
                                                                           ai_mechanics_attack = Replace(ai_mechanics_attack,base,temp_list);

                                                                           temp_list = ai_mechanics_defend[base] ^ i;
                                                                           ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
                                                                      end;

                                                                 continue;
                                                            end;

                                                       if nonbehemoths_in_position[base] = in_position_target[base] and behemoth_lineup_hexes_indexes[base] >= in_position_target[base] + 1 and attack_hexes[ai_attacking_unit_hex_index[i]] in nonbehemoth_wait_for_behemoth_hexes[base] then
                                                            begin
                                                                 in_position_target = Replace(in_position_target,base, in_position_target[base] + 1 );
                                                            end;

                                                       if attack_hexes[ai_attacking_unit_hex_index[i]] in behemoth_wait_for_nonbehemoth_hexes[base] then
                                                            one_nonbehe_in_pos = true;
                                                  end;
                                        end;
                              end;

                    if behe_in_pos then
                         behemoths_in_position = Replace(behemoths_in_position,base,in_position_target[base]);

                    if one_nonbehe_in_pos or UnitFilter(attacking_vehicles,[f_not,[f_weapon,59]]) = 0 then
                         nonbehemoths_in_position = Replace(nonbehemoths_in_position,base,in_position_target[base]);


                    //Make the attack
                    for i in attacking_vehicles do
                         begin
                              //If the unit is shooting at a unit which is Ok and there is a dying human
                              //unit within the same distance or closer than the current target then
                              //kill off that human unit first.
                              {temp_value = GetTaskList(i);
                              if temp_value > 0 then
                                        if temp_value[1][1] = '^' then  //'^' is auto attack
                                             begin
                                                  //The unit is auto attacking because it has met an enemy.
                                                  temp_unit = Attacks(i);
                                                  if temp_unit > 0 and IsOk(temp_unit) then
                                                       begin
                                                            temp_value = GetDistUnits(i,temp_unit);
                                                            temp_list = FilterAllUnits([[f_enemy,GetBaseSide(base)],[f_type,unit_human],[f_not,[f_ok]],[f_dist,i,temp_value]]);
                                                            if temp_list > 0 then
                                                                 ComAttackUnit(i,temp_list[1]);

                                                            continue;
                                                       end;
                                             end;}

                              //If the unit is near the base then start shooting at humans if possible - else vehicles and buildings.
                              //Shoot at nearest non-human unit (not so important with human units since we just agressive move).
                              if GetWeapon(i) = ru_rocket then
                                   if not attack_hexes[ai_attacking_unit_hex_index[i]] in init_attack_hexes then  //Doesn't go well if vehicle is a behemoth
                                        begin
                                             //We cheat a little. To fully exploit the range of ru_rocket we scan the area around the vehicle for buildings
                                             //and attack ground if we find one.
                                             //Range of ru_rocket is approximately 22 hexes.
                                             temp_list = FilterAllUnits([[f_enemy,GetBaseSide(base)],[f_type,unit_building],[f_dist,i,30]]) diff alien_tower;
                                             if temp_list > 0 then
                                                  begin
                                                       temp_unit = AllNearestUnitToUnit(temp_list,i);
                                                       ComAttackPlace(i,GetX(temp_unit),GetY(temp_unit));

                                                       continue;
                                                  end;
                                        end;
                              
                              {if GetWeapon(i) = ar_selfpropelled_bomb then
                                   k = true  //Blow up everything muhahaha!
                              else
                                   k = false;

                              if not k and not attack_hexes[ai_attacking_unit_hex_index[i]] in init_attack_hexes then
                                   begin
                                        temp_list = FilterAllUnits([[f_side,you],[f_or,[f_btype,b_depot],[f_btype,b_warehouse]]]);  -> AI doesn't only attack the player in this mission

                                        if temp_list > 0 then
                                             begin
                                                  temp_unit = AllNearestUnitToUnit(temp_list,i);
                                                  if GetBType(temp_unit) = b_depot then
                                                       dist = 26  //build distance for depot
                                                  else
                                                       dist = 34; //build distance for warehouse

                                                  k = GetDistUnits(i,temp_unit) <= dist;
                                             end;

                                        if not k then
                                             begin
                                                  temp_list = FilterAllUnits([[f_side,you],[f_type,unit_building]]);
                                                  if temp_list > 0 then
                                                       begin
                                                            temp_unit = AllNearestUnitToUnit(temp_list,i);

                                                            k = GetDistUnits(i,temp_unit) <= 20;
                                                       end;
                                             end;
                                   end;}if GetWeapon(i) = 59 then  //behemoth
                                             k := not ai_attacking_unit_hex_index[i] in behemoth_lineup_hexes_indexes[base]
                                        else
                                             k := not attack_hexes[ai_attacking_unit_hex_index[i]] in init_attack_hexes or ContactTime(GetBaseSide(base)) <= 0$2;
                                 
                              if k then
                                   begin
                                        temp_list = FilterAllUnits([[f_enemy,GetBaseSide(base)],[f_type,unit_human],[f_dist,i,25],[f_see,GetBaseSide(base)]]);
                                        if temp_list > 0 then
                                             begin
                                                  //Finish off dying humans as first priority
                                                  temp_list_2 = UnitFilter(temp_list,[f_not,[f_lives,250]]);
                                                  if temp_list_2 > 0 then
                                                       temp_list = temp_list_2;

                                                  temp_unit = AllNearestUnitToUnit(temp_list,i);
                                                  
                                                  case GetWeapon(i) of
                                                       ar_selfpropelled_bomb: begin
                                                            ComAttackUnit(i,temp_unit);
                                                       end;
                                                       ru_time_lapser: begin
                                                            //Don't go too near. Could be damaged by our own units or caught in the explosion
                                                            //from an implosion vehicle or a dying unit.
                                                            dist = GetDistUnits(i,temp_unit);
                                                            if dist > 8 then
                                                                 ComMoveXY(i,GetX(temp_unit),GetY(temp_unit))
                                                            else
                                                                 if dist < 6 then
                                                                      AI_GetAwayFromXY(i,GetX(temp_unit),GetY(temp_unit),6,false);
                                                       end;
                                                       59: begin  //behemoth
                                                            //Move near to all weapons can fire. Shortest range is gatling gun (10 hexes).
                                                            //Don't move too near, though, since heavy gun and rocket launcher has minimum range.
                                                            dist = GetDistUnits(i,temp_unit);
                                                            if dist > 10 then
                                                                 ComMoveXY(i,GetX(temp_unit),GetY(temp_unit))
                                                            else
                                                                 if dist < 6 then
                                                                      AI_GetAwayFromXY(i,GetX(temp_unit),GetY(temp_unit),6,false);
                                                       end;
                                                       else begin
                                                            if GetLives(temp_unit) > 250 then
                                                                 ComAgressiveMove(i,GetX(temp_unit),GetY(temp_unit))
                                                            else
                                                                 ComAttackUnit(i,temp_unit);
                                                       end;
                                                  end;
                                             end
                                        else
                                             begin
                                                  temp_list = FindNonhumansNearUnit(GetBaseSide(base),i,25,true);
                                                  if temp_list > 0 then
                                                       begin
                                                            temp_unit = AllNearestUnitToUnit(temp_list,i);
                                                           
                                                            case GetWeapon(i) of
                                                                 ar_selfpropelled_bomb: begin
                                                                      ComAttackUnit(i,temp_unit);
                                                                 end;
                                                                 ru_time_lapser: begin
                                                                      //Don't go too near. Could be damaged by our own units or caught in the explosion
                                                                      //from an implosion vehicle or a dying unit.
                                                                      dist = GetDistUnits(i,temp_unit);
                                                                      if dist > 8 then
                                                                           ComMoveXY(i,GetX(temp_unit),GetY(temp_unit))
                                                                      else
                                                                           if dist < 6 then
                                                                                AI_GetAwayFromXY(i,GetX(temp_unit),GetY(temp_unit),6,false);
                                                                 end;
                                                                 59: begin  //behemoth
                                                                      //Move near to all weapons can fire. Shortest range is gatling gun (10 hexes).
                                                                      //Don't move too near, though, since heavy gun and rocket launcher has minimum range.
                                                                      dist = GetDistUnits(i,temp_unit);
                                                                      if dist > 10 then
                                                                           ComMoveXY(i,GetX(temp_unit),GetY(temp_unit))
                                                                      else
                                                                           if dist < 6 then
                                                                                AI_GetAwayFromXY(i,GetX(temp_unit),GetY(temp_unit),6,false);
                                                                 end;
                                                                 else begin
                                                                      ComAgressiveMove(i,GetX(temp_unit),GetY(temp_unit));
                                                                 end;
                                                            end;
                                                       end
                                                  else
                                                       begin
                                                            temp_list = FindNonhumansNearUnit(GetBaseSide(base),i,25,false) diff alien_tower;
                                                            if temp_list > 0 then
                                                                 begin
                                                                      temp_unit = AllNearestUnitToUnit(temp_list,i);

                                                                      case GetWeapon(i) of
                                                                           ar_selfpropelled_bomb: begin
                                                                                ComAttackUnit(i,temp_unit);
                                                                           end;
                                                                           ru_time_lapser: begin
                                                                                //Don't go too near. Could be damaged by our own units or caught in the explosion
                                                                                //from an implosion vehicle or a dying unit.
                                                                                dist = GetDistUnits(i,temp_unit);
                                                                                if dist > 8 then
                                                                                     ComMoveXY(i,GetX(temp_unit),GetY(temp_unit))
                                                                                else
                                                                                     if dist < 6 then
                                                                                          AI_GetAwayFromXY(i,GetX(temp_unit),GetY(temp_unit),6,false);
                                                                           end;
                                                                           59: begin  //behemoth
                                                                                ComAttackUnit(i,temp_unit);
                                                                           end;
                                                                           else begin
                                                                                ComAttackUnit(i,temp_unit);
                                                                           end;
                                                                      end;
                                                                 end
                                                            else
                                                                 k = false;
                                                       end;
                                             end;

                                        if k then  //found something to shoot at
                                             continue;
                                   end;

                              //Movement to enemy base
                              if GetWeapon(i) = 59 then  //behemoth
                                   begin
                                        //if GetDistUnitXY(i,behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][1],behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][2]) > behemoth_dist then -> doesn't work with lineup and not necessary since behemoths don't wait for each other
                                             if not ai_attacking_unit_hex_index[i] in behemoth_lineup_hexes_indexes[base] then
                                                  ComAgressiveMove(i,behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][1],behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][2])
                                             else
                                                  ComMoveXY(i,behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][1],behemoth_attack_hexes[i][ai_attacking_unit_hex_index[i]][2]);
                                   end
                              else
                                   if GetDistUnitXY(i,attack_hexes[ai_attacking_unit_hex_index[i]][1],attack_hexes[ai_attacking_unit_hex_index[i]][2]) > vehicle_dist - 2 then  //Less dist hopefully ensures vehicles won't get stuck
                                        if not attack_hexes[ai_attacking_unit_hex_index[i]] in init_attack_hexes or ContactTime(GetBaseSide(base)) <= 0$2 then
                                             ComAgressiveMove(i,attack_hexes[ai_attacking_unit_hex_index[i]][1],attack_hexes[ai_attacking_unit_hex_index[i]][2])
                                        else
                                             ComMoveXY(i,attack_hexes[ai_attacking_unit_hex_index[i]][1],attack_hexes[ai_attacking_unit_hex_index[i]][2]);
                         end;
               end;

          until false;
     end;     
Export Function FindNonhumansNearUnit(side,un,dist,only_dangerous);
     var weapon_list, temp_list, i, btype, b, val;
     begin
          temp_list = FilterAllUnits([[f_enemy,side],[f_not,[f_type,unit_human]],[f_dist,un,dist],[f_see,side]]);

          if only_dangerous then
               begin
                    result = DangerousUnits(temp_list);
               end
          else
               result = temp_list
     end;
Function DangerousUnits(list);
     var weapon_list, i, btype, b, val;
     begin
          weapon_list = [us_machine_gun,us_light_gun,us_gatling_gun,us_double_gun,us_heavy_gun,us_rocket_launcher,
                                   us_siberium_rocket,us_laser,us_double_laser,
                                   ar_multimissile_ballista,ar_light_gun,ar_double_machine_gun,ar_gatling_gun,
                                   ar_flame_thrower,ar_gun,ar_rocket_launcher,ar_selfpropelled_bomb,
                                   ru_heavy_machine_gun,ru_gatling_gun,ru_gun,ru_rocket_launcher,ru_heavy_gun,
                                   ru_rocket,ru_siberium_rocket,ru_time_lapser];

                    result = [];

                    for i in list do
                         case GetType(i) of
                              unit_human: begin
                                   if not IsOk(i) then  //IsOk does take stimulation drugs into consideration
                                        continue;

                                   result = result ^ i;
                              end;
                              unit_vehicle: begin
                                   if not IsOk(i) then
                                        continue;

                                   case GetControl(i) of
                                        control_manual,control_rider: begin
                                             if UnitsInside(i) = 0 then
                                                  continue;
                                        end;
                                        control_remote: begin
                                             if IsControledBy(i) = 0 then
                                                  continue;
                                        end;
                                        control_computer,control_apeman: begin
                                        end;
                                   end;

                                   if GetWeapon(i) in weapon_list then
                                        result = result ^ i;
                              end;
                              unit_building: begin
                                   if not IsOk(i) then
                                        continue;

                                   btype = GetBType(i);

                                   case btype of
                                        b_turret: begin
                                        end;
                                        b_bunker,b_breastwork,b_armoury,b_barracks,b_fort: begin
                                             if UnitsInside(i) = 0 then
                                                  continue;
                                        end;
                                        else
                                             continue;
                                   end;

                                   if btype in [b_bunker,b_turret] then
                                        if not GetBWeapon(i) in weapon_list then
                                             continue
                                        else
                                             begin
                                                  b = GetBase(i);
                                                  val = false;

                                                  if b = 0 then
                                                       val = true
                                                  else
                                                       if GetEnergy(b)[4] = 0 then
                                                            val = true;

                                                  if val then
                                                       continue;
                                             end;

                                   result = result ^ i;
                              end;
                         end;
     end;


//The computers's vehicles never seem to run completely out of fuel...
Every 0$5 do
     var base, i;
     begin
          for base in ai_bases do
               for i in (ai_vehicles_attack[base] ^ ai_vehicles_defend[base] ^ ai_cargo_bay[base] ^ ai_crane[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_control_tower_vehicles[base] ^ ai_sib_bomb_vehicles[base]) diff 0 do
                    if GetFuel(i) < 10 and GetEngine(i) = engine_combustion then
                         SetFuel(i,10);

          enable;
     end;


//Another cheat. The entrance to the major Russian base is narrow so outgoing and incoming vehicles may block for
//each other. Instead of doing some fancy routing of vehicles we cheat. If a vehicle gets stuck in this area
//and is trying to get into the base then "teleport" it into the base.
Every 0$1.4 do
     var base, i, val, area, un;
     var veh_hex_map;
     begin
          base = 1;
          veh_hex_map = [];  //Index is vehicle id, value is hex and time

          repeat
          wait(0$1);

          for base in ai_bases do
          begin

          if not base in [1,4] then
               continue;

          case base of
               1: area = ru_veh_stuck_area;
               4: area = am_veh_stuck_area;
          end;

          for i in (ai_vehicles_attack[base] ^ ai_vehicles_defend[base] ^ ai_cargo_bay[base] ^ ai_crane[base] ^ ai_taufield_vehicles[base] ^ ai_implosion_vehicles[base] ^ ai_control_tower_vehicles[base]) diff 0 do  //Don't include siberite bomb vehicles - they never get stuck and will stand at the same spot for some time to fire their rocket
               begin
                    val = false;
                    if veh_hex_map < i then
                         val = true
                    else
                         if veh_hex_map[i] = 0 then
                              val = true;

                    if val then
                         veh_hex_map = Replace(veh_hex_map,i,[0,0,0$0]);

                    if IsInArea(i,area) then
                         begin
                              if veh_hex_map[i][1] = 0 and veh_hex_map[i][2] = 0 then
                                   veh_hex_map = Replace(veh_hex_map,i,[GetX(i),GetY(i),0$0])
                              else
                                   if GetDistUnitXY(i,veh_hex_map[i][1],veh_hex_map[i][2]) > 2 then
                                        veh_hex_map = Replace(veh_hex_map,i,[GetX(i),GetY(i),0$0])
                                   else
                                        begin
                                             veh_hex_map = Replace(veh_hex_map,i,[veh_hex_map[i][1],veh_hex_map[i][2],veh_hex_map[i][3]+0$1]);

                                             if veh_hex_map[i][3] >= 0$8 and not See(you,i) then  //vehicle is stuck (and the player is not looking)
                                                  begin
                                                       val = GetTaskList(i);

                                                       if val = 0 then  //Just standing there...
                                                            begin
                                                                 veh_hex_map = Replace(veh_hex_map,i,[GetX(i),GetY(i),0$0]);
                                                            end
                                                       else
                                                            begin
                                                                 if val[1][2] = 0 and val[1][3] = 0 then  //bad task
                                                                      begin
                                                                           veh_hex_map = Replace(veh_hex_map,i,[GetX(i),GetY(i),0$0]);
                                                                      end
                                                                 else
                                                                      if not InArea(val[1][2],val[1][3],GetBaseArea(base)) then  //not headed into the base
                                                                           begin
                                                                                veh_hex_map = Replace(veh_hex_map,i,[GetX(i),GetY(i),0$0]);
                                                                           end
                                                                      else
                                                                           begin
                                                                                //Do "teleport"
                                                                                RemoveUnit(i);

                                                                                if not PlaceUnitXYR(i,val[1][2],val[1][3],7,false) then  //couldn't place the unit again
                                                                                     begin
                                                                                          un = UnitsInside(i);
                                                                                          if un > 0 then
                                                                                               begin
                                                                                                    RemoveHumanFromVariables(base,un[1],true);
                                                                                                    DestroyUnit(un[1]);
                                                                                               end;

                                                                                          RemoveVehicleFromVariables(base,i);
                                                                                          DestroyUnit(i);
                                                                                     end;

                                                                                veh_hex_map = Replace(veh_hex_map,i,[0,0,0$0]);  //reset
                                                                           end;
                                                            end;
                                                  end;
                                        end;
                         end
                    else
                         begin
                              veh_hex_map = Replace(veh_hex_map,i,[0,0,0$0]);  //reset
                         end;
               end;
          end;

          until false;
     end;


//Automatic cargo bay
Every 0$1+0$0.5 do
     var base, area_list, area, c, temp_list, crates_list, b, temp_value;
     var refueling;
     begin
          refueling = [false,false,false,false];

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    if ai_cargo_bay[base] = 0 then
                         continue;

                    //If cargo bay is damaged and inside the base then do nothing (mechanics will repair it).
                    //If cargo bay is outside the base and somewhat damaged then pull back to base.
                    temp_value = GetLives(ai_cargo_bay[base]);

                    area = GetBaseArea(base);

                    if IsInArea(ai_cargo_bay[base],area) then
                         begin
                              if temp_value < 1000 then
                                   continue;
                         end
                    else
                         if temp_value < 600 then
                              begin
                                   if IsLive(ai_depot[base]) then
                                        ComGive(ai_cargo_bay[base],ai_depot[base])
                                   else
                                        ComMoveXY(ai_cargo_bay[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);

                                   continue;
                              end;

                    //Refuel if necessary
                    if GetEngine(ai_cargo_bay[base]) = engine_combustion then
                         begin
                              c = GetFuel(ai_cargo_bay[base]);
                              if c > 90 or not IsOk(ai_depot[base]) then
                                   refueling = Replace(refueling,base,false)
                              else
                                   if c < 25 or refueling[base] then
                                        begin
                                             ComMoveUnit(ai_cargo_bay[base],ai_depot[base]);
                                             AddComRefuel(ai_cargo_bay[base],ai_depot[base]);
                                             refueling = Replace(refueling,base,true);

                                             continue;
                                        end;
                         end;

                    //Determine which areas to check for crates
                    case base of
                         1: area_list = [ru_crate_area];
                         2: area_list = [alli_crate_area];
                         3: area_list = [ar_crate_area];
                         4: area_list = [am_crate_area];
                    end;

                    //Check for crates in the areas
                    crates_list = [];
                    for b in area_list do
                         begin
                              crates_list = crates_list ^ GetListOfCratesInArea_ForGathering(base,b);
                         end;

                    //If there are any crates then collect them - else stay inside the base.
                    if crates_list > 0 and ai_depot[base] > 0 then
                         begin
                              //find the closest crate
                              temp_list = [];
                              for c in crates_list do
                                   temp_list = temp_list ^ GetDistUnitXY(ai_cargo_bay[base],c[1],c[2]);
                              temp_list = WorstFromListByList(crates_list,temp_list);

                              ComCollect(ai_cargo_bay[base],temp_list[1],temp_list[2]);
                         end
                    else
                         if IsOk(ai_depot[base]) and Carry(ai_cargo_bay[base]) then
                              ComGive(ai_cargo_bay[base],ai_depot[base])
                         else
                              if not IsInArea(ai_cargo_bay[base],area) then
                                   if IsOk(ai_depot[base]) then
                                        ComGive(ai_cargo_bay[base],ai_depot[base])
                                   else
                                        ComMoveXY(ai_cargo_bay[base],ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
               end;

          until false;
     end;


//Scientists
//If a scientist is wounded them pull him/her back. Else heal what people needs healing. Else stay inside a lab (if no lab is Ok then help
//construct buildings).
Every 0$1+0$0.7 do
     var side, i, scientists_list, temp_list, temp_unit, base, k, temp_list_3, area;
     begin

          repeat
          if ai_bases = 0 then
               exit;

          wait(0$1 mod (ai_bases+0));

          for base in ai_bases do
               begin
                    wait(0$1 div (ai_bases+0));

                    side = GetBaseSide(base);

                    scientists_list = ai_scientists[base] diff ai_heal_these_humans[base];


                    //Identify scientists who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= scientists_list do
                         begin
                              if GetLives(scientists_list[i]) <= 700 then
                                   begin
                                        temp_list = temp_list ^ scientists_list[i];
                                        scientists_list = Delete(scientists_list,i);
                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Update people who need healing. People at full HP or people inside a unit (relevant for soldiers and mechanics)
                    //will not receive healing.
                    temp_list = [];
                    for i in ai_heal_these_humans[base] do
                         if GetLives(i) < 1000 and IsInUnit(i) = 0 then
                              temp_list = temp_list ^ i;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Control people who need healing. Make 'em retreat to the human pullback hex.
                    for i in ai_heal_these_humans[base] do
                         begin
                              if GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 4 then
                                   ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                         end;


                    if scientists_list = 0 then
                         continue;


                    //Heal people. At least one scientist for each human if possible.
                    //Only heal people inside the base.
                    if ai_heal_these_humans[base] > 0 then
                         begin
                              area = GetBaseArea(base);
                              temp_list = UnitFilter(ai_heal_these_humans[base],[f_inarea,area]);

                              if temp_list > 0 then
                                   begin
                                        scientists_list = GetHumansOutOfUnits(scientists_list);

                                        if base = 2 and alliance_deal_status = 2 then  //If the player cooperates with The Alliance we need the main characters to stay alive so just stay inside a lab.
                                             begin
                                                  temp_list_3 = UnitFilter([Joan,Roth,Gossudarov],[f_alive]);
                                                  scientists_list = scientists_list diff temp_list_3;
                                             end
                                        else
                                             temp_list_3 = [];

                                        repeat
                                             i = 1;
                                             while i <= temp_list do
                                                  begin
                                                       if scientists_list = 0 then
                                                            break;

                                                       temp_unit = NearestUnitToUnit(scientists_list,temp_list[i]);
                                                       ComHeal(temp_unit,temp_list[i]);
                                                       scientists_list = scientists_list diff temp_unit;

                                                       i = i + 1;
                                                  end;

                                        until scientists_list = 0;

                                        scientists_list = temp_list_3;
                                   end;
                         end;


                    //Enter and stay in lab
                    DistributeHumansToBuildings(base,scientists_list, UnitFilter(ai_labs[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_scientistic,6,true,false);
               end;

          until false;
     end;
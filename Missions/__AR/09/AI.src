

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//This AI module contains DoNotAttack commands here and there. If you copy this module
//for use in another mission you should consider removing these function invocations.
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//Russians have unlimited resources
Every 0$10 do
     var base;
     begin
          if IsLive(ai_depot[1]) and GetSide(ai_depot[1]) = russians then
               begin
                    base = GetBase(ai_depot[1]);
                    SetResourceType(base,mat_cans,300);
                    SetResourceType(base,mat_oil,0);
                    SetResourceType(base,mat_siberit,300);
               end;

          if IsLive(depot_north) and GetSide(depot_north) = russians then
               begin
                    base = GetBase(depot_north);
                    SetResourceType(base,mat_cans,150);
                    SetResourceType(base,mat_oil,300);
                    SetResourceType(base,mat_siberit,0);
               end;

          enable;
     end;


On UnitDestroyed(un) do
     var side, temp_list, base;
     begin
          if un = Heike then
               begin
                    ExclusiveOn;
                    Wait(0$1);
                    YouLost('HeikeDead');
                    ExclusiveOff;
               end;
          if un = the_archive then
               begin
                    if num_documents_stolen >= 20 then
                         exit;

                    ExclusiveOn;
                    wait(0$1);
                    YouLost('ArchiveDestroyed');
                    ExclusiveOff;
               end;

          for base in ai_bases do
               begin
                    temp_list = ai_captured_buildings[base] diff un;
                    ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
               end;

          side = GetSide(un);

          if side = russians_alt and GetType(un) = unit_vehicle and GetWeapon(un) = ru_cargo_bay then
               begin
                    num_sabotaged_cargo_bays = num_sabotaged_cargo_bays + 1;

                    if num_sabotaged_cargo_bays = 3 then
                         ChangeMissionObjectives('MOutSabotage');
               end;

          if side <> russians then
               exit;

          //Update computer variables
          case GetType(un) of
               unit_human:
                    for base in ai_bases do
                         RemoveHumanFromVariables(base,un,true);
               unit_vehicle:
                    for base in ai_bases do
                         RemoveVehicleFromVariables(base,un);
               unit_building:
                    for base in ai_bases do
                         RemoveBuildingFromVariables(base,un);
          end;
     end;
Function RemoveBuildingFromVariables(base,building);
     var temp_list;
     begin
          temp_list = ai_all_buildings[base] diff building;
          ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

          if building = ai_building_under_construction[base] then
               ai_building_under_construction = Replace(ai_building_under_construction,base,0);

          UpdateBuildingBasicVariables(base,building,false);
     end;
Export Function RemoveVehicleFromVariables(base,vehicle);
     var temp_list;
     begin
          //Global "basis" lists of vehicles. If a vehicle belong to this base it will be in one
          //and only one of these lists.
          if vehicle in ai_vehicles_defend[base] then
               begin
                    temp_list = ai_vehicles_defend[base] diff vehicle;
                    ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
               end;

          if vehicle in ai_vehicles_attack[base] then
               begin
                    temp_list = ai_vehicles_attack[base] diff vehicle;
                    ai_vehicles_attack = Replace(ai_vehicles_attack,base,temp_list);
               end;

          if vehicle = ai_cargo_bay[base] then
               ai_cargo_bay = Replace(ai_cargo_bay,base,0);


          //Global "transient" lists of vehicles. Vehicles belonging to this base may be in one or more of these lists if
          //it performs a special or temporary job (you could say that the vehicle is in a special state).
          if vehicle in ai_retreating_vehicles_defend[base] then
               begin
                    temp_list = ai_retreating_vehicles_defend[base] diff vehicle;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);
               end;

          if vehicle in ai_vehicles_being_repaired[base] then
               begin
                    temp_list = ai_vehicles_being_repaired[base] diff vehicle;
                    ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);
               end;

          if vehicle in ai_refuel_vehicles_list[base] then
               begin
                    temp_list = ai_refuel_vehicles_list[base] diff vehicle;
                    ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);
               end;

          if vehicle = ai_vehicle_being_moved[base] then
               ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);

          if vehicle in ai_vehicles_having_been_moved[base] then
               begin
                    temp_list = ai_vehicles_having_been_moved[base] diff vehicle;
                    ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,temp_list);
               end;
     end;
Export Function RemoveHumanFromVariables(base,human,check_if_base_is_dead);
     var temp_list;
     begin        
          //Global "basis" lists of humans. If a human belong to this base he/she will be in one
          //and only one of these lists.
          if human in ai_soldiers[base] then
               begin
                    temp_list = ai_soldiers[base] diff human;
                    ai_soldiers = Replace(ai_soldiers,base,temp_list);
               end;

          if human in ai_attacking_soldiers[base] then
               begin
                    temp_list = ai_attacking_soldiers[base] diff human;
                    ai_attacking_soldiers = Replace(ai_attacking_soldiers,base,temp_list);
               end;

          if human in ai_engineers[base] then
               begin
                    temp_list = ai_engineers[base] diff human;
                    ai_engineers = Replace(ai_engineers,base,temp_list);
               end;

          if human in ai_apemen_engineers[base] then
               begin
                    temp_list = ai_apemen_engineers[base] diff human;
                    ai_apemen_engineers = Replace(ai_apemen_engineers,base,temp_list);
               end;

          if human in ai_mechanics_defend[base] then
               begin
                    temp_list = ai_mechanics_defend[base] diff human;
                    ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
               end;

          if human in ai_mechanics_attack[base] then
               begin
                    temp_list = ai_mechanics_attack[base] diff human;
                    ai_mechanics_attack = Replace(ai_mechanics_attack,base,temp_list);
               end;

          if human in ai_scientists[base] then
               begin
                    temp_list = ai_scientists[base] diff human;
                    ai_scientists = Replace(ai_scientists,base,temp_list);
               end;

          if human in ai_attacking_scientists[base] then
               begin
                    temp_list = ai_attacking_scientists[base] diff human;
                    ai_attacking_scientists = Replace(ai_attacking_scientists,base,temp_list);
               end;


          //Global "transient" lists of humans. Humans belonging to this base may be in one or more of these lists if
          //he/she performs a special or temporary job (you could say that the human is in a special state).
          if human in ai_heal_these_humans[base] then
               begin
                    temp_list = ai_heal_these_humans[base] diff human;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
               end;

          if human = ai_building_constructor[base] then
               ai_building_constructor = Replace(ai_building_constructor,base,0);

          if human in ai_retreating_attacking_humans[base] then
               begin
                    temp_list = ai_retreating_attacking_humans[base] diff human;
                    ai_retreating_attacking_humans = Replace(ai_retreating_attacking_humans,base,temp_list);
               end;

          //If there are no human units left the base is "dead"
          if check_if_base_is_dead then
               if ((ai_soldiers[base] ^ ai_attacking_soldiers[base] ^ ai_engineers[base] ^ ai_apemen_engineers[base] ^ ai_mechanics_defend[base] ^ ai_mechanics_attack[base] ^ ai_scientists[base] ^
                   ai_attacking_scientists[base]) diff 0) = 0 then
                    ai_bases = ai_bases diff base;
     end;


Function FindBase(un);
     begin
          result = 1;
     end;

Function GetBaseSide(base);
     begin
          result = russians;
     end;

Function GetBaseArea(base);
     begin
          result = ru_base_area;
     end;


//Soldiers
//Keep them in bunkers/armouries. If that's not possible due to structure restrictions then help construct buildings. Else retreat to
//the center of the base.
//If the base is in code black choose a handful of soldiers to attack the intruders.
Every 0$1 do
     var side, i, temp_list, buildings_list, soldiers_list, temp_unit, base, val, temp_list_2, temp_unit_2, j, leave_folks_for_defences, num_sol;
     var temp_list_3, bunkers;
     begin
          side = russians;

          for base in ai_bases do
               begin
                    soldiers_list = ai_soldiers[base];


                    soldiers_list = soldiers_list diff sol_office_to_archive;
                    soldiers_list = soldiers_list diff entrance_guard_to_office;
                    soldiers_list = soldiers_list diff workshop_messenger;

                    if except_Dmitri then
                         soldiers_list = soldiers_list diff Dmitri;

                    if except_Yefibachev then
                         soldiers_list = soldiers_list diff Yefibachev;


                    //Identify soldiers who need healing.
                    temp_list = ai_heal_these_humans[base];
                    for i in soldiers_list diff ai_heal_these_humans[base] do
                         if GetLives(i) < 800 then
                              temp_list = temp_list ^ i;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);

                    if not code_black then  //Soldiers don't care if they are wounded if the base is in code black
                         begin
                              //Make soldiers needing healing go outside (else they won't be healed, cf. the healing
                              //code (controlling scientists) below.
                              for i in ai_heal_these_humans[base] do
                                   if i in soldiers_list then
                                        case GetType(IsInUnit(i)) of
                                             unit_vehicle: ComExitVehicle(i);
                                             unit_building: ComExitBuilding(i);
                                        end;

                              soldiers_list = soldiers_list diff ai_heal_these_humans[base];
                              code_black_soldiers = [];
                         end;


                    if code_black then
                         begin
                              //Find the soldiers for code black assault if we haven't already
                              if code_black_soldiers = 0 then
                                   begin
                                        //At least a certain number of soldiers.
                                        //There are 4 defensive buildings all in all (the armoury, the barracks and
                                        //two breastworks). If there are going to be at least 4 soldiers left then
                                        //avoid taking soldiers which would leave a defensive building empty.
                                        num_sol = [6,7,8][difficulty];
                                        leave_folks_for_defences = soldiers_list - num_sol >= 4;

                                        //Always patrolling guards and the boys at the weapon testing area - we give them high priority
                                        //by putting them in the beginning of the list.
                                        //Yefibachev has lowest priority.
                                        //Don't pick any of the entrance guards if the entrance dialogue hasn't been played (and can
                                        //be played).
                                        soldiers_list = UnitFilter([good_pat,bad_pat,Dmitri,Sergei,Yann],[f_alive]) ^ (soldiers_list diff [Dmitri,Sergei,Yann,good_pat,bad_pat]);
                                        soldiers_list = (soldiers_list diff Yefibachev) ^ UnitFilter(Yefibachev,[f_alive]);

                                        temp_list_3 = [];
                                        if not entrance_guard_dialogue_played and heike_undercover in [0,2] then
                                             for i in ai_bunkers[1] do
                                                  temp_list_3 = temp_list_3 ^ UnitsInside(i);

                                        if leave_folks_for_defences then
                                             begin
                                                  temp_list = [];  //how many folks inside
                                                  temp_list_2 = [];  //what buildings
                                                  for val in ai_armouries[1] do
                                                       begin
                                                            temp_list = temp_list ^ (UnitsInside(val)+0);
                                                            temp_list_2 = temp_list_2 ^ val;
                                                       end;
                                                  for val in ai_bunkers[1] do
                                                       begin
                                                            temp_list = temp_list ^ (UnitsInside(val)+0);
                                                            temp_list_2 = temp_list_2 ^ val;
                                                       end;
                                             end;

                                        for i = 1 to num_sol do
                                             begin
                                                  temp_unit = 0;
                                                  for val in soldiers_list do
                                                       begin
                                                            if val in temp_list_3 then
                                                                 continue;

                                                            if leave_folks_for_defences then
                                                                 begin
                                                                      temp_unit_2 = IsInUnit(val);

                                                                      if temp_unit_2 > 0 and temp_unit_2 in temp_list_2 then
                                                                           begin
                                                                                for j = 1 to temp_list do
                                                                                     if temp_unit_2 = temp_list_2[j] then
                                                                                          begin
                                                                                               if temp_list[j] > 1 then
                                                                                                    begin
                                                                                                         temp_unit = val;
                                                                                                         temp_list = Replace(temp_list,j,temp_list[j]-1);
                                                                                                    end;

                                                                                               break;
                                                                                          end;
                                                                           end
                                                                      else
                                                                           temp_unit = val;
                                                                 end
                                                            else
                                                                 temp_unit = val;

                                                            if temp_unit > 0 then
                                                                 break;
                                                       end;

                                                  if temp_unit > 0 then
                                                       begin
                                                            code_black_soldiers = code_black_soldiers ^ temp_unit;
                                                            soldiers_list = soldiers_list diff temp_unit;
                                                       end
                                                  else
                                                       break;
                                             end;
                                   end;

                              soldiers_list = soldiers_list diff code_black_soldiers;

                              temp_list = [];
                              for i in patrols do
                                   temp_list = temp_list ^ i;

                              code_black_soldiers = code_black_soldiers diff temp_list;


                              //Control the soldiers.
                              ControlCodeBlackUnits(GetHumansOutOfUnits(code_black_soldiers));
                         end;


                    if soldiers_list = 0 then
                         continue;


                    //Yefibachev is (almost) always inside his office.
                    if Yefibachev in soldiers_list and IsOk(leader_office) then
                         begin
                              temp_unit = IsInUnit(Yefibachev);
                              case GetType(temp_unit) of
                                   unit_vehicle: ComExitVehicle(Yefibachev);
                                   unit_building:
                                        if temp_unit <> leader_office then
                                             ComExitBuilding(Yefibachev);
                                   else
                                        ComEnterUnit(Yefibachev,leader_office);
                              end;

                              soldiers_list = soldiers_list diff Yefibachev;
                         end;


                    //The three guys at the weapon testing area hangs out there unless they are patrolling or the
                    //base is in code black.
                    //If just one of them is dead then they act like normal soldiers.
                    //The hex where they gather must be the same as the one used in the every controlling the
                    //event with these guys in module "OtherEvents".
                    if not code_black and (soldiers_list diff [Dmitri,Sergei,Yann])+0 = soldiers_list - 3 then
                         begin
                                        temp_list = [[58,12],[60,13],[59,14]];
                                        temp_list_2 = [Dmitri,Sergei,Yann];
                                        for i = 1 to temp_list_2 do
                                             if not IsAt(temp_list_2[i],temp_list[i][1],temp_list[i][2]) then
                                                  case GetType(IsInUnit(temp_list_2[i])) of
                                                       unit_vehicle: ComExitVehicle(temp_list_2[i]);
                                                       unit_building: ComExitBuilding(temp_list_2[i]);
                                                       else
                                                            begin
                                                                 ComMoveXY(temp_list_2[i],temp_list[i][1],temp_list[i][2]);
                                                                 AddComTurnXY(temp_list_2[i],59,13);
                                                            end;
                                                  end;

                              soldiers_list = soldiers_list diff [Dmitri,Sergei,Yann];
                         end;

                    //The soldier playing poker should be in the main depot unless the base is
                    //in code black.
                    if not code_black and poker_sol in soldiers_list and IsOk(ai_depot[base]) then
                         begin
                              temp_unit = IsInUnit(poker_sol);
                              case GetType(temp_unit) of
                                   unit_vehicle: ComExitVehicle(poker_sol);
                                   unit_building:
                                        if temp_unit <> ai_depot[base] then
                                             ComExitBuilding(poker_sol);
                                   else
                                        ComEnterUnit(poker_sol,ai_depot[base]);
                              end;

                              soldiers_list = soldiers_list diff poker_sol;
                         end;

                    //The two guards patrolling the base are controlled below. They only break their rutine if
                    //the base is in code black or one of them dies.
                    if not terminate_internal_patrol then
                         begin
                              if not code_black and (soldiers_list diff [good_pat,bad_pat])+0 = soldiers_list - 2 then
                                   begin
                                        soldiers_list = soldiers_list diff [good_pat,bad_pat];

                                        if halt_internal_patrol = 1 then
                                             halt_internal_patrol = 0;
                                   end
                              else if IsDead(good_pat) or IsDead(bad_pat) then
                                   terminate_internal_patrol = true
                              else halt_internal_patrol = 1;
                         end;


                    //Find the bunkers which need to be occupied.
                    //Remember which soldiers are already inside a building.
                    //Don't occupy b_bunker if there is no power.
                    i = false;
                    if IsOk(ai_depot[base]) then
                         if GetEnergy(GetBase(ai_depot[base]))[4] > 0 then
                              i = true;

                    if i then
                         bunkers = ai_bunkers[base]
                    else
                         begin
                              bunkers = [];
                              for i in ai_bunkers[base] do
                                   if GetBType(i) = b_breastwork then
                                        bunkers = bunkers ^ i;
                         end;

                    buildings_list = [];
                    for i in UnitFilter(bunkers,[f_ok]) do
                         begin
                              temp_unit = UnitsInside(i);
                              if temp_unit = 0 then
                                   buildings_list = buildings_list ^ i
                              else soldiers_list = soldiers_list diff temp_unit;
                         end;


                    //Stanimir should occupy one of the breastworks. If he's dead just let
                    //some other guy take the place (needs to be male for the dialogue to fit).
                    temp_list = UnitFilter(Stanimir,[f_alive]);
                    for i in temp_list do
                         begin
                              if buildings_list = 0 then
                                   break;

                              if not i in soldiers_list then  //either already in breastwork or being healed
                                   continue;

                              val = buildings_list[1];
                              buildings_list = Delete(buildings_list,1);  //building is reserved for this unit
                              soldiers_list = soldiers_list diff i;

                              temp_unit = IsInUnit(i);
                              case GetType(temp_unit) of
                                   unit_vehicle: ComExitVehicle(i);
                                   unit_building:
                                        if temp_unit <> val then  
                                             ComExitBuilding(i);
                                   else
                                        ComEnterUnit(i,val);
                              end;
                         end;

                    if buildings_list > 0 then
                         begin
                              temp_list = [];
                              for i in soldiers_list do
                                   if GetSex(i) = sex_male then
                                        temp_list = temp_list ^ i;

                              //If there aren't enough males we have to spawn some, but only if Heike has not gone undercover and can
                              //go undercover (it's just so the dialogue at the entrance is ensured).
                              if not entrance_guard_dialogue_played and heike_undercover in [0,2] then
                                   for i = 1 to buildings_list - temp_list do
                                        begin
                                             temp_unit = CreateUnitsWithClass(1,class_soldier,sex_male,'',side)[1];
                                             PlaceUnitXYR(temp_unit,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2],4,false);
                                             DoNotAttack(you,temp_unit);

                                             temp_list_2 = ai_soldiers[base] ^ temp_unit;
                                             ai_soldiers = Replace(ai_soldiers,base,temp_list_2);

                                             temp_list = temp_list ^ temp_unit;
                                             soldiers_list = soldiers_list ^ temp_unit;
                                        end;

                              for i = 1 to buildings_list do
                                   begin
                                        if temp_list = 0 then
                                             break;

                                        temp_unit = temp_list[1];
                                        ComEnterUnit(temp_unit,buildings_list[i]);

                                        temp_list = Delete(temp_list,1);
                                        soldiers_list = soldiers_list diff temp_unit;
                                   end;
                         end;


                    //The rest enter armouries (if possible)
                    DistributeHumansToBuildings(base,soldiers_list, UnitFilter(ai_armouries[base],[[f_ok],[f_not,[f_constructed]]]),
                         false,6,true,true);
               end;

          enable;
     end;

//Function which controls behaviour of code black units (soldiers and war vehicles).
//Attack enemy units near the base - spread equally and take them all on. Not Heike if she is undercover.
//If there are player units inside Russian buildings then camp the buildings - they gotta exit sometime...
//If no humans are present then destroy empty player vehicles in the base.
//If none are present go to the center of the base.
Function ControlCodeBlackUnits(un_list);
     var i, enemy_units, side, base, unit_building_tag, groups, temp_list, j, x, y, dir;
     begin
          side = russians;
          base = 1;

          //The player can steal a Russian vehicle so player humans can be inside vehicles. Filter [f_see,side] for humans doesn't work
          //if the human is inside a vehicle so we have to ask if the Russians can see the vehicle the humans is inside instead.
          unit_building_tag = [];
          enemy_units = [];
          for i in FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_distxy,ai_buildings_locations[base][1][1],ai_buildings_locations[base][1][2],50]]) do
               begin
                    j = IsInUnit(i);
                    if j = 0 then
                         j = i;

                    if See(side,j) {or IsInArea(j,ru_base_area)} then
                         enemy_units = enemy_units ^ i;
               end;

          for i in enemy_units do
               unit_building_tag = Replace(unit_building_tag,i,0);  //not in building

          for i in player_units_in_russian_buildings do
               begin
                    enemy_units = enemy_units ^ i[1];
                    unit_building_tag = Replace(unit_building_tag,i[1],i[2]);
               end;

          if heike_undercover = 2 then
               enemy_units = enemy_units diff Heike;

          //Sort the list so if a player unit enters a building during a fight the same Russian units
          //will camp the building.
          if enemy_units > 0 then
               enemy_units = SortListByListAsc(enemy_units,enemy_units);

          if enemy_units = 0 then
               begin
                    enemy_units = FilterAllUnits([[f_side,you],[f_type,unit_vehicle],[f_not,[f_weapon,ru_cargo_bay]],[f_inarea,ru_base_area]]);
                    if enemy_units > 0 then
                         begin
                              //All just go for the same vehicle.
                              for i in un_list do
                                   ComAttackUnit(i,enemy_units[1]);
                         end
                    else
                         for i in un_list do
                              if GetDistUnitXY(i,last_known_enemy_hex[1],last_known_enemy_hex[2]) > 6 then
                                   ComAgressiveMove(i,last_known_enemy_hex[1],last_known_enemy_hex[2]);
               end
          else
               begin
                    last_known_enemy_hex = [GetX(enemy_units[1]),GetY(enemy_units[1])];

                    //Group the units
                    groups = [];
                    i = enemy_units+0;

                    while i > 0 do
                         begin
                              temp_list = [];
                              for j = 1 to un_list div i do
                                   temp_list = temp_list ^ un_list[j];

                              un_list = un_list diff temp_list;

                              groups = groups ^ [temp_list];
                              i = i - 1;
                         end;
  
                    //Engage the enemy
                    for i = 1 to enemy_units do
                         begin
                              if unit_building_tag[enemy_units[i]] = 0 then  //not in building
                                   begin
                                        x = GetX(enemy_units[i]);
                                        y = GetY(enemy_units[i]);

                                        for j in groups[i] do
                                             ComAgressiveMove(j,x,y);
                                   end
                              else
                                   begin
                                        x = GetX(unit_building_tag[enemy_units[i]]);
                                        y = GetY(unit_building_tag[enemy_units[i]]);
                                        dir = GetDir(unit_building_tag[enemy_units[i]]);

                                        x = ShiftX(x,dir,4);
                                        y = ShiftY(y,dir,4);

                                        for j in groups[i] do
                                             if GetDistUnitXY(j,x,y) > 4 then
                                                  ComAgressiveMove(j,x,y);
                                   end;
                         end;
               end;
     end;

//Every controlling the two patrols in the Russian base.
//The variable "halt_internal_patrol" can halt this every if necessary. It halts automatically if the
//base is in code black. The every terminates if "terminate_internal_patrol" turns true.
//If either of the guards die this every terminates and the remaining guard (if any) becomes and ordinary soldier.
//The guards patrol from north to east to south and back to north (or the reverse of that) taking small breaks
//when reaching the edge of the base.
Every 0$1+0$0.1 do
     var path, north, east, south, val, temp_list, temp_list_2, where_are_we_now_index, break_start_tick, break_started;
     begin
          path = [];
          north = [48,10];
          east = [90,30];
          south = [69,58];

          //Randomize the path
          temp_list = [1,2,3];
          while temp_list > 0 do
               begin
                    temp_list_2 = temp_list;
                    val = temp_list_2[Rand(1,temp_list_2)];
                    temp_list = temp_list diff val;

                    case val of
                         1: path = path ^ [north];
                         2: path = path ^ [east];
                         3: path = path ^ [south];
                    end;
                    path = path ^ [ai_human_pullback_hex[1]];
               end;

          where_are_we_now_index = 1;
          break_started = false;
          break_start_tick = 0;

          repeat
               wait(0$0.5);
               if terminate_internal_patrol then
                    exit;

               if code_black or halt_internal_patrol > 0 then
                    continue;

               //Move to the hex. If the guards are too spread then one will go closer to
               //the other one (always the same one to avoid conflicts where they try to get around
               //buildings different ways and such after a code black).
               //When we reach the "corners" (odd indexes) we take a break for a while.
               if break_started then
                    begin
                         if tick - break_start_tick >= [0$15,0$10,0$5][difficulty] then
                              begin
                                   break_started = false;
                                   where_are_we_now_index = where_are_we_now_index + 1;  //can't go out of bounds here
                              end
                         else
                              begin
                                   ComTurnUnit(good_pat,bad_pat);
                                   ComTurnUnit(bad_pat,good_pat);
                              end;
                    end
               else
                    begin
                         if GetDistUnitXY(bad_pat,path[where_are_we_now_index][1],path[where_are_we_now_index][2]) <= 2 then
                              begin
                                   if where_are_we_now_index mod 2 = 0 then  //at middle of the base
                                        begin
                                             where_are_we_now_index = where_are_we_now_index + 1;
                                             if where_are_we_now_index > path then
                                                  where_are_we_now_index = 1;  //start over again
                                        end
                                   else  //at end points. Time for a break
                                        begin
                                             break_started = true;
                                             break_start_tick = tick;
                                        end;
                              end
                         else
                              begin
                                   if GetDistUnits(good_pat,bad_pat) > 3 then
                                        begin
                                             //Moving directly to the hex where another human stands causes the moving human
                                             //to stop 3-4 hexes away, for some reason.
                                             val = AI_InvertDirection(GetDir(bad_pat));
                                             ComMoveXY(good_pat,ShiftX(GetX(bad_pat),val,1),ShiftY(GetY(bad_pat),val,1));
                                             ComHold(bad_pat);
                                        end
                                   else
                                        ComAgressiveMove([good_pat,bad_pat],path[where_are_we_now_index][1],path[where_are_we_now_index][2]);
                              end;
                    end;

          until false;
     end;

//Function which creates a patrol path through the map used for searching for intruders in the area.
//reverse - true if the path should be reversed (starting with the last hex, then the second last and so on).
//CF. explanation of variable "patrols_subpaths" in module "MAIN".
Export Function CreatePatrolPath(reverse);
     var possible_subpaths, subpaths_allowed, the_path, i, temp_list;
     begin
          the_path = [];
          subpaths_allowed = [1000];

          while subpaths_allowed > 0 do
               begin
                    possible_subpaths = [];
                    for i in patrols_subpaths do
                         if i[1] in subpaths_allowed then
                              possible_subpaths = possible_subpaths ^ [i];

                    if possible_subpaths = 0 then  //should never happen
                         break
                    else
                         begin
                              temp_list = possible_subpaths[Rand(1,possible_subpaths)];

                              //Remove the path ID and fetch the path IDs this path may lead to (and remove those too so we get
                              //a clean list with only coordinates).
                              temp_list = Delete(temp_list,1);  //Path ID for this path
                              subpaths_allowed = temp_list[1];
                              temp_list = Delete(temp_list,1);

                              the_path = the_path ^ temp_list;
                         end;
               end;

          if reverse then
               begin
                    temp_list = [];
                    for i = the_path+0 downto 1 do
                         temp_list = temp_list ^ [the_path[i]];
                    the_path = temp_list;
               end;

          result = the_path;
     end;


//Attacking humans (patrols).
//The patrol route is expected to be specified when a patrol is created.
//The patrol dissolves itself when it reaches the end of its patrol route.
Every 0$1+0$0.8 do
     var side, i, temp_value, base, temp_list, attack_hexes, temp_unit, temp_list_2, k, turn, attacking_units;
     var center_hex, center_dist, attacking_scientists, attacking_soldiers, area, x, y;
     var p, min_dist;
     begin
          side = russians;
          min_dist = 3;  //min distance to waypoint to continue

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    for p = 1 to patrols do
                         begin
                              temp_list = UnitFilter(patrols[p],[f_alive]);
                              patrols = Replace(patrols,p,temp_list);

                              if patrols[p] = 0 then
                                   begin
                                        patrols_path = Replace(patrols_path,p,[]);
                                        patrols_path_hex_index = Replace(patrols_path_hex_index,p,1);
                                        continue;
                                   end;


                              attacking_soldiers = [];
                              attacking_scientists = [];
                              for i in patrols[p] do
                                   if GetClass(i) = class_scientistic then
                                        attacking_scientists = attacking_scientists ^ i
                                   else
                                        attacking_soldiers = attacking_soldiers ^ i;

                              temp_list = GetHumansOutOfUnits(attacking_soldiers);
                              if temp_list < attacking_soldiers then
                                   continue;

                              temp_list = GetHumansOutOfUnits(attacking_scientists);
                              if temp_list < attacking_scientists then
                                   continue;
                              

                                        //Control scientists.
                                        //Scientists just follow the attacking soldiers. The "average position" of the
                                        //attacking soldiers is calcualted. The scientists should be no further away from
                                        //that hex than the soldier furthest away.
                                        //If there are no attacking soldiers then pull back the attacking scientists.
                                        if attacking_scientists > 0 then
                                             if attacking_soldiers = 0 then
                                                  begin
                                                       for i in attacking_scientists do
                                                            if IsInArea(i,ru_base_area) then
                                                                 begin
                                                                      temp_list = patrols[p] diff i;
                                                                      patrols = Replace(patrols,p,temp_list);

                                                                      temp_list = ai_scientists[1] ^ i;
                                                                      ai_scientists = Replace(ai_scientists,1,temp_list);
                                                                 end
                                                            else
                                                                 ComMoveXY(i,ai_human_pullback_hex[1][1],ai_human_pullback_hex[1][2]);
                                                  end
                                             else
                                                  begin
                                                       x = 0;
                                                       y = 0;
                                                       for i in attacking_soldiers do
                                                            begin
                                                                 x = x + GetX(i);
                                                                 y = y + GetY(i);
                                                            end;

                                                       x = x div attacking_soldiers;
                                                       y = y div attacking_soldiers;

                                                       temp_value = 0;
                                                       for i in attacking_soldiers do
                                                            begin
                                                                 k = GetDistUnitXY(i,x,y);

                                                                 if k > temp_value then
                                                                      temp_value = k;
                                                            end;

                                                       for i in attacking_scientists do
                                                            if GetDistUnitXY(i,x,y) > temp_value then
                                                                 ComMoveXY(i,x,y);
                                                  end;

                              //Check if all soldiers are within close distance to the hex we are going for now,
                              //scientists a little further away.
                              //If yes then go for the next hex. In this way soldiers wait for each other at the
                              //waypoints in the route.
                              //Also wait at the waypoint if one or more units are injured (but only if there is
                              //a scientist present).
                              //If we have travelled the whole route through, dissolve the group.
                              temp_value = true;
                              for i in attacking_soldiers do
                                   if GetDistUnitXY(i,patrols_path[p][patrols_path_hex_index[p]][1],patrols_path[p][patrols_path_hex_index[p]][2]) > min_dist then
                                        begin
                                             temp_value = false;
                                             break;
                                        end;

                              if temp_value then
                                   for i in attacking_scientists do
                                        if GetDistUnitXY(i,patrols_path[p][patrols_path_hex_index[p]][1],patrols_path[p][patrols_path_hex_index[p]][2]) > min_dist+5 then
                                             begin
                                                  temp_value = false;
                                                  break;
                                             end;

                              if temp_value and UnitFilter(attacking_scientists,[f_ok]) > 0 then
                                   for i in attacking_soldiers ^ attacking_scientists do
                                        if GetLives(i) < 900 then
                                             begin
                                                  temp_value = false;
                                                  break;
                                             end;

                              if temp_value then
                                   begin
                                        patrols_path_hex_index = Replace(patrols_path_hex_index,p,patrols_path_hex_index[p]+1);

                                        if patrols_path_hex_index[p] > patrols_path[p] then  //end of the line
                                             begin
                                                  temp_list = ai_soldiers[1] ^ attacking_soldiers;
                                                  ai_soldiers = Replace(ai_soldiers,1,temp_list);

                                                  temp_list = ai_scientists[1] ^ attacking_scientists;
                                                  ai_scientists = Replace(ai_scientists,1,temp_list);

                                                  patrols = Replace(patrols,p,[]);
                                                  patrols_path = Replace(patrols_path,p,[]);
                                                  patrols_path_hex_index = Replace(patrols_path_hex_index,p,1);

                                                  continue;
                                             end;
                                   end;

                              //Control the soldiers
                              for i in attacking_soldiers do
                                   begin
                                        temp_value = GetTaskList(i);

                                        //If the unit is shooting at a unit which is Ok and there is a dying human
                                        //unit within the same distance or closer than the current target then
                                        //kill off that human unit first.
                                        {if temp_value > 0 then
                                        if temp_value[1][1] = '^' then  //'^' is auto attack
                                             begin
                                                  //The unit is auto attacking because it has met an enemy.
                                                  temp_unit = Attacks(i);
                                                  if temp_unit > 0 and IsOk(temp_unit) then
                                                       begin
                                                            temp_value = GetDistUnits(i,temp_unit);
                                                            temp_list = FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_not,[f_ok]],[f_dist,i,temp_value]]);
                                                            if temp_list > 0 then
                                                                 ComAttackUnit(i,temp_list[1]);

                                                            continue;
                                                       end;
                                             end;}

                                        //Move 'dem units
                                        if GetDistUnitXY(i,patrols_path[p][patrols_path_hex_index[p]][1],patrols_path[p][patrols_path_hex_index[p]][2]) > min_dist then
                                             ComAgressiveMove(i,patrols_path[p][patrols_path_hex_index[p]][1],patrols_path[p][patrols_path_hex_index[p]][2]);
                                   end;
                         end;
               end;

          until false;
     end;


//Function which sends humans to buildings, distributing them equally and changing their class (if specified).
//The humans there wasn't space for will stay near the pullback hex.
//base - the base calling the function.
//human_list - list of humans
//building_list - list of buildings
//change_to_this_class - class to change to when the human has entered the building (false if none)
//building_capacity - the number of humans the building can handle
//help_building - boolean. If true then units which could not enter a building will help building the building under
//construction (if any).
//aggressive_pullback - boolean. True if movement to pullback hex should be aggressive (else just normal move)
Function DistributeHumansToBuildings(base,human_list,building_list,change_to_this_class,building_capacity,help_building,aggressive_pullback);
     var i, temp_list, val, temp_unit, area;
     begin
          area = ru_base_area;

          val = building_list+0;
          while val > 0 and human_list > 0 do
               begin
                    //Rearrange "human_list" so humans already in inside this building goes
                    //first in the list. Else this algorithm could pick 6 people for a barracks
                    //let's say 2 outside and 4 actually in the barracks but there is a 5. unit
                    //inside the barracks already which is further down "human_list"- the result is
                    //one human can't get in because there isn't space.
                    temp_list = [];
                    for i in human_list do
                         if IsInUnit(i) = building_list[val] then
                              temp_list = temp_list ^ i;
                    human_list = temp_list ^ (human_list diff temp_list);

                    //Distribute humans equally to the buildings
                    temp_list = [];
                    for i = 1 to human_list div val do
                         begin
                              if i > building_capacity then
                                   break;

                              temp_list = temp_list ^ human_list[1];
                              human_list = Delete(human_list,1);
                         end;

                    for i in temp_list do
                         begin
                              temp_unit = IsInUnit(i);
                              if temp_unit <> building_list[val] then
                                   case GetType(IsInUnit(i)) of
                                        unit_vehicle: ComExitVehicle(i);
                                        unit_building: ComExitBuilding(i);
                                        else
                                             begin
                                                  if IsInArea(i,area) or not aggressive_pullback then
                                                       ComEnterUnit(i,building_list[val])
                                                  else
                                                       ComAgressiveMove(i,GetX(building_list[val]),GetY(building_list[val]));  //if pulling back from a patrol

                                                  if change_to_this_class > 0 then
                                                       if GetClass(i) <> change_to_this_class and GetNation(i) <> nation_nature then  //ignore apemen
                                                            AddComChangeProfession(i,change_to_this_class);
                                             end;
                                   end;
                         end;

                    val = val - 1;
               end;

          if human_list > 0 then
               if ai_building_under_construction[base] > 0 and help_building and not code_black then
                    begin
                         for i in human_list do
                              SetTaskList(i,[['h',0,0,ai_building_under_construction[base],0,0,0]]);  //'h' is "help building building"
                    end
               else
                    for i in human_list do
                         if GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 4 then
                              if aggressive_pullback then
                                   ComAgressiveMove(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2])
                              else
                                   ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
     end;


//Engineers and Apemen Engineers
//These are the priorities (descending order):
//- If an engineer is hurt, them pull him/her back for healing.
//- Reparation of red buildings
//- Reparation of any building
//- Reconstruct destroyed buildings if necessary, but only if the base is not under attack (only engineers)
//- Park empty cargo bays not on a proper parking spot (not if code black)
//- Return to and stay inside the depot (if possible).
Every 0$1 do
     var side, i, engineers_list, temp_list, buildings_list, temp_unit, away_dist, temp_list_2, base, apemen_engineers_list;
     var humans_list;
     var free_parking_spots, k;
     begin
          side = russians;

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    //Reset "move empty manual vehicles so we can build our building"-variables if we are under attack so we can use our vehicles freely.
                    if code_black then
                         begin
                              ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);
                              ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,[]);
                         end;


                    engineers_list = ai_engineers[base] diff ai_heal_these_humans[base];
                    apemen_engineers_list = ai_apemen_engineers[base] diff ai_heal_these_humans[base];

                    //Identify engineers who need healing
                    temp_list = ai_heal_these_humans[base];
                    humans_list = engineers_list ^ apemen_engineers_list;
                    i = 1;
                    while i <= humans_list do
                         begin
                              if GetLives(humans_list[i]) <= 700 then
                                   begin
                                        temp_list = temp_list ^ humans_list[i];
                                        engineers_list = engineers_list diff humans_list[i];
                                        apemen_engineers_list = apemen_engineers_list diff humans_list[i];
                                        humans_list = Delete(humans_list,i);
                                        i = i - 1;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    if engineers_list = 0 and apemen_engineers_list = 0 then
                         continue;


                    //Recapture buildings if necessary. Depots first. Here we assume the player hasn't changed the base
                    //of the captured building.
                    //Apemen engineers can't capture buildings.
                    temp_list_2 = UnitFilter(engineers_list,[f_class,class_engineer]);
                    if ai_captured_buildings[base] > 0 and temp_list_2 > 0 then
                         begin
                              temp_list = [];
                              for i in ai_captured_buildings[base] do
                                   if GetBType(i) in [b_depot,b_warehouse] then
                                        temp_list = temp_list ^ 1
                                   else
                                        temp_list = temp_list ^ 0;

                              temp_list = SortListByListDesc(ai_captured_buildings[base],temp_list);

                              //Normal "ComEnterUnit" for capturing doesn't work for buildings which can't be entered (e.g. power plants).
                              temp_list_2 = GetHumansOutOfUnits(temp_list_2);
                              if temp_list_2 > 0 then
                                   begin
                                        temp_list_2 = SortListByListDesc(temp_list_2, temp_list_2);  //To ensure we take the same unit each time
                                        SetTaskList(temp_list_2[1],[['e',GetX(temp_list[1]),GetY(temp_list[1]),temp_list[1],0,0,0]]);
                                        engineers_list = engineers_list diff temp_list_2[1];
                                   end;

                              if engineers_list = 0 and apemen_engineers_list = 0 then
                                   continue;
                         end;


                    //Find buildings which need to be repaired. At least one engineer for each if possible.
                    i = 1;
                    buildings_list = [];
                    repeat
                         case i of
                              1: buildings_list = UnitFilter(ai_all_buildings[base],[f_not,[f_ok]]);  //If building is dead then it won't be part of ai_all_buildings
                              2: buildings_list = UnitFilter(ai_all_buildings[base],[f_not,[f_lives,1000]]);
                         end;

                         i = i + 1;
                    until buildings_list > 0 or i > 2;

                    if buildings_list > 0 then
                         begin
                              humans_list = engineers_list ^ apemen_engineers_list;
                              humans_list = GetHumansOutOfUnits(humans_list);

                              repeat
                                   i = 1;
                                   while i <= buildings_list do
                                        begin
                                             if humans_list = 0 then
                                                  break;

                                             temp_unit = NearestUnitToUnit(humans_list,buildings_list[i]);
                                             ComRepairBuilding(temp_unit,buildings_list[i]);

                                             humans_list = humans_list diff temp_unit;
                                             engineers_list = engineers_list diff temp_unit;
                                             apemen_engineers_list = apemen_engineers_list diff temp_unit;

                                             i = i + 1;
                                        end;

                              until humans_list = 0;

                              continue;
                         end;


                    if not code_black then
                         begin
                              //Reconstruct buildings if any has been destroyed.
                              //First check if a building is already being constructed - then build that one first.
                              //Upgrading buildings can be hard if the building is working or something, so check if the
                              //building is actually under construction (or being upgraded) - if not then reset the
                              //relevant variables.
                              if ai_building_under_construction[base] > 0 then
                                   if BuildingStatus(ai_building_under_construction[base]) = bs_build then
                                        begin
                                             for i in GetHumansOutOfUnits(engineers_list ^ apemen_engineers_list) do
                                                  ComRepairBuilding(i,ai_building_under_construction[base]);

                                             continue;
                                        end
                                   else
                                        begin
                                             ComCancel(ai_building_under_construction[base]);  //To make sure upgrade of building is possible
                                             ai_building_under_construction = Replace(ai_building_under_construction,base,0);
                                        end;

                              if ai_all_buildings[base] < ai_buildings_locations[base] or ai_upcoming_building_data[base] > 0 then
                                   begin
                                        //Decide which building to construct. We take the first building in the location list which is
                                        //arranged in prioritated order.
                                        if ai_upcoming_building_data[base] = 0 then
                                             begin
                                                  temp_list = [];
                                                  for i in ai_buildings_locations[base] do
                                                       if GetBType(HexInfo(i[1],i[2])) = -1 then  //no building on the spot
                                                            begin
                                                                 temp_list = i;
                                                                 break;
                                                            end;

                                                  if temp_list > 0 then  //Not necessarily the case (one of our buildings could have been captured)
                                                       ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,temp_list);
                                             end;


                                        if ai_upcoming_building_data[base] > 0 then
                                             begin
                                                  if ai_building_constructor[base] = 0 then
                                                       begin
                                                            temp_list_2 = UnitFilter(ai_engineers[base],[f_class,class_engineer]);

                                                            if temp_list_2 > 0 then
                                                                 begin
                                                                      temp_list = [];
                                                                      for i in temp_list_2 do
                                                                           temp_list = temp_list ^ GetSkill(i,skill_engineering);
                                                                      ai_building_constructor = Replace(ai_building_constructor,base, BestFromListByList(temp_list_2,temp_list) );
                                                                 end;
                                                       end;

                                                  if ai_building_constructor[base] in engineers_list and ai_building_constructor[base] > 0 then
                                                       begin
                                                            engineers_list = engineers_list diff ai_building_constructor[base];

                                                            //Move vehicles away from the building site.
                                                            away_dist = 7; //Max distance needed for a workshop
                                                            if ai_vehicle_being_moved[base] = 0 then
                                                                 begin
                                                                      temp_list = UnitFilter(ai_vehicles_defend[base] ^ ai_cargo_bay[base],
                                                                                             [[f_control,control_manual],[f_empty],[f_distxy,ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],away_dist]]);  //Don't consider "ai_vehicles_attack" - they will soon move by themselves
                                                                      if temp_list > 0 then
                                                                           begin
                                                                                ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,temp_list[1]);
                                                                                temp_list_2 = ai_vehicles_having_been_moved[base] ^ temp_list[1];
                                                                                ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,temp_list_2);
                                                                           end
                                                                      else
                                                                           //Build/upgrade the building
                                                                           case GetType(IsInUnit(ai_building_constructor[base])) of
                                                                                unit_building: ComExitBuilding(ai_building_constructor[base]);
                                                                                unit_vehicle: ComExitVehicle(ai_building_constructor[base]);
                                                                                else
                                                                                case GetBType(HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2])) of
                                                                                     -1: begin
                                                                                          case ai_upcoming_building_data[base][4] of
                                                                                               b_warehouse: i = b_depot;
                                                                                               b_factory: i = b_workshop;
                                                                                               b_lab_half,b_lab_full: i = b_lab;
                                                                                               b_barracks: i = b_armoury;
                                                                                               else i = ai_upcoming_building_data[base][4];
                                                                                          end;

                                                                                          ComBuild(ai_building_constructor[base],i,ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],ai_upcoming_building_data[base][3]);
                                                                                     end;
                                                                                     b_depot: begin
                                                                                          ComUpgrade(ai_depot[base]);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,ai_depot[base]);
                                                                                     end;
                                                                                     b_workshop: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_lab,b_lab_half: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);

                                                                                          if ai_upcoming_building_data[base][5] <> b_lab_basic and not ai_upcoming_building_data[base][5] in [GetLabKind(temp_unit,1),GetLabKind(temp_unit,2)] then
                                                                                               ComUpgradeLab(temp_unit,ai_upcoming_building_data[base][5])
                                                                                          else
                                                                                               if ai_upcoming_building_data[base][6] <> b_lab_basic then
                                                                                                    ComUpgradeLab(temp_unit,ai_upcoming_building_data[base][6])
                                                                                               else  //should never happen
                                                                                                    begin
                                                                                                         ai_building_constructor = Replace(ai_building_constructor,base,0);
                                                                                                         ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);
                                                                                                    end;

                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_armoury: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                end;
                                                                           end;
                                                                 end
                                                            else
                                                                 if UnitsInside(ai_vehicle_being_moved[base]) > 0 then
                                                                      begin
                                                                           if GetDistUnitXY(ai_vehicle_being_moved[base],ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]) <= away_dist then
                                                                                AI_GetAwayFromXY(ai_vehicle_being_moved[base],ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],away_dist+2,false)
                                                                           else
                                                                                ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);
                                                                      end
                                                                 else
                                                                      case GetType(IsInUnit(ai_building_constructor[base])) of
                                                                           unit_building: ComExitBuilding(ai_building_constructor[base]);
                                                                           unit_vehicle: ComExitVehicle(ai_building_constructor[base]);
                                                                           else
                                                                                ComEnterUnit(ai_building_constructor[base],ai_vehicle_being_moved[base]);
                                                                      end;
                                                       end;
                                             end;
                                   end;


                              //Scan for empty cargo bays not properly parked next to the main depot.
                              //Park them.
                              free_parking_spots = [];  //Keeps track of the parking spots available
                              temp_list_2 = [];  //keeps track of vehicles parked correctly
                              for i in cargo_bay_parking_spots do
                                   begin
                                        temp_unit = HexInfo(i[1],i[2]);

                                        if GetType(temp_unit) <> unit_vehicle then
                                             free_parking_spots = Insert(free_parking_spots,1,i)
                                        else
                                             begin
                                                  temp_list_2 = temp_list_2 ^ temp_unit;
                                                  engineers_vehicles_to_move_drivers = Replace(engineers_vehicles_to_move_drivers,temp_unit,0);
                                             end;
                                   end;

                              //Find drivers for the vehicles which aren't parked correctly.
                              //Don't count in the cargo bay Heike is controlling (if any).
                              temp_list_2 = FilterAllUnits([[f_type,unit_vehicle],[f_weapon,ru_cargo_bay],[f_ok],[f_inarea,ru_base_area]]) diff temp_list_2;  //doesn't need to be Russian side

                              i = IsInUnit(Heike);
                              if i > 0 then
                                   begin
                                        temp_list_2 = temp_list_2 diff i;
                                        engineers_vehicles_to_move_drivers = Replace(engineers_vehicles_to_move_drivers,i,0);
                                   end;

                              temp_list_2 = temp_list_2 diff dont_park_cargo_bay;
                              cargo_bays_being_moved = temp_list_2;

                              for i in UnitFilter(temp_list_2,[f_empty]) do
                                   begin
                                        k = false;
                                        if engineers_vehicles_to_move_drivers < i then
                                             k = true
                                        else
                                             if not engineers_vehicles_to_move_drivers[i] in engineers_list then
                                                  k = true;
                                        if k then
                                             engineers_vehicles_to_move_drivers = Replace(engineers_vehicles_to_move_drivers,i,AllNearestUnitToUnit(engineers_list,i));

                                        if engineers_vehicles_to_move_drivers[i] > 0 then
                                             begin
                                                  temp_unit = IsInUnit(engineers_vehicles_to_move_drivers[i]);

                                                  if temp_unit <> i then
                                                       case GetType(temp_unit) of
                                                            unit_vehicle: ComExitVehicle(engineers_vehicles_to_move_drivers[i]); //could sit in a vehicle which is now parked correctly
                                                            unit_building: ComExitBuilding(engineers_vehicles_to_move_drivers[i]);
                                                            else ComEnterUnit(engineers_vehicles_to_move_drivers[i],i);
                                                       end;
                                             end;
                                   end;

                              //Diff engineers driving vehicles
                              for i in engineers_vehicles_to_move_drivers do
                                   if i > 0 then
                                        engineers_list = engineers_list diff i;

                              //Command vehicles parked the wrong places to retreat to the pullback hexes.
                              //If no pullback hexes are available then the vehicle won't park.
                              for i in temp_list_2 do
                                   if free_parking_spots > 0 then
                                        begin
                                             //Take the closest spot
                                             temp_list = [];
                                             for k in free_parking_spots do
                                                  temp_list = temp_list ^ GetDistUnitXY(i,k[1],k[2]);
                                             temp_list = WorstFromListByList(free_parking_spots,temp_list);

                                             ComMoveXY(i,temp_list[1],temp_list[2]);

                                             free_parking_spots = free_parking_spots diff [temp_list];
                                        end
                                   else
                                        break;
                         end;


                    //Return to and stay inside the depot (if possible)
                    DistributeHumansToBuildings(base,engineers_list ^ apemen_engineers_list, UnitFilter(ai_depot[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_engineer,6,false,false);
               end;

          until false;
     end;
On BuildingStarted(building,builder) do
     var side, base;
     begin
          side = GetSide(building);
          if side <> russians then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          ai_building_constructor = Replace(ai_building_constructor,base,0);
          ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,[]);

          //ONLY 1 building is under construction at a time!
          ai_building_under_construction = Replace(ai_building_under_construction,base,building);

          DoNotAttack(you,building);
     end;
On BuildingComplete(building) do
     var side, base, temp_list;
     begin
          side = GetSide(building);
          if side <> russians then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          BuildUpgradeCommon(base,building);

          temp_list = ai_all_buildings[base] ^ building;
          ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

          //Check if building is the northern depot or Yefibachev's office.
          if IsDead(depot_north) and GetBType(building) = b_depot and not ( GetX(building) = ai_buildings_locations[1][1][1] and GetY(building) = ai_buildings_locations[1][1][2] ) then  //depot, but not the main depot
               depot_north = building
          else
               if IsDead(leader_office) and GetX(building) = leader_office_location[1] and GetY(building) = leader_office_location[2] then
                    leader_office = building
               else
                    UpdateBuildingBasicVariables(base,building,true);
     end;
On UpgradeComplete(building) do
     var side, base;
     begin
          side = GetSide(building);
          if side <> russians then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          BuildUpgradeCommon(base,building);
     end;
Function BuildUpgradeCommon(base,building);
     begin
          //Some buildings require upgrade - e.g. workshop -> factory
          if GetBType(building) = ai_upcoming_building_data[base][4] then
               ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);

          ai_building_under_construction = Replace(ai_building_under_construction,base,0);
     end;
On BuildingCaptured(captured_building,building_former_side,capturing_unit) do
     var temp_list, base;
     begin
          base = FindBase(captured_building);

          if base = 0 then
               exit;

          if building_former_side = GetBaseSide(base) then
               begin
                    if captured_building in ai_all_buildings[base] then
                         begin
                              //Someone captured one of our buildings!
                              RemoveBuildingFromVariables(base,captured_building);

                              temp_list = ai_captured_buildings[base] ^ captured_building;
                              ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
                         end;
               end
          else
               begin
                    if GetSide(captured_building) = GetBaseSide(base) then
                         begin
                              //Ha! We captured it back again!
                              temp_list = ai_all_buildings[base] ^ captured_building;
                              ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

                              UpdateBuildingBasicVariables(base,captured_building,true);

                              temp_list = ai_captured_buildings[base] diff captured_building;
                              ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
                         end;
               end;
     end;


//Function which orders human units inside other units to exit them. Returns a list with the units which weren't inside other units.
Export Function GetHumansOutOfUnits(un_list);
     var i;
     begin
          result = [];
          for i in un_list do
               case GetType(IsInUnit(i)) of
                    unit_building: ComExitBuilding(i);
                    unit_vehicle: ComExitVehicle(i);
                    else result = result ^ i;
               end;
     end;



//Mechanics (defending, i.e. in the base)
//Priorities if base is in code black (descending):
//- If a mechanic is hurt, pull him back for healing, but not if he/she is driving a vehicle, but if he is near an empty vehicle then go inside that one instead.
//- Defend the base using the war vehicles in the base
//- Stay in factory
//Priorites if everything is normal (decending):
//- If a mechanic is hurt, pull him back for healing, but not if he/she is driving a vehicle.
//- Refuel vehicles
//- Drive away vehicles which are blocking the factory entrance / park vehicles properly on the vehicle pullback hexes
//- Repair damaged war vehicles within the base
//- Stay in factory (and possibly construct a vehicle or weapon)
Every 0$1 do
     var side, base, i, mechanics_list, temp_list, temp_list_3, temp_unit, vehicles_list, allowed_to_repair_vehicles;
     var under_attack, free_parking_spots, k, vehicles_drivers, temp_list_2;
     begin
          side = russians;

          //Index is vehicle id, value is driver id.
          //For use to ensure the driver first chosen to drive the
          //vehicle goes for it (doesn't change to another driver).
          vehicles_drivers = [];

          repeat
          wait(0$1);
    
          for base in ai_bases do
               begin
                    under_attack = code_black;


                    //Update vehicles drivers so vehicles with a driver no longer has that driver assigned
                    //so a possible new driver can be assigned next time.
                    for i in ai_vehicles_defend[base] do
                         if vehicles_drivers >= i then
                              if vehicles_drivers[i] > 0 then
                                   if IsInUnit(vehicles_drivers[i]) = i or IsDead(vehicles_drivers[i]) then
                                        vehicles_drivers = Replace(vehicles_drivers,i,0);
                    

                    mechanics_list = UnitFilter(ai_mechanics_defend[base] diff ai_heal_these_humans[base],[f_not,[f_driving]]);

                    if except_Yakov then
                         mechanics_list = mechanics_list diff Yakov;


                    //Identify mechanics who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= mechanics_list do
                         begin
                              if GetLives(mechanics_list[i]) <= 900 then
                                   begin
                                        temp_list = temp_list ^ mechanics_list[i];
                                        mechanics_list = Delete(mechanics_list,i);
                                        continue;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //The mechanic playing poker should be in the main depot unless the base is
                    //in code black.
                    if not code_black and poker_mec in mechanics_list and IsOk(ai_depot[base]) then
                         begin
                              temp_unit = IsInUnit(poker_mec);
                              case GetType(temp_unit) of
                                   unit_vehicle: ComExitVehicle(poker_mec);
                                   unit_building:
                                        if temp_unit <> ai_depot[base] then
                                             ComExitBuilding(poker_mec);
                                   else
                                        ComEnterUnit(poker_mec,ai_depot[base]);
                              end;

                              mechanics_list = mechanics_list diff poker_mec;
                         end;


                    //Find vehicles which no longer need to be repaired (fully repaired).
                    temp_list = [];
                    for i in ai_vehicles_being_repaired[base] do
                         if GetLives(i) < 1000 then
                              temp_list = temp_list ^ i;
                    ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);


                    //Find vehicles which do no longer need to retreat (they have been fully repaired or are being repaired)
                    temp_list = [];
                    for i in ai_retreating_vehicles_defend[base] diff ai_vehicles_being_repaired[base] do
                         if GetLives(i) < 1000 then
                              temp_list = temp_list ^ i;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);


                    //Identify defending vehicles which need to retreat.
                    //Make vehicles retreat if they exceed a certain threshold of damage. Works for any amount of health
                    //(except full health) but is only used when the vehicles are burning. Defend the base at all costs!
                    temp_list = ai_retreating_vehicles_defend[base];
                    for i in ai_vehicles_defend[base] diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base]) do
                         if GetLives(i) <= 250 then
                              temp_list = temp_list ^ i;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);


                    //Find vehicles which no longer need to refuel.
                    //If a vehicles was scheduled to refuel but didn't make it before the base was attacked
                    //and was added to retreating vehicles during the attack it must be removed from
                    //refueling vehicles.
                    temp_list = [];
                    for i in ai_refuel_vehicles_list[base] diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) do
                         if GetFuel(i) < 95 then
                              temp_list = temp_list ^ i;
                    ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);


                    if under_attack then
                         begin
                              //Find the vehicles which need a driver and get them a driver (take the
                              //nearest available mechanic).
                              vehicles_list = ai_vehicles_defend[base] diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]);

                              temp_list = UnitFilter(vehicles_list,[[f_control,control_manual],[f_ok],[f_empty],[f_inarea,GetBaseArea(base)]]);
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];

                              //Control the vehicles
                              ControlCodeBlackUnits(vehicles_list);
                         end
                    else
                         if IsOk(ai_depot[base]) then
                         begin
                              //If some vehicles need to refuel then make 'em refuel.
                              temp_list = ai_refuel_vehicles_list[base];
                              for i in ai_vehicles_defend[base] diff ai_refuel_vehicles_list[base] do
                                   if GetFuel(i) < 70 and GetEngine(i) = engine_combustion then
                                        temp_list = temp_list ^ i;
                              temp_list = temp_list diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]);
                              ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);

                              temp_list = UnitFilter(ai_refuel_vehicles_list[base],[[f_empty],[f_ok]]);
                              temp_list_2 = mechanics_list diff [Mikhail,Natalya];  //Never Mikhail or Natalya
                              temp_list = FindDriverHelper(temp_list,temp_list_2,vehicles_drivers);
                              mechanics_list = mechanics_list diff (temp_list_2 diff temp_list[1]);
                              vehicles_drivers = temp_list[2];

                              ComMoveUnit(ai_refuel_vehicles_list[base],ai_depot[base]);
                              AddComRefuel(ai_refuel_vehicles_list[base],ai_depot[base]);
                         end;


                    //Determine which vehicles are allowed to repair. If base is under attack then only the vehicles on the
                    //parking/retreat spots. If not under attack then all defending vehicles.
                    //Get mechanics in these vehicles out so they can repair too (if we are not under attack).
                    //If the base is not under attack then scan for vehicles which are not parked correctly.
                    free_parking_spots = [];  //Keeps track of the pullback hexes available
                    temp_list_3 = [];  //Keeps track of vehicles on pullback hexes
                    for i in ai_vehicle_pullback_hexes[base] do
                         begin
                              temp_unit = HexInfo(i[1],i[2]);

                              if temp_unit in ai_vehicles_defend[base] then
                                   begin
                                        temp_list_3 = temp_list_3 ^ temp_unit;

                                        if not under_attack and not temp_unit in (ai_refuel_vehicles_list[base] ^ ai_vehicles_attack[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base] ^ cargo_bays_being_moved) then
                                             begin
                                                  if GetControl(temp_unit) = control_manual then
                                                       begin
                                                            ComExitVehicle(IsDrivenBy(temp_unit));
                                                       end;
                                             end;
                                   end
                              else
                                   if temp_unit = 0 or not ( GetType(temp_unit) = unit_building or ( GetType(temp_unit) = unit_vehicle and ( ( GetControl(temp_unit) = control_manual and IsDrivenBy(temp_unit) = 0 ) or ( GetControl(temp_unit) = control_remote and IsControledBy(temp_unit) = 0 ) ) ) ) then
                                        free_parking_spots = Insert(free_parking_spots,1,i);
                         end;


                    if under_attack then
                         begin
                              allowed_to_repair_vehicles = temp_list_3;
                              vehicles_list = UnitFilter((ai_vehicles_being_repaired[base] ^ ai_retreating_vehicles_defend[base]) diff temp_list_3,[f_ok]);

                              //Man only the vehicles being repaired and retreating vehicles which are parked on a parking spot and ( are under attack
                              //or where mechanics are under attack nearby (i.e. the enemy is near) ).
                              //Else use your time on repairing the vehicles.
                              //UnitShoot resets after 10 seconds and detects all kinds of contact (direct hit, bombs, attack ground etc.).
                              temp_list = [];
                              temp_list_3 = temp_list_3 isect UnitFilter(ai_vehicles_being_repaired[base] ^ ai_retreating_vehicles_defend[base],[f_ok]);
                              for i in temp_list_3 do
                                   if UnitShoot(i) > 0 and GetSide(UnitShoot(i)) <> side then
                                        temp_list = temp_list ^ i;

                              for i in ai_mechanics_defend[base] do
                                   if UnitShoot(i) > 0 and GetSide(UnitShoot(i)) <> side then
                                        temp_list = temp_list ^ UnitFilter(temp_list_3 diff temp_list,[f_dist,i,5]);

                              for i in temp_list_3 diff temp_list do
                                   if GetControl(i) = control_manual then
                                        begin
                                             ComExitVehicle(IsDrivenBy(i));
                                        end;

                              temp_list = FindDriverHelper(UnitFilter(temp_list,[[f_empty],[f_ok]]),mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];
                         end
                    else
                         begin
                              //Don't go near burning vehicles too far away from the base - could be dangerous if the
                              //enemy has set up an ambush.
                              allowed_to_repair_vehicles = ai_vehicles_defend[base] diff (ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]);

                              i = 1;
                              while i <= allowed_to_repair_vehicles do
                                   begin
                                        if not IsOk(allowed_to_repair_vehicles[i]) and GetDistUnitArea(allowed_to_repair_vehicles[i],ru_base_area) > 7 then
                                             begin
                                                  allowed_to_repair_vehicles = Delete(allowed_to_repair_vehicles,i);
                                                  continue;
                                             end;

                                        i = i + 1;
                                   end;

                              vehicles_list = UnitFilter(allowed_to_repair_vehicles diff temp_list_3,[f_ok]);

                              //Find drivers for the vehicles which aren't parked correctly
                              temp_list = UnitFilter(vehicles_list,[[f_empty],[f_ok]]);
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];
                         end;

                    //Command (damaged vehicles)/(vehicles parked the wrong places) to retreat to the pullback hexes.
                    //If no pullback hexes are available then the vehicle won't retreat.
                    for i in vehicles_list do
                         if free_parking_spots > 0 then
                              begin
                                   //Take the closest spot
                                   temp_list = [];
                                   for k in free_parking_spots do
                                        temp_list = temp_list ^ GetDistUnitXY(i,k[1],k[2]);
                                   temp_list = WorstFromListByList(free_parking_spots,temp_list);

                                   ComMoveXY(i,temp_list[1],temp_list[2]);
                                   AddComHold(i);

                                   free_parking_spots = free_parking_spots diff [temp_list];
                              end
                         else
                              break;


                    if mechanics_list = 0 then
                         continue;


                    //Repair vehicles.
                    //All mechanics go for the same vehicle.
                    allowed_to_repair_vehicles = UnitFilter(allowed_to_repair_vehicles,[f_not,[f_lives,1000]]) diff ai_vehicles_being_repaired[base];
                    if allowed_to_repair_vehicles > 0 or ai_vehicles_being_repaired[base] > 0 then
                         begin
                              if allowed_to_repair_vehicles > 0 then
                                   begin
                                        k = false;
                                        if ai_vehicles_being_repaired[base] = 0 then
                                             k = true
                                        else
                                             if IsOk(ai_vehicles_being_repaired[base][1]) then
                                                  begin
                                                       allowed_to_repair_vehicles = UnitFilter(allowed_to_repair_vehicles,[f_not,[f_ok]]);
                                                       k := allowed_to_repair_vehicles > 0;
                                                  end;

                                        if k then
                                             begin
                                                  temp_list = [];
                                                  for i in allowed_to_repair_vehicles do
                                                       temp_list = temp_list ^ GetLives(i);
                                                  temp_unit = WorstFromListByList(allowed_to_repair_vehicles,temp_list);

                                                  temp_list = temp_unit ^ ai_vehicles_being_repaired[base];
                                                  ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);

                                                  temp_list = ai_retreating_vehicles_defend[base] diff temp_unit;
                                                  ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);
                                             end;
                                   end;

                              ComRepairVehicle( GetHumansOutOfUnits(mechanics_list) , ai_vehicles_being_repaired[base][1]);
                         end
                    else
                         begin
                              //Rest mechanics stay inside the factory (if possible).
                              //Change class if necessary
                              DistributeHumansToBuildings(base,mechanics_list, UnitFilter(ai_facts[base],[[f_ok],[f_not,[f_constructed]]]),
                                   class_mechanic,6,true,false);
                         end;
               end;

          until false;
     end;
Function FindDriverHelper(vehicles_list,mechanics_list,vehicles_drivers);
     var i, k, temp_unit;
     begin
          for i in vehicles_list do
               begin
                    if mechanics_list = 0 then
                         break;

                    k = false;
                    if vehicles_drivers < i then
                         k = true
                    else
                         if not vehicles_drivers[i] in mechanics_list then
                              k = true;

                    if k then
                         vehicles_drivers = Replace(vehicles_drivers,i,AllNearestUnitToUnit(mechanics_list,i));

                    if vehicles_drivers[i] > 0 then
                        begin
                             temp_unit = IsInUnit(vehicles_drivers[i]);

                             if temp_unit <> i then
                                  case GetType(temp_unit) of
                                       unit_vehicle: ComExitVehicle(vehicles_drivers[i]);  //could sit in a vehicle which is now parked correctly
                                       unit_building: ComExitBuilding(vehicles_drivers[i]);
                                       else ComEnterUnit(vehicles_drivers[i],i);
                                  end;

                             mechanics_list = mechanics_list diff vehicles_drivers[i];
                        end;
               end;

          result = [mechanics_list,vehicles_drivers];
     end;
//Construct combat vehicles and weapons for bunkers. Weapons for bunkers have highest priority.
Every 0$1+0$0.1 do
     var side, i, temp_value, temp_unit, temp_list, base, idle_factories, fact;
     begin
          side = russians;

          for base in ai_bases do
               begin
                    idle_factories = [];
                    for i in ai_facts[base] do
                         if BuildingStatus(i) = bs_idle and IsOk(i) and GetBType(i) = b_factory then
                              idle_factories = idle_factories ^ i;

                    if idle_factories = 0 then
                         continue;


                    //Check if any bunker needs a weapon
                    temp_value = false;
                    for i in ai_buildings_locations[base] do
                         if i[4] in [b_bunker,b_turret] then
                              begin
                                   temp_unit = HexInfo(i[1],i[2]);

                                   if GetBType(temp_unit) in [b_bunker,b_turret] and not IsConstructed(temp_unit) and GetBWeapon(temp_unit) <> i[7] then
                                        for fact in idle_factories do
                                             //if i[7] in AvailableWeaponList(fact) then  //Can the factory produce the weapon? (does it have the gun extension, that is).
                                             if IsWeaponFactory(fact) then
                                                  begin
                                                       //If there are multiple weapon factories and more than one or another factory than
                                                       //the factory getting the job invokes this part of the function the bunker/turret may
                                                       //get the weapon placed several times, but since factories don't have a task list
                                                       //there is no simple way to stop this. Better several times than never.
                                                       ComPlaceWeapon(temp_unit,i[7]);
                                                       temp_value = true;
                                                       break;
                                                  end;

                                   if temp_value then
                                        break;
                              end;

                    if temp_value then
                         continue;


                    //Construct vehicles.
                    //The base should always have 3 war vehicles.
                    if ai_vehicles_defend[base] + ai_vehicles_attack[base] < 3 then
                         case side of
                              russians: begin
                                   if Rand(1,3) = 1 then
                                        begin
                                             if Rand(1,1+difficulty) = 1 then
                                                  temp_value = ru_heavy_machine_gun
                                             else temp_value = ru_gatling_gun;
                                        end
                                   else
                                        temp_value = ru_gun;

                                   //if not temp_value in AvailableWeaponList(idle_factories[1]) then
                                   if not IsWeaponFactory(idle_factories[1]) then
                                        temp_value = ru_heavy_machine_gun;

                                   ComConstruct(idle_factories[1],ru_medium_wheeled,engine_siberite,control_manual,temp_value);
                              end;
                         end;
               end;

          enable;
     end;
//If a factory has the gun extension we presume it has all necessary extensions to construct
//any weapon.
Function IsWeaponFactory(factory);
     begin
          if FilterAllUnits([[f_dist,factory,4],[f_btype,b_ext_gun]]) > 0 then
               result = true
          else
               result = false;
     end;
//If the player captures one of the computer's vehicles, then remove it from our variables-system.
On VehicleCaptured(new_identifier,old_identifier,old_side,capturing_unit) do
     var temp_unit, base, val;
     begin
          //When player captures a Russian cargo bay
          if old_side = russians_alt and GetWeapon(new_identifier) = ru_cargo_bay and the_cargo_bay_captured = 0 then
               the_cargo_bay_captured = new_identifier;

          if old_side = russians then
               begin
                    if capturing_unit = Heike and heike_undercover = 2 and old_identifier in ai_vehicles_defend[1] ^ ai_vehicles_attack[1] then
                         heike_undercover_entered_war_vehicle = true;

                    for base in ai_bases do
                         RemoveVehicleFromVariables(base,old_identifier);
               end;

          if GetWeapon(new_identifier) = ru_cargo_bay then
               begin
                    if cargo_bays_origin >= old_identifier then
                         begin
                              val = cargo_bays_origin[old_identifier];
                              cargo_bays_origin = Replace(cargo_bays_origin,new_identifier,val);
                         end;
               end;

          //For use when engineers move cargo bays to parking spots. Cargo bay may be of the player's side.
          if engineers_vehicles_to_move_drivers >= old_identifier then
               if engineers_vehicles_to_move_drivers[old_identifier] > 0 then
                    begin
                         temp_unit = engineers_vehicles_to_move_drivers[old_identifier];
                         engineers_vehicles_to_move_drivers = Replace(engineers_vehicles_to_move_drivers,old_identifier,0);
                         engineers_vehicles_to_move_drivers = Replace(engineers_vehicles_to_move_drivers,new_identifier,temp_unit);
                    end;

          //If Heike is undercover then don't attack the cargo bay she enters (as well as don't attack her).
          //The DoNotAttack-command is removed when the Russians recapture the vehicle, but to avoid abuse
          //(Heike enters the vehicle, exits and lets another player unit enter - dada! invinsibility) the
          //DoNotAttack-command is removed by an every in module "OtherEvents" when another player unit enters
          //a vehicle.
          //There's another every in module "OtherEvents" below the before mentioned every doing the exact same
          //as this code (necessary because this code only runs when a vehicle is captured - the vehicle could
          //already be of the player's side). The criteria used here and in "OtherEvents" should be alike.
          if capturing_unit = Heike and heike_undercover in [2,3] and GetWeapon(new_identifier) = ru_cargo_bay then
               begin
                    wait(1);  //have to wait until next tick with executing DoNotAttack-command for it to work - apparently
                    DoNotAttack(russians,new_identifier);
                    DoNotAttack(russians_alt,new_identifier);
               end;

          if GetSide(new_identifier) = russians then
               begin
                    wait(1);
                    DoNotAttack(you,new_identifier);
               end;

          if old_identifier in intel_party_vehicles then
               begin
                    intel_party_vehicles = intel_party_vehicles diff old_identifier;
                    intel_party_vehicles = intel_party_vehicles ^ new_identifier;

                    if capturing_unit = Heike and heike_undercover = 2 then
                         begin
                              wait(1);
                              DoNotAttack(russians,new_identifier);
                              DoNotAttack(russians_alt,new_identifier);
                         end;

                    if GetSide(new_identifier) in [russians_alt,russians] then
                         begin
                              wait(1);
                              DoNotAttack(you,new_identifier);
                         end;
               end;
     end;
//When a vehicle is constructed
On VehicleConstructed(vehicle,factory) do
     var side, temp_list, base;
     begin
          side = GetSide(vehicle);
          if side <> russians then
               exit;

          base = 1;

          if GetWeapon(vehicle) <> ru_cargo_bay then
               begin
                    temp_list = ai_vehicles_defend[base] ^ vehicle;
                    ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
               end
          else
               begin
                    ai_cargo_bay = Replace(ai_cargo_bay,base,vehicle);
                    ai_cargo_bay_under_construction = Replace(ai_cargo_bay_under_construction,base,false);
               end;

          DoNotAttack(you,vehicle);
     end;

//Mechanics (patrolling the roads in war vehicles)
//Get the attacking mechanics inside the war vehicles and attack.
//Patrol the roads until code_red is called off or the vehicle is pulled back by this code.
//Two vehicles is optimal but the code can handle more if necessary.
Every 0$1+0$0.6 do
     var side, base, i, attack_vehicles_list, attack_mechanics_list, retreat_vehicles_list, retreat_mechanics_list, temp_list, k, temp_unit;
     var attack_hexes, first, temp_value, base_area, dist, temp_list_2;
     var left_road_hexes, right_road_hexes, unit_target_hex_index, left_units, right_units;
     begin
          //The two parts of the road to patrol (left and right seen from the entrance of the Russian base).
          //The hexes as looped to one going through the hexes means you end almost where you started.
          temp_list = [[74,86],[64,84],[54,76],[44,69]];
          temp_list_2 = [];
          for i in temp_list do
               temp_list_2 = Insert(temp_list_2,1,i);
          left_road_hexes = [[79,71]] ^ temp_list ^ [[36,64]] ^ temp_list_2;

          temp_list = [[106,74],[108,62],[115,59],[122,60],[140,77],[151,83],[162,85]];
          temp_list_2 = [];
          for i in temp_list do
               temp_list_2 = Insert(temp_list_2,1,i);
          right_road_hexes = [[87,74]] ^ temp_list ^ [[171,89]] ^ temp_list_2;

          //List which keeps track of which hex a unit is going for now. Index is unit identifier. Value if index
          //in hex list, e.g. left_road_hexes.
          unit_target_hex_index = [];

          left_units = [];  //units patrolling the left road
          right_units = [];  //units patrolling the right road

          side = russians;

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    if ai_mechanics_attack[base] = 0 then
                         continue;


                    //Check which vehicles should retreat to base.
                    //- If vehicle is damaged
                    //- If code red is no longer
                    retreat_vehicles_list = [];
                    if not code_red then
                         retreat_vehicles_list = ai_vehicles_attack[base]
                    else
                         for i in ai_vehicles_attack[base] do
                              if GetLives(i) <= 500 then
                                   retreat_vehicles_list = retreat_vehicles_list ^ i;


                    //Check which mechanics should retreat to base (if they are not inside a vehicle and there are not enough
                    //vehicles for all mechanics then retreat).
                    retreat_mechanics_list = [];
                    temp_list = [];
                    for i = 1 to ai_mechanics_attack[base] - UnitFilter(ai_vehicles_attack[base],[f_ok]) do
                         begin
                              temp_unit = 0;
                              for k in ai_mechanics_attack[base] diff temp_list do
                                   if not IsInUnit(k) in ai_vehicles_attack[base] then
                                        begin
                                             temp_unit = k;
                                             break;
                                        end;

                              if temp_unit > 0 then
                                   begin
                                        retreat_mechanics_list = retreat_mechanics_list ^ temp_unit;
                                        temp_list = temp_list ^ temp_unit;
                                   end;
                         end;


                    //Make retreating vehicles and mechanics retreat to base.
                    //When they reach the base then remove them from the attacking variables and add them to the
                    //defending variables so they are taken properly care of (see every for defending mechanics above).
                    k = ru_base_area;

                    for i in retreat_vehicles_list ^ retreat_mechanics_list do
                         if IsInArea(i,k) then
                              begin
                                   if GetType(i) = unit_vehicle then
                                        begin
                                             RemoveVehicleFromVariables(base,i);

                                             left_units = left_units diff i;
                                             right_units = right_units diff i;

                                             temp_list = ai_vehicles_defend[base] ^ i;
                                             ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);

                                             i = UnitsInside(i);
                                        end;

                                   temp_list = ai_mechanics_attack[base] diff i;
                                   ai_mechanics_attack = Replace(ai_mechanics_attack,base,temp_list);

                                   temp_list = ai_mechanics_defend[base] ^ i;
                                   ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
                              end
                         else
                              ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);


                    //Make sure units inside war vehicles are attacking mechanics
                    attack_vehicles_list = ai_vehicles_attack[base] diff retreat_vehicles_list;
                    for i in UnitFilter(attack_vehicles_list,[f_not,[f_empty]]) do
                         begin
                              temp_unit = UnitsInside(i)[1];
                              if not temp_unit in ai_mechanics_attack[base] then
                                   ComExitVehicle(temp_unit);
                         end;


                    //Make sure mechanics are inside vehicles
                    temp_list = UnitFilter(attack_vehicles_list,[f_empty]);
                    if temp_list > 0 then
                         begin
                              attack_mechanics_list = UnitFilter(ai_mechanics_attack[base] diff retreat_mechanics_list,[f_not,[f_driving]]);
                              for i in temp_list do
                                   begin
                                        if attack_mechanics_list = 0 then
                                             break;  

                                        temp_unit = AllNearestUnitToUnit(attack_mechanics_list,i);

                                        k = IsInUnit(temp_unit);
                                        if k <> i then
                                             case GetType(k) of
                                                  unit_vehicle: ComExitVehicle(temp_unit);
                                                  unit_building: ComExitBuilding(temp_unit);
                                                  else ComEnterUnit(temp_unit,i);
                                             end;

                                        attack_mechanics_list = attack_mechanics_list diff temp_unit;
                                   end;
                         end;


                    //Command vehicles.
                    for i in attack_vehicles_list do
                         begin
                              if not i in right_units and not i in left_units then
                                   begin
                                        if left_units > right_units then
                                             right_units = right_units ^ i
                                        else
                                             left_units = left_units ^ i;

                                        unit_target_hex_index = Replace(unit_target_hex_index,i,1);
                                   end;

                              if i in right_units then
                                   attack_hexes = right_road_hexes
                              else attack_hexes = left_road_hexes;

                              if GetDistUnitXY(i,attack_hexes[unit_target_hex_index[i]][1],attack_hexes[unit_target_hex_index[i]][2]) < 3 then
                                   begin
                                        unit_target_hex_index = Replace(unit_target_hex_index,i,unit_target_hex_index[i]+1);
                                        if unit_target_hex_index[i] > attack_hexes then
                                             unit_target_hex_index = Replace(unit_target_hex_index,i,1);
                                   end;

                              //If the unit is shooting at a unit which is Ok and there is a dying human
                                        //unit within the same distance or closer than the current target then
                                        //kill off that human unit first.
                                        {temp_value = GetTaskList(i);
                                        if temp_value = 1 then
                                             if temp_value[1][1] = '^' then  //'^' is auto attack
                                                  begin
                                                       //The unit is auto attacking because it has met an enemy.
                                                       temp_unit = Attacks(i);
                                                       if temp_unit > 0 and IsOk(temp_unit) then
                                                            begin
                                                                 temp_value = GetDistUnits(i,temp_unit);
                                                                 temp_list = FilterAllUnits([[f_enemy,side],[f_type,unit_human],[f_not,[f_ok]],[f_dist,i,temp_value]]);
                                                                 if temp_list > 0 then
                                                                      ComAttackUnit(i,temp_list[1]);

                                                                 continue;
                                                            end;
                                                  end;}

                              ComAgressiveMove(i,attack_hexes[unit_target_hex_index[i]][1],attack_hexes[unit_target_hex_index[i]][2]);
                         end;
               end;

          until false;
     end;


//The computers's vehicles never seem to run completely out of fuel...
Every 0$5 do
     var base, i;
     begin
          for base in ai_bases do
               for i in ai_vehicles_attack[base] ^ ai_vehicles_defend[base] ^ FilterAllUnits([[f_side,russians],[f_weapon,ru_cargo_bay]]) do
                    if GetFuel(i) < 10 and GetEngine(i) = engine_combustion then
                         SetFuel(i,10);

          enable;
     end;


//Scientists
//If a scientist is wounded them pull him/her back. Else heal what people needs healing. Else stay inside a lab (if no lab is Ok then help
//construct buildings).
Every 0$1 do
     var side, i, scientists_list, temp_list, temp_unit, base, k, temp_list_3, free_spaces, area, val, j;
     var wandering_scientists, wander_timer;
     begin
          side = russians;

          //Scientists walk back and forth between labs now and then (to exchange documents
          //and such).
          wandering_scientists = [];
          wander_timer = 1$0;

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    scientists_list = ai_scientists[base] diff ai_heal_these_humans[base];


                    //Identify scientists who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= scientists_list do
                         begin
                              if GetLives(scientists_list[i]) <= 700 then
                                   begin
                                        temp_list = temp_list ^ scientists_list[i];
                                        scientists_list = Delete(scientists_list,i);
                                        i = i - 1;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Update people who need healing. People at full HP or people inside a unit (relevant for soldiers and mechanics)
                    //will not receive healing.
                    temp_list = [];
                    for i in ai_heal_these_humans[base] do
                         if GetLives(i) < 1000 and IsInUnit(i) = 0 then
                              temp_list = temp_list ^ i;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Control people who need healing (except soldiers if base is in code black). Make 'em retreat to the human pullback hex.
                    for i in ai_heal_these_humans[base] do
                         if ( not code_black or not GetClass(i) in [class_soldier,class_bazooker] ) and GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 4 then
                              case GetType(IsInUnit(i)) of
                                   unit_vehicle: ComExitVehicle(i);
                                   unit_building: ComExitBuilding(i);
                                   else
                                        ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
                              end;


                    if scientists_list = 0 then
                         continue;


                    //Heal people. At least one scientist for each human if possible.
                    if ai_heal_these_humans[base] > 0 then
                         begin
                              //If we only heal humans inside the base it will be very difficult to
                              //lure the scientists out of the labs.
                              //temp_list = UnitFilter(ai_heal_these_humans[base],[f_inarea,ru_base_area]);
                              temp_list = ai_heal_these_humans[base];

                              if temp_list > 0 then
                                   begin
                                        scientists_list = GetHumansOutOfUnits(scientists_list);
                                        repeat
                                             i = 1;
                                             while i <= temp_list do
                                                  begin
                                                       if scientists_list = 0 then
                                                            break;

                                                       temp_unit = NearestUnitToUnit(scientists_list,temp_list[i]);
                                                       ComHeal(temp_unit,temp_list[i]);
                                                       scientists_list = scientists_list diff temp_unit;

                                                       i = i + 1;
                                                  end;

                                        until scientists_list = 0;
                                   end;
                         end;


                    //Barovnin is always in The Archive (if possible of course).
                    if IsLive(Barovnin) and IsOk(the_archive) and Barovnin in scientists_list then
                         begin
                              scientists_list = scientists_list diff Barovnin;

                              temp_unit = IsinUnit(Barovnin);
                              case GetType(temp_unit) of
                                   unit_vehicle: ComExitVehicle(Barovnin);
                                   unit_building:
                                        if temp_unit <> the_archive then
                                             ComExitBuilding(Barovnin);
                                   else
                                        ComEnterUnit(Barovnin,the_archive);
                              end;
                         end;


                    //Pick and control scientists to walk back and forth between labs.
                    //There's a higher chance the target lab will be The Archive than an "ordinary" lab.
                    //Likewise there's a higher chance a scientist from an "ordinary" lab is chosen to
                    //wander than a scientist from The Archive.
                    //Don't wander if the base is in code black.
                    if not code_black then
                    begin
                    wander_timer = wander_timer - 0$1;
                    if wander_timer <= 0$0 then
                         begin
                              temp_list_3 = [];
                              for i in wandering_scientists do
                                   temp_list_3 = temp_list_3 ^ i[1];

                              temp_list_3 = scientists_list diff temp_list_3;

                              //Only take scientists who are inside a lab
                              temp_list = [];
                              for i in temp_list_3 do
                                   if IsInUnit(i) in ai_labs[1] then
                                        temp_list = temp_list ^ i;

                              if temp_list > 0 then
                                   begin
                                        wander_timer = Rand(0$30,0$45);

                                        temp_list_3 = [];  //gonna holds scientists inside The Archive
                                        for i in temp_list do
                                             if IsInUnit(i) = the_archive then
                                                  temp_list_3 = temp_list_3 ^ i;

                                        if Rand(1,9) = 1 and temp_list_3 > 0 then
                                             temp_list = temp_list_3  //use scis from The Archive
                                        else
                                             begin
                                                  temp_list = temp_list diff temp_list_3;  //use scis not from The Archive

                                                  if temp_list = 0 then  //we have to use scis from The Archive anyway
                                                       temp_list = temp_list_3;
                                             end;

                                        temp_unit = temp_list[Rand(1,temp_list)];

                                        //Don't go for the lab you are already inside
                                        k = 0;
                                        if Rand(1,9) = 1 or IsInUnit(temp_unit) = the_archive then
                                             begin
                                                  temp_list = ai_labs[1] diff IsInUnit(temp_unit);

                                                  if temp_list > 0 then
                                                       k = temp_list[Rand(1,temp_list)];
                                             end
                                        else
                                             k = the_archive;

                                        if k > 0 then
                                             wandering_scientists = wandering_scientists ^ [[temp_unit,k,Rand(0$5,0$10),false,IsInUnit(temp_unit)]];
                                   end;
                         end;

                    i = 1;
                    while i <= wandering_scientists do
                         begin
                              if not wandering_scientists[i][1] in scientists_list then
                                   begin
                                        i = i + 1;
                                        continue;
                                   end;

                              temp_unit = IsInUnit(wandering_scientists[i][1]);
                              if wandering_scientists[i][4] then
                                   k = wandering_scientists[i][5]  //lab where you came from
                              else
                                   k = wandering_scientists[i][2];

                              if temp_unit <> k then
                                   begin
                                        case GetType(temp_unit) of
                                             unit_vehicle: ComExitVehicle(wandering_scientists[i][1]);
                                             unit_building: ComExitBuilding(wandering_scientists[i][1]);
                                             else
                                                  begin
                                                       //Force a unit outside if building is full (not Barovnin)
                                                       if GetDistUnits(wandering_scientists[i][1],k) <= 5 then
                                                            begin
                                                                 temp_list = UnitsInside(k);
                                                                 if temp_list = 6 then
                                                                      begin
                                                                           val = 0;
                                                                           for j in temp_list do
                                                                                if j <> Barovnin then
                                                                                     begin
                                                                                          val = j;
                                                                                          break;
                                                                                     end;

                                                                           ComExitBuilding(val);
                                                                           wait(3);  //wait for exit
                                                                      end;
                                                            end;

                                                       ComEnterUnit(wandering_scientists[i][1],k);
                                                  end;
                                        end;
                                   end
                              else
                                   if not wandering_scientists[i][4] then
                                        begin
                                             temp_list = Replace(wandering_scientists[i],3,wandering_scientists[i][3]-0$1);
                                             wandering_scientists = Replace(wandering_scientists,i,temp_list);

                                             if wandering_scientists[i][3] <= 0$0 then
                                                  begin
                                                       temp_list = Replace(wandering_scientists[i],4,true);
                                                       wandering_scientists = Replace(wandering_scientists,i,temp_list);
                                                  end;
                                        end
                                   else
                                        begin
                                             wandering_scientists = Delete(wandering_scientists,i);
                                             i = i - 1;
                                        end;

                              i = i + 1;
                         end;

                    for i in wandering_scientists do
                         scientists_list = scientists_list diff i[1];
                    end;


                    //Enter and stay in lab
                    //Don't count in scientists already inside a lab if we have wandering scientists around.
                    //It could trigger a scientist being ordered to the lab, where a wandering scientist came
                    //from to even out the number of scientists in each lab.
                    if wandering_scientists > 0 then
                         begin
                              temp_list = [];
                              for i in scientists_list do
                                   if not IsInUnit(i) in ai_labs[1] then
                                        temp_list = temp_list ^ i;
                         end
                    else
                         temp_list = scientists_list;

                    DistributeHumansToBuildings(base,temp_list, UnitFilter(ai_labs[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_scientistic,6,true,false);
               end;

          until false;
     end;
//Labs continuously research something
Every 0$1+0$0.3 do
     var lab, first_time;
     begin
          first_time = true;

          repeat
          wait(0$5);

          for lab in ai_labs[1] do
               if BuildingStatus(lab) = bs_idle then
                    SetSpecResearch(lab,Rand(400,700),true);

          if first_time then
               begin
                    wait(0$1);  //wait for research to start
                    for lab in ai_labs[1] do
                         SetWorkingProgress(lab,Rand(1,90));  //so not all labs research synchronously from the beginning. Looks better

                    first_time = false;
               end;

          until false;
     end;
// export testing ; export you , russians , nature , you_alt , russians_alt ; export Heike , Dwayne , Oswald , Kurt , Gonzo ; export Stanimir , Barovnin , Yefibachev , Yakov , Natalya , Mikhail , good_pat , bad_pat , Dmitri , Sergei , Yann ; export poker_eng , poker_sol , poker_mec ; export ai_soldiers , ai_engineers , ai_mechanics_defend , ai_mechanics_attack , ai_scientists , ai_commander , ai_depot , ai_labs , ai_siberite_mines ; export ai_power_plants , ai_buildings_locations , ai_vehicles_defend , ai_vehicles_attack , ai_vehicle_pullback_hexes , ai_human_pullback_hex ; export ai_building_under_construction , ai_heal_these_humans , ai_all_buildings , ai_building_constructor , ai_vehicle_being_moved ; export ai_upcoming_building_data , ai_facts , ai_armouries , ai_bunkers , ai_oil_mine , ai_fact_extensions , ai_retreating_vehicles_defend ; export ai_going_to_attack_this_base , ai_refuel_vehicles_list , ai_vehicles_being_repaired ; export ai_vehicle_attack_delay , ai_bases , ai_has_switched_base_target , ai_cargo_bay , ai_cargo_bay_under_construction , ai_apemen_engineers ; export ai_attacking_soldiers , ai_attacking_scientists , ai_humans_ready_to_attack , ai_retreating_attacking_humans , ai_human_attack_delay ; export ai_vehicles_having_been_moved , ai_turrets , ai_captured_buildings ; export oswald_is_substitute , kurt_is_substitute , heike_parking_spot , cargo_bay_parking_spots , war_vehicle_parking_spots , the_archive ; export code_red , code_black , patrols , patrols_path , patrols_subpaths , halt_internal_patrol , terminate_internal_patrol , heike_undercover ; export entrance_guard_dialogue_played , code_black_soldiers , depot_north , patrols_path_hex_index ; export player_units_in_russian_buildings , recent_not_went_inside_units , engineers_vehicles_to_move_drivers ; export heike_undercover_entered_war_vehicle , recent_player_units_enter_russian_buildings , leader_office , leader_office_location ; export found_depot_document , send_sol_from_office_to_archive , sol_office_to_archive , the_cargo_bay_captured ; export num_documents_stolen , archive_found , mission_can_end , cargo_bays_origin , send_guard_from_entrance_to_office ; export entrance_guard_to_office , heike_arrived_to_base_in_this_cargo_bay , boyfriend_identified , dont_park_cargo_bay ; export heike_last_exit_building_tick , reenter_building_cooldown , except_Dmitri , except_Yakov , Yakov_to_archive , Yakov_luring ; export intel_party_vehicles , workshop_messenger , intel_soldier_to_archive , intel_party_leave , except_Yefibachev , in_out_russian_units ; export entrance_guard_dialogue_started , num_sabotaged_cargo_bays , last_known_enemy_hex , cargo_bays_being_moved , code_black_renew ; export start_display_guards_distracted_hint , max_num_documents_stealable ; starting begin RandomizeAll ;
   0: CALL_OW 11
// ResetFog ;
   4: CALL_OW 335
// testing = false ;
   8: LD_ADDR_EXP 1
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// ai_bases = [ 1 ] ;
  16: LD_ADDR_EXP 57
  20: PUSH
  21: LD_INT 1
  23: PUSH
  24: EMPTY
  25: LIST
  26: ST_TO_ADDR
// ai_soldiers = [ [ ] , [ ] ] ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: EMPTY
  33: PUSH
  34: EMPTY
  35: PUSH
  36: EMPTY
  37: LIST
  38: LIST
  39: ST_TO_ADDR
// ai_attacking_soldiers = [ [ ] , [ ] ] ;
  40: LD_ADDR_EXP 62
  44: PUSH
  45: EMPTY
  46: PUSH
  47: EMPTY
  48: PUSH
  49: EMPTY
  50: LIST
  51: LIST
  52: ST_TO_ADDR
// ai_engineers = [ [ ] , [ ] ] ;
  53: LD_ADDR_EXP 27
  57: PUSH
  58: EMPTY
  59: PUSH
  60: EMPTY
  61: PUSH
  62: EMPTY
  63: LIST
  64: LIST
  65: ST_TO_ADDR
// ai_mechanics_defend = [ [ ] , [ ] ] ;
  66: LD_ADDR_EXP 28
  70: PUSH
  71: EMPTY
  72: PUSH
  73: EMPTY
  74: PUSH
  75: EMPTY
  76: LIST
  77: LIST
  78: ST_TO_ADDR
// ai_mechanics_attack = [ [ ] , [ ] , [ ] ] ;
  79: LD_ADDR_EXP 29
  83: PUSH
  84: EMPTY
  85: PUSH
  86: EMPTY
  87: PUSH
  88: EMPTY
  89: PUSH
  90: EMPTY
  91: LIST
  92: LIST
  93: LIST
  94: ST_TO_ADDR
// ai_scientists = [ [ ] , [ ] ] ;
  95: LD_ADDR_EXP 30
  99: PUSH
 100: EMPTY
 101: PUSH
 102: EMPTY
 103: PUSH
 104: EMPTY
 105: LIST
 106: LIST
 107: ST_TO_ADDR
// ai_attacking_scientists = [ [ ] , [ ] ] ;
 108: LD_ADDR_EXP 63
 112: PUSH
 113: EMPTY
 114: PUSH
 115: EMPTY
 116: PUSH
 117: EMPTY
 118: LIST
 119: LIST
 120: ST_TO_ADDR
// ai_apemen_engineers = [ [ ] , [ ] ] ;
 121: LD_ADDR_EXP 61
 125: PUSH
 126: EMPTY
 127: PUSH
 128: EMPTY
 129: PUSH
 130: EMPTY
 131: LIST
 132: LIST
 133: ST_TO_ADDR
// ai_depot = [ 0 , 0 ] ;
 134: LD_ADDR_EXP 32
 138: PUSH
 139: LD_INT 0
 141: PUSH
 142: LD_INT 0
 144: PUSH
 145: EMPTY
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// ai_labs = [ [ ] , [ ] ] ;
 149: LD_ADDR_EXP 33
 153: PUSH
 154: EMPTY
 155: PUSH
 156: EMPTY
 157: PUSH
 158: EMPTY
 159: LIST
 160: LIST
 161: ST_TO_ADDR
// ai_facts = [ [ ] , [ ] ] ;
 162: LD_ADDR_EXP 47
 166: PUSH
 167: EMPTY
 168: PUSH
 169: EMPTY
 170: PUSH
 171: EMPTY
 172: LIST
 173: LIST
 174: ST_TO_ADDR
// ai_armouries = [ [ ] , [ ] ] ;
 175: LD_ADDR_EXP 48
 179: PUSH
 180: EMPTY
 181: PUSH
 182: EMPTY
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// ai_bunkers = [ [ ] , [ ] ] ;
 188: LD_ADDR_EXP 49
 192: PUSH
 193: EMPTY
 194: PUSH
 195: EMPTY
 196: PUSH
 197: EMPTY
 198: LIST
 199: LIST
 200: ST_TO_ADDR
// ai_turrets = [ [ ] , [ ] ] ;
 201: LD_ADDR_EXP 68
 205: PUSH
 206: EMPTY
 207: PUSH
 208: EMPTY
 209: PUSH
 210: EMPTY
 211: LIST
 212: LIST
 213: ST_TO_ADDR
// ai_oil_mine = [ 0 , 0 ] ;
 214: LD_ADDR_EXP 50
 218: PUSH
 219: LD_INT 0
 221: PUSH
 222: LD_INT 0
 224: PUSH
 225: EMPTY
 226: LIST
 227: LIST
 228: ST_TO_ADDR
// ai_siberite_mines = [ [ ] , [ ] ] ;
 229: LD_ADDR_EXP 34
 233: PUSH
 234: EMPTY
 235: PUSH
 236: EMPTY
 237: PUSH
 238: EMPTY
 239: LIST
 240: LIST
 241: ST_TO_ADDR
// ai_fact_extensions = [ [ ] , [ ] ] ;
 242: LD_ADDR_EXP 51
 246: PUSH
 247: EMPTY
 248: PUSH
 249: EMPTY
 250: PUSH
 251: EMPTY
 252: LIST
 253: LIST
 254: ST_TO_ADDR
// ai_power_plants = [ [ ] , [ ] ] ;
 255: LD_ADDR_EXP 35
 259: PUSH
 260: EMPTY
 261: PUSH
 262: EMPTY
 263: PUSH
 264: EMPTY
 265: LIST
 266: LIST
 267: ST_TO_ADDR
// ai_buildings_locations = [ [ ] , [ ] ] ;
 268: LD_ADDR_EXP 36
 272: PUSH
 273: EMPTY
 274: PUSH
 275: EMPTY
 276: PUSH
 277: EMPTY
 278: LIST
 279: LIST
 280: ST_TO_ADDR
// ai_captured_buildings = [ [ ] , [ ] ] ;
 281: LD_ADDR_EXP 69
 285: PUSH
 286: EMPTY
 287: PUSH
 288: EMPTY
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: ST_TO_ADDR
// ai_vehicles_defend = [ [ ] , [ ] ] ;
 294: LD_ADDR_EXP 37
 298: PUSH
 299: EMPTY
 300: PUSH
 301: EMPTY
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: ST_TO_ADDR
// ai_vehicles_attack = [ [ ] , [ ] ] ;
 307: LD_ADDR_EXP 38
 311: PUSH
 312: EMPTY
 313: PUSH
 314: EMPTY
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: ST_TO_ADDR
// ai_retreating_vehicles_defend = [ [ ] , [ ] ] ;
 320: LD_ADDR_EXP 52
 324: PUSH
 325: EMPTY
 326: PUSH
 327: EMPTY
 328: PUSH
 329: EMPTY
 330: LIST
 331: LIST
 332: ST_TO_ADDR
// ai_vehicles_being_repaired = [ [ ] , [ ] ] ;
 333: LD_ADDR_EXP 55
 337: PUSH
 338: EMPTY
 339: PUSH
 340: EMPTY
 341: PUSH
 342: EMPTY
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// ai_refuel_vehicles_list = [ [ ] , [ ] ] ;
 346: LD_ADDR_EXP 54
 350: PUSH
 351: EMPTY
 352: PUSH
 353: EMPTY
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: ST_TO_ADDR
// ai_vehicle_pullback_hexes = [ [ ] , [ ] ] ;
 359: LD_ADDR_EXP 39
 363: PUSH
 364: EMPTY
 365: PUSH
 366: EMPTY
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: ST_TO_ADDR
// ai_human_pullback_hex = [ [ 58 , 25 ] , [ ] ] ;
 372: LD_ADDR_EXP 40
 376: PUSH
 377: LD_INT 58
 379: PUSH
 380: LD_INT 25
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: PUSH
 387: EMPTY
 388: PUSH
 389: EMPTY
 390: LIST
 391: LIST
 392: ST_TO_ADDR
// ai_building_under_construction = [ 0 , 0 ] ;
 393: LD_ADDR_EXP 41
 397: PUSH
 398: LD_INT 0
 400: PUSH
 401: LD_INT 0
 403: PUSH
 404: EMPTY
 405: LIST
 406: LIST
 407: ST_TO_ADDR
// ai_heal_these_humans = [ [ ] , [ ] ] ;
 408: LD_ADDR_EXP 42
 412: PUSH
 413: EMPTY
 414: PUSH
 415: EMPTY
 416: PUSH
 417: EMPTY
 418: LIST
 419: LIST
 420: ST_TO_ADDR
// ai_all_buildings = [ [ ] , [ ] ] ;
 421: LD_ADDR_EXP 43
 425: PUSH
 426: EMPTY
 427: PUSH
 428: EMPTY
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: ST_TO_ADDR
// ai_building_constructor = [ 0 , 0 ] ;
 434: LD_ADDR_EXP 44
 438: PUSH
 439: LD_INT 0
 441: PUSH
 442: LD_INT 0
 444: PUSH
 445: EMPTY
 446: LIST
 447: LIST
 448: ST_TO_ADDR
// ai_vehicle_being_moved = [ 0 , - 1 , 0 ] ;
 449: LD_ADDR_EXP 45
 453: PUSH
 454: LD_INT 0
 456: PUSH
 457: LD_INT 1
 459: NEG
 460: PUSH
 461: LD_INT 0
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: ST_TO_ADDR
// ai_vehicles_having_been_moved = [ [ ] , [ ] ] ;
 469: LD_ADDR_EXP 67
 473: PUSH
 474: EMPTY
 475: PUSH
 476: EMPTY
 477: PUSH
 478: EMPTY
 479: LIST
 480: LIST
 481: ST_TO_ADDR
// ai_upcoming_building_data = [ [ ] , [ ] ] ;
 482: LD_ADDR_EXP 46
 486: PUSH
 487: EMPTY
 488: PUSH
 489: EMPTY
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: ST_TO_ADDR
// ai_vehicle_attack_delay = [ 0 0$0 , 0 0$0 ] ;
 495: LD_ADDR_EXP 56
 499: PUSH
 500: LD_INT 0
 502: PUSH
 503: LD_INT 0
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: ST_TO_ADDR
// ai_human_attack_delay = [ 0 0$0 , 0 0$0 ] ;
 510: LD_ADDR_EXP 66
 514: PUSH
 515: LD_INT 0
 517: PUSH
 518: LD_INT 0
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: ST_TO_ADDR
// ai_cargo_bay = [ 0 , 0 ] ;
 525: LD_ADDR_EXP 59
 529: PUSH
 530: LD_INT 0
 532: PUSH
 533: LD_INT 0
 535: PUSH
 536: EMPTY
 537: LIST
 538: LIST
 539: ST_TO_ADDR
// ai_cargo_bay_under_construction = [ false , false ] ;
 540: LD_ADDR_EXP 60
 544: PUSH
 545: LD_INT 0
 547: PUSH
 548: LD_INT 0
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: ST_TO_ADDR
// ai_humans_ready_to_attack = [ false , false ] ;
 555: LD_ADDR_EXP 64
 559: PUSH
 560: LD_INT 0
 562: PUSH
 563: LD_INT 0
 565: PUSH
 566: EMPTY
 567: LIST
 568: LIST
 569: ST_TO_ADDR
// ai_retreating_attacking_humans = [ [ ] , [ ] ] ;
 570: LD_ADDR_EXP 65
 574: PUSH
 575: EMPTY
 576: PUSH
 577: EMPTY
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: ST_TO_ADDR
// oswald_is_substitute = false ;
 583: LD_ADDR_EXP 70
 587: PUSH
 588: LD_INT 0
 590: ST_TO_ADDR
// kurt_is_substitute = false ;
 591: LD_ADDR_EXP 71
 595: PUSH
 596: LD_INT 0
 598: ST_TO_ADDR
// heike_parking_spot = Rand ( 1 , 3 ) ;
 599: LD_ADDR_EXP 72
 603: PUSH
 604: LD_INT 1
 606: PPUSH
 607: LD_INT 3
 609: PPUSH
 610: CALL_OW 12
 614: ST_TO_ADDR
// cargo_bay_parking_spots = [ ] ;
 615: LD_ADDR_EXP 73
 619: PUSH
 620: EMPTY
 621: ST_TO_ADDR
// war_vehicle_parking_spots = [ ] ;
 622: LD_ADDR_EXP 74
 626: PUSH
 627: EMPTY
 628: ST_TO_ADDR
// the_archive = - 1 ;
 629: LD_ADDR_EXP 75
 633: PUSH
 634: LD_INT 1
 636: NEG
 637: ST_TO_ADDR
// code_red = false ;
 638: LD_ADDR_EXP 76
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// code_black = false ;
 646: LD_ADDR_EXP 77
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// patrols = [ [ ] , [ ] ] ;
 654: LD_ADDR_EXP 78
 658: PUSH
 659: EMPTY
 660: PUSH
 661: EMPTY
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: ST_TO_ADDR
// patrols_path = [ [ ] , [ ] ] ;
 667: LD_ADDR_EXP 79
 671: PUSH
 672: EMPTY
 673: PUSH
 674: EMPTY
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: ST_TO_ADDR
// patrols_path_hex_index = [ 1 , 1 ] ;
 680: LD_ADDR_EXP 87
 684: PUSH
 685: LD_INT 1
 687: PUSH
 688: LD_INT 1
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: ST_TO_ADDR
// patrols_subpaths = [ [ 1000 , [ 1001 ] , [ 27 , 7 ] , [ 19 , 20 ] , [ 27 , 38 ] , [ 37 , 62 ] ] , [ 1000 , [ 1001 ] , [ 47 , 48 ] , [ 45 , 62 ] ] , [ 1001 , [ 1002 ] , [ 51 , 79 ] , [ 61 , 99 ] , [ 64 , 115 ] , [ 76 , 107 ] ] , [ 1001 , [ 1002 ] , [ 61 , 80 ] , [ 75 , 95 ] ] , [ 1002 , [ 1003 ] , [ 95 , 109 ] , [ 107 , 107 ] , [ 114 , 99 ] ] , [ 1002 , [ 1003 ] , [ 95 , 109 ] , [ 97 , 100 ] , [ 102 , 95 ] , [ 114 , 99 ] ] , [ 1003 , [ 1006 , 1008 ] , [ 113 , 85 ] , [ 106 , 69 ] , [ 119 , 60 ] ] , [ 1003 , [ 1006 , 1008 ] , [ 129 , 85 ] , [ 130 , 69 ] ] , [ 1003 , [ 1004 ] , [ 136 , 109 ] ] , [ 1004 , [ 1005 , 1009 ] , [ 156 , 111 ] , [ 171 , 108 ] , [ 163 , 89 ] ] , [ 1004 , [ 1005 , 1009 ] , [ 148 , 99 ] , [ 146 , 83 ] ] , [ 1005 , [ 1006 ] , [ 130 , 69 ] ] , [ 1006 , [ 1007 ] , [ 119 , 49 ] , [ 105 , 26 ] ] , [ 1007 , [ ] , [ 92 , 23 ] ] , [ 1007 , [ ] , [ 95 , 15 ] , [ 87 , 4 ] , [ 92 , 23 ] ] , [ 1008 , [ 1009 ] , [ 142 , 76 ] ] , [ 1009 , [ 1010 ] , [ 159 , 74 ] ] , [ 1010 , [ 1011 ] , [ 141 , 54 ] ] , [ 1010 , [ 1011 ] , [ 151 , 58 ] , [ 145 , 37 ] , [ 141 , 54 ] ] , [ 1011 , [ 1007 ] , [ 121 , 40 ] , [ 105 , 26 ] ] ] ;
 695: LD_ADDR_EXP 80
 699: PUSH
 700: LD_INT 1000
 702: PUSH
 703: LD_INT 1001
 705: PUSH
 706: EMPTY
 707: LIST
 708: PUSH
 709: LD_INT 27
 711: PUSH
 712: LD_INT 7
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: PUSH
 719: LD_INT 19
 721: PUSH
 722: LD_INT 20
 724: PUSH
 725: EMPTY
 726: LIST
 727: LIST
 728: PUSH
 729: LD_INT 27
 731: PUSH
 732: LD_INT 38
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: PUSH
 739: LD_INT 37
 741: PUSH
 742: LD_INT 62
 744: PUSH
 745: EMPTY
 746: LIST
 747: LIST
 748: PUSH
 749: EMPTY
 750: LIST
 751: LIST
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: PUSH
 757: LD_INT 1000
 759: PUSH
 760: LD_INT 1001
 762: PUSH
 763: EMPTY
 764: LIST
 765: PUSH
 766: LD_INT 47
 768: PUSH
 769: LD_INT 48
 771: PUSH
 772: EMPTY
 773: LIST
 774: LIST
 775: PUSH
 776: LD_INT 45
 778: PUSH
 779: LD_INT 62
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_INT 1001
 794: PUSH
 795: LD_INT 1002
 797: PUSH
 798: EMPTY
 799: LIST
 800: PUSH
 801: LD_INT 51
 803: PUSH
 804: LD_INT 79
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: PUSH
 811: LD_INT 61
 813: PUSH
 814: LD_INT 99
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: PUSH
 821: LD_INT 64
 823: PUSH
 824: LD_INT 115
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 76
 833: PUSH
 834: LD_INT 107
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: LD_INT 1001
 851: PUSH
 852: LD_INT 1002
 854: PUSH
 855: EMPTY
 856: LIST
 857: PUSH
 858: LD_INT 61
 860: PUSH
 861: LD_INT 80
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 75
 870: PUSH
 871: LD_INT 95
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: PUSH
 884: LD_INT 1002
 886: PUSH
 887: LD_INT 1003
 889: PUSH
 890: EMPTY
 891: LIST
 892: PUSH
 893: LD_INT 95
 895: PUSH
 896: LD_INT 109
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: PUSH
 903: LD_INT 107
 905: PUSH
 906: LD_INT 107
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 114
 915: PUSH
 916: LD_INT 99
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: LIST
 927: LIST
 928: LIST
 929: PUSH
 930: LD_INT 1002
 932: PUSH
 933: LD_INT 1003
 935: PUSH
 936: EMPTY
 937: LIST
 938: PUSH
 939: LD_INT 95
 941: PUSH
 942: LD_INT 109
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 97
 951: PUSH
 952: LD_INT 100
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: PUSH
 959: LD_INT 102
 961: PUSH
 962: LD_INT 95
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: PUSH
 969: LD_INT 114
 971: PUSH
 972: LD_INT 99
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: LIST
 985: LIST
 986: PUSH
 987: LD_INT 1003
 989: PUSH
 990: LD_INT 1006
 992: PUSH
 993: LD_INT 1008
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 113
1002: PUSH
1003: LD_INT 85
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PUSH
1010: LD_INT 106
1012: PUSH
1013: LD_INT 69
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: PUSH
1020: LD_INT 119
1022: PUSH
1023: LD_INT 60
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 1003
1039: PUSH
1040: LD_INT 1006
1042: PUSH
1043: LD_INT 1008
1045: PUSH
1046: EMPTY
1047: LIST
1048: LIST
1049: PUSH
1050: LD_INT 129
1052: PUSH
1053: LD_INT 85
1055: PUSH
1056: EMPTY
1057: LIST
1058: LIST
1059: PUSH
1060: LD_INT 130
1062: PUSH
1063: LD_INT 69
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: PUSH
1070: EMPTY
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_INT 1003
1078: PUSH
1079: LD_INT 1004
1081: PUSH
1082: EMPTY
1083: LIST
1084: PUSH
1085: LD_INT 136
1087: PUSH
1088: LD_INT 109
1090: PUSH
1091: EMPTY
1092: LIST
1093: LIST
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 1004
1102: PUSH
1103: LD_INT 1005
1105: PUSH
1106: LD_INT 1009
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 156
1115: PUSH
1116: LD_INT 111
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: PUSH
1123: LD_INT 171
1125: PUSH
1126: LD_INT 108
1128: PUSH
1129: EMPTY
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 163
1135: PUSH
1136: LD_INT 89
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 1004
1152: PUSH
1153: LD_INT 1005
1155: PUSH
1156: LD_INT 1009
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: PUSH
1163: LD_INT 148
1165: PUSH
1166: LD_INT 99
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 146
1175: PUSH
1176: LD_INT 83
1178: PUSH
1179: EMPTY
1180: LIST
1181: LIST
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: LIST
1187: LIST
1188: PUSH
1189: LD_INT 1005
1191: PUSH
1192: LD_INT 1006
1194: PUSH
1195: EMPTY
1196: LIST
1197: PUSH
1198: LD_INT 130
1200: PUSH
1201: LD_INT 69
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: LD_INT 1006
1215: PUSH
1216: LD_INT 1007
1218: PUSH
1219: EMPTY
1220: LIST
1221: PUSH
1222: LD_INT 119
1224: PUSH
1225: LD_INT 49
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: PUSH
1232: LD_INT 105
1234: PUSH
1235: LD_INT 26
1237: PUSH
1238: EMPTY
1239: LIST
1240: LIST
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 1007
1250: PUSH
1251: EMPTY
1252: PUSH
1253: LD_INT 92
1255: PUSH
1256: LD_INT 23
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: PUSH
1263: EMPTY
1264: LIST
1265: LIST
1266: LIST
1267: PUSH
1268: LD_INT 1007
1270: PUSH
1271: EMPTY
1272: PUSH
1273: LD_INT 95
1275: PUSH
1276: LD_INT 15
1278: PUSH
1279: EMPTY
1280: LIST
1281: LIST
1282: PUSH
1283: LD_INT 87
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: PUSH
1293: LD_INT 92
1295: PUSH
1296: LD_INT 23
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: LIST
1307: LIST
1308: LIST
1309: PUSH
1310: LD_INT 1008
1312: PUSH
1313: LD_INT 1009
1315: PUSH
1316: EMPTY
1317: LIST
1318: PUSH
1319: LD_INT 142
1321: PUSH
1322: LD_INT 76
1324: PUSH
1325: EMPTY
1326: LIST
1327: LIST
1328: PUSH
1329: EMPTY
1330: LIST
1331: LIST
1332: LIST
1333: PUSH
1334: LD_INT 1009
1336: PUSH
1337: LD_INT 1010
1339: PUSH
1340: EMPTY
1341: LIST
1342: PUSH
1343: LD_INT 159
1345: PUSH
1346: LD_INT 74
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: PUSH
1353: EMPTY
1354: LIST
1355: LIST
1356: LIST
1357: PUSH
1358: LD_INT 1010
1360: PUSH
1361: LD_INT 1011
1363: PUSH
1364: EMPTY
1365: LIST
1366: PUSH
1367: LD_INT 141
1369: PUSH
1370: LD_INT 54
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: PUSH
1382: LD_INT 1010
1384: PUSH
1385: LD_INT 1011
1387: PUSH
1388: EMPTY
1389: LIST
1390: PUSH
1391: LD_INT 151
1393: PUSH
1394: LD_INT 58
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: PUSH
1401: LD_INT 145
1403: PUSH
1404: LD_INT 37
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: PUSH
1411: LD_INT 141
1413: PUSH
1414: LD_INT 54
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: PUSH
1428: LD_INT 1011
1430: PUSH
1431: LD_INT 1007
1433: PUSH
1434: EMPTY
1435: LIST
1436: PUSH
1437: LD_INT 121
1439: PUSH
1440: LD_INT 40
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: PUSH
1447: LD_INT 105
1449: PUSH
1450: LD_INT 26
1452: PUSH
1453: EMPTY
1454: LIST
1455: LIST
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: ST_TO_ADDR
// halt_internal_patrol = 0 ;
1485: LD_ADDR_EXP 81
1489: PUSH
1490: LD_INT 0
1492: ST_TO_ADDR
// terminate_internal_patrol = false ;
1493: LD_ADDR_EXP 82
1497: PUSH
1498: LD_INT 0
1500: ST_TO_ADDR
// heike_undercover = 0 ;
1501: LD_ADDR_EXP 83
1505: PUSH
1506: LD_INT 0
1508: ST_TO_ADDR
// entrance_guard_dialogue_played = false ;
1509: LD_ADDR_EXP 84
1513: PUSH
1514: LD_INT 0
1516: ST_TO_ADDR
// code_black_soldiers = [ ] ;
1517: LD_ADDR_EXP 85
1521: PUSH
1522: EMPTY
1523: ST_TO_ADDR
// depot_north = 0 ;
1524: LD_ADDR_EXP 86
1528: PUSH
1529: LD_INT 0
1531: ST_TO_ADDR
// player_units_in_russian_buildings = [ ] ;
1532: LD_ADDR_EXP 88
1536: PUSH
1537: EMPTY
1538: ST_TO_ADDR
// recent_not_went_inside_units = [ ] ;
1539: LD_ADDR_EXP 89
1543: PUSH
1544: EMPTY
1545: ST_TO_ADDR
// engineers_vehicles_to_move_drivers = [ ] ;
1546: LD_ADDR_EXP 90
1550: PUSH
1551: EMPTY
1552: ST_TO_ADDR
// heike_undercover_entered_war_vehicle = false ;
1553: LD_ADDR_EXP 91
1557: PUSH
1558: LD_INT 0
1560: ST_TO_ADDR
// recent_player_units_enter_russian_buildings = [ ] ;
1561: LD_ADDR_EXP 92
1565: PUSH
1566: EMPTY
1567: ST_TO_ADDR
// leader_office = 0 ;
1568: LD_ADDR_EXP 93
1572: PUSH
1573: LD_INT 0
1575: ST_TO_ADDR
// leader_office_location = [ ] ;
1576: LD_ADDR_EXP 94
1580: PUSH
1581: EMPTY
1582: ST_TO_ADDR
// found_depot_document = false ;
1583: LD_ADDR_EXP 95
1587: PUSH
1588: LD_INT 0
1590: ST_TO_ADDR
// send_sol_from_office_to_archive = false ;
1591: LD_ADDR_EXP 96
1595: PUSH
1596: LD_INT 0
1598: ST_TO_ADDR
// sol_office_to_archive = 0 ;
1599: LD_ADDR_EXP 97
1603: PUSH
1604: LD_INT 0
1606: ST_TO_ADDR
// the_cargo_bay_captured = 0 ;
1607: LD_ADDR_EXP 98
1611: PUSH
1612: LD_INT 0
1614: ST_TO_ADDR
// num_documents_stolen = - 1 ;
1615: LD_ADDR_EXP 99
1619: PUSH
1620: LD_INT 1
1622: NEG
1623: ST_TO_ADDR
// archive_found = false ;
1624: LD_ADDR_EXP 100
1628: PUSH
1629: LD_INT 0
1631: ST_TO_ADDR
// mission_can_end = false ;
1632: LD_ADDR_EXP 101
1636: PUSH
1637: LD_INT 0
1639: ST_TO_ADDR
// cargo_bays_origin = [ ] ;
1640: LD_ADDR_EXP 102
1644: PUSH
1645: EMPTY
1646: ST_TO_ADDR
// send_guard_from_entrance_to_office = false ;
1647: LD_ADDR_EXP 103
1651: PUSH
1652: LD_INT 0
1654: ST_TO_ADDR
// entrance_guard_to_office = 0 ;
1655: LD_ADDR_EXP 104
1659: PUSH
1660: LD_INT 0
1662: ST_TO_ADDR
// heike_arrived_to_base_in_this_cargo_bay = 0 ;
1663: LD_ADDR_EXP 105
1667: PUSH
1668: LD_INT 0
1670: ST_TO_ADDR
// boyfriend_identified = false ;
1671: LD_ADDR_EXP 106
1675: PUSH
1676: LD_INT 0
1678: ST_TO_ADDR
// dont_park_cargo_bay = 0 ;
1679: LD_ADDR_EXP 107
1683: PUSH
1684: LD_INT 0
1686: ST_TO_ADDR
// heike_last_exit_building_tick = 0 ;
1687: LD_ADDR_EXP 108
1691: PUSH
1692: LD_INT 0
1694: ST_TO_ADDR
// reenter_building_cooldown = 0 0$5 ;
1695: LD_ADDR_EXP 109
1699: PUSH
1700: LD_INT 175
1702: ST_TO_ADDR
// except_Dmitri = false ;
1703: LD_ADDR_EXP 110
1707: PUSH
1708: LD_INT 0
1710: ST_TO_ADDR
// except_Yakov = false ;
1711: LD_ADDR_EXP 111
1715: PUSH
1716: LD_INT 0
1718: ST_TO_ADDR
// Yakov_to_archive = false ;
1719: LD_ADDR_EXP 112
1723: PUSH
1724: LD_INT 0
1726: ST_TO_ADDR
// Yakov_luring = 0 ;
1727: LD_ADDR_EXP 113
1731: PUSH
1732: LD_INT 0
1734: ST_TO_ADDR
// intel_party_vehicles = [ ] ;
1735: LD_ADDR_EXP 114
1739: PUSH
1740: EMPTY
1741: ST_TO_ADDR
// workshop_messenger = 0 ;
1742: LD_ADDR_EXP 115
1746: PUSH
1747: LD_INT 0
1749: ST_TO_ADDR
// intel_party_leave = false ;
1750: LD_ADDR_EXP 117
1754: PUSH
1755: LD_INT 0
1757: ST_TO_ADDR
// except_Yefibachev = false ;
1758: LD_ADDR_EXP 118
1762: PUSH
1763: LD_INT 0
1765: ST_TO_ADDR
// in_out_russian_units = [ ] ;
1766: LD_ADDR_EXP 119
1770: PUSH
1771: EMPTY
1772: ST_TO_ADDR
// entrance_guard_dialogue_started = false ;
1773: LD_ADDR_EXP 120
1777: PUSH
1778: LD_INT 0
1780: ST_TO_ADDR
// num_sabotaged_cargo_bays = 0 ;
1781: LD_ADDR_EXP 121
1785: PUSH
1786: LD_INT 0
1788: ST_TO_ADDR
// last_known_enemy_hex = ai_human_pullback_hex [ 1 ] ;
1789: LD_ADDR_EXP 122
1793: PUSH
1794: LD_EXP 40
1798: PUSH
1799: LD_INT 1
1801: ARRAY
1802: ST_TO_ADDR
// cargo_bays_being_moved = [ ] ;
1803: LD_ADDR_EXP 123
1807: PUSH
1808: EMPTY
1809: ST_TO_ADDR
// code_black_renew = false ;
1810: LD_ADDR_EXP 124
1814: PUSH
1815: LD_INT 0
1817: ST_TO_ADDR
// start_display_guards_distracted_hint = false ;
1818: LD_ADDR_EXP 125
1822: PUSH
1823: LD_INT 0
1825: ST_TO_ADDR
// max_num_documents_stealable = 50 ;
1826: LD_ADDR_EXP 126
1830: PUSH
1831: LD_INT 50
1833: ST_TO_ADDR
// PrepareSides ;
1834: CALL 1859 0 0
// PrepareNature ;
1838: CALL 2027 0 0
// PrepareArabians ;
1842: CALL 2762 0 0
// ScanBuildings ;
1846: CALL 3325 0 0
// PrepareComputerSides ;
1850: CALL 5427 0 0
// Action ;
1854: CALL 8200 0 0
// end ;
1858: END
// function PrepareSides ; begin
1859: LD_INT 0
1861: PPUSH
// nature = 0 ;
1862: LD_ADDR_EXP 4
1866: PUSH
1867: LD_INT 0
1869: ST_TO_ADDR
// you = 2 ;
1870: LD_ADDR_EXP 2
1874: PUSH
1875: LD_INT 2
1877: ST_TO_ADDR
// russians = 3 ;
1878: LD_ADDR_EXP 3
1882: PUSH
1883: LD_INT 3
1885: ST_TO_ADDR
// you_alt = 5 ;
1886: LD_ADDR_EXP 5
1890: PUSH
1891: LD_INT 5
1893: ST_TO_ADDR
// russians_alt = 6 ;
1894: LD_ADDR_EXP 6
1898: PUSH
1899: LD_INT 6
1901: ST_TO_ADDR
// SetAttitude ( you , russians , att_enemy , true ) ;
1902: LD_EXP 2
1906: PPUSH
1907: LD_EXP 3
1911: PPUSH
1912: LD_INT 2
1914: PPUSH
1915: LD_INT 1
1917: PPUSH
1918: CALL_OW 80
// SetAttitude ( you , you_alt , att_friend , true ) ;
1922: LD_EXP 2
1926: PPUSH
1927: LD_EXP 5
1931: PPUSH
1932: LD_INT 1
1934: PPUSH
1935: LD_INT 1
1937: PPUSH
1938: CALL_OW 80
// SetAttitude ( you , russians_alt , att_enemy , true ) ;
1942: LD_EXP 2
1946: PPUSH
1947: LD_EXP 6
1951: PPUSH
1952: LD_INT 2
1954: PPUSH
1955: LD_INT 1
1957: PPUSH
1958: CALL_OW 80
// SetAttitude ( russians , you_alt , att_enemy , true ) ;
1962: LD_EXP 3
1966: PPUSH
1967: LD_EXP 5
1971: PPUSH
1972: LD_INT 2
1974: PPUSH
1975: LD_INT 1
1977: PPUSH
1978: CALL_OW 80
// SetAttitude ( russians , russians_alt , att_friend , true ) ;
1982: LD_EXP 3
1986: PPUSH
1987: LD_EXP 6
1991: PPUSH
1992: LD_INT 1
1994: PPUSH
1995: LD_INT 1
1997: PPUSH
1998: CALL_OW 80
// SetAttitude ( you_alt , russians_alt , att_enemy , true ) ;
2002: LD_EXP 5
2006: PPUSH
2007: LD_EXP 6
2011: PPUSH
2012: LD_INT 2
2014: PPUSH
2015: LD_INT 1
2017: PPUSH
2018: CALL_OW 80
// end ;
2022: LD_VAR 0 1
2026: RET
// function PrepareNature ; var i , spots , num , agres , count , temp_unit ; begin
2027: LD_INT 0
2029: PPUSH
2030: PPUSH
2031: PPUSH
2032: PPUSH
2033: PPUSH
2034: PPUSH
2035: PPUSH
// spots = [ [ 19 , 26 ] , [ 34 , 51 ] , [ 53 , 86 ] , [ 77 , 95 ] , [ 88 , 115 ] , [ 65 , 111 ] , [ 142 , 108 ] , [ 161 , 107 ] , [ 171 , 99 ] , [ 146 , 88 ] , [ 151 , 66 ] , [ 146 , 38 ] , [ 117 , 42 ] , [ 89 , 6 ] ] ;
2036: LD_ADDR_VAR 0 3
2040: PUSH
2041: LD_INT 19
2043: PUSH
2044: LD_INT 26
2046: PUSH
2047: EMPTY
2048: LIST
2049: LIST
2050: PUSH
2051: LD_INT 34
2053: PUSH
2054: LD_INT 51
2056: PUSH
2057: EMPTY
2058: LIST
2059: LIST
2060: PUSH
2061: LD_INT 53
2063: PUSH
2064: LD_INT 86
2066: PUSH
2067: EMPTY
2068: LIST
2069: LIST
2070: PUSH
2071: LD_INT 77
2073: PUSH
2074: LD_INT 95
2076: PUSH
2077: EMPTY
2078: LIST
2079: LIST
2080: PUSH
2081: LD_INT 88
2083: PUSH
2084: LD_INT 115
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: PUSH
2091: LD_INT 65
2093: PUSH
2094: LD_INT 111
2096: PUSH
2097: EMPTY
2098: LIST
2099: LIST
2100: PUSH
2101: LD_INT 142
2103: PUSH
2104: LD_INT 108
2106: PUSH
2107: EMPTY
2108: LIST
2109: LIST
2110: PUSH
2111: LD_INT 161
2113: PUSH
2114: LD_INT 107
2116: PUSH
2117: EMPTY
2118: LIST
2119: LIST
2120: PUSH
2121: LD_INT 171
2123: PUSH
2124: LD_INT 99
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: LD_INT 146
2133: PUSH
2134: LD_INT 88
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: PUSH
2141: LD_INT 151
2143: PUSH
2144: LD_INT 66
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: PUSH
2151: LD_INT 146
2153: PUSH
2154: LD_INT 38
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 117
2163: PUSH
2164: LD_INT 42
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 89
2173: PUSH
2174: LD_INT 6
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: PUSH
2181: EMPTY
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: ST_TO_ADDR
// InitUc ;
2197: CALL_OW 18
// InitHc ;
2201: CALL_OW 19
// uc_side = nature ;
2205: LD_ADDR_OWVAR 20
2209: PUSH
2210: LD_EXP 4
2214: ST_TO_ADDR
// uc_nation = nation_nature ;
2215: LD_ADDR_OWVAR 21
2219: PUSH
2220: LD_INT 0
2222: ST_TO_ADDR
// agres = - 10 + difficulty * 20 ;
2223: LD_ADDR_VAR 0 5
2227: PUSH
2228: LD_INT 10
2230: NEG
2231: PUSH
2232: LD_OWVAR 67
2236: PUSH
2237: LD_INT 20
2239: MUL
2240: PLUS
2241: ST_TO_ADDR
// count = [ 1 , 2 , 3 ] [ difficulty ] ;
2242: LD_ADDR_VAR 0 6
2246: PUSH
2247: LD_INT 1
2249: PUSH
2250: LD_INT 2
2252: PUSH
2253: LD_INT 3
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: LIST
2260: PUSH
2261: LD_OWVAR 67
2265: ARRAY
2266: ST_TO_ADDR
// hc_gallery = nature_foreg ;
2267: LD_ADDR_OWVAR 33
2271: PUSH
2272: LD_STRING nature_foreg
2274: ST_TO_ADDR
// hc_face_number = 3 ;
2275: LD_ADDR_OWVAR 34
2279: PUSH
2280: LD_INT 3
2282: ST_TO_ADDR
// hc_class = class_tiger ;
2283: LD_ADDR_OWVAR 28
2287: PUSH
2288: LD_INT 14
2290: ST_TO_ADDR
// hc_sex = sex_male ;
2291: LD_ADDR_OWVAR 27
2295: PUSH
2296: LD_INT 1
2298: ST_TO_ADDR
// for i = 1 to count do
2299: LD_ADDR_VAR 0 2
2303: PUSH
2304: DOUBLE
2305: LD_INT 1
2307: DEC
2308: ST_TO_ADDR
2309: LD_VAR 0 6
2313: PUSH
2314: FOR_TO
2315: IFFALSE 2514
// begin if spots = 0 then
2317: LD_VAR 0 3
2321: PUSH
2322: LD_INT 0
2324: EQUAL
2325: IFFALSE 2331
// exit ;
2327: POP
2328: POP
2329: GO 2757
// uc_direction = Rand ( 0 , 5 ) ;
2331: LD_ADDR_OWVAR 24
2335: PUSH
2336: LD_INT 0
2338: PPUSH
2339: LD_INT 5
2341: PPUSH
2342: CALL_OW 12
2346: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , agres ) ;
2347: LD_ADDR_OWVAR 35
2351: PUSH
2352: LD_INT 0
2354: PPUSH
2355: LD_VAR 0 5
2359: PPUSH
2360: CALL_OW 12
2364: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 12 ) , Rand ( 10 , 11 ) ] ;
2365: LD_ADDR_OWVAR 29
2369: PUSH
2370: LD_INT 11
2372: PPUSH
2373: LD_INT 12
2375: PPUSH
2376: CALL_OW 12
2380: PUSH
2381: LD_INT 10
2383: PPUSH
2384: LD_INT 11
2386: PPUSH
2387: CALL_OW 12
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: ST_TO_ADDR
// hc_skills = [ Rand ( 1 , difficulty ) , 0 , 0 , 0 ] ;
2396: LD_ADDR_OWVAR 31
2400: PUSH
2401: LD_INT 1
2403: PPUSH
2404: LD_OWVAR 67
2408: PPUSH
2409: CALL_OW 12
2413: PUSH
2414: LD_INT 0
2416: PUSH
2417: LD_INT 0
2419: PUSH
2420: LD_INT 0
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: LIST
2427: LIST
2428: ST_TO_ADDR
// num = Rand ( 1 , spots ) ;
2429: LD_ADDR_VAR 0 4
2433: PUSH
2434: LD_INT 1
2436: PPUSH
2437: LD_VAR 0 3
2441: PPUSH
2442: CALL_OW 12
2446: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , spots [ num ] [ 1 ] , spots [ num ] [ 2 ] , 5 , false ) ;
2447: CALL_OW 44
2451: PPUSH
2452: LD_VAR 0 3
2456: PUSH
2457: LD_VAR 0 4
2461: ARRAY
2462: PUSH
2463: LD_INT 1
2465: ARRAY
2466: PPUSH
2467: LD_VAR 0 3
2471: PUSH
2472: LD_VAR 0 4
2476: ARRAY
2477: PUSH
2478: LD_INT 2
2480: ARRAY
2481: PPUSH
2482: LD_INT 5
2484: PPUSH
2485: LD_INT 0
2487: PPUSH
2488: CALL_OW 50
// spots = Delete ( spots , num ) ;
2492: LD_ADDR_VAR 0 3
2496: PUSH
2497: LD_VAR 0 3
2501: PPUSH
2502: LD_VAR 0 4
2506: PPUSH
2507: CALL_OW 3
2511: ST_TO_ADDR
// end ;
2512: GO 2314
2514: POP
2515: POP
// count = Rand ( 3 , 5 ) ;
2516: LD_ADDR_VAR 0 6
2520: PUSH
2521: LD_INT 3
2523: PPUSH
2524: LD_INT 5
2526: PPUSH
2527: CALL_OW 12
2531: ST_TO_ADDR
// hc_face_number = 4 ;
2532: LD_ADDR_OWVAR 34
2536: PUSH
2537: LD_INT 4
2539: ST_TO_ADDR
// hc_class = class_baggie ;
2540: LD_ADDR_OWVAR 28
2544: PUSH
2545: LD_INT 13
2547: ST_TO_ADDR
// for i = 1 to count do
2548: LD_ADDR_VAR 0 2
2552: PUSH
2553: DOUBLE
2554: LD_INT 1
2556: DEC
2557: ST_TO_ADDR
2558: LD_VAR 0 6
2562: PUSH
2563: FOR_TO
2564: IFFALSE 2755
// begin if spots = 0 then
2566: LD_VAR 0 3
2570: PUSH
2571: LD_INT 0
2573: EQUAL
2574: IFFALSE 2580
// exit ;
2576: POP
2577: POP
2578: GO 2757
// uc_direction = Rand ( 0 , 5 ) ;
2580: LD_ADDR_OWVAR 24
2584: PUSH
2585: LD_INT 0
2587: PPUSH
2588: LD_INT 5
2590: PPUSH
2591: CALL_OW 12
2595: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) - 50 ;
2596: LD_ADDR_OWVAR 35
2600: PUSH
2601: LD_INT 0
2603: PPUSH
2604: LD_INT 50
2606: PPUSH
2607: CALL_OW 12
2611: PUSH
2612: LD_INT 50
2614: MINUS
2615: ST_TO_ADDR
// hc_attr = [ Rand ( 8 , 10 ) , Rand ( 9 , 11 ) ] ;
2616: LD_ADDR_OWVAR 29
2620: PUSH
2621: LD_INT 8
2623: PPUSH
2624: LD_INT 10
2626: PPUSH
2627: CALL_OW 12
2631: PUSH
2632: LD_INT 9
2634: PPUSH
2635: LD_INT 11
2637: PPUSH
2638: CALL_OW 12
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
2647: LD_ADDR_OWVAR 31
2651: PUSH
2652: LD_INT 0
2654: PUSH
2655: LD_INT 0
2657: PUSH
2658: LD_INT 0
2660: PUSH
2661: LD_INT 0
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: ST_TO_ADDR
// num = Rand ( 1 , spots ) ;
2670: LD_ADDR_VAR 0 4
2674: PUSH
2675: LD_INT 1
2677: PPUSH
2678: LD_VAR 0 3
2682: PPUSH
2683: CALL_OW 12
2687: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , spots [ num ] [ 1 ] , spots [ num ] [ 2 ] , 5 , false ) ;
2688: CALL_OW 44
2692: PPUSH
2693: LD_VAR 0 3
2697: PUSH
2698: LD_VAR 0 4
2702: ARRAY
2703: PUSH
2704: LD_INT 1
2706: ARRAY
2707: PPUSH
2708: LD_VAR 0 3
2712: PUSH
2713: LD_VAR 0 4
2717: ARRAY
2718: PUSH
2719: LD_INT 2
2721: ARRAY
2722: PPUSH
2723: LD_INT 5
2725: PPUSH
2726: LD_INT 0
2728: PPUSH
2729: CALL_OW 50
// spots = Delete ( spots , num ) ;
2733: LD_ADDR_VAR 0 3
2737: PUSH
2738: LD_VAR 0 3
2742: PPUSH
2743: LD_VAR 0 4
2747: PPUSH
2748: CALL_OW 3
2752: ST_TO_ADDR
// end ;
2753: GO 2563
2755: POP
2756: POP
// end ;
2757: LD_VAR 0 1
2761: RET
// function PrepareArabians ; var i ; begin
2762: LD_INT 0
2764: PPUSH
2765: PPUSH
// InitHc ;
2766: CALL_OW 19
// InitUc ;
2770: CALL_OW 18
// uc_side = you ;
2774: LD_ADDR_OWVAR 20
2778: PUSH
2779: LD_EXP 2
2783: ST_TO_ADDR
// uc_nation = nation_arabian ;
2784: LD_ADDR_OWVAR 21
2788: PUSH
2789: LD_INT 2
2791: ST_TO_ADDR
// if not testing then
2792: LD_EXP 1
2796: NOT
2797: IFFALSE 3108
// begin Heike = CreateCharacter ( Heike_08 ) ;
2799: LD_ADDR_EXP 7
2803: PUSH
2804: LD_STRING Heike_08
2806: PPUSH
2807: CALL_OW 34
2811: ST_TO_ADDR
// SetClass ( Heike , class_soldier ) ;
2812: LD_EXP 7
2816: PPUSH
2817: LD_INT 1
2819: PPUSH
2820: CALL_OW 336
// Oswald = 0 ;
2824: LD_ADDR_EXP 9
2828: PUSH
2829: LD_INT 0
2831: ST_TO_ADDR
// if TestCharacters ( Oswald_07_sel ) then
2832: LD_STRING Oswald_07_sel
2834: PPUSH
2835: CALL_OW 28
2839: IFFALSE 2865
// begin if TestCharacters ( Oswald_07_cont ) then
2841: LD_STRING Oswald_07_cont
2843: PPUSH
2844: CALL_OW 28
2848: IFFALSE 2863
// Oswald = CreateCharacter ( Oswald_07_cont ) ;
2850: LD_ADDR_EXP 9
2854: PUSH
2855: LD_STRING Oswald_07_cont
2857: PPUSH
2858: CALL_OW 34
2862: ST_TO_ADDR
// end else
2863: GO 2944
// if TestCharacters ( Oswald_07_not_sel ) then
2865: LD_STRING Oswald_07_not_sel
2867: PPUSH
2868: CALL_OW 28
2872: IFFALSE 2889
// Oswald = CreateCharacter ( Oswald_07_not_sel ) else
2874: LD_ADDR_EXP 9
2878: PUSH
2879: LD_STRING Oswald_07_not_sel
2881: PPUSH
2882: CALL_OW 34
2886: ST_TO_ADDR
2887: GO 2944
// if TestCharacters ( Oswald_05_sel ) then
2889: LD_STRING Oswald_05_sel
2891: PPUSH
2892: CALL_OW 28
2896: IFFALSE 2922
// begin if TestCharacters ( Oswald_05_cont ) then
2898: LD_STRING Oswald_05_cont
2900: PPUSH
2901: CALL_OW 28
2905: IFFALSE 2920
// Oswald = CreateCharacter ( Oswald_05_cont ) ;
2907: LD_ADDR_EXP 9
2911: PUSH
2912: LD_STRING Oswald_05_cont
2914: PPUSH
2915: CALL_OW 34
2919: ST_TO_ADDR
// end else
2920: GO 2944
// if TestCharacters ( Oswald_04 ) then
2922: LD_STRING Oswald_04
2924: PPUSH
2925: CALL_OW 28
2929: IFFALSE 2944
// Oswald = CreateCharacter ( Oswald_04 ) ;
2931: LD_ADDR_EXP 9
2935: PUSH
2936: LD_STRING Oswald_04
2938: PPUSH
2939: CALL_OW 34
2943: ST_TO_ADDR
// if Oswald = 0 then
2944: LD_EXP 9
2948: PUSH
2949: LD_INT 0
2951: EQUAL
2952: IFFALSE 2998
// begin hc_name =  ;
2954: LD_ADDR_OWVAR 26
2958: PUSH
2959: LD_STRING 
2961: ST_TO_ADDR
// hc_gallery =  ;
2962: LD_ADDR_OWVAR 33
2966: PUSH
2967: LD_STRING 
2969: ST_TO_ADDR
// PrepareSoldier ( sex_male , 5 ) ;
2970: LD_INT 1
2972: PPUSH
2973: LD_INT 5
2975: PPUSH
2976: CALL_OW 381
// Oswald = CreateHuman ;
2980: LD_ADDR_EXP 9
2984: PUSH
2985: CALL_OW 44
2989: ST_TO_ADDR
// oswald_is_substitute = true ;
2990: LD_ADDR_EXP 70
2994: PUSH
2995: LD_INT 1
2997: ST_TO_ADDR
// end ; SetClass ( Oswald , class_soldier ) ;
2998: LD_EXP 9
3002: PPUSH
3003: LD_INT 1
3005: PPUSH
3006: CALL_OW 336
// Kurt = 0 ;
3010: LD_ADDR_EXP 10
3014: PUSH
3015: LD_INT 0
3017: ST_TO_ADDR
// if TestCharacters ( Kurt_07_cont ) then
3018: LD_STRING Kurt_07_cont
3020: PPUSH
3021: CALL_OW 28
3025: IFFALSE 3040
// Kurt = CreateCharacter ( Kurt_07_cont ) ;
3027: LD_ADDR_EXP 10
3031: PUSH
3032: LD_STRING Kurt_07_cont
3034: PPUSH
3035: CALL_OW 34
3039: ST_TO_ADDR
// if Kurt = 0 then
3040: LD_EXP 10
3044: PUSH
3045: LD_INT 0
3047: EQUAL
3048: IFFALSE 3094
// begin hc_name =  ;
3050: LD_ADDR_OWVAR 26
3054: PUSH
3055: LD_STRING 
3057: ST_TO_ADDR
// hc_gallery =  ;
3058: LD_ADDR_OWVAR 33
3062: PUSH
3063: LD_STRING 
3065: ST_TO_ADDR
// PrepareSoldier ( sex_male , 5 ) ;
3066: LD_INT 1
3068: PPUSH
3069: LD_INT 5
3071: PPUSH
3072: CALL_OW 381
// Kurt = CreateHuman ;
3076: LD_ADDR_EXP 10
3080: PUSH
3081: CALL_OW 44
3085: ST_TO_ADDR
// kurt_is_substitute = true ;
3086: LD_ADDR_EXP 71
3090: PUSH
3091: LD_INT 1
3093: ST_TO_ADDR
// end ; SetClass ( Kurt , class_soldier ) ;
3094: LD_EXP 10
3098: PPUSH
3099: LD_INT 1
3101: PPUSH
3102: CALL_OW 336
// end else
3106: GO 3196
// begin InitHc ;
3108: CALL_OW 19
// PrepareSoldier ( sex_female , 7 ) ;
3112: LD_INT 2
3114: PPUSH
3115: LD_INT 7
3117: PPUSH
3118: CALL_OW 381
// hc_name = Heike ;
3122: LD_ADDR_OWVAR 26
3126: PUSH
3127: LD_STRING Heike
3129: ST_TO_ADDR
// Heike = CreateHuman ;
3130: LD_ADDR_EXP 7
3134: PUSH
3135: CALL_OW 44
3139: ST_TO_ADDR
// PrepareSoldier ( sex_male , 6 ) ;
3140: LD_INT 1
3142: PPUSH
3143: LD_INT 6
3145: PPUSH
3146: CALL_OW 381
// hc_name = Oswald ;
3150: LD_ADDR_OWVAR 26
3154: PUSH
3155: LD_STRING Oswald
3157: ST_TO_ADDR
// Oswald = CreateHuman ;
3158: LD_ADDR_EXP 9
3162: PUSH
3163: CALL_OW 44
3167: ST_TO_ADDR
// PrepareSoldier ( sex_male , 6 ) ;
3168: LD_INT 1
3170: PPUSH
3171: LD_INT 6
3173: PPUSH
3174: CALL_OW 381
// hc_name = Kurt ;
3178: LD_ADDR_OWVAR 26
3182: PUSH
3183: LD_STRING Kurt
3185: ST_TO_ADDR
// Kurt = CreateHuman ;
3186: LD_ADDR_EXP 10
3190: PUSH
3191: CALL_OW 44
3195: ST_TO_ADDR
// end ; Dwayne = NewCharacter ( Dwayne ) ;
3196: LD_ADDR_EXP 8
3200: PUSH
3201: LD_STRING Dwayne
3203: PPUSH
3204: CALL_OW 25
3208: ST_TO_ADDR
// uc_nation = nation_nature ;
3209: LD_ADDR_OWVAR 21
3213: PUSH
3214: LD_INT 0
3216: ST_TO_ADDR
// hc_name = Gonzo ;
3217: LD_ADDR_OWVAR 26
3221: PUSH
3222: LD_STRING Gonzo
3224: ST_TO_ADDR
// hc_class = class_apeman_soldier ;
3225: LD_ADDR_OWVAR 28
3229: PUSH
3230: LD_INT 15
3232: ST_TO_ADDR
// hc_sex = sex_male ;
3233: LD_ADDR_OWVAR 27
3237: PUSH
3238: LD_INT 1
3240: ST_TO_ADDR
// hc_attr = [ 16 , 12 ] ;
3241: LD_ADDR_OWVAR 29
3245: PUSH
3246: LD_INT 16
3248: PUSH
3249: LD_INT 12
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: ST_TO_ADDR
// hc_basic_skills = [ 4 , 1 , 0 , 0 ] ;
3256: LD_ADDR_OWVAR 30
3260: PUSH
3261: LD_INT 4
3263: PUSH
3264: LD_INT 1
3266: PUSH
3267: LD_INT 0
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: ST_TO_ADDR
// hc_skills = [ 5 , 4 , 1 , 0 ] ;
3279: LD_ADDR_OWVAR 31
3283: PUSH
3284: LD_INT 5
3286: PUSH
3287: LD_INT 4
3289: PUSH
3290: LD_INT 1
3292: PUSH
3293: LD_INT 0
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: ST_TO_ADDR
// Gonzo = CreateHuman ;
3302: LD_ADDR_EXP 11
3306: PUSH
3307: CALL_OW 44
3311: ST_TO_ADDR
// hc_name =  ;
3312: LD_ADDR_OWVAR 26
3316: PUSH
3317: LD_STRING 
3319: ST_TO_ADDR
// end ;
3320: LD_VAR 0 1
3324: RET
// function ScanBuildings ; var side , i , temp_list , base , area ; begin
3325: LD_INT 0
3327: PPUSH
3328: PPUSH
3329: PPUSH
3330: PPUSH
3331: PPUSH
3332: PPUSH
// side = russians ;
3333: LD_ADDR_VAR 0 2
3337: PUSH
3338: LD_EXP 3
3342: ST_TO_ADDR
// for base in ai_bases do
3343: LD_ADDR_VAR 0 5
3347: PUSH
3348: LD_EXP 57
3352: PUSH
3353: FOR_IN
3354: IFFALSE 3969
// begin case base of 1 :
3356: LD_VAR 0 5
3360: PUSH
3361: LD_INT 1
3363: DOUBLE
3364: EQUAL
3365: IFTRUE 3369
3367: GO 3380
3369: POP
// area = ru_base_area ; end ;
3370: LD_ADDR_VAR 0 6
3374: PUSH
3375: LD_INT 2
3377: ST_TO_ADDR
3378: GO 3381
3380: POP
// ai_all_buildings = Replace ( ai_all_buildings , base , FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_inarea , area ] ] ) ) ;
3381: LD_ADDR_EXP 43
3385: PUSH
3386: LD_EXP 43
3390: PPUSH
3391: LD_VAR 0 5
3395: PPUSH
3396: LD_INT 22
3398: PUSH
3399: LD_VAR 0 2
3403: PUSH
3404: EMPTY
3405: LIST
3406: LIST
3407: PUSH
3408: LD_INT 21
3410: PUSH
3411: LD_INT 3
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: PUSH
3418: LD_INT 95
3420: PUSH
3421: LD_VAR 0 6
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: PUSH
3430: EMPTY
3431: LIST
3432: LIST
3433: LIST
3434: PPUSH
3435: CALL_OW 69
3439: PPUSH
3440: CALL_OW 1
3444: ST_TO_ADDR
// depot_north = UnitFilter ( ai_all_buildings [ base ] , [ f_btype , b_depot ] ) [ 1 ] ;
3445: LD_ADDR_EXP 86
3449: PUSH
3450: LD_EXP 43
3454: PUSH
3455: LD_VAR 0 5
3459: ARRAY
3460: PPUSH
3461: LD_INT 30
3463: PUSH
3464: LD_INT 0
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: PPUSH
3471: CALL_OW 72
3475: PUSH
3476: LD_INT 1
3478: ARRAY
3479: ST_TO_ADDR
// for i in ai_all_buildings [ base ] diff depot_north do
3480: LD_ADDR_VAR 0 3
3484: PUSH
3485: LD_EXP 43
3489: PUSH
3490: LD_VAR 0 5
3494: ARRAY
3495: PUSH
3496: LD_EXP 86
3500: DIFF
3501: PUSH
3502: FOR_IN
3503: IFFALSE 3524
// UpdateBuildingBasicVariables ( base , i , true ) ;
3505: LD_VAR 0 5
3509: PPUSH
3510: LD_VAR 0 3
3514: PPUSH
3515: LD_INT 1
3517: PPUSH
3518: CALL 3976 0 3
3522: GO 3502
3524: POP
3525: POP
// temp_list = ai_labs [ base ] ;
3526: LD_ADDR_VAR 0 4
3530: PUSH
3531: LD_EXP 33
3535: PUSH
3536: LD_VAR 0 5
3540: ARRAY
3541: ST_TO_ADDR
// the_archive = temp_list [ Rand ( 1 , temp_list ) ] ;
3542: LD_ADDR_EXP 75
3546: PUSH
3547: LD_VAR 0 4
3551: PUSH
3552: LD_INT 1
3554: PPUSH
3555: LD_VAR 0 4
3559: PPUSH
3560: CALL_OW 12
3564: ARRAY
3565: ST_TO_ADDR
// for i in ai_power_plants [ base ] do
3566: LD_ADDR_VAR 0 3
3570: PUSH
3571: LD_EXP 35
3575: PUSH
3576: LD_VAR 0 5
3580: ARRAY
3581: PUSH
3582: FOR_IN
3583: IFFALSE 3616
// if GetBType ( i ) = b_oil_power then
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL_OW 266
3594: PUSH
3595: LD_INT 26
3597: EQUAL
3598: IFFALSE 3614
// AddComLinkToBase ( depot_north , i ) ;
3600: LD_EXP 86
3604: PPUSH
3605: LD_VAR 0 3
3609: PPUSH
3610: CALL_OW 229
3614: GO 3582
3616: POP
3617: POP
// for i in ai_labs [ base ] do
3618: LD_ADDR_VAR 0 3
3622: PUSH
3623: LD_EXP 33
3627: PUSH
3628: LD_VAR 0 5
3632: ARRAY
3633: PUSH
3634: FOR_IN
3635: IFFALSE 3659
// AddComLinkToBase ( ai_depot [ base ] , i ) ;
3637: LD_EXP 32
3641: PUSH
3642: LD_VAR 0 5
3646: ARRAY
3647: PPUSH
3648: LD_VAR 0 3
3652: PPUSH
3653: CALL_OW 229
3657: GO 3634
3659: POP
3660: POP
// for i in ai_armouries [ base ] do
3661: LD_ADDR_VAR 0 3
3665: PUSH
3666: LD_EXP 48
3670: PUSH
3671: LD_VAR 0 5
3675: ARRAY
3676: PUSH
3677: FOR_IN
3678: IFFALSE 3738
// if GetBType ( i ) = b_barracks then
3680: LD_VAR 0 3
3684: PPUSH
3685: CALL_OW 266
3689: PUSH
3690: LD_INT 5
3692: EQUAL
3693: IFFALSE 3736
// begin leader_office = i ;
3695: LD_ADDR_EXP 93
3699: PUSH
3700: LD_VAR 0 3
3704: ST_TO_ADDR
// leader_office_location = [ GetX ( i ) , GetY ( i ) ] ;
3705: LD_ADDR_EXP 94
3709: PUSH
3710: LD_VAR 0 3
3714: PPUSH
3715: CALL_OW 250
3719: PUSH
3720: LD_VAR 0 3
3724: PPUSH
3725: CALL_OW 251
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: ST_TO_ADDR
// break ;
3734: GO 3738
// end ;
3736: GO 3677
3738: POP
3739: POP
// temp_list = [ ] ;
3740: LD_ADDR_VAR 0 4
3744: PUSH
3745: EMPTY
3746: ST_TO_ADDR
// for i in ai_all_buildings [ base ] do
3747: LD_ADDR_VAR 0 3
3751: PUSH
3752: LD_EXP 43
3756: PUSH
3757: LD_VAR 0 5
3761: ARRAY
3762: PUSH
3763: FOR_IN
3764: IFFALSE 3867
// temp_list = temp_list ^ [ [ GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBType ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
3766: LD_ADDR_VAR 0 4
3770: PUSH
3771: LD_VAR 0 4
3775: PUSH
3776: LD_VAR 0 3
3780: PPUSH
3781: CALL_OW 250
3785: PUSH
3786: LD_VAR 0 3
3790: PPUSH
3791: CALL_OW 251
3795: PUSH
3796: LD_VAR 0 3
3800: PPUSH
3801: CALL_OW 254
3805: PUSH
3806: LD_VAR 0 3
3810: PPUSH
3811: CALL_OW 266
3815: PUSH
3816: LD_VAR 0 3
3820: PPUSH
3821: LD_INT 1
3823: PPUSH
3824: CALL_OW 268
3828: PUSH
3829: LD_VAR 0 3
3833: PPUSH
3834: LD_INT 2
3836: PPUSH
3837: CALL_OW 268
3841: PUSH
3842: LD_VAR 0 3
3846: PPUSH
3847: CALL_OW 269
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: LIST
3856: LIST
3857: LIST
3858: LIST
3859: LIST
3860: PUSH
3861: EMPTY
3862: LIST
3863: ADD
3864: ST_TO_ADDR
3865: GO 3763
3867: POP
3868: POP
// ai_buildings_locations = Replace ( ai_buildings_locations , base , temp_list ) ;
3869: LD_ADDR_EXP 36
3873: PUSH
3874: LD_EXP 36
3878: PPUSH
3879: LD_VAR 0 5
3883: PPUSH
3884: LD_VAR 0 4
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// SortBuildingLocationsListInCorrectOrder ( base ) ;
3894: LD_VAR 0 5
3898: PPUSH
3899: CALL 4966 0 1
// for i in ai_siberite_mines [ base ] ^ ai_oil_mine [ base ] do
3903: LD_ADDR_VAR 0 3
3907: PUSH
3908: LD_EXP 34
3912: PUSH
3913: LD_VAR 0 5
3917: ARRAY
3918: PUSH
3919: LD_EXP 50
3923: PUSH
3924: LD_VAR 0 5
3928: ARRAY
3929: ADD
3930: PUSH
3931: FOR_IN
3932: IFFALSE 3965
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
3934: LD_VAR 0 3
3938: PPUSH
3939: CALL_OW 250
3943: PPUSH
3944: LD_VAR 0 3
3948: PPUSH
3949: CALL_OW 251
3953: PPUSH
3954: LD_VAR 0 2
3958: PPUSH
3959: CALL_OW 441
3963: GO 3931
3965: POP
3966: POP
// end ;
3967: GO 3353
3969: POP
3970: POP
// end ;
3971: LD_VAR 0 1
3975: RET
// export function UpdateBuildingBasicVariables ( base , un , add ) ; var temp_list ; begin
3976: LD_INT 0
3978: PPUSH
3979: PPUSH
// case GetBType ( un ) of b_depot , b_warehouse :
3980: LD_VAR 0 2
3984: PPUSH
3985: CALL_OW 266
3989: PUSH
3990: LD_INT 0
3992: DOUBLE
3993: EQUAL
3994: IFTRUE 4004
3996: LD_INT 1
3998: DOUBLE
3999: EQUAL
4000: IFTRUE 4004
4002: GO 4081
4004: POP
// if add then
4005: LD_VAR 0 3
4009: IFFALSE 4038
// ai_depot = Replace ( ai_depot , base , un ) else
4011: LD_ADDR_EXP 32
4015: PUSH
4016: LD_EXP 32
4020: PPUSH
4021: LD_VAR 0 1
4025: PPUSH
4026: LD_VAR 0 2
4030: PPUSH
4031: CALL_OW 1
4035: ST_TO_ADDR
4036: GO 4079
// if un = ai_depot [ base ] then
4038: LD_VAR 0 2
4042: PUSH
4043: LD_EXP 32
4047: PUSH
4048: LD_VAR 0 1
4052: ARRAY
4053: EQUAL
4054: IFFALSE 4079
// ai_depot = Replace ( ai_depot , base , 0 ) ; b_lab , b_lab_half , b_lab_full :
4056: LD_ADDR_EXP 32
4060: PUSH
4061: LD_EXP 32
4065: PPUSH
4066: LD_VAR 0 1
4070: PPUSH
4071: LD_INT 0
4073: PPUSH
4074: CALL_OW 1
4078: ST_TO_ADDR
4079: GO 4961
4081: LD_INT 6
4083: DOUBLE
4084: EQUAL
4085: IFTRUE 4101
4087: LD_INT 7
4089: DOUBLE
4090: EQUAL
4091: IFTRUE 4101
4093: LD_INT 8
4095: DOUBLE
4096: EQUAL
4097: IFTRUE 4101
4099: GO 4181
4101: POP
// begin if add then
4102: LD_VAR 0 3
4106: IFFALSE 4132
// temp_list = ai_labs [ base ] ^ un else
4108: LD_ADDR_VAR 0 5
4112: PUSH
4113: LD_EXP 33
4117: PUSH
4118: LD_VAR 0 1
4122: ARRAY
4123: PUSH
4124: LD_VAR 0 2
4128: ADD
4129: ST_TO_ADDR
4130: GO 4154
// temp_list = ai_labs [ base ] diff un ;
4132: LD_ADDR_VAR 0 5
4136: PUSH
4137: LD_EXP 33
4141: PUSH
4142: LD_VAR 0 1
4146: ARRAY
4147: PUSH
4148: LD_VAR 0 2
4152: DIFF
4153: ST_TO_ADDR
// ai_labs = Replace ( ai_labs , base , temp_list ) ;
4154: LD_ADDR_EXP 33
4158: PUSH
4159: LD_EXP 33
4163: PPUSH
4164: LD_VAR 0 1
4168: PPUSH
4169: LD_VAR 0 5
4173: PPUSH
4174: CALL_OW 1
4178: ST_TO_ADDR
// end ; b_factory , b_workshop :
4179: GO 4961
4181: LD_INT 3
4183: DOUBLE
4184: EQUAL
4185: IFTRUE 4195
4187: LD_INT 2
4189: DOUBLE
4190: EQUAL
4191: IFTRUE 4195
4193: GO 4275
4195: POP
// begin if add then
4196: LD_VAR 0 3
4200: IFFALSE 4226
// temp_list = ai_facts [ base ] ^ un else
4202: LD_ADDR_VAR 0 5
4206: PUSH
4207: LD_EXP 47
4211: PUSH
4212: LD_VAR 0 1
4216: ARRAY
4217: PUSH
4218: LD_VAR 0 2
4222: ADD
4223: ST_TO_ADDR
4224: GO 4248
// temp_list = ai_facts [ base ] diff un ;
4226: LD_ADDR_VAR 0 5
4230: PUSH
4231: LD_EXP 47
4235: PUSH
4236: LD_VAR 0 1
4240: ARRAY
4241: PUSH
4242: LD_VAR 0 2
4246: DIFF
4247: ST_TO_ADDR
// ai_facts = Replace ( ai_facts , base , temp_list ) ;
4248: LD_ADDR_EXP 47
4252: PUSH
4253: LD_EXP 47
4257: PPUSH
4258: LD_VAR 0 1
4262: PPUSH
4263: LD_VAR 0 5
4267: PPUSH
4268: CALL_OW 1
4272: ST_TO_ADDR
// end ; b_armoury , b_barracks :
4273: GO 4961
4275: LD_INT 4
4277: DOUBLE
4278: EQUAL
4279: IFTRUE 4289
4281: LD_INT 5
4283: DOUBLE
4284: EQUAL
4285: IFTRUE 4289
4287: GO 4369
4289: POP
// begin if add then
4290: LD_VAR 0 3
4294: IFFALSE 4320
// temp_list = ai_armouries [ base ] ^ un else
4296: LD_ADDR_VAR 0 5
4300: PUSH
4301: LD_EXP 48
4305: PUSH
4306: LD_VAR 0 1
4310: ARRAY
4311: PUSH
4312: LD_VAR 0 2
4316: ADD
4317: ST_TO_ADDR
4318: GO 4342
// temp_list = ai_armouries [ base ] diff un ;
4320: LD_ADDR_VAR 0 5
4324: PUSH
4325: LD_EXP 48
4329: PUSH
4330: LD_VAR 0 1
4334: ARRAY
4335: PUSH
4336: LD_VAR 0 2
4340: DIFF
4341: ST_TO_ADDR
// ai_armouries = Replace ( ai_armouries , base , temp_list ) ;
4342: LD_ADDR_EXP 48
4346: PUSH
4347: LD_EXP 48
4351: PPUSH
4352: LD_VAR 0 1
4356: PPUSH
4357: LD_VAR 0 5
4361: PPUSH
4362: CALL_OW 1
4366: ST_TO_ADDR
// end ; b_breastwork , b_bunker :
4367: GO 4961
4369: LD_INT 31
4371: DOUBLE
4372: EQUAL
4373: IFTRUE 4383
4375: LD_INT 32
4377: DOUBLE
4378: EQUAL
4379: IFTRUE 4383
4381: GO 4463
4383: POP
// begin if add then
4384: LD_VAR 0 3
4388: IFFALSE 4414
// temp_list = ai_bunkers [ base ] ^ un else
4390: LD_ADDR_VAR 0 5
4394: PUSH
4395: LD_EXP 49
4399: PUSH
4400: LD_VAR 0 1
4404: ARRAY
4405: PUSH
4406: LD_VAR 0 2
4410: ADD
4411: ST_TO_ADDR
4412: GO 4436
// temp_list = ai_bunkers [ base ] diff un ;
4414: LD_ADDR_VAR 0 5
4418: PUSH
4419: LD_EXP 49
4423: PUSH
4424: LD_VAR 0 1
4428: ARRAY
4429: PUSH
4430: LD_VAR 0 2
4434: DIFF
4435: ST_TO_ADDR
// ai_bunkers = Replace ( ai_bunkers , base , temp_list ) ;
4436: LD_ADDR_EXP 49
4440: PUSH
4441: LD_EXP 49
4445: PPUSH
4446: LD_VAR 0 1
4450: PPUSH
4451: LD_VAR 0 5
4455: PPUSH
4456: CALL_OW 1
4460: ST_TO_ADDR
// end ; b_turret :
4461: GO 4961
4463: LD_INT 33
4465: DOUBLE
4466: EQUAL
4467: IFTRUE 4471
4469: GO 4551
4471: POP
// begin if add then
4472: LD_VAR 0 3
4476: IFFALSE 4502
// temp_list = ai_turrets [ base ] ^ un else
4478: LD_ADDR_VAR 0 5
4482: PUSH
4483: LD_EXP 68
4487: PUSH
4488: LD_VAR 0 1
4492: ARRAY
4493: PUSH
4494: LD_VAR 0 2
4498: ADD
4499: ST_TO_ADDR
4500: GO 4524
// temp_list = ai_turrets [ base ] diff un ;
4502: LD_ADDR_VAR 0 5
4506: PUSH
4507: LD_EXP 68
4511: PUSH
4512: LD_VAR 0 1
4516: ARRAY
4517: PUSH
4518: LD_VAR 0 2
4522: DIFF
4523: ST_TO_ADDR
// ai_turrets = Replace ( ai_turrets , base , temp_list ) ;
4524: LD_ADDR_EXP 68
4528: PUSH
4529: LD_EXP 68
4533: PPUSH
4534: LD_VAR 0 1
4538: PPUSH
4539: LD_VAR 0 5
4543: PPUSH
4544: CALL_OW 1
4548: ST_TO_ADDR
// end ; b_oil_mine :
4549: GO 4961
4551: LD_INT 29
4553: DOUBLE
4554: EQUAL
4555: IFTRUE 4559
4557: GO 4636
4559: POP
// if add then
4560: LD_VAR 0 3
4564: IFFALSE 4593
// ai_oil_mine = Replace ( ai_oil_mine , base , un ) else
4566: LD_ADDR_EXP 50
4570: PUSH
4571: LD_EXP 50
4575: PPUSH
4576: LD_VAR 0 1
4580: PPUSH
4581: LD_VAR 0 2
4585: PPUSH
4586: CALL_OW 1
4590: ST_TO_ADDR
4591: GO 4634
// if un = ai_oil_mine [ base ] then
4593: LD_VAR 0 2
4597: PUSH
4598: LD_EXP 50
4602: PUSH
4603: LD_VAR 0 1
4607: ARRAY
4608: EQUAL
4609: IFFALSE 4634
// ai_oil_mine = Replace ( ai_oil_mine , base , 0 ) ; b_siberite_mine :
4611: LD_ADDR_EXP 50
4615: PUSH
4616: LD_EXP 50
4620: PPUSH
4621: LD_VAR 0 1
4625: PPUSH
4626: LD_INT 0
4628: PPUSH
4629: CALL_OW 1
4633: ST_TO_ADDR
4634: GO 4961
4636: LD_INT 30
4638: DOUBLE
4639: EQUAL
4640: IFTRUE 4644
4642: GO 4724
4644: POP
// begin if add then
4645: LD_VAR 0 3
4649: IFFALSE 4675
// temp_list = ai_siberite_mines [ base ] ^ un else
4651: LD_ADDR_VAR 0 5
4655: PUSH
4656: LD_EXP 34
4660: PUSH
4661: LD_VAR 0 1
4665: ARRAY
4666: PUSH
4667: LD_VAR 0 2
4671: ADD
4672: ST_TO_ADDR
4673: GO 4697
// temp_list = ai_siberite_mines [ base ] diff un ;
4675: LD_ADDR_VAR 0 5
4679: PUSH
4680: LD_EXP 34
4684: PUSH
4685: LD_VAR 0 1
4689: ARRAY
4690: PUSH
4691: LD_VAR 0 2
4695: DIFF
4696: ST_TO_ADDR
// ai_siberite_mines = Replace ( ai_siberite_mines , base , temp_list ) ;
4697: LD_ADDR_EXP 34
4701: PUSH
4702: LD_EXP 34
4706: PPUSH
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_VAR 0 5
4716: PPUSH
4717: CALL_OW 1
4721: ST_TO_ADDR
// end ; b_ext_gun , b_ext_noncombat , b_ext_laser , b_ext_computer , b_ext_radar , b_ext_rocket , b_ext_siberium , b_ext_track , b_ext_stitch :
4722: GO 4961
4724: LD_INT 17
4726: DOUBLE
4727: EQUAL
4728: IFTRUE 4780
4730: LD_INT 19
4732: DOUBLE
4733: EQUAL
4734: IFTRUE 4780
4736: LD_INT 25
4738: DOUBLE
4739: EQUAL
4740: IFTRUE 4780
4742: LD_INT 24
4744: DOUBLE
4745: EQUAL
4746: IFTRUE 4780
4748: LD_INT 20
4750: DOUBLE
4751: EQUAL
4752: IFTRUE 4780
4754: LD_INT 18
4756: DOUBLE
4757: EQUAL
4758: IFTRUE 4780
4760: LD_INT 21
4762: DOUBLE
4763: EQUAL
4764: IFTRUE 4780
4766: LD_INT 16
4768: DOUBLE
4769: EQUAL
4770: IFTRUE 4780
4772: LD_INT 23
4774: DOUBLE
4775: EQUAL
4776: IFTRUE 4780
4778: GO 4860
4780: POP
// begin if add then
4781: LD_VAR 0 3
4785: IFFALSE 4811
// temp_list = ai_fact_extensions [ base ] ^ un else
4787: LD_ADDR_VAR 0 5
4791: PUSH
4792: LD_EXP 51
4796: PUSH
4797: LD_VAR 0 1
4801: ARRAY
4802: PUSH
4803: LD_VAR 0 2
4807: ADD
4808: ST_TO_ADDR
4809: GO 4833
// temp_list = ai_fact_extensions [ base ] diff un ;
4811: LD_ADDR_VAR 0 5
4815: PUSH
4816: LD_EXP 51
4820: PUSH
4821: LD_VAR 0 1
4825: ARRAY
4826: PUSH
4827: LD_VAR 0 2
4831: DIFF
4832: ST_TO_ADDR
// ai_fact_extensions = Replace ( ai_fact_extensions , base , temp_list ) ;
4833: LD_ADDR_EXP 51
4837: PUSH
4838: LD_EXP 51
4842: PPUSH
4843: LD_VAR 0 1
4847: PPUSH
4848: LD_VAR 0 5
4852: PPUSH
4853: CALL_OW 1
4857: ST_TO_ADDR
// end ; b_solar_power , b_oil_power , b_siberite_power :
4858: GO 4961
4860: LD_INT 27
4862: DOUBLE
4863: EQUAL
4864: IFTRUE 4880
4866: LD_INT 26
4868: DOUBLE
4869: EQUAL
4870: IFTRUE 4880
4872: LD_INT 28
4874: DOUBLE
4875: EQUAL
4876: IFTRUE 4880
4878: GO 4960
4880: POP
// begin if add then
4881: LD_VAR 0 3
4885: IFFALSE 4911
// temp_list = ai_power_plants [ base ] ^ un else
4887: LD_ADDR_VAR 0 5
4891: PUSH
4892: LD_EXP 35
4896: PUSH
4897: LD_VAR 0 1
4901: ARRAY
4902: PUSH
4903: LD_VAR 0 2
4907: ADD
4908: ST_TO_ADDR
4909: GO 4933
// temp_list = ai_power_plants [ base ] diff un ;
4911: LD_ADDR_VAR 0 5
4915: PUSH
4916: LD_EXP 35
4920: PUSH
4921: LD_VAR 0 1
4925: ARRAY
4926: PUSH
4927: LD_VAR 0 2
4931: DIFF
4932: ST_TO_ADDR
// ai_power_plants = Replace ( ai_power_plants , base , temp_list ) ;
4933: LD_ADDR_EXP 35
4937: PUSH
4938: LD_EXP 35
4942: PPUSH
4943: LD_VAR 0 1
4947: PPUSH
4948: LD_VAR 0 5
4952: PPUSH
4953: CALL_OW 1
4957: ST_TO_ADDR
// end ; end ;
4958: GO 4961
4960: POP
// end ;
4961: LD_VAR 0 4
4965: RET
// function SortBuildingLocationsListInCorrectOrder ( base ) ; var i , temp_list , p ; begin
4966: LD_INT 0
4968: PPUSH
4969: PPUSH
4970: PPUSH
4971: PPUSH
// temp_list = [ ] ;
4972: LD_ADDR_VAR 0 4
4976: PUSH
4977: EMPTY
4978: ST_TO_ADDR
// for i in ai_buildings_locations [ base ] do
4979: LD_ADDR_VAR 0 3
4983: PUSH
4984: LD_EXP 36
4988: PUSH
4989: LD_VAR 0 1
4993: ARRAY
4994: PUSH
4995: FOR_IN
4996: IFFALSE 5369
// begin case i [ 4 ] of b_depot , b_warehouse :
4998: LD_VAR 0 3
5002: PUSH
5003: LD_INT 4
5005: ARRAY
5006: PUSH
5007: LD_INT 0
5009: DOUBLE
5010: EQUAL
5011: IFTRUE 5021
5013: LD_INT 1
5015: DOUBLE
5016: EQUAL
5017: IFTRUE 5021
5019: GO 5032
5021: POP
// p = 100 ; b_armoury , b_barracks , b_fort :
5022: LD_ADDR_VAR 0 5
5026: PUSH
5027: LD_INT 100
5029: ST_TO_ADDR
5030: GO 5351
5032: LD_INT 4
5034: DOUBLE
5035: EQUAL
5036: IFTRUE 5052
5038: LD_INT 5
5040: DOUBLE
5041: EQUAL
5042: IFTRUE 5052
5044: LD_INT 35
5046: DOUBLE
5047: EQUAL
5048: IFTRUE 5052
5050: GO 5063
5052: POP
// p = 99 ; b_solar_power , b_oil_power , b_siberite_power :
5053: LD_ADDR_VAR 0 5
5057: PUSH
5058: LD_INT 99
5060: ST_TO_ADDR
5061: GO 5351
5063: LD_INT 27
5065: DOUBLE
5066: EQUAL
5067: IFTRUE 5083
5069: LD_INT 26
5071: DOUBLE
5072: EQUAL
5073: IFTRUE 5083
5075: LD_INT 28
5077: DOUBLE
5078: EQUAL
5079: IFTRUE 5083
5081: GO 5094
5083: POP
// p = 98 ; b_breastwork :
5084: LD_ADDR_VAR 0 5
5088: PUSH
5089: LD_INT 98
5091: ST_TO_ADDR
5092: GO 5351
5094: LD_INT 31
5096: DOUBLE
5097: EQUAL
5098: IFTRUE 5102
5100: GO 5113
5102: POP
// p = 97 ; b_factory , b_workshop :
5103: LD_ADDR_VAR 0 5
5107: PUSH
5108: LD_INT 97
5110: ST_TO_ADDR
5111: GO 5351
5113: LD_INT 3
5115: DOUBLE
5116: EQUAL
5117: IFTRUE 5127
5119: LD_INT 2
5121: DOUBLE
5122: EQUAL
5123: IFTRUE 5127
5125: GO 5138
5127: POP
// p = 96 ; b_ext_gun , b_ext_noncombat , b_ext_laser , b_ext_computer , b_ext_radar , b_ext_rocket , b_ext_siberium , b_ext_track , b_ext_stitch :
5128: LD_ADDR_VAR 0 5
5132: PUSH
5133: LD_INT 96
5135: ST_TO_ADDR
5136: GO 5351
5138: LD_INT 17
5140: DOUBLE
5141: EQUAL
5142: IFTRUE 5194
5144: LD_INT 19
5146: DOUBLE
5147: EQUAL
5148: IFTRUE 5194
5150: LD_INT 25
5152: DOUBLE
5153: EQUAL
5154: IFTRUE 5194
5156: LD_INT 24
5158: DOUBLE
5159: EQUAL
5160: IFTRUE 5194
5162: LD_INT 20
5164: DOUBLE
5165: EQUAL
5166: IFTRUE 5194
5168: LD_INT 18
5170: DOUBLE
5171: EQUAL
5172: IFTRUE 5194
5174: LD_INT 21
5176: DOUBLE
5177: EQUAL
5178: IFTRUE 5194
5180: LD_INT 16
5182: DOUBLE
5183: EQUAL
5184: IFTRUE 5194
5186: LD_INT 23
5188: DOUBLE
5189: EQUAL
5190: IFTRUE 5194
5192: GO 5205
5194: POP
// p = 95 ; b_bunker :
5195: LD_ADDR_VAR 0 5
5199: PUSH
5200: LD_INT 95
5202: ST_TO_ADDR
5203: GO 5351
5205: LD_INT 32
5207: DOUBLE
5208: EQUAL
5209: IFTRUE 5213
5211: GO 5224
5213: POP
// p = 94 ; b_control_tower :
5214: LD_ADDR_VAR 0 5
5218: PUSH
5219: LD_INT 94
5221: ST_TO_ADDR
5222: GO 5351
5224: LD_INT 36
5226: DOUBLE
5227: EQUAL
5228: IFTRUE 5232
5230: GO 5243
5232: POP
// p = 93 ; b_turret :
5233: LD_ADDR_VAR 0 5
5237: PUSH
5238: LD_INT 93
5240: ST_TO_ADDR
5241: GO 5351
5243: LD_INT 33
5245: DOUBLE
5246: EQUAL
5247: IFTRUE 5251
5249: GO 5262
5251: POP
// p = 92 ; b_lab , b_lab_half , b_lab_full :
5252: LD_ADDR_VAR 0 5
5256: PUSH
5257: LD_INT 92
5259: ST_TO_ADDR
5260: GO 5351
5262: LD_INT 6
5264: DOUBLE
5265: EQUAL
5266: IFTRUE 5282
5268: LD_INT 7
5270: DOUBLE
5271: EQUAL
5272: IFTRUE 5282
5274: LD_INT 8
5276: DOUBLE
5277: EQUAL
5278: IFTRUE 5282
5280: GO 5293
5282: POP
// p = 91 ; b_teleport :
5283: LD_ADDR_VAR 0 5
5287: PUSH
5288: LD_INT 91
5290: ST_TO_ADDR
5291: GO 5351
5293: LD_INT 34
5295: DOUBLE
5296: EQUAL
5297: IFTRUE 5301
5299: GO 5312
5301: POP
// p = 90 ; b_siberite_mine :
5302: LD_ADDR_VAR 0 5
5306: PUSH
5307: LD_INT 90
5309: ST_TO_ADDR
5310: GO 5351
5312: LD_INT 30
5314: DOUBLE
5315: EQUAL
5316: IFTRUE 5320
5318: GO 5331
5320: POP
// p = 89 ; b_oil_mine :
5321: LD_ADDR_VAR 0 5
5325: PUSH
5326: LD_INT 89
5328: ST_TO_ADDR
5329: GO 5351
5331: LD_INT 29
5333: DOUBLE
5334: EQUAL
5335: IFTRUE 5339
5337: GO 5350
5339: POP
// p = 88 ; end ;
5340: LD_ADDR_VAR 0 5
5344: PUSH
5345: LD_INT 88
5347: ST_TO_ADDR
5348: GO 5351
5350: POP
// temp_list = temp_list ^ p ;
5351: LD_ADDR_VAR 0 4
5355: PUSH
5356: LD_VAR 0 4
5360: PUSH
5361: LD_VAR 0 5
5365: ADD
5366: ST_TO_ADDR
// end ;
5367: GO 4995
5369: POP
5370: POP
// temp_list = SortListByListDesc ( ai_buildings_locations [ base ] , temp_list ) ;
5371: LD_ADDR_VAR 0 4
5375: PUSH
5376: LD_EXP 36
5380: PUSH
5381: LD_VAR 0 1
5385: ARRAY
5386: PPUSH
5387: LD_VAR 0 4
5391: PPUSH
5392: CALL_OW 77
5396: ST_TO_ADDR
// ai_buildings_locations = Replace ( ai_buildings_locations , base , temp_list ) ;
5397: LD_ADDR_EXP 36
5401: PUSH
5402: LD_EXP 36
5406: PPUSH
5407: LD_VAR 0 1
5411: PPUSH
5412: LD_VAR 0 4
5416: PPUSH
5417: CALL_OW 1
5421: ST_TO_ADDR
// end ;
5422: LD_VAR 0 2
5426: RET
// function PrepareComputerSides ; var i , temp_list , side , base , max , num , temp_list_2 , temp_list_3 , j , dir , other_guard ; begin
5427: LD_INT 0
5429: PPUSH
5430: PPUSH
5431: PPUSH
5432: PPUSH
5433: PPUSH
5434: PPUSH
5435: PPUSH
5436: PPUSH
5437: PPUSH
5438: PPUSH
5439: PPUSH
5440: PPUSH
// side = russians ;
5441: LD_ADDR_VAR 0 4
5445: PUSH
5446: LD_EXP 3
5450: ST_TO_ADDR
// for base in ai_bases do
5451: LD_ADDR_VAR 0 5
5455: PUSH
5456: LD_EXP 57
5460: PUSH
5461: FOR_IN
5462: IFFALSE 6023
// begin InitUc ;
5464: CALL_OW 18
// InitHc ;
5468: CALL_OW 19
// uc_side = side ;
5472: LD_ADDR_OWVAR 20
5476: PUSH
5477: LD_VAR 0 4
5481: ST_TO_ADDR
// case side of russians :
5482: LD_VAR 0 4
5486: PUSH
5487: LD_EXP 3
5491: DOUBLE
5492: EQUAL
5493: IFTRUE 5497
5495: GO 5508
5497: POP
// uc_nation = nation_russian ; end ;
5498: LD_ADDR_OWVAR 21
5502: PUSH
5503: LD_INT 3
5505: ST_TO_ADDR
5506: GO 5509
5508: POP
// ai_soldiers = Replace ( ai_soldiers , base , CreateUnitsWithClass ( 4 + 4 , class_soldier , false ,  , side ) ) ;
5509: LD_ADDR_EXP 26
5513: PUSH
5514: LD_EXP 26
5518: PPUSH
5519: LD_VAR 0 5
5523: PPUSH
5524: LD_INT 4
5526: PUSH
5527: LD_INT 4
5529: PLUS
5530: PPUSH
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 0
5536: PPUSH
5537: LD_STRING 
5539: PPUSH
5540: LD_VAR 0 4
5544: PPUSH
5545: CALL 7857 0 5
5549: PPUSH
5550: CALL_OW 1
5554: ST_TO_ADDR
// ai_engineers = Replace ( ai_engineers , base , CreateUnitsWithClass ( 2 , class_engineer , false ,  , side ) ) ;
5555: LD_ADDR_EXP 27
5559: PUSH
5560: LD_EXP 27
5564: PPUSH
5565: LD_VAR 0 5
5569: PPUSH
5570: LD_INT 2
5572: PPUSH
5573: LD_INT 2
5575: PPUSH
5576: LD_INT 0
5578: PPUSH
5579: LD_STRING 
5581: PPUSH
5582: LD_VAR 0 4
5586: PPUSH
5587: CALL 7857 0 5
5591: PPUSH
5592: CALL_OW 1
5596: ST_TO_ADDR
// ai_apemen_engineers = Replace ( ai_apemen_engineers , base , CreateApemenWithClass ( 1 , class_apeman_engineer ) ) ;
5597: LD_ADDR_EXP 61
5601: PUSH
5602: LD_EXP 61
5606: PPUSH
5607: LD_VAR 0 5
5611: PPUSH
5612: LD_INT 1
5614: PPUSH
5615: LD_INT 16
5617: PPUSH
5618: CALL 8024 0 2
5622: PPUSH
5623: CALL_OW 1
5627: ST_TO_ADDR
// temp_list = [ ] ;
5628: LD_ADDR_VAR 0 3
5632: PUSH
5633: EMPTY
5634: ST_TO_ADDR
// for i in ai_engineers [ base ] do
5635: LD_ADDR_VAR 0 2
5639: PUSH
5640: LD_EXP 27
5644: PUSH
5645: LD_VAR 0 5
5649: ARRAY
5650: PUSH
5651: FOR_IN
5652: IFFALSE 5680
// temp_list = temp_list ^ GetSkill ( i , skill_engineering ) ;
5654: LD_ADDR_VAR 0 3
5658: PUSH
5659: LD_VAR 0 3
5663: PUSH
5664: LD_VAR 0 2
5668: PPUSH
5669: LD_INT 2
5671: PPUSH
5672: CALL_OW 259
5676: ADD
5677: ST_TO_ADDR
5678: GO 5651
5680: POP
5681: POP
// max = BestFromListByList ( temp_list , temp_list ) ;
5682: LD_ADDR_VAR 0 6
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_VAR 0 3
5696: PPUSH
5697: CALL_OW 79
5701: ST_TO_ADDR
// for i in ai_all_buildings [ base ] do
5702: LD_ADDR_VAR 0 2
5706: PUSH
5707: LD_EXP 43
5711: PUSH
5712: LD_VAR 0 5
5716: ARRAY
5717: PUSH
5718: FOR_IN
5719: IFFALSE 5737
// SetBLevel ( i , max ) ;
5721: LD_VAR 0 2
5725: PPUSH
5726: LD_VAR 0 6
5730: PPUSH
5731: CALL_OW 241
5735: GO 5718
5737: POP
5738: POP
// ai_mechanics_defend = Replace ( ai_mechanics_defend , base , CreateUnitsWithClass ( 3 , class_mechanic , false ,  , side ) ) ;
5739: LD_ADDR_EXP 28
5743: PUSH
5744: LD_EXP 28
5748: PPUSH
5749: LD_VAR 0 5
5753: PPUSH
5754: LD_INT 3
5756: PPUSH
5757: LD_INT 3
5759: PPUSH
5760: LD_INT 0
5762: PPUSH
5763: LD_STRING 
5765: PPUSH
5766: LD_VAR 0 4
5770: PPUSH
5771: CALL 7857 0 5
5775: PPUSH
5776: CALL_OW 1
5780: ST_TO_ADDR
// num = 0 ;
5781: LD_ADDR_VAR 0 7
5785: PUSH
5786: LD_INT 0
5788: ST_TO_ADDR
// for i = 1 to ai_labs [ base ] do
5789: LD_ADDR_VAR 0 2
5793: PUSH
5794: DOUBLE
5795: LD_INT 1
5797: DEC
5798: ST_TO_ADDR
5799: LD_EXP 33
5803: PUSH
5804: LD_VAR 0 5
5808: ARRAY
5809: PUSH
5810: FOR_TO
5811: IFFALSE 5837
// num = num + Rand ( 3 , 4 ) ;
5813: LD_ADDR_VAR 0 7
5817: PUSH
5818: LD_VAR 0 7
5822: PUSH
5823: LD_INT 3
5825: PPUSH
5826: LD_INT 4
5828: PPUSH
5829: CALL_OW 12
5833: PLUS
5834: ST_TO_ADDR
5835: GO 5810
5837: POP
5838: POP
// ai_scientists = Replace ( ai_scientists , base , CreateUnitsWithClass ( num , class_scientistic , false ,  , side ) ) ;
5839: LD_ADDR_EXP 30
5843: PUSH
5844: LD_EXP 30
5848: PPUSH
5849: LD_VAR 0 5
5853: PPUSH
5854: LD_VAR 0 7
5858: PPUSH
5859: LD_INT 4
5861: PPUSH
5862: LD_INT 0
5864: PPUSH
5865: LD_STRING 
5867: PPUSH
5868: LD_VAR 0 4
5872: PPUSH
5873: CALL 7857 0 5
5877: PPUSH
5878: CALL_OW 1
5882: ST_TO_ADDR
// SetResourceType ( GetBase ( ai_depot [ base ] ) , mat_cans , 300 ) ;
5883: LD_EXP 32
5887: PUSH
5888: LD_VAR 0 5
5892: ARRAY
5893: PPUSH
5894: CALL_OW 274
5898: PPUSH
5899: LD_INT 1
5901: PPUSH
5902: LD_INT 300
5904: PPUSH
5905: CALL_OW 277
// SetResourceType ( GetBase ( ai_depot [ base ] ) , mat_oil , 0 ) ;
5909: LD_EXP 32
5913: PUSH
5914: LD_VAR 0 5
5918: ARRAY
5919: PPUSH
5920: CALL_OW 274
5924: PPUSH
5925: LD_INT 2
5927: PPUSH
5928: LD_INT 0
5930: PPUSH
5931: CALL_OW 277
// SetResourceType ( GetBase ( ai_depot [ base ] ) , mat_siberit , 300 ) ;
5935: LD_EXP 32
5939: PUSH
5940: LD_VAR 0 5
5944: ARRAY
5945: PPUSH
5946: CALL_OW 274
5950: PPUSH
5951: LD_INT 3
5953: PPUSH
5954: LD_INT 300
5956: PPUSH
5957: CALL_OW 277
// SetResourceType ( GetBase ( depot_north ) , mat_cans , 150 ) ;
5961: LD_EXP 86
5965: PPUSH
5966: CALL_OW 274
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: LD_INT 150
5976: PPUSH
5977: CALL_OW 277
// SetResourceType ( GetBase ( depot_north ) , mat_oil , 300 ) ;
5981: LD_EXP 86
5985: PPUSH
5986: CALL_OW 274
5990: PPUSH
5991: LD_INT 2
5993: PPUSH
5994: LD_INT 300
5996: PPUSH
5997: CALL_OW 277
// SetResourceType ( GetBase ( depot_north ) , mat_siberit , 0 ) ;
6001: LD_EXP 86
6005: PPUSH
6006: CALL_OW 274
6010: PPUSH
6011: LD_INT 3
6013: PPUSH
6014: LD_INT 0
6016: PPUSH
6017: CALL_OW 277
// end ;
6021: GO 5461
6023: POP
6024: POP
// Barovnin = NewCharacter ( Barovnin ) ;
6025: LD_ADDR_EXP 13
6029: PUSH
6030: LD_STRING Barovnin
6032: PPUSH
6033: CALL_OW 25
6037: ST_TO_ADDR
// ai_scientists = Replace ( ai_scientists , 1 , ai_scientists [ 1 ] ^ Barovnin ) ;
6038: LD_ADDR_EXP 30
6042: PUSH
6043: LD_EXP 30
6047: PPUSH
6048: LD_INT 1
6050: PPUSH
6051: LD_EXP 30
6055: PUSH
6056: LD_INT 1
6058: ARRAY
6059: PUSH
6060: LD_EXP 13
6064: ADD
6065: PPUSH
6066: CALL_OW 1
6070: ST_TO_ADDR
// Yefibachev = NewCharacter ( Yefibachev ) ;
6071: LD_ADDR_EXP 14
6075: PUSH
6076: LD_STRING Yefibachev
6078: PPUSH
6079: CALL_OW 25
6083: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ Yefibachev ) ;
6084: LD_ADDR_EXP 26
6088: PUSH
6089: LD_EXP 26
6093: PPUSH
6094: LD_INT 1
6096: PPUSH
6097: LD_EXP 26
6101: PUSH
6102: LD_INT 1
6104: ARRAY
6105: PUSH
6106: LD_EXP 14
6110: ADD
6111: PPUSH
6112: CALL_OW 1
6116: ST_TO_ADDR
// Mikhail = NewCharacter ( Mikhail ) ;
6117: LD_ADDR_EXP 17
6121: PUSH
6122: LD_STRING Mikhail
6124: PPUSH
6125: CALL_OW 25
6129: ST_TO_ADDR
// ai_mechanics_defend = Replace ( ai_mechanics_defend , 1 , ai_mechanics_defend [ 1 ] ^ Mikhail ) ;
6130: LD_ADDR_EXP 28
6134: PUSH
6135: LD_EXP 28
6139: PPUSH
6140: LD_INT 1
6142: PPUSH
6143: LD_EXP 28
6147: PUSH
6148: LD_INT 1
6150: ARRAY
6151: PUSH
6152: LD_EXP 17
6156: ADD
6157: PPUSH
6158: CALL_OW 1
6162: ST_TO_ADDR
// Yakov = NewCharacter ( Yakov ) ;
6163: LD_ADDR_EXP 15
6167: PUSH
6168: LD_STRING Yakov
6170: PPUSH
6171: CALL_OW 25
6175: ST_TO_ADDR
// ai_mechanics_defend = Replace ( ai_mechanics_defend , 1 , ai_mechanics_defend [ 1 ] ^ Yakov ) ;
6176: LD_ADDR_EXP 28
6180: PUSH
6181: LD_EXP 28
6185: PPUSH
6186: LD_INT 1
6188: PPUSH
6189: LD_EXP 28
6193: PUSH
6194: LD_INT 1
6196: ARRAY
6197: PUSH
6198: LD_EXP 15
6202: ADD
6203: PPUSH
6204: CALL_OW 1
6208: ST_TO_ADDR
// Natalya = CreateUnitsWithClass ( 1 , class_mechanic , sex_female , Natalya , side ) [ 1 ] ;
6209: LD_ADDR_EXP 16
6213: PUSH
6214: LD_INT 1
6216: PPUSH
6217: LD_INT 3
6219: PPUSH
6220: LD_INT 2
6222: PPUSH
6223: LD_STRING Natalya
6225: PPUSH
6226: LD_VAR 0 4
6230: PPUSH
6231: CALL 7857 0 5
6235: PUSH
6236: LD_INT 1
6238: ARRAY
6239: ST_TO_ADDR
// SetSkill ( Natalya , skill_mechanical , 10 ) ;
6240: LD_EXP 16
6244: PPUSH
6245: LD_INT 3
6247: PPUSH
6248: LD_INT 10
6250: PPUSH
6251: CALL_OW 237
// ai_mechanics_defend = Replace ( ai_mechanics_defend , 1 , ai_mechanics_defend [ 1 ] ^ Natalya ) ;
6255: LD_ADDR_EXP 28
6259: PUSH
6260: LD_EXP 28
6264: PPUSH
6265: LD_INT 1
6267: PPUSH
6268: LD_EXP 28
6272: PUSH
6273: LD_INT 1
6275: ARRAY
6276: PUSH
6277: LD_EXP 16
6281: ADD
6282: PPUSH
6283: CALL_OW 1
6287: ST_TO_ADDR
// Dmitri = NewCharacter ( Dmitri ) ;
6288: LD_ADDR_EXP 20
6292: PUSH
6293: LD_STRING Dmitri
6295: PPUSH
6296: CALL_OW 25
6300: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ Dmitri ) ;
6301: LD_ADDR_EXP 26
6305: PUSH
6306: LD_EXP 26
6310: PPUSH
6311: LD_INT 1
6313: PPUSH
6314: LD_EXP 26
6318: PUSH
6319: LD_INT 1
6321: ARRAY
6322: PUSH
6323: LD_EXP 20
6327: ADD
6328: PPUSH
6329: CALL_OW 1
6333: ST_TO_ADDR
// Sergei = NewCharacter ( Sergei ) ;
6334: LD_ADDR_EXP 21
6338: PUSH
6339: LD_STRING Sergei
6341: PPUSH
6342: CALL_OW 25
6346: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ Sergei ) ;
6347: LD_ADDR_EXP 26
6351: PUSH
6352: LD_EXP 26
6356: PPUSH
6357: LD_INT 1
6359: PPUSH
6360: LD_EXP 26
6364: PUSH
6365: LD_INT 1
6367: ARRAY
6368: PUSH
6369: LD_EXP 21
6373: ADD
6374: PPUSH
6375: CALL_OW 1
6379: ST_TO_ADDR
// Yann = NewCharacter ( Yann ) ;
6380: LD_ADDR_EXP 22
6384: PUSH
6385: LD_STRING Yann
6387: PPUSH
6388: CALL_OW 25
6392: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ Yann ) ;
6393: LD_ADDR_EXP 26
6397: PUSH
6398: LD_EXP 26
6402: PPUSH
6403: LD_INT 1
6405: PPUSH
6406: LD_EXP 26
6410: PUSH
6411: LD_INT 1
6413: ARRAY
6414: PUSH
6415: LD_EXP 22
6419: ADD
6420: PPUSH
6421: CALL_OW 1
6425: ST_TO_ADDR
// poker_mec = CreateUnitsWithClass ( 1 , class_mechanic , sex_male ,  , side ) [ 1 ] ;
6426: LD_ADDR_EXP 25
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 3
6436: PPUSH
6437: LD_INT 1
6439: PPUSH
6440: LD_STRING 
6442: PPUSH
6443: LD_VAR 0 4
6447: PPUSH
6448: CALL 7857 0 5
6452: PUSH
6453: LD_INT 1
6455: ARRAY
6456: ST_TO_ADDR
// ai_mechanics_defend = Replace ( ai_mechanics_defend , 1 , ai_mechanics_defend [ 1 ] ^ poker_mec ) ;
6457: LD_ADDR_EXP 28
6461: PUSH
6462: LD_EXP 28
6466: PPUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_EXP 28
6474: PUSH
6475: LD_INT 1
6477: ARRAY
6478: PUSH
6479: LD_EXP 25
6483: ADD
6484: PPUSH
6485: CALL_OW 1
6489: ST_TO_ADDR
// poker_eng = CreateUnitsWithClass ( 1 , class_engineer , sex_female , Aporia , side ) [ 1 ] ;
6490: LD_ADDR_EXP 23
6494: PUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 2
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: LD_STRING Aporia
6506: PPUSH
6507: LD_VAR 0 4
6511: PPUSH
6512: CALL 7857 0 5
6516: PUSH
6517: LD_INT 1
6519: ARRAY
6520: ST_TO_ADDR
// ai_engineers = Replace ( ai_engineers , 1 , ai_engineers [ 1 ] ^ poker_eng ) ;
6521: LD_ADDR_EXP 27
6525: PUSH
6526: LD_EXP 27
6530: PPUSH
6531: LD_INT 1
6533: PPUSH
6534: LD_EXP 27
6538: PUSH
6539: LD_INT 1
6541: ARRAY
6542: PUSH
6543: LD_EXP 23
6547: ADD
6548: PPUSH
6549: CALL_OW 1
6553: ST_TO_ADDR
// poker_sol = CreateUnitsWithClass ( 1 , class_soldier , sex_male , Boris , side ) [ 1 ] ;
6554: LD_ADDR_EXP 24
6558: PUSH
6559: LD_INT 1
6561: PPUSH
6562: LD_INT 1
6564: PPUSH
6565: LD_INT 1
6567: PPUSH
6568: LD_STRING Boris
6570: PPUSH
6571: LD_VAR 0 4
6575: PPUSH
6576: CALL 7857 0 5
6580: PUSH
6581: LD_INT 1
6583: ARRAY
6584: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ poker_sol ) ;
6585: LD_ADDR_EXP 26
6589: PUSH
6590: LD_EXP 26
6594: PPUSH
6595: LD_INT 1
6597: PPUSH
6598: LD_EXP 26
6602: PUSH
6603: LD_INT 1
6605: ARRAY
6606: PUSH
6607: LD_EXP 24
6611: ADD
6612: PPUSH
6613: CALL_OW 1
6617: ST_TO_ADDR
// good_pat = CreateUnitsWithClass ( 1 , class_soldier , sex_male ,  , side ) [ 1 ] ;
6618: LD_ADDR_EXP 18
6622: PUSH
6623: LD_INT 1
6625: PPUSH
6626: LD_INT 1
6628: PPUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_STRING 
6634: PPUSH
6635: LD_VAR 0 4
6639: PPUSH
6640: CALL 7857 0 5
6644: PUSH
6645: LD_INT 1
6647: ARRAY
6648: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ good_pat ) ;
6649: LD_ADDR_EXP 26
6653: PUSH
6654: LD_EXP 26
6658: PPUSH
6659: LD_INT 1
6661: PPUSH
6662: LD_EXP 26
6666: PUSH
6667: LD_INT 1
6669: ARRAY
6670: PUSH
6671: LD_EXP 18
6675: ADD
6676: PPUSH
6677: CALL_OW 1
6681: ST_TO_ADDR
// bad_pat = CreateUnitsWithClass ( 1 , class_soldier , sex_male ,  , side ) [ 1 ] ;
6682: LD_ADDR_EXP 19
6686: PUSH
6687: LD_INT 1
6689: PPUSH
6690: LD_INT 1
6692: PPUSH
6693: LD_INT 1
6695: PPUSH
6696: LD_STRING 
6698: PPUSH
6699: LD_VAR 0 4
6703: PPUSH
6704: CALL 7857 0 5
6708: PUSH
6709: LD_INT 1
6711: ARRAY
6712: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ bad_pat ) ;
6713: LD_ADDR_EXP 26
6717: PUSH
6718: LD_EXP 26
6722: PPUSH
6723: LD_INT 1
6725: PPUSH
6726: LD_EXP 26
6730: PUSH
6731: LD_INT 1
6733: ARRAY
6734: PUSH
6735: LD_EXP 19
6739: ADD
6740: PPUSH
6741: CALL_OW 1
6745: ST_TO_ADDR
// SetAttr ( [ good_pat , bad_pat ] , attr_speed , [ 9 , 10 , 11 ] [ difficulty ] ) ;
6746: LD_EXP 18
6750: PUSH
6751: LD_EXP 19
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: PPUSH
6760: LD_INT 2
6762: PPUSH
6763: LD_INT 9
6765: PUSH
6766: LD_INT 10
6768: PUSH
6769: LD_INT 11
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_OWVAR 67
6781: ARRAY
6782: PPUSH
6783: CALL_OW 239
// Stanimir = NewCharacter ( Stanimir ) ;
6787: LD_ADDR_EXP 12
6791: PUSH
6792: LD_STRING Stanimir
6794: PPUSH
6795: CALL_OW 25
6799: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ Stanimir ) ;
6800: LD_ADDR_EXP 26
6804: PUSH
6805: LD_EXP 26
6809: PPUSH
6810: LD_INT 1
6812: PPUSH
6813: LD_EXP 26
6817: PUSH
6818: LD_INT 1
6820: ARRAY
6821: PUSH
6822: LD_EXP 12
6826: ADD
6827: PPUSH
6828: CALL_OW 1
6832: ST_TO_ADDR
// other_guard = CreateUnitsWithClass ( 1 , class_soldier , sex_male ,  , side ) [ 1 ] ;
6833: LD_ADDR_VAR 0 12
6837: PUSH
6838: LD_INT 1
6840: PPUSH
6841: LD_INT 1
6843: PPUSH
6844: LD_INT 1
6846: PPUSH
6847: LD_STRING 
6849: PPUSH
6850: LD_VAR 0 4
6854: PPUSH
6855: CALL 7857 0 5
6859: PUSH
6860: LD_INT 1
6862: ARRAY
6863: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , ai_soldiers [ 1 ] ^ other_guard ) ;
6864: LD_ADDR_EXP 26
6868: PUSH
6869: LD_EXP 26
6873: PPUSH
6874: LD_INT 1
6876: PPUSH
6877: LD_EXP 26
6881: PUSH
6882: LD_INT 1
6884: ARRAY
6885: PUSH
6886: LD_VAR 0 12
6890: ADD
6891: PPUSH
6892: CALL_OW 1
6896: ST_TO_ADDR
// for base in ai_bases do
6897: LD_ADDR_VAR 0 5
6901: PUSH
6902: LD_EXP 57
6906: PUSH
6907: FOR_IN
6908: IFFALSE 7004
// for i in ai_soldiers [ base ] ^ ai_engineers [ base ] ^ ai_mechanics_defend [ base ] ^ ai_scientists [ base ] ^ ai_apemen_engineers [ base ] do
6910: LD_ADDR_VAR 0 2
6914: PUSH
6915: LD_EXP 26
6919: PUSH
6920: LD_VAR 0 5
6924: ARRAY
6925: PUSH
6926: LD_EXP 27
6930: PUSH
6931: LD_VAR 0 5
6935: ARRAY
6936: ADD
6937: PUSH
6938: LD_EXP 28
6942: PUSH
6943: LD_VAR 0 5
6947: ARRAY
6948: ADD
6949: PUSH
6950: LD_EXP 30
6954: PUSH
6955: LD_VAR 0 5
6959: ARRAY
6960: ADD
6961: PUSH
6962: LD_EXP 61
6966: PUSH
6967: LD_VAR 0 5
6971: ARRAY
6972: ADD
6973: PUSH
6974: FOR_IN
6975: IFFALSE 7000
// PlaceUnitXYR ( i , 62 , 47 , 7 , false ) ;
6977: LD_VAR 0 2
6981: PPUSH
6982: LD_INT 62
6984: PPUSH
6985: LD_INT 47
6987: PPUSH
6988: LD_INT 7
6990: PPUSH
6991: LD_INT 0
6993: PPUSH
6994: CALL_OW 50
6998: GO 6974
7000: POP
7001: POP
7002: GO 6907
7004: POP
7005: POP
// temp_list = FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7006: LD_ADDR_VAR 0 3
7010: PUSH
7011: LD_INT 22
7013: PUSH
7014: LD_EXP 3
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 21
7025: PUSH
7026: LD_INT 2
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 34
7035: PUSH
7036: LD_INT 51
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: LIST
7047: PPUSH
7048: CALL_OW 69
7052: ST_TO_ADDR
// temp_list_2 = FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) diff temp_list ;
7053: LD_ADDR_VAR 0 8
7057: PUSH
7058: LD_INT 22
7060: PUSH
7061: LD_EXP 3
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 21
7072: PUSH
7073: LD_INT 2
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: PUSH
7080: EMPTY
7081: LIST
7082: LIST
7083: PPUSH
7084: CALL_OW 69
7088: PUSH
7089: LD_VAR 0 3
7093: DIFF
7094: ST_TO_ADDR
// temp_list_3 = [ ] ;
7095: LD_ADDR_VAR 0 9
7099: PUSH
7100: EMPTY
7101: ST_TO_ADDR
// for i in temp_list do
7102: LD_ADDR_VAR 0 2
7106: PUSH
7107: LD_VAR 0 3
7111: PUSH
7112: FOR_IN
7113: IFFALSE 7176
// begin cargo_bay_parking_spots = cargo_bay_parking_spots ^ [ [ GetX ( i ) , GetY ( i ) ] ] ;
7115: LD_ADDR_EXP 73
7119: PUSH
7120: LD_EXP 73
7124: PUSH
7125: LD_VAR 0 2
7129: PPUSH
7130: CALL_OW 250
7134: PUSH
7135: LD_VAR 0 2
7139: PPUSH
7140: CALL_OW 251
7144: PUSH
7145: EMPTY
7146: LIST
7147: LIST
7148: PUSH
7149: EMPTY
7150: LIST
7151: ADD
7152: ST_TO_ADDR
// temp_list_3 = temp_list_3 ^ GetX ( i ) ;
7153: LD_ADDR_VAR 0 9
7157: PUSH
7158: LD_VAR 0 9
7162: PUSH
7163: LD_VAR 0 2
7167: PPUSH
7168: CALL_OW 250
7172: ADD
7173: ST_TO_ADDR
// end ;
7174: GO 7112
7176: POP
7177: POP
// cargo_bay_parking_spots = SortListByListAsc ( cargo_bay_parking_spots , temp_list_3 ) ;
7178: LD_ADDR_EXP 73
7182: PUSH
7183: LD_EXP 73
7187: PPUSH
7188: LD_VAR 0 9
7192: PPUSH
7193: CALL_OW 76
7197: ST_TO_ADDR
// temp_list_3 = [ ] ;
7198: LD_ADDR_VAR 0 9
7202: PUSH
7203: EMPTY
7204: ST_TO_ADDR
// for i in temp_list_2 do
7205: LD_ADDR_VAR 0 2
7209: PUSH
7210: LD_VAR 0 8
7214: PUSH
7215: FOR_IN
7216: IFFALSE 7279
// begin war_vehicle_parking_spots = war_vehicle_parking_spots ^ [ [ GetX ( i ) , GetY ( i ) ] ] ;
7218: LD_ADDR_EXP 74
7222: PUSH
7223: LD_EXP 74
7227: PUSH
7228: LD_VAR 0 2
7232: PPUSH
7233: CALL_OW 250
7237: PUSH
7238: LD_VAR 0 2
7242: PPUSH
7243: CALL_OW 251
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PUSH
7252: EMPTY
7253: LIST
7254: ADD
7255: ST_TO_ADDR
// temp_list_3 = temp_list_3 ^ GetY ( i ) ;
7256: LD_ADDR_VAR 0 9
7260: PUSH
7261: LD_VAR 0 9
7265: PUSH
7266: LD_VAR 0 2
7270: PPUSH
7271: CALL_OW 251
7275: ADD
7276: ST_TO_ADDR
// end ;
7277: GO 7215
7279: POP
7280: POP
// war_vehicle_parking_spots = SortListByListAsc ( war_vehicle_parking_spots , temp_list_3 ) ;
7281: LD_ADDR_EXP 74
7285: PUSH
7286: LD_EXP 74
7290: PPUSH
7291: LD_VAR 0 9
7295: PPUSH
7296: CALL_OW 76
7300: ST_TO_ADDR
// ai_vehicle_pullback_hexes = Replace ( ai_vehicle_pullback_hexes , 1 , war_vehicle_parking_spots ) ;
7301: LD_ADDR_EXP 39
7305: PUSH
7306: LD_EXP 39
7310: PPUSH
7311: LD_INT 1
7313: PPUSH
7314: LD_EXP 74
7318: PPUSH
7319: CALL_OW 1
7323: ST_TO_ADDR
// case heike_parking_spot of 1 :
7324: LD_EXP 72
7328: PUSH
7329: LD_INT 1
7331: DOUBLE
7332: EQUAL
7333: IFTRUE 7337
7335: GO 7355
7337: POP
// temp_list_3 = [ 1 , 2 ] ; 2 :
7338: LD_ADDR_VAR 0 9
7342: PUSH
7343: LD_INT 1
7345: PUSH
7346: LD_INT 2
7348: PUSH
7349: EMPTY
7350: LIST
7351: LIST
7352: ST_TO_ADDR
7353: GO 7424
7355: LD_INT 2
7357: DOUBLE
7358: EQUAL
7359: IFTRUE 7363
7361: GO 7397
7363: POP
// temp_list_3 = [ 2 , Rand ( 1 , 2 ) * 2 - 1 ] ; 3 :
7364: LD_ADDR_VAR 0 9
7368: PUSH
7369: LD_INT 2
7371: PUSH
7372: LD_INT 1
7374: PPUSH
7375: LD_INT 2
7377: PPUSH
7378: CALL_OW 12
7382: PUSH
7383: LD_INT 2
7385: MUL
7386: PUSH
7387: LD_INT 1
7389: MINUS
7390: PUSH
7391: EMPTY
7392: LIST
7393: LIST
7394: ST_TO_ADDR
7395: GO 7424
7397: LD_INT 3
7399: DOUBLE
7400: EQUAL
7401: IFTRUE 7405
7403: GO 7423
7405: POP
// temp_list_3 = [ 2 , 3 ] ; end ;
7406: LD_ADDR_VAR 0 9
7410: PUSH
7411: LD_INT 2
7413: PUSH
7414: LD_INT 3
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: ST_TO_ADDR
7421: GO 7424
7423: POP
// for i in temp_list_3 do
7424: LD_ADDR_VAR 0 2
7428: PUSH
7429: LD_VAR 0 9
7433: PUSH
7434: FOR_IN
7435: IFFALSE 7478
// DestroyUnit ( HexInfo ( cargo_bay_parking_spots [ i ] [ 1 ] , cargo_bay_parking_spots [ i ] [ 2 ] ) ) ;
7437: LD_EXP 73
7441: PUSH
7442: LD_VAR 0 2
7446: ARRAY
7447: PUSH
7448: LD_INT 1
7450: ARRAY
7451: PPUSH
7452: LD_EXP 73
7456: PUSH
7457: LD_VAR 0 2
7461: ARRAY
7462: PUSH
7463: LD_INT 2
7465: ARRAY
7466: PPUSH
7467: CALL_OW 428
7471: PPUSH
7472: CALL_OW 65
7476: GO 7434
7478: POP
7479: POP
// DestroyUnit ( HexInfo ( war_vehicle_parking_spots [ heike_parking_spot ] [ 1 ] , war_vehicle_parking_spots [ heike_parking_spot ] [ 2 ] ) ) ;
7480: LD_EXP 74
7484: PUSH
7485: LD_EXP 72
7489: ARRAY
7490: PUSH
7491: LD_INT 1
7493: ARRAY
7494: PPUSH
7495: LD_EXP 74
7499: PUSH
7500: LD_EXP 72
7504: ARRAY
7505: PUSH
7506: LD_INT 2
7508: ARRAY
7509: PPUSH
7510: CALL_OW 428
7514: PPUSH
7515: CALL_OW 65
// uc_side = russians ;
7519: LD_ADDR_OWVAR 20
7523: PUSH
7524: LD_EXP 3
7528: ST_TO_ADDR
// uc_nation = nation_russian ;
7529: LD_ADDR_OWVAR 21
7533: PUSH
7534: LD_INT 3
7536: ST_TO_ADDR
// vc_chassis = ru_medium_wheeled ;
7537: LD_ADDR_OWVAR 37
7541: PUSH
7542: LD_INT 21
7544: ST_TO_ADDR
// vc_engine = engine_siberite ;
7545: LD_ADDR_OWVAR 39
7549: PUSH
7550: LD_INT 3
7552: ST_TO_ADDR
// vc_control = control_manual ;
7553: LD_ADDR_OWVAR 38
7557: PUSH
7558: LD_INT 1
7560: ST_TO_ADDR
// temp_list = [ ] ;
7561: LD_ADDR_VAR 0 3
7565: PUSH
7566: EMPTY
7567: ST_TO_ADDR
// for i in war_vehicle_parking_spots do
7568: LD_ADDR_VAR 0 2
7572: PUSH
7573: LD_EXP 74
7577: PUSH
7578: FOR_IN
7579: IFFALSE 7784
// begin num = HexInfo ( i [ 1 ] , i [ 2 ] ) ;
7581: LD_ADDR_VAR 0 7
7585: PUSH
7586: LD_VAR 0 2
7590: PUSH
7591: LD_INT 1
7593: ARRAY
7594: PPUSH
7595: LD_VAR 0 2
7599: PUSH
7600: LD_INT 2
7602: ARRAY
7603: PPUSH
7604: CALL_OW 428
7608: ST_TO_ADDR
// if num > 0 then
7609: LD_VAR 0 7
7613: PUSH
7614: LD_INT 0
7616: GREATER
7617: IFFALSE 7782
// begin dir = DestroyUnit ( num ) ;
7619: LD_ADDR_VAR 0 11
7623: PUSH
7624: LD_VAR 0 7
7628: PPUSH
7629: CALL_OW 65
7633: ST_TO_ADDR
// temp_list_2 = [ ru_heavy_machine_gun ] ;
7634: LD_ADDR_VAR 0 8
7638: PUSH
7639: LD_INT 42
7641: PUSH
7642: EMPTY
7643: LIST
7644: ST_TO_ADDR
// for j = 1 to difficulty do
7645: LD_ADDR_VAR 0 10
7649: PUSH
7650: DOUBLE
7651: LD_INT 1
7653: DEC
7654: ST_TO_ADDR
7655: LD_OWVAR 67
7659: PUSH
7660: FOR_TO
7661: IFFALSE 7686
// temp_list_2 = temp_list_2 ^ [ ru_gun , ru_gatling_gun ] ;
7663: LD_ADDR_VAR 0 8
7667: PUSH
7668: LD_VAR 0 8
7672: PUSH
7673: LD_INT 44
7675: PUSH
7676: LD_INT 43
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: ADD
7683: ST_TO_ADDR
7684: GO 7660
7686: POP
7687: POP
// vc_weapon = temp_list_2 [ Rand ( 1 , temp_list_2 ) ] ;
7688: LD_ADDR_OWVAR 40
7692: PUSH
7693: LD_VAR 0 8
7697: PUSH
7698: LD_INT 1
7700: PPUSH
7701: LD_VAR 0 8
7705: PPUSH
7706: CALL_OW 12
7710: ARRAY
7711: ST_TO_ADDR
// num = CreateVehicle ;
7712: LD_ADDR_VAR 0 7
7716: PUSH
7717: CALL_OW 45
7721: ST_TO_ADDR
// temp_list = temp_list ^ num ;
7722: LD_ADDR_VAR 0 3
7726: PUSH
7727: LD_VAR 0 3
7731: PUSH
7732: LD_VAR 0 7
7736: ADD
7737: ST_TO_ADDR
// SetDir ( num , dir ) ;
7738: LD_VAR 0 7
7742: PPUSH
7743: LD_VAR 0 11
7747: PPUSH
7748: CALL_OW 233
// PlaceUnitXY ( num , i [ 1 ] , i [ 2 ] , false ) ;
7752: LD_VAR 0 7
7756: PPUSH
7757: LD_VAR 0 2
7761: PUSH
7762: LD_INT 1
7764: ARRAY
7765: PPUSH
7766: LD_VAR 0 2
7770: PUSH
7771: LD_INT 2
7773: ARRAY
7774: PPUSH
7775: LD_INT 0
7777: PPUSH
7778: CALL_OW 48
// end ; end ;
7782: GO 7578
7784: POP
7785: POP
// ai_vehicles_defend = Replace ( ai_vehicles_defend , 1 , temp_list ) ;
7786: LD_ADDR_EXP 37
7790: PUSH
7791: LD_EXP 37
7795: PPUSH
7796: LD_INT 1
7798: PPUSH
7799: LD_VAR 0 3
7803: PPUSH
7804: CALL_OW 1
7808: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , russians ] ) do
7809: LD_ADDR_VAR 0 2
7813: PUSH
7814: LD_INT 22
7816: PUSH
7817: LD_EXP 3
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PPUSH
7826: CALL_OW 69
7830: PUSH
7831: FOR_IN
7832: IFFALSE 7850
// DoNotAttack ( you , i ) ;
7834: LD_EXP 2
7838: PPUSH
7839: LD_VAR 0 2
7843: PPUSH
7844: CALL_OW 471
7848: GO 7831
7850: POP
7851: POP
// end ;
7852: LD_VAR 0 1
7856: RET
// export function CreateUnitsWithClass ( num_units , un_class , sex , name , side ) ; var i , overskill , temp_diffi ; begin
7857: LD_INT 0
7859: PPUSH
7860: PPUSH
7861: PPUSH
7862: PPUSH
// result = [ ] ;
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: EMPTY
7869: ST_TO_ADDR
// InitUc ;
7870: CALL_OW 18
// InitHc ;
7874: CALL_OW 19
// hc_name = name ;
7878: LD_ADDR_OWVAR 26
7882: PUSH
7883: LD_VAR 0 4
7887: ST_TO_ADDR
// uc_nation = nation_russian ;
7888: LD_ADDR_OWVAR 21
7892: PUSH
7893: LD_INT 3
7895: ST_TO_ADDR
// uc_side = side ;
7896: LD_ADDR_OWVAR 20
7900: PUSH
7901: LD_VAR 0 5
7905: ST_TO_ADDR
// overskill = difficulty + 4 ;
7906: LD_ADDR_VAR 0 8
7910: PUSH
7911: LD_OWVAR 67
7915: PUSH
7916: LD_INT 4
7918: PLUS
7919: ST_TO_ADDR
// for i = 1 to num_units do
7920: LD_ADDR_VAR 0 7
7924: PUSH
7925: DOUBLE
7926: LD_INT 1
7928: DEC
7929: ST_TO_ADDR
7930: LD_VAR 0 1
7934: PUSH
7935: FOR_TO
7936: IFFALSE 8017
// begin if Rand ( 1 , 3 ) = 1 then
7938: LD_INT 1
7940: PPUSH
7941: LD_INT 3
7943: PPUSH
7944: CALL_OW 12
7948: PUSH
7949: LD_INT 1
7951: EQUAL
7952: IFFALSE 7980
// PrepareHuman ( sex , un_class , - overskill + 1 ) else
7954: LD_VAR 0 3
7958: PPUSH
7959: LD_VAR 0 2
7963: PPUSH
7964: LD_VAR 0 8
7968: NEG
7969: PUSH
7970: LD_INT 1
7972: PLUS
7973: PPUSH
7974: CALL_OW 380
7978: GO 7999
// PrepareHuman ( sex , un_class , overskill ) ;
7980: LD_VAR 0 3
7984: PPUSH
7985: LD_VAR 0 2
7989: PPUSH
7990: LD_VAR 0 8
7994: PPUSH
7995: CALL_OW 380
// result = result ^ CreateHuman ;
7999: LD_ADDR_VAR 0 6
8003: PUSH
8004: LD_VAR 0 6
8008: PUSH
8009: CALL_OW 44
8013: ADD
8014: ST_TO_ADDR
// end ;
8015: GO 7935
8017: POP
8018: POP
// end ;
8019: LD_VAR 0 6
8023: RET
// export function CreateApemenWithClass ( num_units , un_class ) ; var i ; begin
8024: LD_INT 0
8026: PPUSH
8027: PPUSH
// result = [ ] ;
8028: LD_ADDR_VAR 0 3
8032: PUSH
8033: EMPTY
8034: ST_TO_ADDR
// InitUc ;
8035: CALL_OW 18
// InitHc ;
8039: CALL_OW 19
// uc_side = russians ;
8043: LD_ADDR_OWVAR 20
8047: PUSH
8048: LD_EXP 3
8052: ST_TO_ADDR
// uc_nation = nation_nature ;
8053: LD_ADDR_OWVAR 21
8057: PUSH
8058: LD_INT 0
8060: ST_TO_ADDR
// hc_class = un_class ;
8061: LD_ADDR_OWVAR 28
8065: PUSH
8066: LD_VAR 0 2
8070: ST_TO_ADDR
// for i = 1 to num_units do
8071: LD_ADDR_VAR 0 4
8075: PUSH
8076: DOUBLE
8077: LD_INT 1
8079: DEC
8080: ST_TO_ADDR
8081: LD_VAR 0 1
8085: PUSH
8086: FOR_TO
8087: IFFALSE 8193
// begin hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
8089: LD_ADDR_OWVAR 29
8093: PUSH
8094: LD_INT 11
8096: PPUSH
8097: LD_INT 13
8099: PPUSH
8100: CALL_OW 12
8104: PUSH
8105: LD_INT 10
8107: PPUSH
8108: LD_INT 11
8110: PPUSH
8111: CALL_OW 12
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: ST_TO_ADDR
// hc_sex = Rand ( sex_male , sex_female ) ;
8120: LD_ADDR_OWVAR 27
8124: PUSH
8125: LD_INT 1
8127: PPUSH
8128: LD_INT 2
8130: PPUSH
8131: CALL_OW 12
8135: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 1 ) , Rand ( 0 , 1 ) , 0 , 0 ] ;
8136: LD_ADDR_OWVAR 31
8140: PUSH
8141: LD_INT 0
8143: PPUSH
8144: LD_INT 1
8146: PPUSH
8147: CALL_OW 12
8151: PUSH
8152: LD_INT 0
8154: PPUSH
8155: LD_INT 1
8157: PPUSH
8158: CALL_OW 12
8162: PUSH
8163: LD_INT 0
8165: PUSH
8166: LD_INT 0
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: LIST
8173: LIST
8174: ST_TO_ADDR
// result = result ^ CreateHuman ;
8175: LD_ADDR_VAR 0 3
8179: PUSH
8180: LD_VAR 0 3
8184: PUSH
8185: CALL_OW 44
8189: ADD
8190: ST_TO_ADDR
// end ;
8191: GO 8086
8193: POP
8194: POP
// end ;
8195: LD_VAR 0 3
8199: RET
// function Action ; var temp_list , i ; begin
8200: LD_INT 0
8202: PPUSH
8203: PPUSH
8204: PPUSH
// for i in FilterAllUnits ( [ f_side , nature ] ) do
8205: LD_ADDR_VAR 0 3
8209: PUSH
8210: LD_INT 22
8212: PUSH
8213: LD_EXP 4
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: PPUSH
8222: CALL_OW 69
8226: PUSH
8227: FOR_IN
8228: IFFALSE 8241
// ComStand ( i ) ;
8230: LD_VAR 0 3
8234: PPUSH
8235: CALL_OW 165
8239: GO 8227
8241: POP
8242: POP
// InGameOn ;
8243: CALL_OW 8
// CenterNowOnXY ( 54 , 99 ) ;
8247: LD_INT 54
8249: PPUSH
8250: LD_INT 99
8252: PPUSH
8253: CALL_OW 86
// wait ( 2 ) ;
8257: LD_INT 2
8259: PPUSH
8260: CALL_OW 67
// Query ( QCutsceneInfo ) ;
8264: LD_STRING QCutsceneInfo
8266: PPUSH
8267: CALL_OW 97
// for i in [ Heike , Oswald , Kurt , Dwayne ] do
8271: LD_ADDR_VAR 0 3
8275: PUSH
8276: LD_EXP 7
8280: PUSH
8281: LD_EXP 9
8285: PUSH
8286: LD_EXP 10
8290: PUSH
8291: LD_EXP 8
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: LIST
8300: LIST
8301: PUSH
8302: FOR_IN
8303: IFFALSE 8328
// PlaceUnitXYR ( i , 54 , 99 , 2 , false ) ;
8305: LD_VAR 0 3
8309: PPUSH
8310: LD_INT 54
8312: PPUSH
8313: LD_INT 99
8315: PPUSH
8316: LD_INT 2
8318: PPUSH
8319: LD_INT 0
8321: PPUSH
8322: CALL_OW 50
8326: GO 8302
8328: POP
8329: POP
// for i in [ Heike , Oswald , Kurt , Dwayne ] do
8330: LD_ADDR_VAR 0 3
8334: PUSH
8335: LD_EXP 7
8339: PUSH
8340: LD_EXP 9
8344: PUSH
8345: LD_EXP 10
8349: PUSH
8350: LD_EXP 8
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: PUSH
8361: FOR_IN
8362: IFFALSE 8390
// begin ComMoveXY ( i , 67 , 103 ) ;
8364: LD_VAR 0 3
8368: PPUSH
8369: LD_INT 67
8371: PPUSH
8372: LD_INT 103
8374: PPUSH
8375: CALL_OW 111
// AddComHold ( i ) ;
8379: LD_VAR 0 3
8383: PPUSH
8384: CALL_OW 200
// end ;
8388: GO 8361
8390: POP
8391: POP
// Say ( Dwayne , D1-Dw-1 ) ;
8392: LD_EXP 8
8396: PPUSH
8397: LD_STRING D1-Dw-1
8399: PPUSH
8400: CALL_OW 88
// if not kurt_is_substitute then
8404: LD_EXP 71
8408: NOT
8409: IFFALSE 8425
// Say ( Kurt , D1-Ku-1 ) else
8411: LD_EXP 10
8415: PPUSH
8416: LD_STRING D1-Ku-1
8418: PPUSH
8419: CALL_OW 88
8423: GO 8437
// Say ( Kurt , D1-Ku_sub-1 ) ;
8425: LD_EXP 10
8429: PPUSH
8430: LD_STRING D1-Ku_sub-1
8432: PPUSH
8433: CALL_OW 88
// Wait ( 0 0$1.5 ) ;
8437: LD_INT 52
8439: PPUSH
8440: CALL_OW 67
// Say ( Heike , D1-H-1 ) ;
8444: LD_EXP 7
8448: PPUSH
8449: LD_STRING D1-H-1
8451: PPUSH
8452: CALL_OW 88
// if oswald_is_substitute then
8456: LD_EXP 70
8460: IFFALSE 8476
// Say ( Oswald , D1-Os_sub-1 ) else
8462: LD_EXP 9
8466: PPUSH
8467: LD_STRING D1-Os_sub-1
8469: PPUSH
8470: CALL_OW 88
8474: GO 8559
// if LoadVariable ( vehicle_01_cont , [ 1 , 1 , 1 , 4 ] ) = 0 then
8476: LD_STRING vehicle_01_cont
8478: PPUSH
8479: LD_INT 1
8481: PUSH
8482: LD_INT 1
8484: PUSH
8485: LD_INT 1
8487: PUSH
8488: LD_INT 4
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: LIST
8495: LIST
8496: PPUSH
8497: CALL_OW 30
8501: PUSH
8502: LD_INT 0
8504: EQUAL
8505: IFFALSE 8521
// Say ( Oswald , D1-Os-1a ) else
8507: LD_EXP 9
8511: PPUSH
8512: LD_STRING D1-Os-1a
8514: PPUSH
8515: CALL_OW 88
8519: GO 8559
// if LoadVariable ( Begging_07 , false ) then
8521: LD_STRING Begging_07
8523: PPUSH
8524: LD_INT 0
8526: PPUSH
8527: CALL_OW 30
8531: IFFALSE 8547
// Say ( Oswald , D1-Os-1b ) else
8533: LD_EXP 9
8537: PPUSH
8538: LD_STRING D1-Os-1b
8540: PPUSH
8541: CALL_OW 88
8545: GO 8559
// Say ( Oswald , D1-Os-1c ) ;
8547: LD_EXP 9
8551: PPUSH
8552: LD_STRING D1-Os-1c
8554: PPUSH
8555: CALL_OW 88
// wait ( 0 0$1 ) ;
8559: LD_INT 35
8561: PPUSH
8562: CALL_OW 67
// if not oswald_is_substitute then
8566: LD_EXP 70
8570: NOT
8571: IFFALSE 8587
// Say ( Oswald , D1-Os-2 ) else
8573: LD_EXP 9
8577: PPUSH
8578: LD_STRING D1-Os-2
8580: PPUSH
8581: CALL_OW 88
8585: GO 8599
// Say ( Oswald , D1-Os_sub-2 ) ;
8587: LD_EXP 9
8591: PPUSH
8592: LD_STRING D1-Os_sub-2
8594: PPUSH
8595: CALL_OW 88
// Say ( Heike , D1-H-2 ) ;
8599: LD_EXP 7
8603: PPUSH
8604: LD_STRING D1-H-2
8606: PPUSH
8607: CALL_OW 88
// if not oswald_is_substitute then
8611: LD_EXP 70
8615: NOT
8616: IFFALSE 8632
// Say ( Oswald , D1-Os-3 ) else
8618: LD_EXP 9
8622: PPUSH
8623: LD_STRING D1-Os-3
8625: PPUSH
8626: CALL_OW 88
8630: GO 8644
// Say ( Oswald , D1-Os_sub-3 ) ;
8632: LD_EXP 9
8636: PPUSH
8637: LD_STRING D1-Os_sub-3
8639: PPUSH
8640: CALL_OW 88
// if LoadVariable ( Heike_surrendered_08 , true ) then
8644: LD_STRING Heike_surrendered_08
8646: PPUSH
8647: LD_INT 1
8649: PPUSH
8650: CALL_OW 30
8654: IFFALSE 8691
// begin if not oswald_is_substitute then
8656: LD_EXP 70
8660: NOT
8661: IFFALSE 8677
// Say ( Oswald , D1-Os-4b ) else
8663: LD_EXP 9
8667: PPUSH
8668: LD_STRING D1-Os-4b
8670: PPUSH
8671: CALL_OW 88
8675: GO 8689
// Say ( Oswald , D1-Os_sub-4b ) ;
8677: LD_EXP 9
8681: PPUSH
8682: LD_STRING D1-Os_sub-4b
8684: PPUSH
8685: CALL_OW 88
// end else
8689: GO 8724
// begin if not oswald_is_substitute then
8691: LD_EXP 70
8695: NOT
8696: IFFALSE 8712
// Say ( Oswald , D1-Os-4a ) else
8698: LD_EXP 9
8702: PPUSH
8703: LD_STRING D1-Os-4a
8705: PPUSH
8706: CALL_OW 88
8710: GO 8724
// Say ( Oswald , D1-Os_sub-4a ) ;
8712: LD_EXP 9
8716: PPUSH
8717: LD_STRING D1-Os_sub-4a
8719: PPUSH
8720: CALL_OW 88
// end ; if not oswald_is_substitute then
8724: LD_EXP 70
8728: NOT
8729: IFFALSE 8745
// Say ( Oswald , D1-Os-5 ) else
8731: LD_EXP 9
8735: PPUSH
8736: LD_STRING D1-Os-5
8738: PPUSH
8739: CALL_OW 88
8743: GO 8757
// Say ( Oswald , D1-Os_sub-5 ) ;
8745: LD_EXP 9
8749: PPUSH
8750: LD_STRING D1-Os_sub-5
8752: PPUSH
8753: CALL_OW 88
// Say ( Heike , D1-H-3 ) ;
8757: LD_EXP 7
8761: PPUSH
8762: LD_STRING D1-H-3
8764: PPUSH
8765: CALL_OW 88
// if not oswald_is_substitute then
8769: LD_EXP 70
8773: NOT
8774: IFFALSE 8790
// Say ( Oswald , D1-Os-6 ) else
8776: LD_EXP 9
8780: PPUSH
8781: LD_STRING D1-Os-6
8783: PPUSH
8784: CALL_OW 88
8788: GO 8802
// Say ( Oswald , D1-Os_sub-6 ) ;
8790: LD_EXP 9
8794: PPUSH
8795: LD_STRING D1-Os_sub-6
8797: PPUSH
8798: CALL_OW 88
// Say ( Dwayne , D1-Dw-2 ) ;
8802: LD_EXP 8
8806: PPUSH
8807: LD_STRING D1-Dw-2
8809: PPUSH
8810: CALL_OW 88
// if not oswald_is_substitute then
8814: LD_EXP 70
8818: NOT
8819: IFFALSE 8835
// Say ( Oswald , D1-Os-7 ) else
8821: LD_EXP 9
8825: PPUSH
8826: LD_STRING D1-Os-7
8828: PPUSH
8829: CALL_OW 88
8833: GO 8847
// Say ( Oswald , D1-Os_sub-7 ) ;
8835: LD_EXP 9
8839: PPUSH
8840: LD_STRING D1-Os_sub-7
8842: PPUSH
8843: CALL_OW 88
// Say ( Heike , D1-H-4 ) ;
8847: LD_EXP 7
8851: PPUSH
8852: LD_STRING D1-H-4
8854: PPUSH
8855: CALL_OW 88
// if not oswald_is_substitute then
8859: LD_EXP 70
8863: NOT
8864: IFFALSE 8880
// Say ( Oswald , D1-Os-8 ) else
8866: LD_EXP 9
8870: PPUSH
8871: LD_STRING D1-Os-8
8873: PPUSH
8874: CALL_OW 88
8878: GO 8892
// Say ( Oswald , D1-Os_sub-8 ) ;
8880: LD_EXP 9
8884: PPUSH
8885: LD_STRING D1-Os_sub-8
8887: PPUSH
8888: CALL_OW 88
// Say ( Heike , D1-H-5 ) ;
8892: LD_EXP 7
8896: PPUSH
8897: LD_STRING D1-H-5
8899: PPUSH
8900: CALL_OW 88
// if not oswald_is_substitute then
8904: LD_EXP 70
8908: NOT
8909: IFFALSE 8925
// Say ( Oswald , D1-Os-9 ) else
8911: LD_EXP 9
8915: PPUSH
8916: LD_STRING D1-Os-9
8918: PPUSH
8919: CALL_OW 88
8923: GO 8937
// Say ( Oswald , D1-Os_sub-9 ) ;
8925: LD_EXP 9
8929: PPUSH
8930: LD_STRING D1-Os_sub-9
8932: PPUSH
8933: CALL_OW 88
// Say ( Heike , D1-H-6 ) ;
8937: LD_EXP 7
8941: PPUSH
8942: LD_STRING D1-H-6
8944: PPUSH
8945: CALL_OW 88
// Say ( Dwayne , D1-Dw-3 ) ;
8949: LD_EXP 8
8953: PPUSH
8954: LD_STRING D1-Dw-3
8956: PPUSH
8957: CALL_OW 88
// if LoadVariable ( Heike_surrendered_08 , true ) then
8961: LD_STRING Heike_surrendered_08
8963: PPUSH
8964: LD_INT 1
8966: PPUSH
8967: CALL_OW 30
8971: IFFALSE 8987
// Say ( Heike , D1-H-7b ) else
8973: LD_EXP 7
8977: PPUSH
8978: LD_STRING D1-H-7b
8980: PPUSH
8981: CALL_OW 88
8985: GO 8999
// Say ( Heike , D1-H-7a ) ;
8987: LD_EXP 7
8991: PPUSH
8992: LD_STRING D1-H-7a
8994: PPUSH
8995: CALL_OW 88
// if not oswald_is_substitute then
8999: LD_EXP 70
9003: NOT
9004: IFFALSE 9032
// begin Say ( Oswald , D1-Os-10 ) ;
9006: LD_EXP 9
9010: PPUSH
9011: LD_STRING D1-Os-10
9013: PPUSH
9014: CALL_OW 88
// Say ( Oswald , D1-Os-11 ) ;
9018: LD_EXP 9
9022: PPUSH
9023: LD_STRING D1-Os-11
9025: PPUSH
9026: CALL_OW 88
// end else
9030: GO 9056
// begin Say ( Oswald , D1-Os_sub-10 ) ;
9032: LD_EXP 9
9036: PPUSH
9037: LD_STRING D1-Os_sub-10
9039: PPUSH
9040: CALL_OW 88
// Say ( Oswald , D1-Os_sub-11 ) ;
9044: LD_EXP 9
9048: PPUSH
9049: LD_STRING D1-Os_sub-11
9051: PPUSH
9052: CALL_OW 88
// end ; Say ( Dwayne , D1-Dw-4 ) ;
9056: LD_EXP 8
9060: PPUSH
9061: LD_STRING D1-Dw-4
9063: PPUSH
9064: CALL_OW 88
// Say ( Heike , D1-H-8 ) ;
9068: LD_EXP 7
9072: PPUSH
9073: LD_STRING D1-H-8
9075: PPUSH
9076: CALL_OW 88
// if not kurt_is_substitute then
9080: LD_EXP 71
9084: NOT
9085: IFFALSE 9101
// Say ( Kurt , D1-Ku-2 ) else
9087: LD_EXP 10
9091: PPUSH
9092: LD_STRING D1-Ku-2
9094: PPUSH
9095: CALL_OW 88
9099: GO 9113
// Say ( Kurt , D1-Ku_sub-2 ) ;
9101: LD_EXP 10
9105: PPUSH
9106: LD_STRING D1-Ku_sub-2
9108: PPUSH
9109: CALL_OW 88
// Say ( Dwayne , D1-Dw-5 ) ;
9113: LD_EXP 8
9117: PPUSH
9118: LD_STRING D1-Dw-5
9120: PPUSH
9121: CALL_OW 88
// Say ( Heike , D1-H-9 ) ;
9125: LD_EXP 7
9129: PPUSH
9130: LD_STRING D1-H-9
9132: PPUSH
9133: CALL_OW 88
// wait ( 0 0$1.5 ) ;
9137: LD_INT 52
9139: PPUSH
9140: CALL_OW 67
// SetSide ( Gonzo , you_alt ) ;
9144: LD_EXP 11
9148: PPUSH
9149: LD_EXP 5
9153: PPUSH
9154: CALL_OW 235
// PlaceUnitXYR ( Gonzo , 79 , 115 , 1 , false ) ;
9158: LD_EXP 11
9162: PPUSH
9163: LD_INT 79
9165: PPUSH
9166: LD_INT 115
9168: PPUSH
9169: LD_INT 1
9171: PPUSH
9172: LD_INT 0
9174: PPUSH
9175: CALL_OW 50
// ComMoveXY ( Gonzo , GetX ( Dwayne ) , GetY ( Dwayne ) ) ;
9179: LD_EXP 11
9183: PPUSH
9184: LD_EXP 8
9188: PPUSH
9189: CALL_OW 250
9193: PPUSH
9194: LD_EXP 8
9198: PPUSH
9199: CALL_OW 251
9203: PPUSH
9204: CALL_OW 111
// AddComStand ( Gonzo ) ;
9208: LD_EXP 11
9212: PPUSH
9213: CALL_OW 225
// repeat wait ( 3 ) ;
9217: LD_INT 3
9219: PPUSH
9220: CALL_OW 67
// until See ( you , Gonzo ) ;
9224: LD_EXP 2
9228: PPUSH
9229: LD_EXP 11
9233: PPUSH
9234: CALL_OW 292
9238: IFFALSE 9217
// wait ( 0 0$0.5 ) ;
9240: LD_INT 18
9242: PPUSH
9243: CALL_OW 67
// CenterOnUnits ( Gonzo ) ;
9247: LD_EXP 11
9251: PPUSH
9252: CALL_OW 85
// Say ( Dwayne , D1-Dw-6 ) ;
9256: LD_EXP 8
9260: PPUSH
9261: LD_STRING D1-Dw-6
9263: PPUSH
9264: CALL_OW 88
// Say ( Gonzo , D1-Gonzo-1 ) ;
9268: LD_EXP 11
9272: PPUSH
9273: LD_STRING D1-Gonzo-1
9275: PPUSH
9276: CALL_OW 88
// CenterOnUnits ( Dwayne ) ;
9280: LD_EXP 8
9284: PPUSH
9285: CALL_OW 85
// Say ( Dwayne , D1-Dw-7 ) ;
9289: LD_EXP 8
9293: PPUSH
9294: LD_STRING D1-Dw-7
9296: PPUSH
9297: CALL_OW 88
// wait ( 0 0$2 ) ;
9301: LD_INT 70
9303: PPUSH
9304: CALL_OW 67
// Say ( Dwayne , D1-Dw-8 ) ;
9308: LD_EXP 8
9312: PPUSH
9313: LD_STRING D1-Dw-8
9315: PPUSH
9316: CALL_OW 88
// Say ( Heike , D1-H-10 ) ;
9320: LD_EXP 7
9324: PPUSH
9325: LD_STRING D1-H-10
9327: PPUSH
9328: CALL_OW 88
// wait ( 0 0$0.2 ) ;
9332: LD_INT 7
9334: PPUSH
9335: CALL_OW 67
// Query ( QMessage ) ;
9339: LD_STRING QMessage
9341: PPUSH
9342: CALL_OW 97
// wait ( 0 0$0.2 ) ;
9346: LD_INT 7
9348: PPUSH
9349: CALL_OW 67
// Say ( Heike , D1-H-11 ) ;
9353: LD_EXP 7
9357: PPUSH
9358: LD_STRING D1-H-11
9360: PPUSH
9361: CALL_OW 88
// Say ( Dwayne , D1-Dw-9 ) ;
9365: LD_EXP 8
9369: PPUSH
9370: LD_STRING D1-Dw-9
9372: PPUSH
9373: CALL_OW 88
// Say ( Gonzo , D1-Gonzo-2 ) ;
9377: LD_EXP 11
9381: PPUSH
9382: LD_STRING D1-Gonzo-2
9384: PPUSH
9385: CALL_OW 88
// Say ( Heike , D1-H-12 ) ;
9389: LD_EXP 7
9393: PPUSH
9394: LD_STRING D1-H-12
9396: PPUSH
9397: CALL_OW 88
// Say ( Dwayne , D1-Dw-10 ) ;
9401: LD_EXP 8
9405: PPUSH
9406: LD_STRING D1-Dw-10
9408: PPUSH
9409: CALL_OW 88
// Say ( Heike , D1-H-13 ) ;
9413: LD_EXP 7
9417: PPUSH
9418: LD_STRING D1-H-13
9420: PPUSH
9421: CALL_OW 88
// if not kurt_is_substitute then
9425: LD_EXP 71
9429: NOT
9430: IFFALSE 9458
// begin Say ( Kurt , D1-Ku-3 ) ;
9432: LD_EXP 10
9436: PPUSH
9437: LD_STRING D1-Ku-3
9439: PPUSH
9440: CALL_OW 88
// Say ( Heike , D1-H-14a ) ;
9444: LD_EXP 7
9448: PPUSH
9449: LD_STRING D1-H-14a
9451: PPUSH
9452: CALL_OW 88
// end else
9456: GO 9482
// begin Say ( Kurt , D1-Ku_sub-3 ) ;
9458: LD_EXP 10
9462: PPUSH
9463: LD_STRING D1-Ku_sub-3
9465: PPUSH
9466: CALL_OW 88
// Say ( Heike , D1-H-14b ) ;
9470: LD_EXP 7
9474: PPUSH
9475: LD_STRING D1-H-14b
9477: PPUSH
9478: CALL_OW 88
// end ; InGameOff ;
9482: CALL_OW 9
// SetSide ( Gonzo , you ) ;
9486: LD_EXP 11
9490: PPUSH
9491: LD_EXP 2
9495: PPUSH
9496: CALL_OW 235
// for i in [ Heike , Dwayne , Oswald , Kurt , Gonzo ] do
9500: LD_ADDR_VAR 0 3
9504: PUSH
9505: LD_EXP 7
9509: PUSH
9510: LD_EXP 8
9514: PUSH
9515: LD_EXP 9
9519: PUSH
9520: LD_EXP 10
9524: PUSH
9525: LD_EXP 11
9529: PUSH
9530: EMPTY
9531: LIST
9532: LIST
9533: LIST
9534: LIST
9535: LIST
9536: PUSH
9537: FOR_IN
9538: IFFALSE 9551
// ComFree ( i ) ;
9540: LD_VAR 0 3
9544: PPUSH
9545: CALL_OW 139
9549: GO 9537
9551: POP
9552: POP
// for i in FilterAllUnits ( [ f_side , nature ] ) do
9553: LD_ADDR_VAR 0 3
9557: PUSH
9558: LD_INT 22
9560: PUSH
9561: LD_EXP 4
9565: PUSH
9566: EMPTY
9567: LIST
9568: LIST
9569: PPUSH
9570: CALL_OW 69
9574: PUSH
9575: FOR_IN
9576: IFFALSE 9589
// ComFree ( i ) ;
9578: LD_VAR 0 3
9582: PPUSH
9583: CALL_OW 139
9587: GO 9575
9589: POP
9590: POP
// wait ( 0 0$0.2 ) ;
9591: LD_INT 7
9593: PPUSH
9594: CALL_OW 67
// SaveForQuickRestart ;
9598: CALL_OW 22
// wait ( 0 0$1 ) ;
9602: LD_INT 35
9604: PPUSH
9605: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
9609: LD_STRING M1
9611: PPUSH
9612: CALL_OW 337
// wait ( 0 0$1 ) ;
9616: LD_INT 35
9618: PPUSH
9619: CALL_OW 67
// Query ( QEnterExitBuildingsInfo ) ;
9623: LD_STRING QEnterExitBuildingsInfo
9625: PPUSH
9626: CALL_OW 97
// end ; end_of_file
9630: LD_VAR 0 1
9634: RET
// every 0 0$10 do var base ;
9635: GO 9637
9637: DISABLE
9638: LD_INT 0
9640: PPUSH
// begin if IsLive ( ai_depot [ 1 ] ) and GetSide ( ai_depot [ 1 ] ) = russians then
9641: LD_EXP 32
9645: PUSH
9646: LD_INT 1
9648: ARRAY
9649: PPUSH
9650: CALL_OW 300
9654: PUSH
9655: LD_EXP 32
9659: PUSH
9660: LD_INT 1
9662: ARRAY
9663: PPUSH
9664: CALL_OW 255
9668: PUSH
9669: LD_EXP 3
9673: EQUAL
9674: AND
9675: IFFALSE 9741
// begin base = GetBase ( ai_depot [ 1 ] ) ;
9677: LD_ADDR_VAR 0 1
9681: PUSH
9682: LD_EXP 32
9686: PUSH
9687: LD_INT 1
9689: ARRAY
9690: PPUSH
9691: CALL_OW 274
9695: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 300 ) ;
9696: LD_VAR 0 1
9700: PPUSH
9701: LD_INT 1
9703: PPUSH
9704: LD_INT 300
9706: PPUSH
9707: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
9711: LD_VAR 0 1
9715: PPUSH
9716: LD_INT 2
9718: PPUSH
9719: LD_INT 0
9721: PPUSH
9722: CALL_OW 277
// SetResourceType ( base , mat_siberit , 300 ) ;
9726: LD_VAR 0 1
9730: PPUSH
9731: LD_INT 3
9733: PPUSH
9734: LD_INT 300
9736: PPUSH
9737: CALL_OW 277
// end ; if IsLive ( depot_north ) and GetSide ( depot_north ) = russians then
9741: LD_EXP 86
9745: PPUSH
9746: CALL_OW 300
9750: PUSH
9751: LD_EXP 86
9755: PPUSH
9756: CALL_OW 255
9760: PUSH
9761: LD_EXP 3
9765: EQUAL
9766: AND
9767: IFFALSE 9829
// begin base = GetBase ( depot_north ) ;
9769: LD_ADDR_VAR 0 1
9773: PUSH
9774: LD_EXP 86
9778: PPUSH
9779: CALL_OW 274
9783: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 150 ) ;
9784: LD_VAR 0 1
9788: PPUSH
9789: LD_INT 1
9791: PPUSH
9792: LD_INT 150
9794: PPUSH
9795: CALL_OW 277
// SetResourceType ( base , mat_oil , 300 ) ;
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_INT 2
9806: PPUSH
9807: LD_INT 300
9809: PPUSH
9810: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_INT 3
9821: PPUSH
9822: LD_INT 0
9824: PPUSH
9825: CALL_OW 277
// end ; enable ;
9829: ENABLE
// end ;
9830: PPOPN 1
9832: END
// on UnitDestroyed ( un ) do var side , temp_list , base ;
9833: LD_INT 0
9835: PPUSH
9836: PPUSH
9837: PPUSH
// begin if un = Heike then
9838: LD_VAR 0 1
9842: PUSH
9843: LD_EXP 7
9847: EQUAL
9848: IFFALSE 9872
// begin ExclusiveOn ;
9850: CALL_OW 4
// Wait ( 0 0$1 ) ;
9854: LD_INT 35
9856: PPUSH
9857: CALL_OW 67
// YouLost ( HeikeDead ) ;
9861: LD_STRING HeikeDead
9863: PPUSH
9864: CALL_OW 104
// ExclusiveOff ;
9868: CALL_OW 5
// end ; if un = the_archive then
9872: LD_VAR 0 1
9876: PUSH
9877: LD_EXP 75
9881: EQUAL
9882: IFFALSE 9918
// begin if num_documents_stolen >= 20 then
9884: LD_EXP 99
9888: PUSH
9889: LD_INT 20
9891: GREATEREQUAL
9892: IFFALSE 9896
// exit ;
9894: GO 10224
// ExclusiveOn ;
9896: CALL_OW 4
// wait ( 0 0$1 ) ;
9900: LD_INT 35
9902: PPUSH
9903: CALL_OW 67
// YouLost ( ArchiveDestroyed ) ;
9907: LD_STRING ArchiveDestroyed
9909: PPUSH
9910: CALL_OW 104
// ExclusiveOff ;
9914: CALL_OW 5
// end ; for base in ai_bases do
9918: LD_ADDR_VAR 0 4
9922: PUSH
9923: LD_EXP 57
9927: PUSH
9928: FOR_IN
9929: IFFALSE 9980
// begin temp_list = ai_captured_buildings [ base ] diff un ;
9931: LD_ADDR_VAR 0 3
9935: PUSH
9936: LD_EXP 69
9940: PUSH
9941: LD_VAR 0 4
9945: ARRAY
9946: PUSH
9947: LD_VAR 0 1
9951: DIFF
9952: ST_TO_ADDR
// ai_captured_buildings = Replace ( ai_captured_buildings , base , temp_list ) ;
9953: LD_ADDR_EXP 69
9957: PUSH
9958: LD_EXP 69
9962: PPUSH
9963: LD_VAR 0 4
9967: PPUSH
9968: LD_VAR 0 3
9972: PPUSH
9973: CALL_OW 1
9977: ST_TO_ADDR
// end ;
9978: GO 9928
9980: POP
9981: POP
// side = GetSide ( un ) ;
9982: LD_ADDR_VAR 0 2
9986: PUSH
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 255
9996: ST_TO_ADDR
// if side = russians_alt and GetType ( un ) = unit_vehicle and GetWeapon ( un ) = ru_cargo_bay then
9997: LD_VAR 0 2
10001: PUSH
10002: LD_EXP 6
10006: EQUAL
10007: PUSH
10008: LD_VAR 0 1
10012: PPUSH
10013: CALL_OW 247
10017: PUSH
10018: LD_INT 2
10020: EQUAL
10021: AND
10022: PUSH
10023: LD_VAR 0 1
10027: PPUSH
10028: CALL_OW 264
10032: PUSH
10033: LD_INT 51
10035: EQUAL
10036: AND
10037: IFFALSE 10070
// begin num_sabotaged_cargo_bays = num_sabotaged_cargo_bays + 1 ;
10039: LD_ADDR_EXP 121
10043: PUSH
10044: LD_EXP 121
10048: PUSH
10049: LD_INT 1
10051: PLUS
10052: ST_TO_ADDR
// if num_sabotaged_cargo_bays = 3 then
10053: LD_EXP 121
10057: PUSH
10058: LD_INT 3
10060: EQUAL
10061: IFFALSE 10070
// ChangeMissionObjectives ( MOutSabotage ) ;
10063: LD_STRING MOutSabotage
10065: PPUSH
10066: CALL_OW 337
// end ; if side <> russians then
10070: LD_VAR 0 2
10074: PUSH
10075: LD_EXP 3
10079: NONEQUAL
10080: IFFALSE 10084
// exit ;
10082: GO 10224
// case GetType ( un ) of unit_human :
10084: LD_VAR 0 1
10088: PPUSH
10089: CALL_OW 247
10093: PUSH
10094: LD_INT 1
10096: DOUBLE
10097: EQUAL
10098: IFTRUE 10102
10100: GO 10139
10102: POP
// for base in ai_bases do
10103: LD_ADDR_VAR 0 4
10107: PUSH
10108: LD_EXP 57
10112: PUSH
10113: FOR_IN
10114: IFFALSE 10135
// RemoveHumanFromVariables ( base , un , true ) ; unit_vehicle :
10116: LD_VAR 0 4
10120: PPUSH
10121: LD_VAR 0 1
10125: PPUSH
10126: LD_INT 1
10128: PPUSH
10129: CALL 10822 0 3
10133: GO 10113
10135: POP
10136: POP
10137: GO 10224
10139: LD_INT 2
10141: DOUBLE
10142: EQUAL
10143: IFTRUE 10147
10145: GO 10181
10147: POP
// for base in ai_bases do
10148: LD_ADDR_VAR 0 4
10152: PUSH
10153: LD_EXP 57
10157: PUSH
10158: FOR_IN
10159: IFFALSE 10177
// RemoveVehicleFromVariables ( base , un ) ; unit_building :
10161: LD_VAR 0 4
10165: PPUSH
10166: LD_VAR 0 1
10170: PPUSH
10171: CALL 10341 0 2
10175: GO 10158
10177: POP
10178: POP
10179: GO 10224
10181: LD_INT 3
10183: DOUBLE
10184: EQUAL
10185: IFTRUE 10189
10187: GO 10223
10189: POP
// for base in ai_bases do
10190: LD_ADDR_VAR 0 4
10194: PUSH
10195: LD_EXP 57
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10219
// RemoveBuildingFromVariables ( base , un ) ; end ;
10203: LD_VAR 0 4
10207: PPUSH
10208: LD_VAR 0 1
10212: PPUSH
10213: CALL 10227 0 2
10217: GO 10200
10219: POP
10220: POP
10221: GO 10224
10223: POP
// end ;
10224: PPOPN 4
10226: END
// function RemoveBuildingFromVariables ( base , building ) ; var temp_list ; begin
10227: LD_INT 0
10229: PPUSH
10230: PPUSH
// temp_list = ai_all_buildings [ base ] diff building ;
10231: LD_ADDR_VAR 0 4
10235: PUSH
10236: LD_EXP 43
10240: PUSH
10241: LD_VAR 0 1
10245: ARRAY
10246: PUSH
10247: LD_VAR 0 2
10251: DIFF
10252: ST_TO_ADDR
// ai_all_buildings = Replace ( ai_all_buildings , base , temp_list ) ;
10253: LD_ADDR_EXP 43
10257: PUSH
10258: LD_EXP 43
10262: PPUSH
10263: LD_VAR 0 1
10267: PPUSH
10268: LD_VAR 0 4
10272: PPUSH
10273: CALL_OW 1
10277: ST_TO_ADDR
// if building = ai_building_under_construction [ base ] then
10278: LD_VAR 0 2
10282: PUSH
10283: LD_EXP 41
10287: PUSH
10288: LD_VAR 0 1
10292: ARRAY
10293: EQUAL
10294: IFFALSE 10319
// ai_building_under_construction = Replace ( ai_building_under_construction , base , 0 ) ;
10296: LD_ADDR_EXP 41
10300: PUSH
10301: LD_EXP 41
10305: PPUSH
10306: LD_VAR 0 1
10310: PPUSH
10311: LD_INT 0
10313: PPUSH
10314: CALL_OW 1
10318: ST_TO_ADDR
// UpdateBuildingBasicVariables ( base , building , false ) ;
10319: LD_VAR 0 1
10323: PPUSH
10324: LD_VAR 0 2
10328: PPUSH
10329: LD_INT 0
10331: PPUSH
10332: CALL 3976 0 3
// end ;
10336: LD_VAR 0 3
10340: RET
// export function RemoveVehicleFromVariables ( base , vehicle ) ; var temp_list ; begin
10341: LD_INT 0
10343: PPUSH
10344: PPUSH
// if vehicle in ai_vehicles_defend [ base ] then
10345: LD_VAR 0 2
10349: PUSH
10350: LD_EXP 37
10354: PUSH
10355: LD_VAR 0 1
10359: ARRAY
10360: IN
10361: IFFALSE 10410
// begin temp_list = ai_vehicles_defend [ base ] diff vehicle ;
10363: LD_ADDR_VAR 0 4
10367: PUSH
10368: LD_EXP 37
10372: PUSH
10373: LD_VAR 0 1
10377: ARRAY
10378: PUSH
10379: LD_VAR 0 2
10383: DIFF
10384: ST_TO_ADDR
// ai_vehicles_defend = Replace ( ai_vehicles_defend , base , temp_list ) ;
10385: LD_ADDR_EXP 37
10389: PUSH
10390: LD_EXP 37
10394: PPUSH
10395: LD_VAR 0 1
10399: PPUSH
10400: LD_VAR 0 4
10404: PPUSH
10405: CALL_OW 1
10409: ST_TO_ADDR
// end ; if vehicle in ai_vehicles_attack [ base ] then
10410: LD_VAR 0 2
10414: PUSH
10415: LD_EXP 38
10419: PUSH
10420: LD_VAR 0 1
10424: ARRAY
10425: IN
10426: IFFALSE 10475
// begin temp_list = ai_vehicles_attack [ base ] diff vehicle ;
10428: LD_ADDR_VAR 0 4
10432: PUSH
10433: LD_EXP 38
10437: PUSH
10438: LD_VAR 0 1
10442: ARRAY
10443: PUSH
10444: LD_VAR 0 2
10448: DIFF
10449: ST_TO_ADDR
// ai_vehicles_attack = Replace ( ai_vehicles_attack , base , temp_list ) ;
10450: LD_ADDR_EXP 38
10454: PUSH
10455: LD_EXP 38
10459: PPUSH
10460: LD_VAR 0 1
10464: PPUSH
10465: LD_VAR 0 4
10469: PPUSH
10470: CALL_OW 1
10474: ST_TO_ADDR
// end ; if vehicle = ai_cargo_bay [ base ] then
10475: LD_VAR 0 2
10479: PUSH
10480: LD_EXP 59
10484: PUSH
10485: LD_VAR 0 1
10489: ARRAY
10490: EQUAL
10491: IFFALSE 10516
// ai_cargo_bay = Replace ( ai_cargo_bay , base , 0 ) ;
10493: LD_ADDR_EXP 59
10497: PUSH
10498: LD_EXP 59
10502: PPUSH
10503: LD_VAR 0 1
10507: PPUSH
10508: LD_INT 0
10510: PPUSH
10511: CALL_OW 1
10515: ST_TO_ADDR
// if vehicle in ai_retreating_vehicles_defend [ base ] then
10516: LD_VAR 0 2
10520: PUSH
10521: LD_EXP 52
10525: PUSH
10526: LD_VAR 0 1
10530: ARRAY
10531: IN
10532: IFFALSE 10581
// begin temp_list = ai_retreating_vehicles_defend [ base ] diff vehicle ;
10534: LD_ADDR_VAR 0 4
10538: PUSH
10539: LD_EXP 52
10543: PUSH
10544: LD_VAR 0 1
10548: ARRAY
10549: PUSH
10550: LD_VAR 0 2
10554: DIFF
10555: ST_TO_ADDR
// ai_retreating_vehicles_defend = Replace ( ai_retreating_vehicles_defend , base , temp_list ) ;
10556: LD_ADDR_EXP 52
10560: PUSH
10561: LD_EXP 52
10565: PPUSH
10566: LD_VAR 0 1
10570: PPUSH
10571: LD_VAR 0 4
10575: PPUSH
10576: CALL_OW 1
10580: ST_TO_ADDR
// end ; if vehicle in ai_vehicles_being_repaired [ base ] then
10581: LD_VAR 0 2
10585: PUSH
10586: LD_EXP 55
10590: PUSH
10591: LD_VAR 0 1
10595: ARRAY
10596: IN
10597: IFFALSE 10646
// begin temp_list = ai_vehicles_being_repaired [ base ] diff vehicle ;
10599: LD_ADDR_VAR 0 4
10603: PUSH
10604: LD_EXP 55
10608: PUSH
10609: LD_VAR 0 1
10613: ARRAY
10614: PUSH
10615: LD_VAR 0 2
10619: DIFF
10620: ST_TO_ADDR
// ai_vehicles_being_repaired = Replace ( ai_vehicles_being_repaired , base , temp_list ) ;
10621: LD_ADDR_EXP 55
10625: PUSH
10626: LD_EXP 55
10630: PPUSH
10631: LD_VAR 0 1
10635: PPUSH
10636: LD_VAR 0 4
10640: PPUSH
10641: CALL_OW 1
10645: ST_TO_ADDR
// end ; if vehicle in ai_refuel_vehicles_list [ base ] then
10646: LD_VAR 0 2
10650: PUSH
10651: LD_EXP 54
10655: PUSH
10656: LD_VAR 0 1
10660: ARRAY
10661: IN
10662: IFFALSE 10711
// begin temp_list = ai_refuel_vehicles_list [ base ] diff vehicle ;
10664: LD_ADDR_VAR 0 4
10668: PUSH
10669: LD_EXP 54
10673: PUSH
10674: LD_VAR 0 1
10678: ARRAY
10679: PUSH
10680: LD_VAR 0 2
10684: DIFF
10685: ST_TO_ADDR
// ai_refuel_vehicles_list = Replace ( ai_refuel_vehicles_list , base , temp_list ) ;
10686: LD_ADDR_EXP 54
10690: PUSH
10691: LD_EXP 54
10695: PPUSH
10696: LD_VAR 0 1
10700: PPUSH
10701: LD_VAR 0 4
10705: PPUSH
10706: CALL_OW 1
10710: ST_TO_ADDR
// end ; if vehicle = ai_vehicle_being_moved [ base ] then
10711: LD_VAR 0 2
10715: PUSH
10716: LD_EXP 45
10720: PUSH
10721: LD_VAR 0 1
10725: ARRAY
10726: EQUAL
10727: IFFALSE 10752
// ai_vehicle_being_moved = Replace ( ai_vehicle_being_moved , base , 0 ) ;
10729: LD_ADDR_EXP 45
10733: PUSH
10734: LD_EXP 45
10738: PPUSH
10739: LD_VAR 0 1
10743: PPUSH
10744: LD_INT 0
10746: PPUSH
10747: CALL_OW 1
10751: ST_TO_ADDR
// if vehicle in ai_vehicles_having_been_moved [ base ] then
10752: LD_VAR 0 2
10756: PUSH
10757: LD_EXP 67
10761: PUSH
10762: LD_VAR 0 1
10766: ARRAY
10767: IN
10768: IFFALSE 10817
// begin temp_list = ai_vehicles_having_been_moved [ base ] diff vehicle ;
10770: LD_ADDR_VAR 0 4
10774: PUSH
10775: LD_EXP 67
10779: PUSH
10780: LD_VAR 0 1
10784: ARRAY
10785: PUSH
10786: LD_VAR 0 2
10790: DIFF
10791: ST_TO_ADDR
// ai_vehicles_having_been_moved = Replace ( ai_vehicles_having_been_moved , base , temp_list ) ;
10792: LD_ADDR_EXP 67
10796: PUSH
10797: LD_EXP 67
10801: PPUSH
10802: LD_VAR 0 1
10806: PPUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL_OW 1
10816: ST_TO_ADDR
// end ; end ;
10817: LD_VAR 0 3
10821: RET
// export function RemoveHumanFromVariables ( base , human , check_if_base_is_dead ) ; var temp_list ; begin
10822: LD_INT 0
10824: PPUSH
10825: PPUSH
// if human in ai_soldiers [ base ] then
10826: LD_VAR 0 2
10830: PUSH
10831: LD_EXP 26
10835: PUSH
10836: LD_VAR 0 1
10840: ARRAY
10841: IN
10842: IFFALSE 10891
// begin temp_list = ai_soldiers [ base ] diff human ;
10844: LD_ADDR_VAR 0 5
10848: PUSH
10849: LD_EXP 26
10853: PUSH
10854: LD_VAR 0 1
10858: ARRAY
10859: PUSH
10860: LD_VAR 0 2
10864: DIFF
10865: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , base , temp_list ) ;
10866: LD_ADDR_EXP 26
10870: PUSH
10871: LD_EXP 26
10875: PPUSH
10876: LD_VAR 0 1
10880: PPUSH
10881: LD_VAR 0 5
10885: PPUSH
10886: CALL_OW 1
10890: ST_TO_ADDR
// end ; if human in ai_attacking_soldiers [ base ] then
10891: LD_VAR 0 2
10895: PUSH
10896: LD_EXP 62
10900: PUSH
10901: LD_VAR 0 1
10905: ARRAY
10906: IN
10907: IFFALSE 10956
// begin temp_list = ai_attacking_soldiers [ base ] diff human ;
10909: LD_ADDR_VAR 0 5
10913: PUSH
10914: LD_EXP 62
10918: PUSH
10919: LD_VAR 0 1
10923: ARRAY
10924: PUSH
10925: LD_VAR 0 2
10929: DIFF
10930: ST_TO_ADDR
// ai_attacking_soldiers = Replace ( ai_attacking_soldiers , base , temp_list ) ;
10931: LD_ADDR_EXP 62
10935: PUSH
10936: LD_EXP 62
10940: PPUSH
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_VAR 0 5
10950: PPUSH
10951: CALL_OW 1
10955: ST_TO_ADDR
// end ; if human in ai_engineers [ base ] then
10956: LD_VAR 0 2
10960: PUSH
10961: LD_EXP 27
10965: PUSH
10966: LD_VAR 0 1
10970: ARRAY
10971: IN
10972: IFFALSE 11021
// begin temp_list = ai_engineers [ base ] diff human ;
10974: LD_ADDR_VAR 0 5
10978: PUSH
10979: LD_EXP 27
10983: PUSH
10984: LD_VAR 0 1
10988: ARRAY
10989: PUSH
10990: LD_VAR 0 2
10994: DIFF
10995: ST_TO_ADDR
// ai_engineers = Replace ( ai_engineers , base , temp_list ) ;
10996: LD_ADDR_EXP 27
11000: PUSH
11001: LD_EXP 27
11005: PPUSH
11006: LD_VAR 0 1
11010: PPUSH
11011: LD_VAR 0 5
11015: PPUSH
11016: CALL_OW 1
11020: ST_TO_ADDR
// end ; if human in ai_apemen_engineers [ base ] then
11021: LD_VAR 0 2
11025: PUSH
11026: LD_EXP 61
11030: PUSH
11031: LD_VAR 0 1
11035: ARRAY
11036: IN
11037: IFFALSE 11086
// begin temp_list = ai_apemen_engineers [ base ] diff human ;
11039: LD_ADDR_VAR 0 5
11043: PUSH
11044: LD_EXP 61
11048: PUSH
11049: LD_VAR 0 1
11053: ARRAY
11054: PUSH
11055: LD_VAR 0 2
11059: DIFF
11060: ST_TO_ADDR
// ai_apemen_engineers = Replace ( ai_apemen_engineers , base , temp_list ) ;
11061: LD_ADDR_EXP 61
11065: PUSH
11066: LD_EXP 61
11070: PPUSH
11071: LD_VAR 0 1
11075: PPUSH
11076: LD_VAR 0 5
11080: PPUSH
11081: CALL_OW 1
11085: ST_TO_ADDR
// end ; if human in ai_mechanics_defend [ base ] then
11086: LD_VAR 0 2
11090: PUSH
11091: LD_EXP 28
11095: PUSH
11096: LD_VAR 0 1
11100: ARRAY
11101: IN
11102: IFFALSE 11151
// begin temp_list = ai_mechanics_defend [ base ] diff human ;
11104: LD_ADDR_VAR 0 5
11108: PUSH
11109: LD_EXP 28
11113: PUSH
11114: LD_VAR 0 1
11118: ARRAY
11119: PUSH
11120: LD_VAR 0 2
11124: DIFF
11125: ST_TO_ADDR
// ai_mechanics_defend = Replace ( ai_mechanics_defend , base , temp_list ) ;
11126: LD_ADDR_EXP 28
11130: PUSH
11131: LD_EXP 28
11135: PPUSH
11136: LD_VAR 0 1
11140: PPUSH
11141: LD_VAR 0 5
11145: PPUSH
11146: CALL_OW 1
11150: ST_TO_ADDR
// end ; if human in ai_mechanics_attack [ base ] then
11151: LD_VAR 0 2
11155: PUSH
11156: LD_EXP 29
11160: PUSH
11161: LD_VAR 0 1
11165: ARRAY
11166: IN
11167: IFFALSE 11216
// begin temp_list = ai_mechanics_attack [ base ] diff human ;
11169: LD_ADDR_VAR 0 5
11173: PUSH
11174: LD_EXP 29
11178: PUSH
11179: LD_VAR 0 1
11183: ARRAY
11184: PUSH
11185: LD_VAR 0 2
11189: DIFF
11190: ST_TO_ADDR
// ai_mechanics_attack = Replace ( ai_mechanics_attack , base , temp_list ) ;
11191: LD_ADDR_EXP 29
11195: PUSH
11196: LD_EXP 29
11200: PPUSH
11201: LD_VAR 0 1
11205: PPUSH
11206: LD_VAR 0 5
11210: PPUSH
11211: CALL_OW 1
11215: ST_TO_ADDR
// end ; if human in ai_scientists [ base ] then
11216: LD_VAR 0 2
11220: PUSH
11221: LD_EXP 30
11225: PUSH
11226: LD_VAR 0 1
11230: ARRAY
11231: IN
11232: IFFALSE 11281
// begin temp_list = ai_scientists [ base ] diff human ;
11234: LD_ADDR_VAR 0 5
11238: PUSH
11239: LD_EXP 30
11243: PUSH
11244: LD_VAR 0 1
11248: ARRAY
11249: PUSH
11250: LD_VAR 0 2
11254: DIFF
11255: ST_TO_ADDR
// ai_scientists = Replace ( ai_scientists , base , temp_list ) ;
11256: LD_ADDR_EXP 30
11260: PUSH
11261: LD_EXP 30
11265: PPUSH
11266: LD_VAR 0 1
11270: PPUSH
11271: LD_VAR 0 5
11275: PPUSH
11276: CALL_OW 1
11280: ST_TO_ADDR
// end ; if human in ai_attacking_scientists [ base ] then
11281: LD_VAR 0 2
11285: PUSH
11286: LD_EXP 63
11290: PUSH
11291: LD_VAR 0 1
11295: ARRAY
11296: IN
11297: IFFALSE 11346
// begin temp_list = ai_attacking_scientists [ base ] diff human ;
11299: LD_ADDR_VAR 0 5
11303: PUSH
11304: LD_EXP 63
11308: PUSH
11309: LD_VAR 0 1
11313: ARRAY
11314: PUSH
11315: LD_VAR 0 2
11319: DIFF
11320: ST_TO_ADDR
// ai_attacking_scientists = Replace ( ai_attacking_scientists , base , temp_list ) ;
11321: LD_ADDR_EXP 63
11325: PUSH
11326: LD_EXP 63
11330: PPUSH
11331: LD_VAR 0 1
11335: PPUSH
11336: LD_VAR 0 5
11340: PPUSH
11341: CALL_OW 1
11345: ST_TO_ADDR
// end ; if human in ai_heal_these_humans [ base ] then
11346: LD_VAR 0 2
11350: PUSH
11351: LD_EXP 42
11355: PUSH
11356: LD_VAR 0 1
11360: ARRAY
11361: IN
11362: IFFALSE 11411
// begin temp_list = ai_heal_these_humans [ base ] diff human ;
11364: LD_ADDR_VAR 0 5
11368: PUSH
11369: LD_EXP 42
11373: PUSH
11374: LD_VAR 0 1
11378: ARRAY
11379: PUSH
11380: LD_VAR 0 2
11384: DIFF
11385: ST_TO_ADDR
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
11386: LD_ADDR_EXP 42
11390: PUSH
11391: LD_EXP 42
11395: PPUSH
11396: LD_VAR 0 1
11400: PPUSH
11401: LD_VAR 0 5
11405: PPUSH
11406: CALL_OW 1
11410: ST_TO_ADDR
// end ; if human = ai_building_constructor [ base ] then
11411: LD_VAR 0 2
11415: PUSH
11416: LD_EXP 44
11420: PUSH
11421: LD_VAR 0 1
11425: ARRAY
11426: EQUAL
11427: IFFALSE 11452
// ai_building_constructor = Replace ( ai_building_constructor , base , 0 ) ;
11429: LD_ADDR_EXP 44
11433: PUSH
11434: LD_EXP 44
11438: PPUSH
11439: LD_VAR 0 1
11443: PPUSH
11444: LD_INT 0
11446: PPUSH
11447: CALL_OW 1
11451: ST_TO_ADDR
// if human in ai_retreating_attacking_humans [ base ] then
11452: LD_VAR 0 2
11456: PUSH
11457: LD_EXP 65
11461: PUSH
11462: LD_VAR 0 1
11466: ARRAY
11467: IN
11468: IFFALSE 11517
// begin temp_list = ai_retreating_attacking_humans [ base ] diff human ;
11470: LD_ADDR_VAR 0 5
11474: PUSH
11475: LD_EXP 65
11479: PUSH
11480: LD_VAR 0 1
11484: ARRAY
11485: PUSH
11486: LD_VAR 0 2
11490: DIFF
11491: ST_TO_ADDR
// ai_retreating_attacking_humans = Replace ( ai_retreating_attacking_humans , base , temp_list ) ;
11492: LD_ADDR_EXP 65
11496: PUSH
11497: LD_EXP 65
11501: PPUSH
11502: LD_VAR 0 1
11506: PPUSH
11507: LD_VAR 0 5
11511: PPUSH
11512: CALL_OW 1
11516: ST_TO_ADDR
// end ; if check_if_base_is_dead then
11517: LD_VAR 0 3
11521: IFFALSE 11643
// if ( ( ai_soldiers [ base ] ^ ai_attacking_soldiers [ base ] ^ ai_engineers [ base ] ^ ai_apemen_engineers [ base ] ^ ai_mechanics_defend [ base ] ^ ai_mechanics_attack [ base ] ^ ai_scientists [ base ] ^ ai_attacking_scientists [ base ] ) diff 0 ) = 0 then
11523: LD_EXP 26
11527: PUSH
11528: LD_VAR 0 1
11532: ARRAY
11533: PUSH
11534: LD_EXP 62
11538: PUSH
11539: LD_VAR 0 1
11543: ARRAY
11544: ADD
11545: PUSH
11546: LD_EXP 27
11550: PUSH
11551: LD_VAR 0 1
11555: ARRAY
11556: ADD
11557: PUSH
11558: LD_EXP 61
11562: PUSH
11563: LD_VAR 0 1
11567: ARRAY
11568: ADD
11569: PUSH
11570: LD_EXP 28
11574: PUSH
11575: LD_VAR 0 1
11579: ARRAY
11580: ADD
11581: PUSH
11582: LD_EXP 29
11586: PUSH
11587: LD_VAR 0 1
11591: ARRAY
11592: ADD
11593: PUSH
11594: LD_EXP 30
11598: PUSH
11599: LD_VAR 0 1
11603: ARRAY
11604: ADD
11605: PUSH
11606: LD_EXP 63
11610: PUSH
11611: LD_VAR 0 1
11615: ARRAY
11616: ADD
11617: PUSH
11618: LD_INT 0
11620: DIFF
11621: PUSH
11622: LD_INT 0
11624: EQUAL
11625: IFFALSE 11643
// ai_bases = ai_bases diff base ;
11627: LD_ADDR_EXP 57
11631: PUSH
11632: LD_EXP 57
11636: PUSH
11637: LD_VAR 0 1
11641: DIFF
11642: ST_TO_ADDR
// end ;
11643: LD_VAR 0 4
11647: RET
// function FindBase ( un ) ; begin
11648: LD_INT 0
11650: PPUSH
// result = 1 ;
11651: LD_ADDR_VAR 0 2
11655: PUSH
11656: LD_INT 1
11658: ST_TO_ADDR
// end ;
11659: LD_VAR 0 2
11663: RET
// function GetBaseSide ( base ) ; begin
11664: LD_INT 0
11666: PPUSH
// result = russians ;
11667: LD_ADDR_VAR 0 2
11671: PUSH
11672: LD_EXP 3
11676: ST_TO_ADDR
// end ;
11677: LD_VAR 0 2
11681: RET
// function GetBaseArea ( base ) ; begin
11682: LD_INT 0
11684: PPUSH
// result = ru_base_area ;
11685: LD_ADDR_VAR 0 2
11689: PUSH
11690: LD_INT 2
11692: ST_TO_ADDR
// end ;
11693: LD_VAR 0 2
11697: RET
// every 0 0$1 do var side , i , temp_list , buildings_list , soldiers_list , temp_unit , base , val , temp_list_2 , temp_unit_2 , j , leave_folks_for_defences , num_sol ; var temp_list_3 , bunkers ;
11698: GO 11700
11700: DISABLE
11701: LD_INT 0
11703: PPUSH
11704: PPUSH
11705: PPUSH
11706: PPUSH
11707: PPUSH
11708: PPUSH
11709: PPUSH
11710: PPUSH
11711: PPUSH
11712: PPUSH
11713: PPUSH
11714: PPUSH
11715: PPUSH
11716: PPUSH
11717: PPUSH
// begin side = russians ;
11718: LD_ADDR_VAR 0 1
11722: PUSH
11723: LD_EXP 3
11727: ST_TO_ADDR
// for base in ai_bases do
11728: LD_ADDR_VAR 0 7
11732: PUSH
11733: LD_EXP 57
11737: PUSH
11738: FOR_IN
11739: IFFALSE 14539
// begin soldiers_list = ai_soldiers [ base ] ;
11741: LD_ADDR_VAR 0 5
11745: PUSH
11746: LD_EXP 26
11750: PUSH
11751: LD_VAR 0 7
11755: ARRAY
11756: ST_TO_ADDR
// soldiers_list = soldiers_list diff sol_office_to_archive ;
11757: LD_ADDR_VAR 0 5
11761: PUSH
11762: LD_VAR 0 5
11766: PUSH
11767: LD_EXP 97
11771: DIFF
11772: ST_TO_ADDR
// soldiers_list = soldiers_list diff entrance_guard_to_office ;
11773: LD_ADDR_VAR 0 5
11777: PUSH
11778: LD_VAR 0 5
11782: PUSH
11783: LD_EXP 104
11787: DIFF
11788: ST_TO_ADDR
// soldiers_list = soldiers_list diff workshop_messenger ;
11789: LD_ADDR_VAR 0 5
11793: PUSH
11794: LD_VAR 0 5
11798: PUSH
11799: LD_EXP 115
11803: DIFF
11804: ST_TO_ADDR
// if except_Dmitri then
11805: LD_EXP 110
11809: IFFALSE 11827
// soldiers_list = soldiers_list diff Dmitri ;
11811: LD_ADDR_VAR 0 5
11815: PUSH
11816: LD_VAR 0 5
11820: PUSH
11821: LD_EXP 20
11825: DIFF
11826: ST_TO_ADDR
// if except_Yefibachev then
11827: LD_EXP 118
11831: IFFALSE 11849
// soldiers_list = soldiers_list diff Yefibachev ;
11833: LD_ADDR_VAR 0 5
11837: PUSH
11838: LD_VAR 0 5
11842: PUSH
11843: LD_EXP 14
11847: DIFF
11848: ST_TO_ADDR
// temp_list = ai_heal_these_humans [ base ] ;
11849: LD_ADDR_VAR 0 3
11853: PUSH
11854: LD_EXP 42
11858: PUSH
11859: LD_VAR 0 7
11863: ARRAY
11864: ST_TO_ADDR
// for i in soldiers_list diff ai_heal_these_humans [ base ] do
11865: LD_ADDR_VAR 0 2
11869: PUSH
11870: LD_VAR 0 5
11874: PUSH
11875: LD_EXP 42
11879: PUSH
11880: LD_VAR 0 7
11884: ARRAY
11885: DIFF
11886: PUSH
11887: FOR_IN
11888: IFFALSE 11923
// if GetLives ( i ) < 800 then
11890: LD_VAR 0 2
11894: PPUSH
11895: CALL_OW 256
11899: PUSH
11900: LD_INT 800
11902: LESS
11903: IFFALSE 11921
// temp_list = temp_list ^ i ;
11905: LD_ADDR_VAR 0 3
11909: PUSH
11910: LD_VAR 0 3
11914: PUSH
11915: LD_VAR 0 2
11919: ADD
11920: ST_TO_ADDR
11921: GO 11887
11923: POP
11924: POP
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
11925: LD_ADDR_EXP 42
11929: PUSH
11930: LD_EXP 42
11934: PPUSH
11935: LD_VAR 0 7
11939: PPUSH
11940: LD_VAR 0 3
11944: PPUSH
11945: CALL_OW 1
11949: ST_TO_ADDR
// if not code_black then
11950: LD_EXP 77
11954: NOT
11955: IFFALSE 12077
// begin for i in ai_heal_these_humans [ base ] do
11957: LD_ADDR_VAR 0 2
11961: PUSH
11962: LD_EXP 42
11966: PUSH
11967: LD_VAR 0 7
11971: ARRAY
11972: PUSH
11973: FOR_IN
11974: IFFALSE 12046
// if i in soldiers_list then
11976: LD_VAR 0 2
11980: PUSH
11981: LD_VAR 0 5
11985: IN
11986: IFFALSE 12044
// case GetType ( IsInUnit ( i ) ) of unit_vehicle :
11988: LD_VAR 0 2
11992: PPUSH
11993: CALL_OW 310
11997: PPUSH
11998: CALL_OW 247
12002: PUSH
12003: LD_INT 2
12005: DOUBLE
12006: EQUAL
12007: IFTRUE 12011
12009: GO 12023
12011: POP
// ComExitVehicle ( i ) ; unit_building :
12012: LD_VAR 0 2
12016: PPUSH
12017: CALL_OW 121
12021: GO 12044
12023: LD_INT 3
12025: DOUBLE
12026: EQUAL
12027: IFTRUE 12031
12029: GO 12043
12031: POP
// ComExitBuilding ( i ) ; end ;
12032: LD_VAR 0 2
12036: PPUSH
12037: CALL_OW 122
12041: GO 12044
12043: POP
12044: GO 11973
12046: POP
12047: POP
// soldiers_list = soldiers_list diff ai_heal_these_humans [ base ] ;
12048: LD_ADDR_VAR 0 5
12052: PUSH
12053: LD_VAR 0 5
12057: PUSH
12058: LD_EXP 42
12062: PUSH
12063: LD_VAR 0 7
12067: ARRAY
12068: DIFF
12069: ST_TO_ADDR
// code_black_soldiers = [ ] ;
12070: LD_ADDR_EXP 85
12074: PUSH
12075: EMPTY
12076: ST_TO_ADDR
// end ; if code_black then
12077: LD_EXP 77
12081: IFFALSE 12850
// begin if code_black_soldiers = 0 then
12083: LD_EXP 85
12087: PUSH
12088: LD_INT 0
12090: EQUAL
12091: IFFALSE 12764
// begin num_sol = [ 6 , 7 , 8 ] [ difficulty ] ;
12093: LD_ADDR_VAR 0 13
12097: PUSH
12098: LD_INT 6
12100: PUSH
12101: LD_INT 7
12103: PUSH
12104: LD_INT 8
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: LIST
12111: PUSH
12112: LD_OWVAR 67
12116: ARRAY
12117: ST_TO_ADDR
// leave_folks_for_defences = soldiers_list - num_sol >= 4 ;
12118: LD_ADDR_VAR 0 12
12122: PUSH
12123: LD_VAR 0 5
12127: PUSH
12128: LD_VAR 0 13
12132: MINUS
12133: PUSH
12134: LD_INT 4
12136: GREATEREQUAL
12137: ST_TO_ADDR
// soldiers_list = UnitFilter ( [ good_pat , bad_pat , Dmitri , Sergei , Yann ] , [ f_alive ] ) ^ ( soldiers_list diff [ Dmitri , Sergei , Yann , good_pat , bad_pat ] ) ;
12138: LD_ADDR_VAR 0 5
12142: PUSH
12143: LD_EXP 18
12147: PUSH
12148: LD_EXP 19
12152: PUSH
12153: LD_EXP 20
12157: PUSH
12158: LD_EXP 21
12162: PUSH
12163: LD_EXP 22
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: LIST
12172: LIST
12173: LIST
12174: PPUSH
12175: LD_INT 51
12177: PUSH
12178: EMPTY
12179: LIST
12180: PPUSH
12181: CALL_OW 72
12185: PUSH
12186: LD_VAR 0 5
12190: PUSH
12191: LD_EXP 20
12195: PUSH
12196: LD_EXP 21
12200: PUSH
12201: LD_EXP 22
12205: PUSH
12206: LD_EXP 18
12210: PUSH
12211: LD_EXP 19
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: LIST
12220: LIST
12221: LIST
12222: DIFF
12223: ADD
12224: ST_TO_ADDR
// soldiers_list = ( soldiers_list diff Yefibachev ) ^ UnitFilter ( Yefibachev , [ f_alive ] ) ;
12225: LD_ADDR_VAR 0 5
12229: PUSH
12230: LD_VAR 0 5
12234: PUSH
12235: LD_EXP 14
12239: DIFF
12240: PUSH
12241: LD_EXP 14
12245: PPUSH
12246: LD_INT 51
12248: PUSH
12249: EMPTY
12250: LIST
12251: PPUSH
12252: CALL_OW 72
12256: ADD
12257: ST_TO_ADDR
// temp_list_3 = [ ] ;
12258: LD_ADDR_VAR 0 14
12262: PUSH
12263: EMPTY
12264: ST_TO_ADDR
// if not entrance_guard_dialogue_played and heike_undercover in [ 0 , 2 ] then
12265: LD_EXP 84
12269: NOT
12270: PUSH
12271: LD_EXP 83
12275: PUSH
12276: LD_INT 0
12278: PUSH
12279: LD_INT 2
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: IN
12286: AND
12287: IFFALSE 12331
// for i in ai_bunkers [ 1 ] do
12289: LD_ADDR_VAR 0 2
12293: PUSH
12294: LD_EXP 49
12298: PUSH
12299: LD_INT 1
12301: ARRAY
12302: PUSH
12303: FOR_IN
12304: IFFALSE 12329
// temp_list_3 = temp_list_3 ^ UnitsInside ( i ) ;
12306: LD_ADDR_VAR 0 14
12310: PUSH
12311: LD_VAR 0 14
12315: PUSH
12316: LD_VAR 0 2
12320: PPUSH
12321: CALL_OW 313
12325: ADD
12326: ST_TO_ADDR
12327: GO 12303
12329: POP
12330: POP
// if leave_folks_for_defences then
12331: LD_VAR 0 12
12335: IFFALSE 12475
// begin temp_list = [ ] ;
12337: LD_ADDR_VAR 0 3
12341: PUSH
12342: EMPTY
12343: ST_TO_ADDR
// temp_list_2 = [ ] ;
12344: LD_ADDR_VAR 0 9
12348: PUSH
12349: EMPTY
12350: ST_TO_ADDR
// for val in ai_armouries [ 1 ] do
12351: LD_ADDR_VAR 0 8
12355: PUSH
12356: LD_EXP 48
12360: PUSH
12361: LD_INT 1
12363: ARRAY
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12411
// begin temp_list = temp_list ^ ( UnitsInside ( val ) + 0 ) ;
12368: LD_ADDR_VAR 0 3
12372: PUSH
12373: LD_VAR 0 3
12377: PUSH
12378: LD_VAR 0 8
12382: PPUSH
12383: CALL_OW 313
12387: PUSH
12388: LD_INT 0
12390: PLUS
12391: ADD
12392: ST_TO_ADDR
// temp_list_2 = temp_list_2 ^ val ;
12393: LD_ADDR_VAR 0 9
12397: PUSH
12398: LD_VAR 0 9
12402: PUSH
12403: LD_VAR 0 8
12407: ADD
12408: ST_TO_ADDR
// end ;
12409: GO 12365
12411: POP
12412: POP
// for val in ai_bunkers [ 1 ] do
12413: LD_ADDR_VAR 0 8
12417: PUSH
12418: LD_EXP 49
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PUSH
12427: FOR_IN
12428: IFFALSE 12473
// begin temp_list = temp_list ^ ( UnitsInside ( val ) + 0 ) ;
12430: LD_ADDR_VAR 0 3
12434: PUSH
12435: LD_VAR 0 3
12439: PUSH
12440: LD_VAR 0 8
12444: PPUSH
12445: CALL_OW 313
12449: PUSH
12450: LD_INT 0
12452: PLUS
12453: ADD
12454: ST_TO_ADDR
// temp_list_2 = temp_list_2 ^ val ;
12455: LD_ADDR_VAR 0 9
12459: PUSH
12460: LD_VAR 0 9
12464: PUSH
12465: LD_VAR 0 8
12469: ADD
12470: ST_TO_ADDR
// end ;
12471: GO 12427
12473: POP
12474: POP
// end ; for i = 1 to num_sol do
12475: LD_ADDR_VAR 0 2
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_VAR 0 13
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12762
// begin temp_unit = 0 ;
12493: LD_ADDR_VAR 0 6
12497: PUSH
12498: LD_INT 0
12500: ST_TO_ADDR
// for val in soldiers_list do
12501: LD_ADDR_VAR 0 8
12505: PUSH
12506: LD_VAR 0 5
12510: PUSH
12511: FOR_IN
12512: IFFALSE 12712
// begin if val in temp_list_3 then
12514: LD_VAR 0 8
12518: PUSH
12519: LD_VAR 0 14
12523: IN
12524: IFFALSE 12528
// continue ;
12526: GO 12511
// if leave_folks_for_defences then
12528: LD_VAR 0 12
12532: IFFALSE 12688
// begin temp_unit_2 = IsInUnit ( val ) ;
12534: LD_ADDR_VAR 0 10
12538: PUSH
12539: LD_VAR 0 8
12543: PPUSH
12544: CALL_OW 310
12548: ST_TO_ADDR
// if temp_unit_2 > 0 and temp_unit_2 in temp_list_2 then
12549: LD_VAR 0 10
12553: PUSH
12554: LD_INT 0
12556: GREATER
12557: PUSH
12558: LD_VAR 0 10
12562: PUSH
12563: LD_VAR 0 9
12567: IN
12568: AND
12569: IFFALSE 12676
// begin for j = 1 to temp_list do
12571: LD_ADDR_VAR 0 11
12575: PUSH
12576: DOUBLE
12577: LD_INT 1
12579: DEC
12580: ST_TO_ADDR
12581: LD_VAR 0 3
12585: PUSH
12586: FOR_TO
12587: IFFALSE 12672
// if temp_unit_2 = temp_list_2 [ j ] then
12589: LD_VAR 0 10
12593: PUSH
12594: LD_VAR 0 9
12598: PUSH
12599: LD_VAR 0 11
12603: ARRAY
12604: EQUAL
12605: IFFALSE 12670
// begin if temp_list [ j ] > 1 then
12607: LD_VAR 0 3
12611: PUSH
12612: LD_VAR 0 11
12616: ARRAY
12617: PUSH
12618: LD_INT 1
12620: GREATER
12621: IFFALSE 12668
// begin temp_unit = val ;
12623: LD_ADDR_VAR 0 6
12627: PUSH
12628: LD_VAR 0 8
12632: ST_TO_ADDR
// temp_list = Replace ( temp_list , j , temp_list [ j ] - 1 ) ;
12633: LD_ADDR_VAR 0 3
12637: PUSH
12638: LD_VAR 0 3
12642: PPUSH
12643: LD_VAR 0 11
12647: PPUSH
12648: LD_VAR 0 3
12652: PUSH
12653: LD_VAR 0 11
12657: ARRAY
12658: PUSH
12659: LD_INT 1
12661: MINUS
12662: PPUSH
12663: CALL_OW 1
12667: ST_TO_ADDR
// end ; break ;
12668: GO 12672
// end ;
12670: GO 12586
12672: POP
12673: POP
// end else
12674: GO 12686
// temp_unit = val ;
12676: LD_ADDR_VAR 0 6
12680: PUSH
12681: LD_VAR 0 8
12685: ST_TO_ADDR
// end else
12686: GO 12698
// temp_unit = val ;
12688: LD_ADDR_VAR 0 6
12692: PUSH
12693: LD_VAR 0 8
12697: ST_TO_ADDR
// if temp_unit > 0 then
12698: LD_VAR 0 6
12702: PUSH
12703: LD_INT 0
12705: GREATER
12706: IFFALSE 12710
// break ;
12708: GO 12712
// end ;
12710: GO 12511
12712: POP
12713: POP
// if temp_unit > 0 then
12714: LD_VAR 0 6
12718: PUSH
12719: LD_INT 0
12721: GREATER
12722: IFFALSE 12758
// begin code_black_soldiers = code_black_soldiers ^ temp_unit ;
12724: LD_ADDR_EXP 85
12728: PUSH
12729: LD_EXP 85
12733: PUSH
12734: LD_VAR 0 6
12738: ADD
12739: ST_TO_ADDR
// soldiers_list = soldiers_list diff temp_unit ;
12740: LD_ADDR_VAR 0 5
12744: PUSH
12745: LD_VAR 0 5
12749: PUSH
12750: LD_VAR 0 6
12754: DIFF
12755: ST_TO_ADDR
// end else
12756: GO 12760
// break ;
12758: GO 12762
// end ;
12760: GO 12490
12762: POP
12763: POP
// end ; soldiers_list = soldiers_list diff code_black_soldiers ;
12764: LD_ADDR_VAR 0 5
12768: PUSH
12769: LD_VAR 0 5
12773: PUSH
12774: LD_EXP 85
12778: DIFF
12779: ST_TO_ADDR
// temp_list = [ ] ;
12780: LD_ADDR_VAR 0 3
12784: PUSH
12785: EMPTY
12786: ST_TO_ADDR
// for i in patrols do
12787: LD_ADDR_VAR 0 2
12791: PUSH
12792: LD_EXP 78
12796: PUSH
12797: FOR_IN
12798: IFFALSE 12818
// temp_list = temp_list ^ i ;
12800: LD_ADDR_VAR 0 3
12804: PUSH
12805: LD_VAR 0 3
12809: PUSH
12810: LD_VAR 0 2
12814: ADD
12815: ST_TO_ADDR
12816: GO 12797
12818: POP
12819: POP
// code_black_soldiers = code_black_soldiers diff temp_list ;
12820: LD_ADDR_EXP 85
12824: PUSH
12825: LD_EXP 85
12829: PUSH
12830: LD_VAR 0 3
12834: DIFF
12835: ST_TO_ADDR
// ControlCodeBlackUnits ( GetHumansOutOfUnits ( code_black_soldiers ) ) ;
12836: LD_EXP 85
12840: PPUSH
12841: CALL 23354 0 1
12845: PPUSH
12846: CALL 14545 0 1
// end ; if soldiers_list = 0 then
12850: LD_VAR 0 5
12854: PUSH
12855: LD_INT 0
12857: EQUAL
12858: IFFALSE 12862
// continue ;
12860: GO 11738
// if Yefibachev in soldiers_list and IsOk ( leader_office ) then
12862: LD_EXP 14
12866: PUSH
12867: LD_VAR 0 5
12871: IN
12872: PUSH
12873: LD_EXP 93
12877: PPUSH
12878: CALL_OW 302
12882: AND
12883: IFFALSE 12993
// begin temp_unit = IsInUnit ( Yefibachev ) ;
12885: LD_ADDR_VAR 0 6
12889: PUSH
12890: LD_EXP 14
12894: PPUSH
12895: CALL_OW 310
12899: ST_TO_ADDR
// case GetType ( temp_unit ) of unit_vehicle :
12900: LD_VAR 0 6
12904: PPUSH
12905: CALL_OW 247
12909: PUSH
12910: LD_INT 2
12912: DOUBLE
12913: EQUAL
12914: IFTRUE 12918
12916: GO 12930
12918: POP
// ComExitVehicle ( Yefibachev ) ; unit_building :
12919: LD_EXP 14
12923: PPUSH
12924: CALL_OW 121
12928: GO 12977
12930: LD_INT 3
12932: DOUBLE
12933: EQUAL
12934: IFTRUE 12938
12936: GO 12962
12938: POP
// if temp_unit <> leader_office then
12939: LD_VAR 0 6
12943: PUSH
12944: LD_EXP 93
12948: NONEQUAL
12949: IFFALSE 12960
// ComExitBuilding ( Yefibachev ) ; else
12951: LD_EXP 14
12955: PPUSH
12956: CALL_OW 122
12960: GO 12977
12962: POP
// ComEnterUnit ( Yefibachev , leader_office ) ; end ;
12963: LD_EXP 14
12967: PPUSH
12968: LD_EXP 93
12972: PPUSH
12973: CALL_OW 120
// soldiers_list = soldiers_list diff Yefibachev ;
12977: LD_ADDR_VAR 0 5
12981: PUSH
12982: LD_VAR 0 5
12986: PUSH
12987: LD_EXP 14
12991: DIFF
12992: ST_TO_ADDR
// end ; if not code_black and ( soldiers_list diff [ Dmitri , Sergei , Yann ] ) + 0 = soldiers_list - 3 then
12993: LD_EXP 77
12997: NOT
12998: PUSH
12999: LD_VAR 0 5
13003: PUSH
13004: LD_EXP 20
13008: PUSH
13009: LD_EXP 21
13013: PUSH
13014: LD_EXP 22
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: LIST
13023: DIFF
13024: PUSH
13025: LD_INT 0
13027: PLUS
13028: PUSH
13029: LD_VAR 0 5
13033: PUSH
13034: LD_INT 3
13036: MINUS
13037: EQUAL
13038: AND
13039: IFFALSE 13347
// begin temp_list = [ [ 58 , 12 ] , [ 60 , 13 ] , [ 59 , 14 ] ] ;
13041: LD_ADDR_VAR 0 3
13045: PUSH
13046: LD_INT 58
13048: PUSH
13049: LD_INT 12
13051: PUSH
13052: EMPTY
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 60
13058: PUSH
13059: LD_INT 13
13061: PUSH
13062: EMPTY
13063: LIST
13064: LIST
13065: PUSH
13066: LD_INT 59
13068: PUSH
13069: LD_INT 14
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PUSH
13076: EMPTY
13077: LIST
13078: LIST
13079: LIST
13080: ST_TO_ADDR
// temp_list_2 = [ Dmitri , Sergei , Yann ] ;
13081: LD_ADDR_VAR 0 9
13085: PUSH
13086: LD_EXP 20
13090: PUSH
13091: LD_EXP 21
13095: PUSH
13096: LD_EXP 22
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: ST_TO_ADDR
// for i = 1 to temp_list_2 do
13106: LD_ADDR_VAR 0 2
13110: PUSH
13111: DOUBLE
13112: LD_INT 1
13114: DEC
13115: ST_TO_ADDR
13116: LD_VAR 0 9
13120: PUSH
13121: FOR_TO
13122: IFFALSE 13314
// if not IsAt ( temp_list_2 [ i ] , temp_list [ i ] [ 1 ] , temp_list [ i ] [ 2 ] ) then
13124: LD_VAR 0 9
13128: PUSH
13129: LD_VAR 0 2
13133: ARRAY
13134: PPUSH
13135: LD_VAR 0 3
13139: PUSH
13140: LD_VAR 0 2
13144: ARRAY
13145: PUSH
13146: LD_INT 1
13148: ARRAY
13149: PPUSH
13150: LD_VAR 0 3
13154: PUSH
13155: LD_VAR 0 2
13159: ARRAY
13160: PUSH
13161: LD_INT 2
13163: ARRAY
13164: PPUSH
13165: CALL_OW 307
13169: NOT
13170: IFFALSE 13312
// case GetType ( IsInUnit ( temp_list_2 [ i ] ) ) of unit_vehicle :
13172: LD_VAR 0 9
13176: PUSH
13177: LD_VAR 0 2
13181: ARRAY
13182: PPUSH
13183: CALL_OW 310
13187: PPUSH
13188: CALL_OW 247
13192: PUSH
13193: LD_INT 2
13195: DOUBLE
13196: EQUAL
13197: IFTRUE 13201
13199: GO 13219
13201: POP
// ComExitVehicle ( temp_list_2 [ i ] ) ; unit_building :
13202: LD_VAR 0 9
13206: PUSH
13207: LD_VAR 0 2
13211: ARRAY
13212: PPUSH
13213: CALL_OW 121
13217: GO 13312
13219: LD_INT 3
13221: DOUBLE
13222: EQUAL
13223: IFTRUE 13227
13225: GO 13245
13227: POP
// ComExitBuilding ( temp_list_2 [ i ] ) ; else
13228: LD_VAR 0 9
13232: PUSH
13233: LD_VAR 0 2
13237: ARRAY
13238: PPUSH
13239: CALL_OW 122
13243: GO 13312
13245: POP
// begin ComMoveXY ( temp_list_2 [ i ] , temp_list [ i ] [ 1 ] , temp_list [ i ] [ 2 ] ) ;
13246: LD_VAR 0 9
13250: PUSH
13251: LD_VAR 0 2
13255: ARRAY
13256: PPUSH
13257: LD_VAR 0 3
13261: PUSH
13262: LD_VAR 0 2
13266: ARRAY
13267: PUSH
13268: LD_INT 1
13270: ARRAY
13271: PPUSH
13272: LD_VAR 0 3
13276: PUSH
13277: LD_VAR 0 2
13281: ARRAY
13282: PUSH
13283: LD_INT 2
13285: ARRAY
13286: PPUSH
13287: CALL_OW 111
// AddComTurnXY ( temp_list_2 [ i ] , 59 , 13 ) ;
13291: LD_VAR 0 9
13295: PUSH
13296: LD_VAR 0 2
13300: ARRAY
13301: PPUSH
13302: LD_INT 59
13304: PPUSH
13305: LD_INT 13
13307: PPUSH
13308: CALL_OW 178
// end ; end ;
13312: GO 13121
13314: POP
13315: POP
// soldiers_list = soldiers_list diff [ Dmitri , Sergei , Yann ] ;
13316: LD_ADDR_VAR 0 5
13320: PUSH
13321: LD_VAR 0 5
13325: PUSH
13326: LD_EXP 20
13330: PUSH
13331: LD_EXP 21
13335: PUSH
13336: LD_EXP 22
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: LIST
13345: DIFF
13346: ST_TO_ADDR
// end ; if not code_black and poker_sol in soldiers_list and IsOk ( ai_depot [ base ] ) then
13347: LD_EXP 77
13351: NOT
13352: PUSH
13353: LD_EXP 24
13357: PUSH
13358: LD_VAR 0 5
13362: IN
13363: AND
13364: PUSH
13365: LD_EXP 32
13369: PUSH
13370: LD_VAR 0 7
13374: ARRAY
13375: PPUSH
13376: CALL_OW 302
13380: AND
13381: IFFALSE 13503
// begin temp_unit = IsInUnit ( poker_sol ) ;
13383: LD_ADDR_VAR 0 6
13387: PUSH
13388: LD_EXP 24
13392: PPUSH
13393: CALL_OW 310
13397: ST_TO_ADDR
// case GetType ( temp_unit ) of unit_vehicle :
13398: LD_VAR 0 6
13402: PPUSH
13403: CALL_OW 247
13407: PUSH
13408: LD_INT 2
13410: DOUBLE
13411: EQUAL
13412: IFTRUE 13416
13414: GO 13428
13416: POP
// ComExitVehicle ( poker_sol ) ; unit_building :
13417: LD_EXP 24
13421: PPUSH
13422: CALL_OW 121
13426: GO 13487
13428: LD_INT 3
13430: DOUBLE
13431: EQUAL
13432: IFTRUE 13436
13434: GO 13466
13436: POP
// if temp_unit <> ai_depot [ base ] then
13437: LD_VAR 0 6
13441: PUSH
13442: LD_EXP 32
13446: PUSH
13447: LD_VAR 0 7
13451: ARRAY
13452: NONEQUAL
13453: IFFALSE 13464
// ComExitBuilding ( poker_sol ) ; else
13455: LD_EXP 24
13459: PPUSH
13460: CALL_OW 122
13464: GO 13487
13466: POP
// ComEnterUnit ( poker_sol , ai_depot [ base ] ) ; end ;
13467: LD_EXP 24
13471: PPUSH
13472: LD_EXP 32
13476: PUSH
13477: LD_VAR 0 7
13481: ARRAY
13482: PPUSH
13483: CALL_OW 120
// soldiers_list = soldiers_list diff poker_sol ;
13487: LD_ADDR_VAR 0 5
13491: PUSH
13492: LD_VAR 0 5
13496: PUSH
13497: LD_EXP 24
13501: DIFF
13502: ST_TO_ADDR
// end ; if not terminate_internal_patrol then
13503: LD_EXP 82
13507: NOT
13508: IFFALSE 13637
// begin if not code_black and ( soldiers_list diff [ good_pat , bad_pat ] ) + 0 = soldiers_list - 2 then
13510: LD_EXP 77
13514: NOT
13515: PUSH
13516: LD_VAR 0 5
13520: PUSH
13521: LD_EXP 18
13525: PUSH
13526: LD_EXP 19
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: DIFF
13535: PUSH
13536: LD_INT 0
13538: PLUS
13539: PUSH
13540: LD_VAR 0 5
13544: PUSH
13545: LD_INT 2
13547: MINUS
13548: EQUAL
13549: AND
13550: IFFALSE 13597
// begin soldiers_list = soldiers_list diff [ good_pat , bad_pat ] ;
13552: LD_ADDR_VAR 0 5
13556: PUSH
13557: LD_VAR 0 5
13561: PUSH
13562: LD_EXP 18
13566: PUSH
13567: LD_EXP 19
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: DIFF
13576: ST_TO_ADDR
// if halt_internal_patrol = 1 then
13577: LD_EXP 81
13581: PUSH
13582: LD_INT 1
13584: EQUAL
13585: IFFALSE 13595
// halt_internal_patrol = 0 ;
13587: LD_ADDR_EXP 81
13591: PUSH
13592: LD_INT 0
13594: ST_TO_ADDR
// end else
13595: GO 13637
// if IsDead ( good_pat ) or IsDead ( bad_pat ) then
13597: LD_EXP 18
13601: PPUSH
13602: CALL_OW 301
13606: PUSH
13607: LD_EXP 19
13611: PPUSH
13612: CALL_OW 301
13616: OR
13617: IFFALSE 13629
// terminate_internal_patrol = true else
13619: LD_ADDR_EXP 82
13623: PUSH
13624: LD_INT 1
13626: ST_TO_ADDR
13627: GO 13637
// halt_internal_patrol = 1 ;
13629: LD_ADDR_EXP 81
13633: PUSH
13634: LD_INT 1
13636: ST_TO_ADDR
// end ; i = false ;
13637: LD_ADDR_VAR 0 2
13641: PUSH
13642: LD_INT 0
13644: ST_TO_ADDR
// if IsOk ( ai_depot [ base ] ) then
13645: LD_EXP 32
13649: PUSH
13650: LD_VAR 0 7
13654: ARRAY
13655: PPUSH
13656: CALL_OW 302
13660: IFFALSE 13700
// if GetEnergy ( GetBase ( ai_depot [ base ] ) ) [ 4 ] > 0 then
13662: LD_EXP 32
13666: PUSH
13667: LD_VAR 0 7
13671: ARRAY
13672: PPUSH
13673: CALL_OW 274
13677: PPUSH
13678: CALL_OW 278
13682: PUSH
13683: LD_INT 4
13685: ARRAY
13686: PUSH
13687: LD_INT 0
13689: GREATER
13690: IFFALSE 13700
// i = true ;
13692: LD_ADDR_VAR 0 2
13696: PUSH
13697: LD_INT 1
13699: ST_TO_ADDR
// if i then
13700: LD_VAR 0 2
13704: IFFALSE 13724
// bunkers = ai_bunkers [ base ] else
13706: LD_ADDR_VAR 0 15
13710: PUSH
13711: LD_EXP 49
13715: PUSH
13716: LD_VAR 0 7
13720: ARRAY
13721: ST_TO_ADDR
13722: GO 13785
// begin bunkers = [ ] ;
13724: LD_ADDR_VAR 0 15
13728: PUSH
13729: EMPTY
13730: ST_TO_ADDR
// for i in ai_bunkers [ base ] do
13731: LD_ADDR_VAR 0 2
13735: PUSH
13736: LD_EXP 49
13740: PUSH
13741: LD_VAR 0 7
13745: ARRAY
13746: PUSH
13747: FOR_IN
13748: IFFALSE 13783
// if GetBType ( i ) = b_breastwork then
13750: LD_VAR 0 2
13754: PPUSH
13755: CALL_OW 266
13759: PUSH
13760: LD_INT 31
13762: EQUAL
13763: IFFALSE 13781
// bunkers = bunkers ^ i ;
13765: LD_ADDR_VAR 0 15
13769: PUSH
13770: LD_VAR 0 15
13774: PUSH
13775: LD_VAR 0 2
13779: ADD
13780: ST_TO_ADDR
13781: GO 13747
13783: POP
13784: POP
// end ; buildings_list = [ ] ;
13785: LD_ADDR_VAR 0 4
13789: PUSH
13790: EMPTY
13791: ST_TO_ADDR
// for i in UnitFilter ( bunkers , [ f_ok ] ) do
13792: LD_ADDR_VAR 0 2
13796: PUSH
13797: LD_VAR 0 15
13801: PPUSH
13802: LD_INT 50
13804: PUSH
13805: EMPTY
13806: LIST
13807: PPUSH
13808: CALL_OW 72
13812: PUSH
13813: FOR_IN
13814: IFFALSE 13877
// begin temp_unit = UnitsInside ( i ) ;
13816: LD_ADDR_VAR 0 6
13820: PUSH
13821: LD_VAR 0 2
13825: PPUSH
13826: CALL_OW 313
13830: ST_TO_ADDR
// if temp_unit = 0 then
13831: LD_VAR 0 6
13835: PUSH
13836: LD_INT 0
13838: EQUAL
13839: IFFALSE 13859
// buildings_list = buildings_list ^ i else
13841: LD_ADDR_VAR 0 4
13845: PUSH
13846: LD_VAR 0 4
13850: PUSH
13851: LD_VAR 0 2
13855: ADD
13856: ST_TO_ADDR
13857: GO 13875
// soldiers_list = soldiers_list diff temp_unit ;
13859: LD_ADDR_VAR 0 5
13863: PUSH
13864: LD_VAR 0 5
13868: PUSH
13869: LD_VAR 0 6
13873: DIFF
13874: ST_TO_ADDR
// end ;
13875: GO 13813
13877: POP
13878: POP
// temp_list = UnitFilter ( Stanimir , [ f_alive ] ) ;
13879: LD_ADDR_VAR 0 3
13883: PUSH
13884: LD_EXP 12
13888: PPUSH
13889: LD_INT 51
13891: PUSH
13892: EMPTY
13893: LIST
13894: PPUSH
13895: CALL_OW 72
13899: ST_TO_ADDR
// for i in temp_list do
13900: LD_ADDR_VAR 0 2
13904: PUSH
13905: LD_VAR 0 3
13909: PUSH
13910: FOR_IN
13911: IFFALSE 14082
// begin if buildings_list = 0 then
13913: LD_VAR 0 4
13917: PUSH
13918: LD_INT 0
13920: EQUAL
13921: IFFALSE 13925
// break ;
13923: GO 14082
// if not i in soldiers_list then
13925: LD_VAR 0 2
13929: PUSH
13930: LD_VAR 0 5
13934: IN
13935: NOT
13936: IFFALSE 13940
// continue ;
13938: GO 13910
// val = buildings_list [ 1 ] ;
13940: LD_ADDR_VAR 0 8
13944: PUSH
13945: LD_VAR 0 4
13949: PUSH
13950: LD_INT 1
13952: ARRAY
13953: ST_TO_ADDR
// buildings_list = Delete ( buildings_list , 1 ) ;
13954: LD_ADDR_VAR 0 4
13958: PUSH
13959: LD_VAR 0 4
13963: PPUSH
13964: LD_INT 1
13966: PPUSH
13967: CALL_OW 3
13971: ST_TO_ADDR
// soldiers_list = soldiers_list diff i ;
13972: LD_ADDR_VAR 0 5
13976: PUSH
13977: LD_VAR 0 5
13981: PUSH
13982: LD_VAR 0 2
13986: DIFF
13987: ST_TO_ADDR
// temp_unit = IsInUnit ( i ) ;
13988: LD_ADDR_VAR 0 6
13992: PUSH
13993: LD_VAR 0 2
13997: PPUSH
13998: CALL_OW 310
14002: ST_TO_ADDR
// case GetType ( temp_unit ) of unit_vehicle :
14003: LD_VAR 0 6
14007: PPUSH
14008: CALL_OW 247
14012: PUSH
14013: LD_INT 2
14015: DOUBLE
14016: EQUAL
14017: IFTRUE 14021
14019: GO 14033
14021: POP
// ComExitVehicle ( i ) ; unit_building :
14022: LD_VAR 0 2
14026: PPUSH
14027: CALL_OW 121
14031: GO 14080
14033: LD_INT 3
14035: DOUBLE
14036: EQUAL
14037: IFTRUE 14041
14039: GO 14065
14041: POP
// if temp_unit <> val then
14042: LD_VAR 0 6
14046: PUSH
14047: LD_VAR 0 8
14051: NONEQUAL
14052: IFFALSE 14063
// ComExitBuilding ( i ) ; else
14054: LD_VAR 0 2
14058: PPUSH
14059: CALL_OW 122
14063: GO 14080
14065: POP
// ComEnterUnit ( i , val ) ; end ;
14066: LD_VAR 0 2
14070: PPUSH
14071: LD_VAR 0 8
14075: PPUSH
14076: CALL_OW 120
// end ;
14080: GO 13910
14082: POP
14083: POP
// if buildings_list > 0 then
14084: LD_VAR 0 4
14088: PUSH
14089: LD_INT 0
14091: GREATER
14092: IFFALSE 14472
// begin temp_list = [ ] ;
14094: LD_ADDR_VAR 0 3
14098: PUSH
14099: EMPTY
14100: ST_TO_ADDR
// for i in soldiers_list do
14101: LD_ADDR_VAR 0 2
14105: PUSH
14106: LD_VAR 0 5
14110: PUSH
14111: FOR_IN
14112: IFFALSE 14147
// if GetSex ( i ) = sex_male then
14114: LD_VAR 0 2
14118: PPUSH
14119: CALL_OW 258
14123: PUSH
14124: LD_INT 1
14126: EQUAL
14127: IFFALSE 14145
// temp_list = temp_list ^ i ;
14129: LD_ADDR_VAR 0 3
14133: PUSH
14134: LD_VAR 0 3
14138: PUSH
14139: LD_VAR 0 2
14143: ADD
14144: ST_TO_ADDR
14145: GO 14111
14147: POP
14148: POP
// if not entrance_guard_dialogue_played and heike_undercover in [ 0 , 2 ] then
14149: LD_EXP 84
14153: NOT
14154: PUSH
14155: LD_EXP 83
14159: PUSH
14160: LD_INT 0
14162: PUSH
14163: LD_INT 2
14165: PUSH
14166: EMPTY
14167: LIST
14168: LIST
14169: IN
14170: AND
14171: IFFALSE 14370
// for i = 1 to buildings_list - temp_list do
14173: LD_ADDR_VAR 0 2
14177: PUSH
14178: DOUBLE
14179: LD_INT 1
14181: DEC
14182: ST_TO_ADDR
14183: LD_VAR 0 4
14187: PUSH
14188: LD_VAR 0 3
14192: MINUS
14193: PUSH
14194: FOR_TO
14195: IFFALSE 14368
// begin temp_unit = CreateUnitsWithClass ( 1 , class_soldier , sex_male ,  , side ) [ 1 ] ;
14197: LD_ADDR_VAR 0 6
14201: PUSH
14202: LD_INT 1
14204: PPUSH
14205: LD_INT 1
14207: PPUSH
14208: LD_INT 1
14210: PPUSH
14211: LD_STRING 
14213: PPUSH
14214: LD_VAR 0 1
14218: PPUSH
14219: CALL 7857 0 5
14223: PUSH
14224: LD_INT 1
14226: ARRAY
14227: ST_TO_ADDR
// PlaceUnitXYR ( temp_unit , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] , 4 , false ) ;
14228: LD_VAR 0 6
14232: PPUSH
14233: LD_EXP 40
14237: PUSH
14238: LD_VAR 0 7
14242: ARRAY
14243: PUSH
14244: LD_INT 1
14246: ARRAY
14247: PPUSH
14248: LD_EXP 40
14252: PUSH
14253: LD_VAR 0 7
14257: ARRAY
14258: PUSH
14259: LD_INT 2
14261: ARRAY
14262: PPUSH
14263: LD_INT 4
14265: PPUSH
14266: LD_INT 0
14268: PPUSH
14269: CALL_OW 50
// DoNotAttack ( you , temp_unit ) ;
14273: LD_EXP 2
14277: PPUSH
14278: LD_VAR 0 6
14282: PPUSH
14283: CALL_OW 471
// temp_list_2 = ai_soldiers [ base ] ^ temp_unit ;
14287: LD_ADDR_VAR 0 9
14291: PUSH
14292: LD_EXP 26
14296: PUSH
14297: LD_VAR 0 7
14301: ARRAY
14302: PUSH
14303: LD_VAR 0 6
14307: ADD
14308: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , base , temp_list_2 ) ;
14309: LD_ADDR_EXP 26
14313: PUSH
14314: LD_EXP 26
14318: PPUSH
14319: LD_VAR 0 7
14323: PPUSH
14324: LD_VAR 0 9
14328: PPUSH
14329: CALL_OW 1
14333: ST_TO_ADDR
// temp_list = temp_list ^ temp_unit ;
14334: LD_ADDR_VAR 0 3
14338: PUSH
14339: LD_VAR 0 3
14343: PUSH
14344: LD_VAR 0 6
14348: ADD
14349: ST_TO_ADDR
// soldiers_list = soldiers_list ^ temp_unit ;
14350: LD_ADDR_VAR 0 5
14354: PUSH
14355: LD_VAR 0 5
14359: PUSH
14360: LD_VAR 0 6
14364: ADD
14365: ST_TO_ADDR
// end ;
14366: GO 14194
14368: POP
14369: POP
// for i = 1 to buildings_list do
14370: LD_ADDR_VAR 0 2
14374: PUSH
14375: DOUBLE
14376: LD_INT 1
14378: DEC
14379: ST_TO_ADDR
14380: LD_VAR 0 4
14384: PUSH
14385: FOR_TO
14386: IFFALSE 14470
// begin if temp_list = 0 then
14388: LD_VAR 0 3
14392: PUSH
14393: LD_INT 0
14395: EQUAL
14396: IFFALSE 14400
// break ;
14398: GO 14470
// temp_unit = temp_list [ 1 ] ;
14400: LD_ADDR_VAR 0 6
14404: PUSH
14405: LD_VAR 0 3
14409: PUSH
14410: LD_INT 1
14412: ARRAY
14413: ST_TO_ADDR
// ComEnterUnit ( temp_unit , buildings_list [ i ] ) ;
14414: LD_VAR 0 6
14418: PPUSH
14419: LD_VAR 0 4
14423: PUSH
14424: LD_VAR 0 2
14428: ARRAY
14429: PPUSH
14430: CALL_OW 120
// temp_list = Delete ( temp_list , 1 ) ;
14434: LD_ADDR_VAR 0 3
14438: PUSH
14439: LD_VAR 0 3
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: CALL_OW 3
14451: ST_TO_ADDR
// soldiers_list = soldiers_list diff temp_unit ;
14452: LD_ADDR_VAR 0 5
14456: PUSH
14457: LD_VAR 0 5
14461: PUSH
14462: LD_VAR 0 6
14466: DIFF
14467: ST_TO_ADDR
// end ;
14468: GO 14385
14470: POP
14471: POP
// end ; DistributeHumansToBuildings ( base , soldiers_list , UnitFilter ( ai_armouries [ base ] , [ [ f_ok ] , [ f_not , [ f_constructed ] ] ] ) , false , 6 , true , true ) ;
14472: LD_VAR 0 7
14476: PPUSH
14477: LD_VAR 0 5
14481: PPUSH
14482: LD_EXP 48
14486: PUSH
14487: LD_VAR 0 7
14491: ARRAY
14492: PPUSH
14493: LD_INT 50
14495: PUSH
14496: EMPTY
14497: LIST
14498: PUSH
14499: LD_INT 3
14501: PUSH
14502: LD_INT 57
14504: PUSH
14505: EMPTY
14506: LIST
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 72
14520: PPUSH
14521: LD_INT 0
14523: PPUSH
14524: LD_INT 6
14526: PPUSH
14527: LD_INT 1
14529: PPUSH
14530: LD_INT 1
14532: PPUSH
14533: CALL 18059 0 7
// end ;
14537: GO 11738
14539: POP
14540: POP
// enable ;
14541: ENABLE
// end ;
14542: PPOPN 15
14544: END
// function ControlCodeBlackUnits ( un_list ) ; var i , enemy_units , side , base , unit_building_tag , groups , temp_list , j , x , y , dir ; begin
14545: LD_INT 0
14547: PPUSH
14548: PPUSH
14549: PPUSH
14550: PPUSH
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
// side = russians ;
14559: LD_ADDR_VAR 0 5
14563: PUSH
14564: LD_EXP 3
14568: ST_TO_ADDR
// base = 1 ;
14569: LD_ADDR_VAR 0 6
14573: PUSH
14574: LD_INT 1
14576: ST_TO_ADDR
// unit_building_tag = [ ] ;
14577: LD_ADDR_VAR 0 7
14581: PUSH
14582: EMPTY
14583: ST_TO_ADDR
// enemy_units = [ ] ;
14584: LD_ADDR_VAR 0 4
14588: PUSH
14589: EMPTY
14590: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_enemy , side ] , [ f_type , unit_human ] , [ f_distxy , ai_buildings_locations [ base ] [ 1 ] [ 1 ] , ai_buildings_locations [ base ] [ 1 ] [ 2 ] , 50 ] ] ) do
14591: LD_ADDR_VAR 0 3
14595: PUSH
14596: LD_INT 81
14598: PUSH
14599: LD_VAR 0 5
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: PUSH
14608: LD_INT 21
14610: PUSH
14611: LD_INT 1
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PUSH
14618: LD_INT 92
14620: PUSH
14621: LD_EXP 36
14625: PUSH
14626: LD_VAR 0 6
14630: ARRAY
14631: PUSH
14632: LD_INT 1
14634: ARRAY
14635: PUSH
14636: LD_INT 1
14638: ARRAY
14639: PUSH
14640: LD_EXP 36
14644: PUSH
14645: LD_VAR 0 6
14649: ARRAY
14650: PUSH
14651: LD_INT 1
14653: ARRAY
14654: PUSH
14655: LD_INT 2
14657: ARRAY
14658: PUSH
14659: LD_INT 50
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: PUSH
14668: EMPTY
14669: LIST
14670: LIST
14671: LIST
14672: PPUSH
14673: CALL_OW 69
14677: PUSH
14678: FOR_IN
14679: IFFALSE 14750
// begin j = IsInUnit ( i ) ;
14681: LD_ADDR_VAR 0 10
14685: PUSH
14686: LD_VAR 0 3
14690: PPUSH
14691: CALL_OW 310
14695: ST_TO_ADDR
// if j = 0 then
14696: LD_VAR 0 10
14700: PUSH
14701: LD_INT 0
14703: EQUAL
14704: IFFALSE 14716
// j = i ;
14706: LD_ADDR_VAR 0 10
14710: PUSH
14711: LD_VAR 0 3
14715: ST_TO_ADDR
// if See ( side , j ) then
14716: LD_VAR 0 5
14720: PPUSH
14721: LD_VAR 0 10
14725: PPUSH
14726: CALL_OW 292
14730: IFFALSE 14748
// enemy_units = enemy_units ^ i ;
14732: LD_ADDR_VAR 0 4
14736: PUSH
14737: LD_VAR 0 4
14741: PUSH
14742: LD_VAR 0 3
14746: ADD
14747: ST_TO_ADDR
// end ;
14748: GO 14678
14750: POP
14751: POP
// for i in enemy_units do
14752: LD_ADDR_VAR 0 3
14756: PUSH
14757: LD_VAR 0 4
14761: PUSH
14762: FOR_IN
14763: IFFALSE 14790
// unit_building_tag = Replace ( unit_building_tag , i , 0 ) ;
14765: LD_ADDR_VAR 0 7
14769: PUSH
14770: LD_VAR 0 7
14774: PPUSH
14775: LD_VAR 0 3
14779: PPUSH
14780: LD_INT 0
14782: PPUSH
14783: CALL_OW 1
14787: ST_TO_ADDR
14788: GO 14762
14790: POP
14791: POP
// for i in player_units_in_russian_buildings do
14792: LD_ADDR_VAR 0 3
14796: PUSH
14797: LD_EXP 88
14801: PUSH
14802: FOR_IN
14803: IFFALSE 14860
// begin enemy_units = enemy_units ^ i [ 1 ] ;
14805: LD_ADDR_VAR 0 4
14809: PUSH
14810: LD_VAR 0 4
14814: PUSH
14815: LD_VAR 0 3
14819: PUSH
14820: LD_INT 1
14822: ARRAY
14823: ADD
14824: ST_TO_ADDR
// unit_building_tag = Replace ( unit_building_tag , i [ 1 ] , i [ 2 ] ) ;
14825: LD_ADDR_VAR 0 7
14829: PUSH
14830: LD_VAR 0 7
14834: PPUSH
14835: LD_VAR 0 3
14839: PUSH
14840: LD_INT 1
14842: ARRAY
14843: PPUSH
14844: LD_VAR 0 3
14848: PUSH
14849: LD_INT 2
14851: ARRAY
14852: PPUSH
14853: CALL_OW 1
14857: ST_TO_ADDR
// end ;
14858: GO 14802
14860: POP
14861: POP
// if heike_undercover = 2 then
14862: LD_EXP 83
14866: PUSH
14867: LD_INT 2
14869: EQUAL
14870: IFFALSE 14888
// enemy_units = enemy_units diff Heike ;
14872: LD_ADDR_VAR 0 4
14876: PUSH
14877: LD_VAR 0 4
14881: PUSH
14882: LD_EXP 7
14886: DIFF
14887: ST_TO_ADDR
// if enemy_units > 0 then
14888: LD_VAR 0 4
14892: PUSH
14893: LD_INT 0
14895: GREATER
14896: IFFALSE 14918
// enemy_units = SortListByListAsc ( enemy_units , enemy_units ) ;
14898: LD_ADDR_VAR 0 4
14902: PUSH
14903: LD_VAR 0 4
14907: PPUSH
14908: LD_VAR 0 4
14912: PPUSH
14913: CALL_OW 76
14917: ST_TO_ADDR
// if enemy_units = 0 then
14918: LD_VAR 0 4
14922: PUSH
14923: LD_INT 0
14925: EQUAL
14926: IFFALSE 15119
// begin enemy_units = FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_inarea , ru_base_area ] ] ) ;
14928: LD_ADDR_VAR 0 4
14932: PUSH
14933: LD_INT 22
14935: PUSH
14936: LD_EXP 2
14940: PUSH
14941: EMPTY
14942: LIST
14943: LIST
14944: PUSH
14945: LD_INT 21
14947: PUSH
14948: LD_INT 2
14950: PUSH
14951: EMPTY
14952: LIST
14953: LIST
14954: PUSH
14955: LD_INT 3
14957: PUSH
14958: LD_INT 34
14960: PUSH
14961: LD_INT 51
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: PUSH
14968: EMPTY
14969: LIST
14970: LIST
14971: PUSH
14972: LD_INT 95
14974: PUSH
14975: LD_INT 2
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: PUSH
14982: EMPTY
14983: LIST
14984: LIST
14985: LIST
14986: LIST
14987: PPUSH
14988: CALL_OW 69
14992: ST_TO_ADDR
// if enemy_units > 0 then
14993: LD_VAR 0 4
14997: PUSH
14998: LD_INT 0
15000: GREATER
15001: IFFALSE 15040
// begin for i in un_list do
15003: LD_ADDR_VAR 0 3
15007: PUSH
15008: LD_VAR 0 1
15012: PUSH
15013: FOR_IN
15014: IFFALSE 15036
// ComAttackUnit ( i , enemy_units [ 1 ] ) ;
15016: LD_VAR 0 3
15020: PPUSH
15021: LD_VAR 0 4
15025: PUSH
15026: LD_INT 1
15028: ARRAY
15029: PPUSH
15030: CALL_OW 115
15034: GO 15013
15036: POP
15037: POP
// end else
15038: GO 15117
// for i in un_list do
15040: LD_ADDR_VAR 0 3
15044: PUSH
15045: LD_VAR 0 1
15049: PUSH
15050: FOR_IN
15051: IFFALSE 15115
// if GetDistUnitXY ( i , last_known_enemy_hex [ 1 ] , last_known_enemy_hex [ 2 ] ) > 6 then
15053: LD_VAR 0 3
15057: PPUSH
15058: LD_EXP 122
15062: PUSH
15063: LD_INT 1
15065: ARRAY
15066: PPUSH
15067: LD_EXP 122
15071: PUSH
15072: LD_INT 2
15074: ARRAY
15075: PPUSH
15076: CALL_OW 297
15080: PUSH
15081: LD_INT 6
15083: GREATER
15084: IFFALSE 15113
// ComAgressiveMove ( i , last_known_enemy_hex [ 1 ] , last_known_enemy_hex [ 2 ] ) ;
15086: LD_VAR 0 3
15090: PPUSH
15091: LD_EXP 122
15095: PUSH
15096: LD_INT 1
15098: ARRAY
15099: PPUSH
15100: LD_EXP 122
15104: PUSH
15105: LD_INT 2
15107: ARRAY
15108: PPUSH
15109: CALL_OW 114
15113: GO 15050
15115: POP
15116: POP
// end else
15117: GO 15619
// begin last_known_enemy_hex = [ GetX ( enemy_units [ 1 ] ) , GetY ( enemy_units [ 1 ] ) ] ;
15119: LD_ADDR_EXP 122
15123: PUSH
15124: LD_VAR 0 4
15128: PUSH
15129: LD_INT 1
15131: ARRAY
15132: PPUSH
15133: CALL_OW 250
15137: PUSH
15138: LD_VAR 0 4
15142: PUSH
15143: LD_INT 1
15145: ARRAY
15146: PPUSH
15147: CALL_OW 251
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: ST_TO_ADDR
// groups = [ ] ;
15156: LD_ADDR_VAR 0 8
15160: PUSH
15161: EMPTY
15162: ST_TO_ADDR
// i = enemy_units + 0 ;
15163: LD_ADDR_VAR 0 3
15167: PUSH
15168: LD_VAR 0 4
15172: PUSH
15173: LD_INT 0
15175: PLUS
15176: ST_TO_ADDR
// while i > 0 do
15177: LD_VAR 0 3
15181: PUSH
15182: LD_INT 0
15184: GREATER
15185: IFFALSE 15295
// begin temp_list = [ ] ;
15187: LD_ADDR_VAR 0 9
15191: PUSH
15192: EMPTY
15193: ST_TO_ADDR
// for j = 1 to un_list div i do
15194: LD_ADDR_VAR 0 10
15198: PUSH
15199: DOUBLE
15200: LD_INT 1
15202: DEC
15203: ST_TO_ADDR
15204: LD_VAR 0 1
15208: PUSH
15209: LD_VAR 0 3
15213: DIV
15214: PUSH
15215: FOR_TO
15216: IFFALSE 15242
// temp_list = temp_list ^ un_list [ j ] ;
15218: LD_ADDR_VAR 0 9
15222: PUSH
15223: LD_VAR 0 9
15227: PUSH
15228: LD_VAR 0 1
15232: PUSH
15233: LD_VAR 0 10
15237: ARRAY
15238: ADD
15239: ST_TO_ADDR
15240: GO 15215
15242: POP
15243: POP
// un_list = un_list diff temp_list ;
15244: LD_ADDR_VAR 0 1
15248: PUSH
15249: LD_VAR 0 1
15253: PUSH
15254: LD_VAR 0 9
15258: DIFF
15259: ST_TO_ADDR
// groups = groups ^ [ temp_list ] ;
15260: LD_ADDR_VAR 0 8
15264: PUSH
15265: LD_VAR 0 8
15269: PUSH
15270: LD_VAR 0 9
15274: PUSH
15275: EMPTY
15276: LIST
15277: ADD
15278: ST_TO_ADDR
// i = i - 1 ;
15279: LD_ADDR_VAR 0 3
15283: PUSH
15284: LD_VAR 0 3
15288: PUSH
15289: LD_INT 1
15291: MINUS
15292: ST_TO_ADDR
// end ;
15293: GO 15177
// for i = 1 to enemy_units do
15295: LD_ADDR_VAR 0 3
15299: PUSH
15300: DOUBLE
15301: LD_INT 1
15303: DEC
15304: ST_TO_ADDR
15305: LD_VAR 0 4
15309: PUSH
15310: FOR_TO
15311: IFFALSE 15617
// begin if unit_building_tag [ enemy_units [ i ] ] = 0 then
15313: LD_VAR 0 7
15317: PUSH
15318: LD_VAR 0 4
15322: PUSH
15323: LD_VAR 0 3
15327: ARRAY
15328: ARRAY
15329: PUSH
15330: LD_INT 0
15332: EQUAL
15333: IFFALSE 15421
// begin x = GetX ( enemy_units [ i ] ) ;
15335: LD_ADDR_VAR 0 11
15339: PUSH
15340: LD_VAR 0 4
15344: PUSH
15345: LD_VAR 0 3
15349: ARRAY
15350: PPUSH
15351: CALL_OW 250
15355: ST_TO_ADDR
// y = GetY ( enemy_units [ i ] ) ;
15356: LD_ADDR_VAR 0 12
15360: PUSH
15361: LD_VAR 0 4
15365: PUSH
15366: LD_VAR 0 3
15370: ARRAY
15371: PPUSH
15372: CALL_OW 251
15376: ST_TO_ADDR
// for j in groups [ i ] do
15377: LD_ADDR_VAR 0 10
15381: PUSH
15382: LD_VAR 0 8
15386: PUSH
15387: LD_VAR 0 3
15391: ARRAY
15392: PUSH
15393: FOR_IN
15394: IFFALSE 15417
// ComAgressiveMove ( j , x , y ) ;
15396: LD_VAR 0 10
15400: PPUSH
15401: LD_VAR 0 11
15405: PPUSH
15406: LD_VAR 0 12
15410: PPUSH
15411: CALL_OW 114
15415: GO 15393
15417: POP
15418: POP
// end else
15419: GO 15615
// begin x = GetX ( unit_building_tag [ enemy_units [ i ] ] ) ;
15421: LD_ADDR_VAR 0 11
15425: PUSH
15426: LD_VAR 0 7
15430: PUSH
15431: LD_VAR 0 4
15435: PUSH
15436: LD_VAR 0 3
15440: ARRAY
15441: ARRAY
15442: PPUSH
15443: CALL_OW 250
15447: ST_TO_ADDR
// y = GetY ( unit_building_tag [ enemy_units [ i ] ] ) ;
15448: LD_ADDR_VAR 0 12
15452: PUSH
15453: LD_VAR 0 7
15457: PUSH
15458: LD_VAR 0 4
15462: PUSH
15463: LD_VAR 0 3
15467: ARRAY
15468: ARRAY
15469: PPUSH
15470: CALL_OW 251
15474: ST_TO_ADDR
// dir = GetDir ( unit_building_tag [ enemy_units [ i ] ] ) ;
15475: LD_ADDR_VAR 0 13
15479: PUSH
15480: LD_VAR 0 7
15484: PUSH
15485: LD_VAR 0 4
15489: PUSH
15490: LD_VAR 0 3
15494: ARRAY
15495: ARRAY
15496: PPUSH
15497: CALL_OW 254
15501: ST_TO_ADDR
// x = ShiftX ( x , dir , 4 ) ;
15502: LD_ADDR_VAR 0 11
15506: PUSH
15507: LD_VAR 0 11
15511: PPUSH
15512: LD_VAR 0 13
15516: PPUSH
15517: LD_INT 4
15519: PPUSH
15520: CALL_OW 272
15524: ST_TO_ADDR
// y = ShiftY ( y , dir , 4 ) ;
15525: LD_ADDR_VAR 0 12
15529: PUSH
15530: LD_VAR 0 12
15534: PPUSH
15535: LD_VAR 0 13
15539: PPUSH
15540: LD_INT 4
15542: PPUSH
15543: CALL_OW 273
15547: ST_TO_ADDR
// for j in groups [ i ] do
15548: LD_ADDR_VAR 0 10
15552: PUSH
15553: LD_VAR 0 8
15557: PUSH
15558: LD_VAR 0 3
15562: ARRAY
15563: PUSH
15564: FOR_IN
15565: IFFALSE 15613
// if GetDistUnitXY ( j , x , y ) > 4 then
15567: LD_VAR 0 10
15571: PPUSH
15572: LD_VAR 0 11
15576: PPUSH
15577: LD_VAR 0 12
15581: PPUSH
15582: CALL_OW 297
15586: PUSH
15587: LD_INT 4
15589: GREATER
15590: IFFALSE 15611
// ComAgressiveMove ( j , x , y ) ;
15592: LD_VAR 0 10
15596: PPUSH
15597: LD_VAR 0 11
15601: PPUSH
15602: LD_VAR 0 12
15606: PPUSH
15607: CALL_OW 114
15611: GO 15564
15613: POP
15614: POP
// end ; end ;
15615: GO 15310
15617: POP
15618: POP
// end ; end ;
15619: LD_VAR 0 2
15623: RET
// every 0 0$1 + 0 0$0.1 do var path , north , east , south , val , temp_list , temp_list_2 , where_are_we_now_index , break_start_tick , break_started ;
15624: GO 15626
15626: DISABLE
15627: LD_INT 0
15629: PPUSH
15630: PPUSH
15631: PPUSH
15632: PPUSH
15633: PPUSH
15634: PPUSH
15635: PPUSH
15636: PPUSH
15637: PPUSH
15638: PPUSH
// begin path = [ ] ;
15639: LD_ADDR_VAR 0 1
15643: PUSH
15644: EMPTY
15645: ST_TO_ADDR
// north = [ 48 , 10 ] ;
15646: LD_ADDR_VAR 0 2
15650: PUSH
15651: LD_INT 48
15653: PUSH
15654: LD_INT 10
15656: PUSH
15657: EMPTY
15658: LIST
15659: LIST
15660: ST_TO_ADDR
// east = [ 90 , 30 ] ;
15661: LD_ADDR_VAR 0 3
15665: PUSH
15666: LD_INT 90
15668: PUSH
15669: LD_INT 30
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: ST_TO_ADDR
// south = [ 69 , 58 ] ;
15676: LD_ADDR_VAR 0 4
15680: PUSH
15681: LD_INT 69
15683: PUSH
15684: LD_INT 58
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: ST_TO_ADDR
// temp_list = [ 1 , 2 , 3 ] ;
15691: LD_ADDR_VAR 0 6
15695: PUSH
15696: LD_INT 1
15698: PUSH
15699: LD_INT 2
15701: PUSH
15702: LD_INT 3
15704: PUSH
15705: EMPTY
15706: LIST
15707: LIST
15708: LIST
15709: ST_TO_ADDR
// while temp_list > 0 do
15710: LD_VAR 0 6
15714: PUSH
15715: LD_INT 0
15717: GREATER
15718: IFFALSE 15891
// begin temp_list_2 = temp_list ;
15720: LD_ADDR_VAR 0 7
15724: PUSH
15725: LD_VAR 0 6
15729: ST_TO_ADDR
// val = temp_list_2 [ Rand ( 1 , temp_list_2 ) ] ;
15730: LD_ADDR_VAR 0 5
15734: PUSH
15735: LD_VAR 0 7
15739: PUSH
15740: LD_INT 1
15742: PPUSH
15743: LD_VAR 0 7
15747: PPUSH
15748: CALL_OW 12
15752: ARRAY
15753: ST_TO_ADDR
// temp_list = temp_list diff val ;
15754: LD_ADDR_VAR 0 6
15758: PUSH
15759: LD_VAR 0 6
15763: PUSH
15764: LD_VAR 0 5
15768: DIFF
15769: ST_TO_ADDR
// case val of 1 :
15770: LD_VAR 0 5
15774: PUSH
15775: LD_INT 1
15777: DOUBLE
15778: EQUAL
15779: IFTRUE 15783
15781: GO 15805
15783: POP
// path = path ^ [ north ] ; 2 :
15784: LD_ADDR_VAR 0 1
15788: PUSH
15789: LD_VAR 0 1
15793: PUSH
15794: LD_VAR 0 2
15798: PUSH
15799: EMPTY
15800: LIST
15801: ADD
15802: ST_TO_ADDR
15803: GO 15866
15805: LD_INT 2
15807: DOUBLE
15808: EQUAL
15809: IFTRUE 15813
15811: GO 15835
15813: POP
// path = path ^ [ east ] ; 3 :
15814: LD_ADDR_VAR 0 1
15818: PUSH
15819: LD_VAR 0 1
15823: PUSH
15824: LD_VAR 0 3
15828: PUSH
15829: EMPTY
15830: LIST
15831: ADD
15832: ST_TO_ADDR
15833: GO 15866
15835: LD_INT 3
15837: DOUBLE
15838: EQUAL
15839: IFTRUE 15843
15841: GO 15865
15843: POP
// path = path ^ [ south ] ; end ;
15844: LD_ADDR_VAR 0 1
15848: PUSH
15849: LD_VAR 0 1
15853: PUSH
15854: LD_VAR 0 4
15858: PUSH
15859: EMPTY
15860: LIST
15861: ADD
15862: ST_TO_ADDR
15863: GO 15866
15865: POP
// path = path ^ [ ai_human_pullback_hex [ 1 ] ] ;
15866: LD_ADDR_VAR 0 1
15870: PUSH
15871: LD_VAR 0 1
15875: PUSH
15876: LD_EXP 40
15880: PUSH
15881: LD_INT 1
15883: ARRAY
15884: PUSH
15885: EMPTY
15886: LIST
15887: ADD
15888: ST_TO_ADDR
// end ;
15889: GO 15710
// where_are_we_now_index = 1 ;
15891: LD_ADDR_VAR 0 8
15895: PUSH
15896: LD_INT 1
15898: ST_TO_ADDR
// break_started = false ;
15899: LD_ADDR_VAR 0 10
15903: PUSH
15904: LD_INT 0
15906: ST_TO_ADDR
// break_start_tick = 0 ;
15907: LD_ADDR_VAR 0 9
15911: PUSH
15912: LD_INT 0
15914: ST_TO_ADDR
// repeat wait ( 0 0$0.5 ) ;
15915: LD_INT 18
15917: PPUSH
15918: CALL_OW 67
// if terminate_internal_patrol then
15922: LD_EXP 82
15926: IFFALSE 15930
// exit ;
15928: GO 16314
// if code_black or halt_internal_patrol > 0 then
15930: LD_EXP 77
15934: PUSH
15935: LD_EXP 81
15939: PUSH
15940: LD_INT 0
15942: GREATER
15943: OR
15944: IFFALSE 15948
// continue ;
15946: GO 15915
// if break_started then
15948: LD_VAR 0 10
15952: IFFALSE 16041
// begin if tick - break_start_tick >= [ 0 0$15 , 0 0$10 , 0 0$5 ] [ difficulty ] then
15954: LD_OWVAR 1
15958: PUSH
15959: LD_VAR 0 9
15963: MINUS
15964: PUSH
15965: LD_INT 525
15967: PUSH
15968: LD_INT 350
15970: PUSH
15971: LD_INT 175
15973: PUSH
15974: EMPTY
15975: LIST
15976: LIST
15977: LIST
15978: PUSH
15979: LD_OWVAR 67
15983: ARRAY
15984: GREATEREQUAL
15985: IFFALSE 16011
// begin break_started = false ;
15987: LD_ADDR_VAR 0 10
15991: PUSH
15992: LD_INT 0
15994: ST_TO_ADDR
// where_are_we_now_index = where_are_we_now_index + 1 ;
15995: LD_ADDR_VAR 0 8
15999: PUSH
16000: LD_VAR 0 8
16004: PUSH
16005: LD_INT 1
16007: PLUS
16008: ST_TO_ADDR
// end else
16009: GO 16039
// begin ComTurnUnit ( good_pat , bad_pat ) ;
16011: LD_EXP 18
16015: PPUSH
16016: LD_EXP 19
16020: PPUSH
16021: CALL_OW 119
// ComTurnUnit ( bad_pat , good_pat ) ;
16025: LD_EXP 19
16029: PPUSH
16030: LD_EXP 18
16034: PPUSH
16035: CALL_OW 119
// end ; end else
16039: GO 16310
// begin if GetDistUnitXY ( bad_pat , path [ where_are_we_now_index ] [ 1 ] , path [ where_are_we_now_index ] [ 2 ] ) <= 2 then
16041: LD_EXP 19
16045: PPUSH
16046: LD_VAR 0 1
16050: PUSH
16051: LD_VAR 0 8
16055: ARRAY
16056: PUSH
16057: LD_INT 1
16059: ARRAY
16060: PPUSH
16061: LD_VAR 0 1
16065: PUSH
16066: LD_VAR 0 8
16070: ARRAY
16071: PUSH
16072: LD_INT 2
16074: ARRAY
16075: PPUSH
16076: CALL_OW 297
16080: PUSH
16081: LD_INT 2
16083: LESSEQUAL
16084: IFFALSE 16156
// begin if where_are_we_now_index mod 2 = 0 then
16086: LD_VAR 0 8
16090: PUSH
16091: LD_INT 2
16093: MOD
16094: PUSH
16095: LD_INT 0
16097: EQUAL
16098: IFFALSE 16136
// begin where_are_we_now_index = where_are_we_now_index + 1 ;
16100: LD_ADDR_VAR 0 8
16104: PUSH
16105: LD_VAR 0 8
16109: PUSH
16110: LD_INT 1
16112: PLUS
16113: ST_TO_ADDR
// if where_are_we_now_index > path then
16114: LD_VAR 0 8
16118: PUSH
16119: LD_VAR 0 1
16123: GREATER
16124: IFFALSE 16134
// where_are_we_now_index = 1 ;
16126: LD_ADDR_VAR 0 8
16130: PUSH
16131: LD_INT 1
16133: ST_TO_ADDR
// end else
16134: GO 16154
// begin break_started = true ;
16136: LD_ADDR_VAR 0 10
16140: PUSH
16141: LD_INT 1
16143: ST_TO_ADDR
// break_start_tick = tick ;
16144: LD_ADDR_VAR 0 9
16148: PUSH
16149: LD_OWVAR 1
16153: ST_TO_ADDR
// end ; end else
16154: GO 16310
// begin if GetDistUnits ( good_pat , bad_pat ) > 3 then
16156: LD_EXP 18
16160: PPUSH
16161: LD_EXP 19
16165: PPUSH
16166: CALL_OW 296
16170: PUSH
16171: LD_INT 3
16173: GREATER
16174: IFFALSE 16262
// begin val = AI_InvertDirection ( GetDir ( bad_pat ) ) ;
16176: LD_ADDR_VAR 0 5
16180: PUSH
16181: LD_EXP 19
16185: PPUSH
16186: CALL_OW 254
16190: PPUSH
16191: CALL 34263 0 1
16195: ST_TO_ADDR
// ComMoveXY ( good_pat , ShiftX ( GetX ( bad_pat ) , val , 1 ) , ShiftY ( GetY ( bad_pat ) , val , 1 ) ) ;
16196: LD_EXP 18
16200: PPUSH
16201: LD_EXP 19
16205: PPUSH
16206: CALL_OW 250
16210: PPUSH
16211: LD_VAR 0 5
16215: PPUSH
16216: LD_INT 1
16218: PPUSH
16219: CALL_OW 272
16223: PPUSH
16224: LD_EXP 19
16228: PPUSH
16229: CALL_OW 251
16233: PPUSH
16234: LD_VAR 0 5
16238: PPUSH
16239: LD_INT 1
16241: PPUSH
16242: CALL_OW 273
16246: PPUSH
16247: CALL_OW 111
// ComHold ( bad_pat ) ;
16251: LD_EXP 19
16255: PPUSH
16256: CALL_OW 140
// end else
16260: GO 16310
// ComAgressiveMove ( [ good_pat , bad_pat ] , path [ where_are_we_now_index ] [ 1 ] , path [ where_are_we_now_index ] [ 2 ] ) ;
16262: LD_EXP 18
16266: PUSH
16267: LD_EXP 19
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PPUSH
16276: LD_VAR 0 1
16280: PUSH
16281: LD_VAR 0 8
16285: ARRAY
16286: PUSH
16287: LD_INT 1
16289: ARRAY
16290: PPUSH
16291: LD_VAR 0 1
16295: PUSH
16296: LD_VAR 0 8
16300: ARRAY
16301: PUSH
16302: LD_INT 2
16304: ARRAY
16305: PPUSH
16306: CALL_OW 114
// end ; end ; until false ;
16310: LD_INT 0
16312: IFFALSE 15915
// end ;
16314: PPOPN 10
16316: END
// export function CreatePatrolPath ( reverse ) ; var possible_subpaths , subpaths_allowed , the_path , i , temp_list ; begin
16317: LD_INT 0
16319: PPUSH
16320: PPUSH
16321: PPUSH
16322: PPUSH
16323: PPUSH
16324: PPUSH
// the_path = [ ] ;
16325: LD_ADDR_VAR 0 5
16329: PUSH
16330: EMPTY
16331: ST_TO_ADDR
// subpaths_allowed = [ 1000 ] ;
16332: LD_ADDR_VAR 0 4
16336: PUSH
16337: LD_INT 1000
16339: PUSH
16340: EMPTY
16341: LIST
16342: ST_TO_ADDR
// while subpaths_allowed > 0 do
16343: LD_VAR 0 4
16347: PUSH
16348: LD_INT 0
16350: GREATER
16351: IFFALSE 16518
// begin possible_subpaths = [ ] ;
16353: LD_ADDR_VAR 0 3
16357: PUSH
16358: EMPTY
16359: ST_TO_ADDR
// for i in patrols_subpaths do
16360: LD_ADDR_VAR 0 6
16364: PUSH
16365: LD_EXP 80
16369: PUSH
16370: FOR_IN
16371: IFFALSE 16410
// if i [ 1 ] in subpaths_allowed then
16373: LD_VAR 0 6
16377: PUSH
16378: LD_INT 1
16380: ARRAY
16381: PUSH
16382: LD_VAR 0 4
16386: IN
16387: IFFALSE 16408
// possible_subpaths = possible_subpaths ^ [ i ] ;
16389: LD_ADDR_VAR 0 3
16393: PUSH
16394: LD_VAR 0 3
16398: PUSH
16399: LD_VAR 0 6
16403: PUSH
16404: EMPTY
16405: LIST
16406: ADD
16407: ST_TO_ADDR
16408: GO 16370
16410: POP
16411: POP
// if possible_subpaths = 0 then
16412: LD_VAR 0 3
16416: PUSH
16417: LD_INT 0
16419: EQUAL
16420: IFFALSE 16426
// break else
16422: GO 16518
16424: GO 16516
// begin temp_list = possible_subpaths [ Rand ( 1 , possible_subpaths ) ] ;
16426: LD_ADDR_VAR 0 7
16430: PUSH
16431: LD_VAR 0 3
16435: PUSH
16436: LD_INT 1
16438: PPUSH
16439: LD_VAR 0 3
16443: PPUSH
16444: CALL_OW 12
16448: ARRAY
16449: ST_TO_ADDR
// temp_list = Delete ( temp_list , 1 ) ;
16450: LD_ADDR_VAR 0 7
16454: PUSH
16455: LD_VAR 0 7
16459: PPUSH
16460: LD_INT 1
16462: PPUSH
16463: CALL_OW 3
16467: ST_TO_ADDR
// subpaths_allowed = temp_list [ 1 ] ;
16468: LD_ADDR_VAR 0 4
16472: PUSH
16473: LD_VAR 0 7
16477: PUSH
16478: LD_INT 1
16480: ARRAY
16481: ST_TO_ADDR
// temp_list = Delete ( temp_list , 1 ) ;
16482: LD_ADDR_VAR 0 7
16486: PUSH
16487: LD_VAR 0 7
16491: PPUSH
16492: LD_INT 1
16494: PPUSH
16495: CALL_OW 3
16499: ST_TO_ADDR
// the_path = the_path ^ temp_list ;
16500: LD_ADDR_VAR 0 5
16504: PUSH
16505: LD_VAR 0 5
16509: PUSH
16510: LD_VAR 0 7
16514: ADD
16515: ST_TO_ADDR
// end ; end ;
16516: GO 16343
// if reverse then
16518: LD_VAR 0 1
16522: IFFALSE 16592
// begin temp_list = [ ] ;
16524: LD_ADDR_VAR 0 7
16528: PUSH
16529: EMPTY
16530: ST_TO_ADDR
// for i = the_path + 0 downto 1 do
16531: LD_ADDR_VAR 0 6
16535: PUSH
16536: DOUBLE
16537: LD_VAR 0 5
16541: PUSH
16542: LD_INT 0
16544: PLUS
16545: INC
16546: ST_TO_ADDR
16547: LD_INT 1
16549: PUSH
16550: FOR_DOWNTO
16551: IFFALSE 16580
// temp_list = temp_list ^ [ the_path [ i ] ] ;
16553: LD_ADDR_VAR 0 7
16557: PUSH
16558: LD_VAR 0 7
16562: PUSH
16563: LD_VAR 0 5
16567: PUSH
16568: LD_VAR 0 6
16572: ARRAY
16573: PUSH
16574: EMPTY
16575: LIST
16576: ADD
16577: ST_TO_ADDR
16578: GO 16550
16580: POP
16581: POP
// the_path = temp_list ;
16582: LD_ADDR_VAR 0 5
16586: PUSH
16587: LD_VAR 0 7
16591: ST_TO_ADDR
// end ; result = the_path ;
16592: LD_ADDR_VAR 0 2
16596: PUSH
16597: LD_VAR 0 5
16601: ST_TO_ADDR
// end ;
16602: LD_VAR 0 2
16606: RET
// every 0 0$1 + 0 0$0.8 do var side , i , temp_value , base , temp_list , attack_hexes , temp_unit , temp_list_2 , k , turn , attacking_units ; var center_hex , center_dist , attacking_scientists , attacking_soldiers , area , x , y ; var p , min_dist ;
16607: GO 16609
16609: DISABLE
16610: LD_INT 0
16612: PPUSH
16613: PPUSH
16614: PPUSH
16615: PPUSH
16616: PPUSH
16617: PPUSH
16618: PPUSH
16619: PPUSH
16620: PPUSH
16621: PPUSH
16622: PPUSH
16623: PPUSH
16624: PPUSH
16625: PPUSH
16626: PPUSH
16627: PPUSH
16628: PPUSH
16629: PPUSH
16630: PPUSH
16631: PPUSH
// begin side = russians ;
16632: LD_ADDR_VAR 0 1
16636: PUSH
16637: LD_EXP 3
16641: ST_TO_ADDR
// min_dist = 3 ;
16642: LD_ADDR_VAR 0 20
16646: PUSH
16647: LD_INT 3
16649: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
16650: LD_INT 35
16652: PPUSH
16653: CALL_OW 67
// for base in ai_bases do
16657: LD_ADDR_VAR 0 4
16661: PUSH
16662: LD_EXP 57
16666: PUSH
16667: FOR_IN
16668: IFFALSE 18050
// begin for p = 1 to patrols do
16670: LD_ADDR_VAR 0 19
16674: PUSH
16675: DOUBLE
16676: LD_INT 1
16678: DEC
16679: ST_TO_ADDR
16680: LD_EXP 78
16684: PUSH
16685: FOR_TO
16686: IFFALSE 18046
// begin temp_list = UnitFilter ( patrols [ p ] , [ f_alive ] ) ;
16688: LD_ADDR_VAR 0 5
16692: PUSH
16693: LD_EXP 78
16697: PUSH
16698: LD_VAR 0 19
16702: ARRAY
16703: PPUSH
16704: LD_INT 51
16706: PUSH
16707: EMPTY
16708: LIST
16709: PPUSH
16710: CALL_OW 72
16714: ST_TO_ADDR
// patrols = Replace ( patrols , p , temp_list ) ;
16715: LD_ADDR_EXP 78
16719: PUSH
16720: LD_EXP 78
16724: PPUSH
16725: LD_VAR 0 19
16729: PPUSH
16730: LD_VAR 0 5
16734: PPUSH
16735: CALL_OW 1
16739: ST_TO_ADDR
// if patrols [ p ] = 0 then
16740: LD_EXP 78
16744: PUSH
16745: LD_VAR 0 19
16749: ARRAY
16750: PUSH
16751: LD_INT 0
16753: EQUAL
16754: IFFALSE 16803
// begin patrols_path = Replace ( patrols_path , p , [ ] ) ;
16756: LD_ADDR_EXP 79
16760: PUSH
16761: LD_EXP 79
16765: PPUSH
16766: LD_VAR 0 19
16770: PPUSH
16771: EMPTY
16772: PPUSH
16773: CALL_OW 1
16777: ST_TO_ADDR
// patrols_path_hex_index = Replace ( patrols_path_hex_index , p , 1 ) ;
16778: LD_ADDR_EXP 87
16782: PUSH
16783: LD_EXP 87
16787: PPUSH
16788: LD_VAR 0 19
16792: PPUSH
16793: LD_INT 1
16795: PPUSH
16796: CALL_OW 1
16800: ST_TO_ADDR
// continue ;
16801: GO 16685
// end ; attacking_soldiers = [ ] ;
16803: LD_ADDR_VAR 0 15
16807: PUSH
16808: EMPTY
16809: ST_TO_ADDR
// attacking_scientists = [ ] ;
16810: LD_ADDR_VAR 0 14
16814: PUSH
16815: EMPTY
16816: ST_TO_ADDR
// for i in patrols [ p ] do
16817: LD_ADDR_VAR 0 2
16821: PUSH
16822: LD_EXP 78
16826: PUSH
16827: LD_VAR 0 19
16831: ARRAY
16832: PUSH
16833: FOR_IN
16834: IFFALSE 16887
// if GetClass ( i ) = class_scientistic then
16836: LD_VAR 0 2
16840: PPUSH
16841: CALL_OW 257
16845: PUSH
16846: LD_INT 4
16848: EQUAL
16849: IFFALSE 16869
// attacking_scientists = attacking_scientists ^ i else
16851: LD_ADDR_VAR 0 14
16855: PUSH
16856: LD_VAR 0 14
16860: PUSH
16861: LD_VAR 0 2
16865: ADD
16866: ST_TO_ADDR
16867: GO 16885
// attacking_soldiers = attacking_soldiers ^ i ;
16869: LD_ADDR_VAR 0 15
16873: PUSH
16874: LD_VAR 0 15
16878: PUSH
16879: LD_VAR 0 2
16883: ADD
16884: ST_TO_ADDR
16885: GO 16833
16887: POP
16888: POP
// temp_list = GetHumansOutOfUnits ( attacking_soldiers ) ;
16889: LD_ADDR_VAR 0 5
16893: PUSH
16894: LD_VAR 0 15
16898: PPUSH
16899: CALL 23354 0 1
16903: ST_TO_ADDR
// if temp_list < attacking_soldiers then
16904: LD_VAR 0 5
16908: PUSH
16909: LD_VAR 0 15
16913: LESS
16914: IFFALSE 16918
// continue ;
16916: GO 16685
// temp_list = GetHumansOutOfUnits ( attacking_scientists ) ;
16918: LD_ADDR_VAR 0 5
16922: PUSH
16923: LD_VAR 0 14
16927: PPUSH
16928: CALL 23354 0 1
16932: ST_TO_ADDR
// if temp_list < attacking_scientists then
16933: LD_VAR 0 5
16937: PUSH
16938: LD_VAR 0 14
16942: LESS
16943: IFFALSE 16947
// continue ;
16945: GO 16685
// if attacking_scientists > 0 then
16947: LD_VAR 0 14
16951: PUSH
16952: LD_INT 0
16954: GREATER
16955: IFFALSE 17369
// if attacking_soldiers = 0 then
16957: LD_VAR 0 15
16961: PUSH
16962: LD_INT 0
16964: EQUAL
16965: IFFALSE 17127
// begin for i in attacking_scientists do
16967: LD_ADDR_VAR 0 2
16971: PUSH
16972: LD_VAR 0 14
16976: PUSH
16977: FOR_IN
16978: IFFALSE 17123
// if IsInArea ( i , ru_base_area ) then
16980: LD_VAR 0 2
16984: PPUSH
16985: LD_INT 2
16987: PPUSH
16988: CALL_OW 308
16992: IFFALSE 17086
// begin temp_list = patrols [ p ] diff i ;
16994: LD_ADDR_VAR 0 5
16998: PUSH
16999: LD_EXP 78
17003: PUSH
17004: LD_VAR 0 19
17008: ARRAY
17009: PUSH
17010: LD_VAR 0 2
17014: DIFF
17015: ST_TO_ADDR
// patrols = Replace ( patrols , p , temp_list ) ;
17016: LD_ADDR_EXP 78
17020: PUSH
17021: LD_EXP 78
17025: PPUSH
17026: LD_VAR 0 19
17030: PPUSH
17031: LD_VAR 0 5
17035: PPUSH
17036: CALL_OW 1
17040: ST_TO_ADDR
// temp_list = ai_scientists [ 1 ] ^ i ;
17041: LD_ADDR_VAR 0 5
17045: PUSH
17046: LD_EXP 30
17050: PUSH
17051: LD_INT 1
17053: ARRAY
17054: PUSH
17055: LD_VAR 0 2
17059: ADD
17060: ST_TO_ADDR
// ai_scientists = Replace ( ai_scientists , 1 , temp_list ) ;
17061: LD_ADDR_EXP 30
17065: PUSH
17066: LD_EXP 30
17070: PPUSH
17071: LD_INT 1
17073: PPUSH
17074: LD_VAR 0 5
17078: PPUSH
17079: CALL_OW 1
17083: ST_TO_ADDR
// end else
17084: GO 17121
// ComMoveXY ( i , ai_human_pullback_hex [ 1 ] [ 1 ] , ai_human_pullback_hex [ 1 ] [ 2 ] ) ;
17086: LD_VAR 0 2
17090: PPUSH
17091: LD_EXP 40
17095: PUSH
17096: LD_INT 1
17098: ARRAY
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: PPUSH
17104: LD_EXP 40
17108: PUSH
17109: LD_INT 1
17111: ARRAY
17112: PUSH
17113: LD_INT 2
17115: ARRAY
17116: PPUSH
17117: CALL_OW 111
17121: GO 16977
17123: POP
17124: POP
// end else
17125: GO 17369
// begin x = 0 ;
17127: LD_ADDR_VAR 0 17
17131: PUSH
17132: LD_INT 0
17134: ST_TO_ADDR
// y = 0 ;
17135: LD_ADDR_VAR 0 18
17139: PUSH
17140: LD_INT 0
17142: ST_TO_ADDR
// for i in attacking_soldiers do
17143: LD_ADDR_VAR 0 2
17147: PUSH
17148: LD_VAR 0 15
17152: PUSH
17153: FOR_IN
17154: IFFALSE 17200
// begin x = x + GetX ( i ) ;
17156: LD_ADDR_VAR 0 17
17160: PUSH
17161: LD_VAR 0 17
17165: PUSH
17166: LD_VAR 0 2
17170: PPUSH
17171: CALL_OW 250
17175: PLUS
17176: ST_TO_ADDR
// y = y + GetY ( i ) ;
17177: LD_ADDR_VAR 0 18
17181: PUSH
17182: LD_VAR 0 18
17186: PUSH
17187: LD_VAR 0 2
17191: PPUSH
17192: CALL_OW 251
17196: PLUS
17197: ST_TO_ADDR
// end ;
17198: GO 17153
17200: POP
17201: POP
// x = x div attacking_soldiers ;
17202: LD_ADDR_VAR 0 17
17206: PUSH
17207: LD_VAR 0 17
17211: PUSH
17212: LD_VAR 0 15
17216: DIV
17217: ST_TO_ADDR
// y = y div attacking_soldiers ;
17218: LD_ADDR_VAR 0 18
17222: PUSH
17223: LD_VAR 0 18
17227: PUSH
17228: LD_VAR 0 15
17232: DIV
17233: ST_TO_ADDR
// temp_value = 0 ;
17234: LD_ADDR_VAR 0 3
17238: PUSH
17239: LD_INT 0
17241: ST_TO_ADDR
// for i in attacking_soldiers do
17242: LD_ADDR_VAR 0 2
17246: PUSH
17247: LD_VAR 0 15
17251: PUSH
17252: FOR_IN
17253: IFFALSE 17304
// begin k = GetDistUnitXY ( i , x , y ) ;
17255: LD_ADDR_VAR 0 9
17259: PUSH
17260: LD_VAR 0 2
17264: PPUSH
17265: LD_VAR 0 17
17269: PPUSH
17270: LD_VAR 0 18
17274: PPUSH
17275: CALL_OW 297
17279: ST_TO_ADDR
// if k > temp_value then
17280: LD_VAR 0 9
17284: PUSH
17285: LD_VAR 0 3
17289: GREATER
17290: IFFALSE 17302
// temp_value = k ;
17292: LD_ADDR_VAR 0 3
17296: PUSH
17297: LD_VAR 0 9
17301: ST_TO_ADDR
// end ;
17302: GO 17252
17304: POP
17305: POP
// for i in attacking_scientists do
17306: LD_ADDR_VAR 0 2
17310: PUSH
17311: LD_VAR 0 14
17315: PUSH
17316: FOR_IN
17317: IFFALSE 17367
// if GetDistUnitXY ( i , x , y ) > temp_value then
17319: LD_VAR 0 2
17323: PPUSH
17324: LD_VAR 0 17
17328: PPUSH
17329: LD_VAR 0 18
17333: PPUSH
17334: CALL_OW 297
17338: PUSH
17339: LD_VAR 0 3
17343: GREATER
17344: IFFALSE 17365
// ComMoveXY ( i , x , y ) ;
17346: LD_VAR 0 2
17350: PPUSH
17351: LD_VAR 0 17
17355: PPUSH
17356: LD_VAR 0 18
17360: PPUSH
17361: CALL_OW 111
17365: GO 17316
17367: POP
17368: POP
// end ; temp_value = true ;
17369: LD_ADDR_VAR 0 3
17373: PUSH
17374: LD_INT 1
17376: ST_TO_ADDR
// for i in attacking_soldiers do
17377: LD_ADDR_VAR 0 2
17381: PUSH
17382: LD_VAR 0 15
17386: PUSH
17387: FOR_IN
17388: IFFALSE 17473
// if GetDistUnitXY ( i , patrols_path [ p ] [ patrols_path_hex_index [ p ] ] [ 1 ] , patrols_path [ p ] [ patrols_path_hex_index [ p ] ] [ 2 ] ) > min_dist then
17390: LD_VAR 0 2
17394: PPUSH
17395: LD_EXP 79
17399: PUSH
17400: LD_VAR 0 19
17404: ARRAY
17405: PUSH
17406: LD_EXP 87
17410: PUSH
17411: LD_VAR 0 19
17415: ARRAY
17416: ARRAY
17417: PUSH
17418: LD_INT 1
17420: ARRAY
17421: PPUSH
17422: LD_EXP 79
17426: PUSH
17427: LD_VAR 0 19
17431: ARRAY
17432: PUSH
17433: LD_EXP 87
17437: PUSH
17438: LD_VAR 0 19
17442: ARRAY
17443: ARRAY
17444: PUSH
17445: LD_INT 2
17447: ARRAY
17448: PPUSH
17449: CALL_OW 297
17453: PUSH
17454: LD_VAR 0 20
17458: GREATER
17459: IFFALSE 17471
// begin temp_value = false ;
17461: LD_ADDR_VAR 0 3
17465: PUSH
17466: LD_INT 0
17468: ST_TO_ADDR
// break ;
17469: GO 17473
// end ;
17471: GO 17387
17473: POP
17474: POP
// if temp_value then
17475: LD_VAR 0 3
17479: IFFALSE 17583
// for i in attacking_scientists do
17481: LD_ADDR_VAR 0 2
17485: PUSH
17486: LD_VAR 0 14
17490: PUSH
17491: FOR_IN
17492: IFFALSE 17581
// if GetDistUnitXY ( i , patrols_path [ p ] [ patrols_path_hex_index [ p ] ] [ 1 ] , patrols_path [ p ] [ patrols_path_hex_index [ p ] ] [ 2 ] ) > min_dist + 5 then
17494: LD_VAR 0 2
17498: PPUSH
17499: LD_EXP 79
17503: PUSH
17504: LD_VAR 0 19
17508: ARRAY
17509: PUSH
17510: LD_EXP 87
17514: PUSH
17515: LD_VAR 0 19
17519: ARRAY
17520: ARRAY
17521: PUSH
17522: LD_INT 1
17524: ARRAY
17525: PPUSH
17526: LD_EXP 79
17530: PUSH
17531: LD_VAR 0 19
17535: ARRAY
17536: PUSH
17537: LD_EXP 87
17541: PUSH
17542: LD_VAR 0 19
17546: ARRAY
17547: ARRAY
17548: PUSH
17549: LD_INT 2
17551: ARRAY
17552: PPUSH
17553: CALL_OW 297
17557: PUSH
17558: LD_VAR 0 20
17562: PUSH
17563: LD_INT 5
17565: PLUS
17566: GREATER
17567: IFFALSE 17579
// begin temp_value = false ;
17569: LD_ADDR_VAR 0 3
17573: PUSH
17574: LD_INT 0
17576: ST_TO_ADDR
// break ;
17577: GO 17581
// end ;
17579: GO 17491
17581: POP
17582: POP
// if temp_value and UnitFilter ( attacking_scientists , [ f_ok ] ) > 0 then
17583: LD_VAR 0 3
17587: PUSH
17588: LD_VAR 0 14
17592: PPUSH
17593: LD_INT 50
17595: PUSH
17596: EMPTY
17597: LIST
17598: PPUSH
17599: CALL_OW 72
17603: PUSH
17604: LD_INT 0
17606: GREATER
17607: AND
17608: IFFALSE 17658
// for i in attacking_soldiers ^ attacking_scientists do
17610: LD_ADDR_VAR 0 2
17614: PUSH
17615: LD_VAR 0 15
17619: PUSH
17620: LD_VAR 0 14
17624: ADD
17625: PUSH
17626: FOR_IN
17627: IFFALSE 17656
// if GetLives ( i ) < 900 then
17629: LD_VAR 0 2
17633: PPUSH
17634: CALL_OW 256
17638: PUSH
17639: LD_INT 900
17641: LESS
17642: IFFALSE 17654
// begin temp_value = false ;
17644: LD_ADDR_VAR 0 3
17648: PUSH
17649: LD_INT 0
17651: ST_TO_ADDR
// break ;
17652: GO 17656
// end ;
17654: GO 17626
17656: POP
17657: POP
// if temp_value then
17658: LD_VAR 0 3
17662: IFFALSE 17878
// begin patrols_path_hex_index = Replace ( patrols_path_hex_index , p , patrols_path_hex_index [ p ] + 1 ) ;
17664: LD_ADDR_EXP 87
17668: PUSH
17669: LD_EXP 87
17673: PPUSH
17674: LD_VAR 0 19
17678: PPUSH
17679: LD_EXP 87
17683: PUSH
17684: LD_VAR 0 19
17688: ARRAY
17689: PUSH
17690: LD_INT 1
17692: PLUS
17693: PPUSH
17694: CALL_OW 1
17698: ST_TO_ADDR
// if patrols_path_hex_index [ p ] > patrols_path [ p ] then
17699: LD_EXP 87
17703: PUSH
17704: LD_VAR 0 19
17708: ARRAY
17709: PUSH
17710: LD_EXP 79
17714: PUSH
17715: LD_VAR 0 19
17719: ARRAY
17720: GREATER
17721: IFFALSE 17878
// begin temp_list = ai_soldiers [ 1 ] ^ attacking_soldiers ;
17723: LD_ADDR_VAR 0 5
17727: PUSH
17728: LD_EXP 26
17732: PUSH
17733: LD_INT 1
17735: ARRAY
17736: PUSH
17737: LD_VAR 0 15
17741: ADD
17742: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , temp_list ) ;
17743: LD_ADDR_EXP 26
17747: PUSH
17748: LD_EXP 26
17752: PPUSH
17753: LD_INT 1
17755: PPUSH
17756: LD_VAR 0 5
17760: PPUSH
17761: CALL_OW 1
17765: ST_TO_ADDR
// temp_list = ai_scientists [ 1 ] ^ attacking_scientists ;
17766: LD_ADDR_VAR 0 5
17770: PUSH
17771: LD_EXP 30
17775: PUSH
17776: LD_INT 1
17778: ARRAY
17779: PUSH
17780: LD_VAR 0 14
17784: ADD
17785: ST_TO_ADDR
// ai_scientists = Replace ( ai_scientists , 1 , temp_list ) ;
17786: LD_ADDR_EXP 30
17790: PUSH
17791: LD_EXP 30
17795: PPUSH
17796: LD_INT 1
17798: PPUSH
17799: LD_VAR 0 5
17803: PPUSH
17804: CALL_OW 1
17808: ST_TO_ADDR
// patrols = Replace ( patrols , p , [ ] ) ;
17809: LD_ADDR_EXP 78
17813: PUSH
17814: LD_EXP 78
17818: PPUSH
17819: LD_VAR 0 19
17823: PPUSH
17824: EMPTY
17825: PPUSH
17826: CALL_OW 1
17830: ST_TO_ADDR
// patrols_path = Replace ( patrols_path , p , [ ] ) ;
17831: LD_ADDR_EXP 79
17835: PUSH
17836: LD_EXP 79
17840: PPUSH
17841: LD_VAR 0 19
17845: PPUSH
17846: EMPTY
17847: PPUSH
17848: CALL_OW 1
17852: ST_TO_ADDR
// patrols_path_hex_index = Replace ( patrols_path_hex_index , p , 1 ) ;
17853: LD_ADDR_EXP 87
17857: PUSH
17858: LD_EXP 87
17862: PPUSH
17863: LD_VAR 0 19
17867: PPUSH
17868: LD_INT 1
17870: PPUSH
17871: CALL_OW 1
17875: ST_TO_ADDR
// continue ;
17876: GO 16685
// end ; end ; for i in attacking_soldiers do
17878: LD_ADDR_VAR 0 2
17882: PUSH
17883: LD_VAR 0 15
17887: PUSH
17888: FOR_IN
17889: IFFALSE 18042
// begin temp_value = GetTaskList ( i ) ;
17891: LD_ADDR_VAR 0 3
17895: PUSH
17896: LD_VAR 0 2
17900: PPUSH
17901: CALL_OW 437
17905: ST_TO_ADDR
// if GetDistUnitXY ( i , patrols_path [ p ] [ patrols_path_hex_index [ p ] ] [ 1 ] , patrols_path [ p ] [ patrols_path_hex_index [ p ] ] [ 2 ] ) > min_dist then
17906: LD_VAR 0 2
17910: PPUSH
17911: LD_EXP 79
17915: PUSH
17916: LD_VAR 0 19
17920: ARRAY
17921: PUSH
17922: LD_EXP 87
17926: PUSH
17927: LD_VAR 0 19
17931: ARRAY
17932: ARRAY
17933: PUSH
17934: LD_INT 1
17936: ARRAY
17937: PPUSH
17938: LD_EXP 79
17942: PUSH
17943: LD_VAR 0 19
17947: ARRAY
17948: PUSH
17949: LD_EXP 87
17953: PUSH
17954: LD_VAR 0 19
17958: ARRAY
17959: ARRAY
17960: PUSH
17961: LD_INT 2
17963: ARRAY
17964: PPUSH
17965: CALL_OW 297
17969: PUSH
17970: LD_VAR 0 20
17974: GREATER
17975: IFFALSE 18040
// ComAgressiveMove ( i , patrols_path [ p ] [ patrols_path_hex_index [ p ] ] [ 1 ] , patrols_path [ p ] [ patrols_path_hex_index [ p ] ] [ 2 ] ) ;
17977: LD_VAR 0 2
17981: PPUSH
17982: LD_EXP 79
17986: PUSH
17987: LD_VAR 0 19
17991: ARRAY
17992: PUSH
17993: LD_EXP 87
17997: PUSH
17998: LD_VAR 0 19
18002: ARRAY
18003: ARRAY
18004: PUSH
18005: LD_INT 1
18007: ARRAY
18008: PPUSH
18009: LD_EXP 79
18013: PUSH
18014: LD_VAR 0 19
18018: ARRAY
18019: PUSH
18020: LD_EXP 87
18024: PUSH
18025: LD_VAR 0 19
18029: ARRAY
18030: ARRAY
18031: PUSH
18032: LD_INT 2
18034: ARRAY
18035: PPUSH
18036: CALL_OW 114
// end ;
18040: GO 17888
18042: POP
18043: POP
// end ;
18044: GO 16685
18046: POP
18047: POP
// end ;
18048: GO 16667
18050: POP
18051: POP
// until false ;
18052: LD_INT 0
18054: IFFALSE 16650
// end ;
18056: PPOPN 20
18058: END
// function DistributeHumansToBuildings ( base , human_list , building_list , change_to_this_class , building_capacity , help_building , aggressive_pullback ) ; var i , temp_list , val , temp_unit , area ; begin
18059: LD_INT 0
18061: PPUSH
18062: PPUSH
18063: PPUSH
18064: PPUSH
18065: PPUSH
18066: PPUSH
// area = ru_base_area ;
18067: LD_ADDR_VAR 0 13
18071: PUSH
18072: LD_INT 2
18074: ST_TO_ADDR
// val = building_list + 0 ;
18075: LD_ADDR_VAR 0 11
18079: PUSH
18080: LD_VAR 0 3
18084: PUSH
18085: LD_INT 0
18087: PLUS
18088: ST_TO_ADDR
// while val > 0 and human_list > 0 do
18089: LD_VAR 0 11
18093: PUSH
18094: LD_INT 0
18096: GREATER
18097: PUSH
18098: LD_VAR 0 2
18102: PUSH
18103: LD_INT 0
18105: GREATER
18106: AND
18107: IFFALSE 18545
// begin temp_list = [ ] ;
18109: LD_ADDR_VAR 0 10
18113: PUSH
18114: EMPTY
18115: ST_TO_ADDR
// for i in human_list do
18116: LD_ADDR_VAR 0 9
18120: PUSH
18121: LD_VAR 0 2
18125: PUSH
18126: FOR_IN
18127: IFFALSE 18170
// if IsInUnit ( i ) = building_list [ val ] then
18129: LD_VAR 0 9
18133: PPUSH
18134: CALL_OW 310
18138: PUSH
18139: LD_VAR 0 3
18143: PUSH
18144: LD_VAR 0 11
18148: ARRAY
18149: EQUAL
18150: IFFALSE 18168
// temp_list = temp_list ^ i ;
18152: LD_ADDR_VAR 0 10
18156: PUSH
18157: LD_VAR 0 10
18161: PUSH
18162: LD_VAR 0 9
18166: ADD
18167: ST_TO_ADDR
18168: GO 18126
18170: POP
18171: POP
// human_list = temp_list ^ ( human_list diff temp_list ) ;
18172: LD_ADDR_VAR 0 2
18176: PUSH
18177: LD_VAR 0 10
18181: PUSH
18182: LD_VAR 0 2
18186: PUSH
18187: LD_VAR 0 10
18191: DIFF
18192: ADD
18193: ST_TO_ADDR
// temp_list = [ ] ;
18194: LD_ADDR_VAR 0 10
18198: PUSH
18199: EMPTY
18200: ST_TO_ADDR
// for i = 1 to human_list div val do
18201: LD_ADDR_VAR 0 9
18205: PUSH
18206: DOUBLE
18207: LD_INT 1
18209: DEC
18210: ST_TO_ADDR
18211: LD_VAR 0 2
18215: PUSH
18216: LD_VAR 0 11
18220: DIV
18221: PUSH
18222: FOR_TO
18223: IFFALSE 18279
// begin if i > building_capacity then
18225: LD_VAR 0 9
18229: PUSH
18230: LD_VAR 0 5
18234: GREATER
18235: IFFALSE 18239
// break ;
18237: GO 18279
// temp_list = temp_list ^ human_list [ 1 ] ;
18239: LD_ADDR_VAR 0 10
18243: PUSH
18244: LD_VAR 0 10
18248: PUSH
18249: LD_VAR 0 2
18253: PUSH
18254: LD_INT 1
18256: ARRAY
18257: ADD
18258: ST_TO_ADDR
// human_list = Delete ( human_list , 1 ) ;
18259: LD_ADDR_VAR 0 2
18263: PUSH
18264: LD_VAR 0 2
18268: PPUSH
18269: LD_INT 1
18271: PPUSH
18272: CALL_OW 3
18276: ST_TO_ADDR
// end ;
18277: GO 18222
18279: POP
18280: POP
// for i in temp_list do
18281: LD_ADDR_VAR 0 9
18285: PUSH
18286: LD_VAR 0 10
18290: PUSH
18291: FOR_IN
18292: IFFALSE 18527
// begin temp_unit = IsInUnit ( i ) ;
18294: LD_ADDR_VAR 0 12
18298: PUSH
18299: LD_VAR 0 9
18303: PPUSH
18304: CALL_OW 310
18308: ST_TO_ADDR
// if temp_unit <> building_list [ val ] then
18309: LD_VAR 0 12
18313: PUSH
18314: LD_VAR 0 3
18318: PUSH
18319: LD_VAR 0 11
18323: ARRAY
18324: NONEQUAL
18325: IFFALSE 18525
// case GetType ( IsInUnit ( i ) ) of unit_vehicle :
18327: LD_VAR 0 9
18331: PPUSH
18332: CALL_OW 310
18336: PPUSH
18337: CALL_OW 247
18341: PUSH
18342: LD_INT 2
18344: DOUBLE
18345: EQUAL
18346: IFTRUE 18350
18348: GO 18362
18350: POP
// ComExitVehicle ( i ) ; unit_building :
18351: LD_VAR 0 9
18355: PPUSH
18356: CALL_OW 121
18360: GO 18525
18362: LD_INT 3
18364: DOUBLE
18365: EQUAL
18366: IFTRUE 18370
18368: GO 18382
18370: POP
// ComExitBuilding ( i ) ; else
18371: LD_VAR 0 9
18375: PPUSH
18376: CALL_OW 122
18380: GO 18525
18382: POP
// begin if IsInArea ( i , area ) or not aggressive_pullback then
18383: LD_VAR 0 9
18387: PPUSH
18388: LD_VAR 0 13
18392: PPUSH
18393: CALL_OW 308
18397: PUSH
18398: LD_VAR 0 7
18402: NOT
18403: OR
18404: IFFALSE 18428
// ComEnterUnit ( i , building_list [ val ] ) else
18406: LD_VAR 0 9
18410: PPUSH
18411: LD_VAR 0 3
18415: PUSH
18416: LD_VAR 0 11
18420: ARRAY
18421: PPUSH
18422: CALL_OW 120
18426: GO 18469
// ComAgressiveMove ( i , GetX ( building_list [ val ] ) , GetY ( building_list [ val ] ) ) ;
18428: LD_VAR 0 9
18432: PPUSH
18433: LD_VAR 0 3
18437: PUSH
18438: LD_VAR 0 11
18442: ARRAY
18443: PPUSH
18444: CALL_OW 250
18448: PPUSH
18449: LD_VAR 0 3
18453: PUSH
18454: LD_VAR 0 11
18458: ARRAY
18459: PPUSH
18460: CALL_OW 251
18464: PPUSH
18465: CALL_OW 114
// if change_to_this_class > 0 then
18469: LD_VAR 0 4
18473: PUSH
18474: LD_INT 0
18476: GREATER
18477: IFFALSE 18525
// if GetClass ( i ) <> change_to_this_class and GetNation ( i ) <> nation_nature then
18479: LD_VAR 0 9
18483: PPUSH
18484: CALL_OW 257
18488: PUSH
18489: LD_VAR 0 4
18493: NONEQUAL
18494: PUSH
18495: LD_VAR 0 9
18499: PPUSH
18500: CALL_OW 248
18504: PUSH
18505: LD_INT 0
18507: NONEQUAL
18508: AND
18509: IFFALSE 18525
// AddComChangeProfession ( i , change_to_this_class ) ;
18511: LD_VAR 0 9
18515: PPUSH
18516: LD_VAR 0 4
18520: PPUSH
18521: CALL_OW 183
// end ; end ; end ;
18525: GO 18291
18527: POP
18528: POP
// val = val - 1 ;
18529: LD_ADDR_VAR 0 11
18533: PUSH
18534: LD_VAR 0 11
18538: PUSH
18539: LD_INT 1
18541: MINUS
18542: ST_TO_ADDR
// end ;
18543: GO 18089
// if human_list > 0 then
18545: LD_VAR 0 2
18549: PUSH
18550: LD_INT 0
18552: GREATER
18553: IFFALSE 18801
// if ai_building_under_construction [ base ] > 0 and help_building and not code_black then
18555: LD_EXP 41
18559: PUSH
18560: LD_VAR 0 1
18564: ARRAY
18565: PUSH
18566: LD_INT 0
18568: GREATER
18569: PUSH
18570: LD_VAR 0 6
18574: AND
18575: PUSH
18576: LD_EXP 77
18580: NOT
18581: AND
18582: IFFALSE 18653
// begin for i in human_list do
18584: LD_ADDR_VAR 0 9
18588: PUSH
18589: LD_VAR 0 2
18593: PUSH
18594: FOR_IN
18595: IFFALSE 18649
// SetTaskList ( i , [ [ h , 0 , 0 , ai_building_under_construction [ base ] , 0 , 0 , 0 ] ] ) ;
18597: LD_VAR 0 9
18601: PPUSH
18602: LD_STRING h
18604: PUSH
18605: LD_INT 0
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: LD_EXP 41
18615: PUSH
18616: LD_VAR 0 1
18620: ARRAY
18621: PUSH
18622: LD_INT 0
18624: PUSH
18625: LD_INT 0
18627: PUSH
18628: LD_INT 0
18630: PUSH
18631: EMPTY
18632: LIST
18633: LIST
18634: LIST
18635: LIST
18636: LIST
18637: LIST
18638: LIST
18639: PUSH
18640: EMPTY
18641: LIST
18642: PPUSH
18643: CALL_OW 446
18647: GO 18594
18649: POP
18650: POP
// end else
18651: GO 18801
// for i in human_list do
18653: LD_ADDR_VAR 0 9
18657: PUSH
18658: LD_VAR 0 2
18662: PUSH
18663: FOR_IN
18664: IFFALSE 18799
// if GetDistUnitXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) > 4 then
18666: LD_VAR 0 9
18670: PPUSH
18671: LD_EXP 40
18675: PUSH
18676: LD_VAR 0 1
18680: ARRAY
18681: PUSH
18682: LD_INT 1
18684: ARRAY
18685: PPUSH
18686: LD_EXP 40
18690: PUSH
18691: LD_VAR 0 1
18695: ARRAY
18696: PUSH
18697: LD_INT 2
18699: ARRAY
18700: PPUSH
18701: CALL_OW 297
18705: PUSH
18706: LD_INT 4
18708: GREATER
18709: IFFALSE 18797
// if aggressive_pullback then
18711: LD_VAR 0 7
18715: IFFALSE 18758
// ComAgressiveMove ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) else
18717: LD_VAR 0 9
18721: PPUSH
18722: LD_EXP 40
18726: PUSH
18727: LD_VAR 0 1
18731: ARRAY
18732: PUSH
18733: LD_INT 1
18735: ARRAY
18736: PPUSH
18737: LD_EXP 40
18741: PUSH
18742: LD_VAR 0 1
18746: ARRAY
18747: PUSH
18748: LD_INT 2
18750: ARRAY
18751: PPUSH
18752: CALL_OW 114
18756: GO 18797
// ComMoveXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
18758: LD_VAR 0 9
18762: PPUSH
18763: LD_EXP 40
18767: PUSH
18768: LD_VAR 0 1
18772: ARRAY
18773: PUSH
18774: LD_INT 1
18776: ARRAY
18777: PPUSH
18778: LD_EXP 40
18782: PUSH
18783: LD_VAR 0 1
18787: ARRAY
18788: PUSH
18789: LD_INT 2
18791: ARRAY
18792: PPUSH
18793: CALL_OW 111
18797: GO 18663
18799: POP
18800: POP
// end ;
18801: LD_VAR 0 8
18805: RET
// every 0 0$1 do var side , i , engineers_list , temp_list , buildings_list , temp_unit , away_dist , temp_list_2 , base , apemen_engineers_list ; var humans_list ; var free_parking_spots , k ;
18806: GO 18808
18808: DISABLE
18809: LD_INT 0
18811: PPUSH
18812: PPUSH
18813: PPUSH
18814: PPUSH
18815: PPUSH
18816: PPUSH
18817: PPUSH
18818: PPUSH
18819: PPUSH
18820: PPUSH
18821: PPUSH
18822: PPUSH
18823: PPUSH
// begin side = russians ;
18824: LD_ADDR_VAR 0 1
18828: PUSH
18829: LD_EXP 3
18833: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18834: LD_INT 35
18836: PPUSH
18837: CALL_OW 67
// for base in ai_bases do
18841: LD_ADDR_VAR 0 9
18845: PUSH
18846: LD_EXP 57
18850: PUSH
18851: FOR_IN
18852: IFFALSE 22472
// begin if code_black then
18854: LD_EXP 77
18858: IFFALSE 18905
// begin ai_vehicle_being_moved = Replace ( ai_vehicle_being_moved , base , 0 ) ;
18860: LD_ADDR_EXP 45
18864: PUSH
18865: LD_EXP 45
18869: PPUSH
18870: LD_VAR 0 9
18874: PPUSH
18875: LD_INT 0
18877: PPUSH
18878: CALL_OW 1
18882: ST_TO_ADDR
// ai_vehicles_having_been_moved = Replace ( ai_vehicles_having_been_moved , base , [ ] ) ;
18883: LD_ADDR_EXP 67
18887: PUSH
18888: LD_EXP 67
18892: PPUSH
18893: LD_VAR 0 9
18897: PPUSH
18898: EMPTY
18899: PPUSH
18900: CALL_OW 1
18904: ST_TO_ADDR
// end ; engineers_list = ai_engineers [ base ] diff ai_heal_these_humans [ base ] ;
18905: LD_ADDR_VAR 0 3
18909: PUSH
18910: LD_EXP 27
18914: PUSH
18915: LD_VAR 0 9
18919: ARRAY
18920: PUSH
18921: LD_EXP 42
18925: PUSH
18926: LD_VAR 0 9
18930: ARRAY
18931: DIFF
18932: ST_TO_ADDR
// apemen_engineers_list = ai_apemen_engineers [ base ] diff ai_heal_these_humans [ base ] ;
18933: LD_ADDR_VAR 0 10
18937: PUSH
18938: LD_EXP 61
18942: PUSH
18943: LD_VAR 0 9
18947: ARRAY
18948: PUSH
18949: LD_EXP 42
18953: PUSH
18954: LD_VAR 0 9
18958: ARRAY
18959: DIFF
18960: ST_TO_ADDR
// temp_list = ai_heal_these_humans [ base ] ;
18961: LD_ADDR_VAR 0 4
18965: PUSH
18966: LD_EXP 42
18970: PUSH
18971: LD_VAR 0 9
18975: ARRAY
18976: ST_TO_ADDR
// humans_list = engineers_list ^ apemen_engineers_list ;
18977: LD_ADDR_VAR 0 11
18981: PUSH
18982: LD_VAR 0 3
18986: PUSH
18987: LD_VAR 0 10
18991: ADD
18992: ST_TO_ADDR
// i = 1 ;
18993: LD_ADDR_VAR 0 2
18997: PUSH
18998: LD_INT 1
19000: ST_TO_ADDR
// while i <= humans_list do
19001: LD_VAR 0 2
19005: PUSH
19006: LD_VAR 0 11
19010: LESSEQUAL
19011: IFFALSE 19150
// begin if GetLives ( humans_list [ i ] ) <= 700 then
19013: LD_VAR 0 11
19017: PUSH
19018: LD_VAR 0 2
19022: ARRAY
19023: PPUSH
19024: CALL_OW 256
19028: PUSH
19029: LD_INT 700
19031: LESSEQUAL
19032: IFFALSE 19134
// begin temp_list = temp_list ^ humans_list [ i ] ;
19034: LD_ADDR_VAR 0 4
19038: PUSH
19039: LD_VAR 0 4
19043: PUSH
19044: LD_VAR 0 11
19048: PUSH
19049: LD_VAR 0 2
19053: ARRAY
19054: ADD
19055: ST_TO_ADDR
// engineers_list = engineers_list diff humans_list [ i ] ;
19056: LD_ADDR_VAR 0 3
19060: PUSH
19061: LD_VAR 0 3
19065: PUSH
19066: LD_VAR 0 11
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: DIFF
19077: ST_TO_ADDR
// apemen_engineers_list = apemen_engineers_list diff humans_list [ i ] ;
19078: LD_ADDR_VAR 0 10
19082: PUSH
19083: LD_VAR 0 10
19087: PUSH
19088: LD_VAR 0 11
19092: PUSH
19093: LD_VAR 0 2
19097: ARRAY
19098: DIFF
19099: ST_TO_ADDR
// humans_list = Delete ( humans_list , i ) ;
19100: LD_ADDR_VAR 0 11
19104: PUSH
19105: LD_VAR 0 11
19109: PPUSH
19110: LD_VAR 0 2
19114: PPUSH
19115: CALL_OW 3
19119: ST_TO_ADDR
// i = i - 1 ;
19120: LD_ADDR_VAR 0 2
19124: PUSH
19125: LD_VAR 0 2
19129: PUSH
19130: LD_INT 1
19132: MINUS
19133: ST_TO_ADDR
// end ; i = i + 1 ;
19134: LD_ADDR_VAR 0 2
19138: PUSH
19139: LD_VAR 0 2
19143: PUSH
19144: LD_INT 1
19146: PLUS
19147: ST_TO_ADDR
// end ;
19148: GO 19001
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
19150: LD_ADDR_EXP 42
19154: PUSH
19155: LD_EXP 42
19159: PPUSH
19160: LD_VAR 0 9
19164: PPUSH
19165: LD_VAR 0 4
19169: PPUSH
19170: CALL_OW 1
19174: ST_TO_ADDR
// if engineers_list = 0 and apemen_engineers_list = 0 then
19175: LD_VAR 0 3
19179: PUSH
19180: LD_INT 0
19182: EQUAL
19183: PUSH
19184: LD_VAR 0 10
19188: PUSH
19189: LD_INT 0
19191: EQUAL
19192: AND
19193: IFFALSE 19197
// continue ;
19195: GO 18851
// temp_list_2 = UnitFilter ( engineers_list , [ f_class , class_engineer ] ) ;
19197: LD_ADDR_VAR 0 8
19201: PUSH
19202: LD_VAR 0 3
19206: PPUSH
19207: LD_INT 25
19209: PUSH
19210: LD_INT 2
19212: PUSH
19213: EMPTY
19214: LIST
19215: LIST
19216: PPUSH
19217: CALL_OW 72
19221: ST_TO_ADDR
// if ai_captured_buildings [ base ] > 0 and temp_list_2 > 0 then
19222: LD_EXP 69
19226: PUSH
19227: LD_VAR 0 9
19231: ARRAY
19232: PUSH
19233: LD_INT 0
19235: GREATER
19236: PUSH
19237: LD_VAR 0 8
19241: PUSH
19242: LD_INT 0
19244: GREATER
19245: AND
19246: IFFALSE 19517
// begin temp_list = [ ] ;
19248: LD_ADDR_VAR 0 4
19252: PUSH
19253: EMPTY
19254: ST_TO_ADDR
// for i in ai_captured_buildings [ base ] do
19255: LD_ADDR_VAR 0 2
19259: PUSH
19260: LD_EXP 69
19264: PUSH
19265: LD_VAR 0 9
19269: ARRAY
19270: PUSH
19271: FOR_IN
19272: IFFALSE 19328
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
19274: LD_VAR 0 2
19278: PPUSH
19279: CALL_OW 266
19283: PUSH
19284: LD_INT 0
19286: PUSH
19287: LD_INT 1
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: IN
19294: IFFALSE 19312
// temp_list = temp_list ^ 1 else
19296: LD_ADDR_VAR 0 4
19300: PUSH
19301: LD_VAR 0 4
19305: PUSH
19306: LD_INT 1
19308: ADD
19309: ST_TO_ADDR
19310: GO 19326
// temp_list = temp_list ^ 0 ;
19312: LD_ADDR_VAR 0 4
19316: PUSH
19317: LD_VAR 0 4
19321: PUSH
19322: LD_INT 0
19324: ADD
19325: ST_TO_ADDR
19326: GO 19271
19328: POP
19329: POP
// temp_list = SortListByListDesc ( ai_captured_buildings [ base ] , temp_list ) ;
19330: LD_ADDR_VAR 0 4
19334: PUSH
19335: LD_EXP 69
19339: PUSH
19340: LD_VAR 0 9
19344: ARRAY
19345: PPUSH
19346: LD_VAR 0 4
19350: PPUSH
19351: CALL_OW 77
19355: ST_TO_ADDR
// temp_list_2 = GetHumansOutOfUnits ( temp_list_2 ) ;
19356: LD_ADDR_VAR 0 8
19360: PUSH
19361: LD_VAR 0 8
19365: PPUSH
19366: CALL 23354 0 1
19370: ST_TO_ADDR
// if temp_list_2 > 0 then
19371: LD_VAR 0 8
19375: PUSH
19376: LD_INT 0
19378: GREATER
19379: IFFALSE 19495
// begin temp_list_2 = SortListByListDesc ( temp_list_2 , temp_list_2 ) ;
19381: LD_ADDR_VAR 0 8
19385: PUSH
19386: LD_VAR 0 8
19390: PPUSH
19391: LD_VAR 0 8
19395: PPUSH
19396: CALL_OW 77
19400: ST_TO_ADDR
// SetTaskList ( temp_list_2 [ 1 ] , [ [ e , GetX ( temp_list [ 1 ] ) , GetY ( temp_list [ 1 ] ) , temp_list [ 1 ] , 0 , 0 , 0 ] ] ) ;
19401: LD_VAR 0 8
19405: PUSH
19406: LD_INT 1
19408: ARRAY
19409: PPUSH
19410: LD_STRING e
19412: PUSH
19413: LD_VAR 0 4
19417: PUSH
19418: LD_INT 1
19420: ARRAY
19421: PPUSH
19422: CALL_OW 250
19426: PUSH
19427: LD_VAR 0 4
19431: PUSH
19432: LD_INT 1
19434: ARRAY
19435: PPUSH
19436: CALL_OW 251
19440: PUSH
19441: LD_VAR 0 4
19445: PUSH
19446: LD_INT 1
19448: ARRAY
19449: PUSH
19450: LD_INT 0
19452: PUSH
19453: LD_INT 0
19455: PUSH
19456: LD_INT 0
19458: PUSH
19459: EMPTY
19460: LIST
19461: LIST
19462: LIST
19463: LIST
19464: LIST
19465: LIST
19466: LIST
19467: PUSH
19468: EMPTY
19469: LIST
19470: PPUSH
19471: CALL_OW 446
// engineers_list = engineers_list diff temp_list_2 [ 1 ] ;
19475: LD_ADDR_VAR 0 3
19479: PUSH
19480: LD_VAR 0 3
19484: PUSH
19485: LD_VAR 0 8
19489: PUSH
19490: LD_INT 1
19492: ARRAY
19493: DIFF
19494: ST_TO_ADDR
// end ; if engineers_list = 0 and apemen_engineers_list = 0 then
19495: LD_VAR 0 3
19499: PUSH
19500: LD_INT 0
19502: EQUAL
19503: PUSH
19504: LD_VAR 0 10
19508: PUSH
19509: LD_INT 0
19511: EQUAL
19512: AND
19513: IFFALSE 19517
// continue ;
19515: GO 18851
// end ; i = 1 ;
19517: LD_ADDR_VAR 0 2
19521: PUSH
19522: LD_INT 1
19524: ST_TO_ADDR
// buildings_list = [ ] ;
19525: LD_ADDR_VAR 0 5
19529: PUSH
19530: EMPTY
19531: ST_TO_ADDR
// repeat case i of 1 :
19532: LD_VAR 0 2
19536: PUSH
19537: LD_INT 1
19539: DOUBLE
19540: EQUAL
19541: IFTRUE 19545
19543: GO 19582
19545: POP
// buildings_list = UnitFilter ( ai_all_buildings [ base ] , [ f_not , [ f_ok ] ] ) ; 2 :
19546: LD_ADDR_VAR 0 5
19550: PUSH
19551: LD_EXP 43
19555: PUSH
19556: LD_VAR 0 9
19560: ARRAY
19561: PPUSH
19562: LD_INT 3
19564: PUSH
19565: LD_INT 50
19567: PUSH
19568: EMPTY
19569: LIST
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: PPUSH
19575: CALL_OW 72
19579: ST_TO_ADDR
19580: GO 19632
19582: LD_INT 2
19584: DOUBLE
19585: EQUAL
19586: IFTRUE 19590
19588: GO 19631
19590: POP
// buildings_list = UnitFilter ( ai_all_buildings [ base ] , [ f_not , [ f_lives , 1000 ] ] ) ; end ;
19591: LD_ADDR_VAR 0 5
19595: PUSH
19596: LD_EXP 43
19600: PUSH
19601: LD_VAR 0 9
19605: ARRAY
19606: PPUSH
19607: LD_INT 3
19609: PUSH
19610: LD_INT 24
19612: PUSH
19613: LD_INT 1000
19615: PUSH
19616: EMPTY
19617: LIST
19618: LIST
19619: PUSH
19620: EMPTY
19621: LIST
19622: LIST
19623: PPUSH
19624: CALL_OW 72
19628: ST_TO_ADDR
19629: GO 19632
19631: POP
// i = i + 1 ;
19632: LD_ADDR_VAR 0 2
19636: PUSH
19637: LD_VAR 0 2
19641: PUSH
19642: LD_INT 1
19644: PLUS
19645: ST_TO_ADDR
// until buildings_list > 0 or i > 2 ;
19646: LD_VAR 0 5
19650: PUSH
19651: LD_INT 0
19653: GREATER
19654: PUSH
19655: LD_VAR 0 2
19659: PUSH
19660: LD_INT 2
19662: GREATER
19663: OR
19664: IFFALSE 19532
// if buildings_list > 0 then
19666: LD_VAR 0 5
19670: PUSH
19671: LD_INT 0
19673: GREATER
19674: IFFALSE 19861
// begin humans_list = engineers_list ^ apemen_engineers_list ;
19676: LD_ADDR_VAR 0 11
19680: PUSH
19681: LD_VAR 0 3
19685: PUSH
19686: LD_VAR 0 10
19690: ADD
19691: ST_TO_ADDR
// humans_list = GetHumansOutOfUnits ( humans_list ) ;
19692: LD_ADDR_VAR 0 11
19696: PUSH
19697: LD_VAR 0 11
19701: PPUSH
19702: CALL 23354 0 1
19706: ST_TO_ADDR
// repeat i = 1 ;
19707: LD_ADDR_VAR 0 2
19711: PUSH
19712: LD_INT 1
19714: ST_TO_ADDR
// while i <= buildings_list do
19715: LD_VAR 0 2
19719: PUSH
19720: LD_VAR 0 5
19724: LESSEQUAL
19725: IFFALSE 19849
// begin if humans_list = 0 then
19727: LD_VAR 0 11
19731: PUSH
19732: LD_INT 0
19734: EQUAL
19735: IFFALSE 19739
// break ;
19737: GO 19849
// temp_unit = NearestUnitToUnit ( humans_list , buildings_list [ i ] ) ;
19739: LD_ADDR_VAR 0 6
19743: PUSH
19744: LD_VAR 0 11
19748: PPUSH
19749: LD_VAR 0 5
19753: PUSH
19754: LD_VAR 0 2
19758: ARRAY
19759: PPUSH
19760: CALL_OW 74
19764: ST_TO_ADDR
// ComRepairBuilding ( temp_unit , buildings_list [ i ] ) ;
19765: LD_VAR 0 6
19769: PPUSH
19770: LD_VAR 0 5
19774: PUSH
19775: LD_VAR 0 2
19779: ARRAY
19780: PPUSH
19781: CALL_OW 130
// humans_list = humans_list diff temp_unit ;
19785: LD_ADDR_VAR 0 11
19789: PUSH
19790: LD_VAR 0 11
19794: PUSH
19795: LD_VAR 0 6
19799: DIFF
19800: ST_TO_ADDR
// engineers_list = engineers_list diff temp_unit ;
19801: LD_ADDR_VAR 0 3
19805: PUSH
19806: LD_VAR 0 3
19810: PUSH
19811: LD_VAR 0 6
19815: DIFF
19816: ST_TO_ADDR
// apemen_engineers_list = apemen_engineers_list diff temp_unit ;
19817: LD_ADDR_VAR 0 10
19821: PUSH
19822: LD_VAR 0 10
19826: PUSH
19827: LD_VAR 0 6
19831: DIFF
19832: ST_TO_ADDR
// i = i + 1 ;
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 2
19842: PUSH
19843: LD_INT 1
19845: PLUS
19846: ST_TO_ADDR
// end ;
19847: GO 19715
// until humans_list = 0 ;
19849: LD_VAR 0 11
19853: PUSH
19854: LD_INT 0
19856: EQUAL
19857: IFFALSE 19707
// continue ;
19859: GO 18851
// end ; if not code_black then
19861: LD_EXP 77
19865: NOT
19866: IFFALSE 22399
// begin if ai_building_under_construction [ base ] > 0 then
19868: LD_EXP 41
19872: PUSH
19873: LD_VAR 0 9
19877: ARRAY
19878: PUSH
19879: LD_INT 0
19881: GREATER
19882: IFFALSE 19995
// if BuildingStatus ( ai_building_under_construction [ base ] ) = bs_build then
19884: LD_EXP 41
19888: PUSH
19889: LD_VAR 0 9
19893: ARRAY
19894: PPUSH
19895: CALL_OW 461
19899: PUSH
19900: LD_INT 1
19902: EQUAL
19903: IFFALSE 19957
// begin for i in GetHumansOutOfUnits ( engineers_list ^ apemen_engineers_list ) do
19905: LD_ADDR_VAR 0 2
19909: PUSH
19910: LD_VAR 0 3
19914: PUSH
19915: LD_VAR 0 10
19919: ADD
19920: PPUSH
19921: CALL 23354 0 1
19925: PUSH
19926: FOR_IN
19927: IFFALSE 19951
// ComRepairBuilding ( i , ai_building_under_construction [ base ] ) ;
19929: LD_VAR 0 2
19933: PPUSH
19934: LD_EXP 41
19938: PUSH
19939: LD_VAR 0 9
19943: ARRAY
19944: PPUSH
19945: CALL_OW 130
19949: GO 19926
19951: POP
19952: POP
// continue ;
19953: GO 18851
// end else
19955: GO 19995
// begin ComCancel ( ai_building_under_construction [ base ] ) ;
19957: LD_EXP 41
19961: PUSH
19962: LD_VAR 0 9
19966: ARRAY
19967: PPUSH
19968: CALL_OW 127
// ai_building_under_construction = Replace ( ai_building_under_construction , base , 0 ) ;
19972: LD_ADDR_EXP 41
19976: PUSH
19977: LD_EXP 41
19981: PPUSH
19982: LD_VAR 0 9
19986: PPUSH
19987: LD_INT 0
19989: PPUSH
19990: CALL_OW 1
19994: ST_TO_ADDR
// end ; if ai_all_buildings [ base ] < ai_buildings_locations [ base ] or ai_upcoming_building_data [ base ] > 0 then
19995: LD_EXP 43
19999: PUSH
20000: LD_VAR 0 9
20004: ARRAY
20005: PUSH
20006: LD_EXP 36
20010: PUSH
20011: LD_VAR 0 9
20015: ARRAY
20016: LESS
20017: PUSH
20018: LD_EXP 46
20022: PUSH
20023: LD_VAR 0 9
20027: ARRAY
20028: PUSH
20029: LD_INT 0
20031: GREATER
20032: OR
20033: IFFALSE 21652
// begin if ai_upcoming_building_data [ base ] = 0 then
20035: LD_EXP 46
20039: PUSH
20040: LD_VAR 0 9
20044: ARRAY
20045: PUSH
20046: LD_INT 0
20048: EQUAL
20049: IFFALSE 20162
// begin temp_list = [ ] ;
20051: LD_ADDR_VAR 0 4
20055: PUSH
20056: EMPTY
20057: ST_TO_ADDR
// for i in ai_buildings_locations [ base ] do
20058: LD_ADDR_VAR 0 2
20062: PUSH
20063: LD_EXP 36
20067: PUSH
20068: LD_VAR 0 9
20072: ARRAY
20073: PUSH
20074: FOR_IN
20075: IFFALSE 20125
// if GetBType ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) = - 1 then
20077: LD_VAR 0 2
20081: PUSH
20082: LD_INT 1
20084: ARRAY
20085: PPUSH
20086: LD_VAR 0 2
20090: PUSH
20091: LD_INT 2
20093: ARRAY
20094: PPUSH
20095: CALL_OW 428
20099: PPUSH
20100: CALL_OW 266
20104: PUSH
20105: LD_INT 1
20107: NEG
20108: EQUAL
20109: IFFALSE 20123
// begin temp_list = i ;
20111: LD_ADDR_VAR 0 4
20115: PUSH
20116: LD_VAR 0 2
20120: ST_TO_ADDR
// break ;
20121: GO 20125
// end ;
20123: GO 20074
20125: POP
20126: POP
// if temp_list > 0 then
20127: LD_VAR 0 4
20131: PUSH
20132: LD_INT 0
20134: GREATER
20135: IFFALSE 20162
// ai_upcoming_building_data = Replace ( ai_upcoming_building_data , base , temp_list ) ;
20137: LD_ADDR_EXP 46
20141: PUSH
20142: LD_EXP 46
20146: PPUSH
20147: LD_VAR 0 9
20151: PPUSH
20152: LD_VAR 0 4
20156: PPUSH
20157: CALL_OW 1
20161: ST_TO_ADDR
// end ; if ai_upcoming_building_data [ base ] > 0 then
20162: LD_EXP 46
20166: PUSH
20167: LD_VAR 0 9
20171: ARRAY
20172: PUSH
20173: LD_INT 0
20175: GREATER
20176: IFFALSE 21652
// begin if ai_building_constructor [ base ] = 0 then
20178: LD_EXP 44
20182: PUSH
20183: LD_VAR 0 9
20187: ARRAY
20188: PUSH
20189: LD_INT 0
20191: EQUAL
20192: IFFALSE 20318
// begin temp_list_2 = UnitFilter ( ai_engineers [ base ] , [ f_class , class_engineer ] ) ;
20194: LD_ADDR_VAR 0 8
20198: PUSH
20199: LD_EXP 27
20203: PUSH
20204: LD_VAR 0 9
20208: ARRAY
20209: PPUSH
20210: LD_INT 25
20212: PUSH
20213: LD_INT 2
20215: PUSH
20216: EMPTY
20217: LIST
20218: LIST
20219: PPUSH
20220: CALL_OW 72
20224: ST_TO_ADDR
// if temp_list_2 > 0 then
20225: LD_VAR 0 8
20229: PUSH
20230: LD_INT 0
20232: GREATER
20233: IFFALSE 20318
// begin temp_list = [ ] ;
20235: LD_ADDR_VAR 0 4
20239: PUSH
20240: EMPTY
20241: ST_TO_ADDR
// for i in temp_list_2 do
20242: LD_ADDR_VAR 0 2
20246: PUSH
20247: LD_VAR 0 8
20251: PUSH
20252: FOR_IN
20253: IFFALSE 20281
// temp_list = temp_list ^ GetSkill ( i , skill_engineering ) ;
20255: LD_ADDR_VAR 0 4
20259: PUSH
20260: LD_VAR 0 4
20264: PUSH
20265: LD_VAR 0 2
20269: PPUSH
20270: LD_INT 2
20272: PPUSH
20273: CALL_OW 259
20277: ADD
20278: ST_TO_ADDR
20279: GO 20252
20281: POP
20282: POP
// ai_building_constructor = Replace ( ai_building_constructor , base , BestFromListByList ( temp_list_2 , temp_list ) ) ;
20283: LD_ADDR_EXP 44
20287: PUSH
20288: LD_EXP 44
20292: PPUSH
20293: LD_VAR 0 9
20297: PPUSH
20298: LD_VAR 0 8
20302: PPUSH
20303: LD_VAR 0 4
20307: PPUSH
20308: CALL_OW 79
20312: PPUSH
20313: CALL_OW 1
20317: ST_TO_ADDR
// end ; end ; if ai_building_constructor [ base ] in engineers_list and ai_building_constructor [ base ] > 0 then
20318: LD_EXP 44
20322: PUSH
20323: LD_VAR 0 9
20327: ARRAY
20328: PUSH
20329: LD_VAR 0 3
20333: IN
20334: PUSH
20335: LD_EXP 44
20339: PUSH
20340: LD_VAR 0 9
20344: ARRAY
20345: PUSH
20346: LD_INT 0
20348: GREATER
20349: AND
20350: IFFALSE 21652
// begin engineers_list = engineers_list diff ai_building_constructor [ base ] ;
20352: LD_ADDR_VAR 0 3
20356: PUSH
20357: LD_VAR 0 3
20361: PUSH
20362: LD_EXP 44
20366: PUSH
20367: LD_VAR 0 9
20371: ARRAY
20372: DIFF
20373: ST_TO_ADDR
// away_dist = 7 ;
20374: LD_ADDR_VAR 0 7
20378: PUSH
20379: LD_INT 7
20381: ST_TO_ADDR
// if ai_vehicle_being_moved [ base ] = 0 then
20382: LD_EXP 45
20386: PUSH
20387: LD_VAR 0 9
20391: ARRAY
20392: PUSH
20393: LD_INT 0
20395: EQUAL
20396: IFFALSE 21394
// begin temp_list = UnitFilter ( ai_vehicles_defend [ base ] ^ ai_cargo_bay [ base ] , [ [ f_control , control_manual ] , [ f_empty ] , [ f_distxy , ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] , away_dist ] ] ) ;
20398: LD_ADDR_VAR 0 4
20402: PUSH
20403: LD_EXP 37
20407: PUSH
20408: LD_VAR 0 9
20412: ARRAY
20413: PUSH
20414: LD_EXP 59
20418: PUSH
20419: LD_VAR 0 9
20423: ARRAY
20424: ADD
20425: PPUSH
20426: LD_INT 33
20428: PUSH
20429: LD_INT 1
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PUSH
20436: LD_INT 58
20438: PUSH
20439: EMPTY
20440: LIST
20441: PUSH
20442: LD_INT 92
20444: PUSH
20445: LD_EXP 46
20449: PUSH
20450: LD_VAR 0 9
20454: ARRAY
20455: PUSH
20456: LD_INT 1
20458: ARRAY
20459: PUSH
20460: LD_EXP 46
20464: PUSH
20465: LD_VAR 0 9
20469: ARRAY
20470: PUSH
20471: LD_INT 2
20473: ARRAY
20474: PUSH
20475: LD_VAR 0 7
20479: PUSH
20480: EMPTY
20481: LIST
20482: LIST
20483: LIST
20484: LIST
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: LIST
20490: PPUSH
20491: CALL_OW 72
20495: ST_TO_ADDR
// if temp_list > 0 then
20496: LD_VAR 0 4
20500: PUSH
20501: LD_INT 0
20503: GREATER
20504: IFFALSE 20588
// begin ai_vehicle_being_moved = Replace ( ai_vehicle_being_moved , base , temp_list [ 1 ] ) ;
20506: LD_ADDR_EXP 45
20510: PUSH
20511: LD_EXP 45
20515: PPUSH
20516: LD_VAR 0 9
20520: PPUSH
20521: LD_VAR 0 4
20525: PUSH
20526: LD_INT 1
20528: ARRAY
20529: PPUSH
20530: CALL_OW 1
20534: ST_TO_ADDR
// temp_list_2 = ai_vehicles_having_been_moved [ base ] ^ temp_list [ 1 ] ;
20535: LD_ADDR_VAR 0 8
20539: PUSH
20540: LD_EXP 67
20544: PUSH
20545: LD_VAR 0 9
20549: ARRAY
20550: PUSH
20551: LD_VAR 0 4
20555: PUSH
20556: LD_INT 1
20558: ARRAY
20559: ADD
20560: ST_TO_ADDR
// ai_vehicles_having_been_moved = Replace ( ai_vehicles_having_been_moved , base , temp_list_2 ) ;
20561: LD_ADDR_EXP 67
20565: PUSH
20566: LD_EXP 67
20570: PPUSH
20571: LD_VAR 0 9
20575: PPUSH
20576: LD_VAR 0 8
20580: PPUSH
20581: CALL_OW 1
20585: ST_TO_ADDR
// end else
20586: GO 21392
// case GetType ( IsInUnit ( ai_building_constructor [ base ] ) ) of unit_building :
20588: LD_EXP 44
20592: PUSH
20593: LD_VAR 0 9
20597: ARRAY
20598: PPUSH
20599: CALL_OW 310
20603: PPUSH
20604: CALL_OW 247
20608: PUSH
20609: LD_INT 3
20611: DOUBLE
20612: EQUAL
20613: IFTRUE 20617
20615: GO 20635
20617: POP
// ComExitBuilding ( ai_building_constructor [ base ] ) ; unit_vehicle :
20618: LD_EXP 44
20622: PUSH
20623: LD_VAR 0 9
20627: ARRAY
20628: PPUSH
20629: CALL_OW 122
20633: GO 21392
20635: LD_INT 2
20637: DOUBLE
20638: EQUAL
20639: IFTRUE 20643
20641: GO 20661
20643: POP
// ComExitVehicle ( ai_building_constructor [ base ] ) ; else
20644: LD_EXP 44
20648: PUSH
20649: LD_VAR 0 9
20653: ARRAY
20654: PPUSH
20655: CALL_OW 121
20659: GO 21392
20661: POP
// case GetBType ( HexInfo ( ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] ) ) of - 1 :
20662: LD_EXP 46
20666: PUSH
20667: LD_VAR 0 9
20671: ARRAY
20672: PUSH
20673: LD_INT 1
20675: ARRAY
20676: PPUSH
20677: LD_EXP 46
20681: PUSH
20682: LD_VAR 0 9
20686: ARRAY
20687: PUSH
20688: LD_INT 2
20690: ARRAY
20691: PPUSH
20692: CALL_OW 428
20696: PPUSH
20697: CALL_OW 266
20701: PUSH
20702: LD_INT 1
20704: NEG
20705: DOUBLE
20706: EQUAL
20707: IFTRUE 20711
20709: GO 20897
20711: POP
// begin case ai_upcoming_building_data [ base ] [ 4 ] of b_warehouse :
20712: LD_EXP 46
20716: PUSH
20717: LD_VAR 0 9
20721: ARRAY
20722: PUSH
20723: LD_INT 4
20725: ARRAY
20726: PUSH
20727: LD_INT 1
20729: DOUBLE
20730: EQUAL
20731: IFTRUE 20735
20733: GO 20746
20735: POP
// i = b_depot ; b_factory :
20736: LD_ADDR_VAR 0 2
20740: PUSH
20741: LD_INT 0
20743: ST_TO_ADDR
20744: GO 20830
20746: LD_INT 3
20748: DOUBLE
20749: EQUAL
20750: IFTRUE 20754
20752: GO 20765
20754: POP
// i = b_workshop ; b_lab_half , b_lab_full :
20755: LD_ADDR_VAR 0 2
20759: PUSH
20760: LD_INT 2
20762: ST_TO_ADDR
20763: GO 20830
20765: LD_INT 7
20767: DOUBLE
20768: EQUAL
20769: IFTRUE 20779
20771: LD_INT 8
20773: DOUBLE
20774: EQUAL
20775: IFTRUE 20779
20777: GO 20790
20779: POP
// i = b_lab ; b_barracks :
20780: LD_ADDR_VAR 0 2
20784: PUSH
20785: LD_INT 6
20787: ST_TO_ADDR
20788: GO 20830
20790: LD_INT 5
20792: DOUBLE
20793: EQUAL
20794: IFTRUE 20798
20796: GO 20809
20798: POP
// i = b_armoury ; else
20799: LD_ADDR_VAR 0 2
20803: PUSH
20804: LD_INT 4
20806: ST_TO_ADDR
20807: GO 20830
20809: POP
// i = ai_upcoming_building_data [ base ] [ 4 ] ; end ;
20810: LD_ADDR_VAR 0 2
20814: PUSH
20815: LD_EXP 46
20819: PUSH
20820: LD_VAR 0 9
20824: ARRAY
20825: PUSH
20826: LD_INT 4
20828: ARRAY
20829: ST_TO_ADDR
// ComBuild ( ai_building_constructor [ base ] , i , ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] , ai_upcoming_building_data [ base ] [ 3 ] ) ;
20830: LD_EXP 44
20834: PUSH
20835: LD_VAR 0 9
20839: ARRAY
20840: PPUSH
20841: LD_VAR 0 2
20845: PPUSH
20846: LD_EXP 46
20850: PUSH
20851: LD_VAR 0 9
20855: ARRAY
20856: PUSH
20857: LD_INT 1
20859: ARRAY
20860: PPUSH
20861: LD_EXP 46
20865: PUSH
20866: LD_VAR 0 9
20870: ARRAY
20871: PUSH
20872: LD_INT 2
20874: ARRAY
20875: PPUSH
20876: LD_EXP 46
20880: PUSH
20881: LD_VAR 0 9
20885: ARRAY
20886: PUSH
20887: LD_INT 3
20889: ARRAY
20890: PPUSH
20891: CALL_OW 145
// end ; b_depot :
20895: GO 21392
20897: LD_INT 0
20899: DOUBLE
20900: EQUAL
20901: IFTRUE 20905
20903: GO 20954
20905: POP
// begin ComUpgrade ( ai_depot [ base ] ) ;
20906: LD_EXP 32
20910: PUSH
20911: LD_VAR 0 9
20915: ARRAY
20916: PPUSH
20917: CALL_OW 146
// ai_building_under_construction = Replace ( ai_building_under_construction , base , ai_depot [ base ] ) ;
20921: LD_ADDR_EXP 41
20925: PUSH
20926: LD_EXP 41
20930: PPUSH
20931: LD_VAR 0 9
20935: PPUSH
20936: LD_EXP 32
20940: PUSH
20941: LD_VAR 0 9
20945: ARRAY
20946: PPUSH
20947: CALL_OW 1
20951: ST_TO_ADDR
// end ; b_workshop :
20952: GO 21392
20954: LD_INT 2
20956: DOUBLE
20957: EQUAL
20958: IFTRUE 20962
20960: GO 21039
20962: POP
// begin temp_unit = HexInfo ( ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] ) ;
20963: LD_ADDR_VAR 0 6
20967: PUSH
20968: LD_EXP 46
20972: PUSH
20973: LD_VAR 0 9
20977: ARRAY
20978: PUSH
20979: LD_INT 1
20981: ARRAY
20982: PPUSH
20983: LD_EXP 46
20987: PUSH
20988: LD_VAR 0 9
20992: ARRAY
20993: PUSH
20994: LD_INT 2
20996: ARRAY
20997: PPUSH
20998: CALL_OW 428
21002: ST_TO_ADDR
// ComUpgrade ( temp_unit ) ;
21003: LD_VAR 0 6
21007: PPUSH
21008: CALL_OW 146
// ai_building_under_construction = Replace ( ai_building_under_construction , base , temp_unit ) ;
21012: LD_ADDR_EXP 41
21016: PUSH
21017: LD_EXP 41
21021: PPUSH
21022: LD_VAR 0 9
21026: PPUSH
21027: LD_VAR 0 6
21031: PPUSH
21032: CALL_OW 1
21036: ST_TO_ADDR
// end ; b_lab , b_lab_half :
21037: GO 21392
21039: LD_INT 6
21041: DOUBLE
21042: EQUAL
21043: IFTRUE 21053
21045: LD_INT 7
21047: DOUBLE
21048: EQUAL
21049: IFTRUE 21053
21051: GO 21306
21053: POP
// begin temp_unit = HexInfo ( ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] ) ;
21054: LD_ADDR_VAR 0 6
21058: PUSH
21059: LD_EXP 46
21063: PUSH
21064: LD_VAR 0 9
21068: ARRAY
21069: PUSH
21070: LD_INT 1
21072: ARRAY
21073: PPUSH
21074: LD_EXP 46
21078: PUSH
21079: LD_VAR 0 9
21083: ARRAY
21084: PUSH
21085: LD_INT 2
21087: ARRAY
21088: PPUSH
21089: CALL_OW 428
21093: ST_TO_ADDR
// if ai_upcoming_building_data [ base ] [ 5 ] <> b_lab_basic and not ai_upcoming_building_data [ base ] [ 5 ] in [ GetLabKind ( temp_unit , 1 ) , GetLabKind ( temp_unit , 2 ) ] then
21094: LD_EXP 46
21098: PUSH
21099: LD_VAR 0 9
21103: ARRAY
21104: PUSH
21105: LD_INT 5
21107: ARRAY
21108: PUSH
21109: LD_INT 9
21111: NONEQUAL
21112: PUSH
21113: LD_EXP 46
21117: PUSH
21118: LD_VAR 0 9
21122: ARRAY
21123: PUSH
21124: LD_INT 5
21126: ARRAY
21127: PUSH
21128: LD_VAR 0 6
21132: PPUSH
21133: LD_INT 1
21135: PPUSH
21136: CALL_OW 268
21140: PUSH
21141: LD_VAR 0 6
21145: PPUSH
21146: LD_INT 2
21148: PPUSH
21149: CALL_OW 268
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: IN
21158: NOT
21159: AND
21160: IFFALSE 21188
// ComUpgradeLab ( temp_unit , ai_upcoming_building_data [ base ] [ 5 ] ) else
21162: LD_VAR 0 6
21166: PPUSH
21167: LD_EXP 46
21171: PUSH
21172: LD_VAR 0 9
21176: ARRAY
21177: PUSH
21178: LD_INT 5
21180: ARRAY
21181: PPUSH
21182: CALL_OW 147
21186: GO 21279
// if ai_upcoming_building_data [ base ] [ 6 ] <> b_lab_basic then
21188: LD_EXP 46
21192: PUSH
21193: LD_VAR 0 9
21197: ARRAY
21198: PUSH
21199: LD_INT 6
21201: ARRAY
21202: PUSH
21203: LD_INT 9
21205: NONEQUAL
21206: IFFALSE 21234
// ComUpgradeLab ( temp_unit , ai_upcoming_building_data [ base ] [ 6 ] ) else
21208: LD_VAR 0 6
21212: PPUSH
21213: LD_EXP 46
21217: PUSH
21218: LD_VAR 0 9
21222: ARRAY
21223: PUSH
21224: LD_INT 6
21226: ARRAY
21227: PPUSH
21228: CALL_OW 147
21232: GO 21279
// begin ai_building_constructor = Replace ( ai_building_constructor , base , 0 ) ;
21234: LD_ADDR_EXP 44
21238: PUSH
21239: LD_EXP 44
21243: PPUSH
21244: LD_VAR 0 9
21248: PPUSH
21249: LD_INT 0
21251: PPUSH
21252: CALL_OW 1
21256: ST_TO_ADDR
// ai_upcoming_building_data = Replace ( ai_upcoming_building_data , base , [ ] ) ;
21257: LD_ADDR_EXP 46
21261: PUSH
21262: LD_EXP 46
21266: PPUSH
21267: LD_VAR 0 9
21271: PPUSH
21272: EMPTY
21273: PPUSH
21274: CALL_OW 1
21278: ST_TO_ADDR
// end ; ai_building_under_construction = Replace ( ai_building_under_construction , base , temp_unit ) ;
21279: LD_ADDR_EXP 41
21283: PUSH
21284: LD_EXP 41
21288: PPUSH
21289: LD_VAR 0 9
21293: PPUSH
21294: LD_VAR 0 6
21298: PPUSH
21299: CALL_OW 1
21303: ST_TO_ADDR
// end ; b_armoury :
21304: GO 21392
21306: LD_INT 4
21308: DOUBLE
21309: EQUAL
21310: IFTRUE 21314
21312: GO 21391
21314: POP
// begin temp_unit = HexInfo ( ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] ) ;
21315: LD_ADDR_VAR 0 6
21319: PUSH
21320: LD_EXP 46
21324: PUSH
21325: LD_VAR 0 9
21329: ARRAY
21330: PUSH
21331: LD_INT 1
21333: ARRAY
21334: PPUSH
21335: LD_EXP 46
21339: PUSH
21340: LD_VAR 0 9
21344: ARRAY
21345: PUSH
21346: LD_INT 2
21348: ARRAY
21349: PPUSH
21350: CALL_OW 428
21354: ST_TO_ADDR
// ComUpgrade ( temp_unit ) ;
21355: LD_VAR 0 6
21359: PPUSH
21360: CALL_OW 146
// ai_building_under_construction = Replace ( ai_building_under_construction , base , temp_unit ) ;
21364: LD_ADDR_EXP 41
21368: PUSH
21369: LD_EXP 41
21373: PPUSH
21374: LD_VAR 0 9
21378: PPUSH
21379: LD_VAR 0 6
21383: PPUSH
21384: CALL_OW 1
21388: ST_TO_ADDR
// end ; end ; end ;
21389: GO 21392
21391: POP
// end else
21392: GO 21652
// if UnitsInside ( ai_vehicle_being_moved [ base ] ) > 0 then
21394: LD_EXP 45
21398: PUSH
21399: LD_VAR 0 9
21403: ARRAY
21404: PPUSH
21405: CALL_OW 313
21409: PUSH
21410: LD_INT 0
21412: GREATER
21413: IFFALSE 21552
// begin if GetDistUnitXY ( ai_vehicle_being_moved [ base ] , ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] ) <= away_dist then
21415: LD_EXP 45
21419: PUSH
21420: LD_VAR 0 9
21424: ARRAY
21425: PPUSH
21426: LD_EXP 46
21430: PUSH
21431: LD_VAR 0 9
21435: ARRAY
21436: PUSH
21437: LD_INT 1
21439: ARRAY
21440: PPUSH
21441: LD_EXP 46
21445: PUSH
21446: LD_VAR 0 9
21450: ARRAY
21451: PUSH
21452: LD_INT 2
21454: ARRAY
21455: PPUSH
21456: CALL_OW 297
21460: PUSH
21461: LD_VAR 0 7
21465: LESSEQUAL
21466: IFFALSE 21527
// AI_GetAwayFromXY ( ai_vehicle_being_moved [ base ] , ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] , away_dist + 2 , false ) else
21468: LD_EXP 45
21472: PUSH
21473: LD_VAR 0 9
21477: ARRAY
21478: PPUSH
21479: LD_EXP 46
21483: PUSH
21484: LD_VAR 0 9
21488: ARRAY
21489: PUSH
21490: LD_INT 1
21492: ARRAY
21493: PPUSH
21494: LD_EXP 46
21498: PUSH
21499: LD_VAR 0 9
21503: ARRAY
21504: PUSH
21505: LD_INT 2
21507: ARRAY
21508: PPUSH
21509: LD_VAR 0 7
21513: PUSH
21514: LD_INT 2
21516: PLUS
21517: PPUSH
21518: LD_INT 0
21520: PPUSH
21521: CALL 32383 0 5
21525: GO 21550
// ai_vehicle_being_moved = Replace ( ai_vehicle_being_moved , base , 0 ) ;
21527: LD_ADDR_EXP 45
21531: PUSH
21532: LD_EXP 45
21536: PPUSH
21537: LD_VAR 0 9
21541: PPUSH
21542: LD_INT 0
21544: PPUSH
21545: CALL_OW 1
21549: ST_TO_ADDR
// end else
21550: GO 21652
// case GetType ( IsInUnit ( ai_building_constructor [ base ] ) ) of unit_building :
21552: LD_EXP 44
21556: PUSH
21557: LD_VAR 0 9
21561: ARRAY
21562: PPUSH
21563: CALL_OW 310
21567: PPUSH
21568: CALL_OW 247
21572: PUSH
21573: LD_INT 3
21575: DOUBLE
21576: EQUAL
21577: IFTRUE 21581
21579: GO 21599
21581: POP
// ComExitBuilding ( ai_building_constructor [ base ] ) ; unit_vehicle :
21582: LD_EXP 44
21586: PUSH
21587: LD_VAR 0 9
21591: ARRAY
21592: PPUSH
21593: CALL_OW 122
21597: GO 21652
21599: LD_INT 2
21601: DOUBLE
21602: EQUAL
21603: IFTRUE 21607
21605: GO 21625
21607: POP
// ComExitVehicle ( ai_building_constructor [ base ] ) ; else
21608: LD_EXP 44
21612: PUSH
21613: LD_VAR 0 9
21617: ARRAY
21618: PPUSH
21619: CALL_OW 121
21623: GO 21652
21625: POP
// ComEnterUnit ( ai_building_constructor [ base ] , ai_vehicle_being_moved [ base ] ) ; end ;
21626: LD_EXP 44
21630: PUSH
21631: LD_VAR 0 9
21635: ARRAY
21636: PPUSH
21637: LD_EXP 45
21641: PUSH
21642: LD_VAR 0 9
21646: ARRAY
21647: PPUSH
21648: CALL_OW 120
// end ; end ; end ; free_parking_spots = [ ] ;
21652: LD_ADDR_VAR 0 12
21656: PUSH
21657: EMPTY
21658: ST_TO_ADDR
// temp_list_2 = [ ] ;
21659: LD_ADDR_VAR 0 8
21663: PUSH
21664: EMPTY
21665: ST_TO_ADDR
// for i in cargo_bay_parking_spots do
21666: LD_ADDR_VAR 0 2
21670: PUSH
21671: LD_EXP 73
21675: PUSH
21676: FOR_IN
21677: IFFALSE 21788
// begin temp_unit = HexInfo ( i [ 1 ] , i [ 2 ] ) ;
21679: LD_ADDR_VAR 0 6
21683: PUSH
21684: LD_VAR 0 2
21688: PUSH
21689: LD_INT 1
21691: ARRAY
21692: PPUSH
21693: LD_VAR 0 2
21697: PUSH
21698: LD_INT 2
21700: ARRAY
21701: PPUSH
21702: CALL_OW 428
21706: ST_TO_ADDR
// if GetType ( temp_unit ) <> unit_vehicle then
21707: LD_VAR 0 6
21711: PPUSH
21712: CALL_OW 247
21716: PUSH
21717: LD_INT 2
21719: NONEQUAL
21720: IFFALSE 21747
// free_parking_spots = Insert ( free_parking_spots , 1 , i ) else
21722: LD_ADDR_VAR 0 12
21726: PUSH
21727: LD_VAR 0 12
21731: PPUSH
21732: LD_INT 1
21734: PPUSH
21735: LD_VAR 0 2
21739: PPUSH
21740: CALL_OW 2
21744: ST_TO_ADDR
21745: GO 21786
// begin temp_list_2 = temp_list_2 ^ temp_unit ;
21747: LD_ADDR_VAR 0 8
21751: PUSH
21752: LD_VAR 0 8
21756: PUSH
21757: LD_VAR 0 6
21761: ADD
21762: ST_TO_ADDR
// engineers_vehicles_to_move_drivers = Replace ( engineers_vehicles_to_move_drivers , temp_unit , 0 ) ;
21763: LD_ADDR_EXP 90
21767: PUSH
21768: LD_EXP 90
21772: PPUSH
21773: LD_VAR 0 6
21777: PPUSH
21778: LD_INT 0
21780: PPUSH
21781: CALL_OW 1
21785: ST_TO_ADDR
// end ; end ;
21786: GO 21676
21788: POP
21789: POP
// temp_list_2 = FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] , [ f_ok ] , [ f_inarea , ru_base_area ] ] ) diff temp_list_2 ;
21790: LD_ADDR_VAR 0 8
21794: PUSH
21795: LD_INT 21
21797: PUSH
21798: LD_INT 2
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: PUSH
21805: LD_INT 34
21807: PUSH
21808: LD_INT 51
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: PUSH
21815: LD_INT 50
21817: PUSH
21818: EMPTY
21819: LIST
21820: PUSH
21821: LD_INT 95
21823: PUSH
21824: LD_INT 2
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: EMPTY
21832: LIST
21833: LIST
21834: LIST
21835: LIST
21836: PPUSH
21837: CALL_OW 69
21841: PUSH
21842: LD_VAR 0 8
21846: DIFF
21847: ST_TO_ADDR
// i = IsInUnit ( Heike ) ;
21848: LD_ADDR_VAR 0 2
21852: PUSH
21853: LD_EXP 7
21857: PPUSH
21858: CALL_OW 310
21862: ST_TO_ADDR
// if i > 0 then
21863: LD_VAR 0 2
21867: PUSH
21868: LD_INT 0
21870: GREATER
21871: IFFALSE 21912
// begin temp_list_2 = temp_list_2 diff i ;
21873: LD_ADDR_VAR 0 8
21877: PUSH
21878: LD_VAR 0 8
21882: PUSH
21883: LD_VAR 0 2
21887: DIFF
21888: ST_TO_ADDR
// engineers_vehicles_to_move_drivers = Replace ( engineers_vehicles_to_move_drivers , i , 0 ) ;
21889: LD_ADDR_EXP 90
21893: PUSH
21894: LD_EXP 90
21898: PPUSH
21899: LD_VAR 0 2
21903: PPUSH
21904: LD_INT 0
21906: PPUSH
21907: CALL_OW 1
21911: ST_TO_ADDR
// end ; temp_list_2 = temp_list_2 diff dont_park_cargo_bay ;
21912: LD_ADDR_VAR 0 8
21916: PUSH
21917: LD_VAR 0 8
21921: PUSH
21922: LD_EXP 107
21926: DIFF
21927: ST_TO_ADDR
// cargo_bays_being_moved = temp_list_2 ;
21928: LD_ADDR_EXP 123
21932: PUSH
21933: LD_VAR 0 8
21937: ST_TO_ADDR
// for i in UnitFilter ( temp_list_2 , [ f_empty ] ) do
21938: LD_ADDR_VAR 0 2
21942: PUSH
21943: LD_VAR 0 8
21947: PPUSH
21948: LD_INT 58
21950: PUSH
21951: EMPTY
21952: LIST
21953: PPUSH
21954: CALL_OW 72
21958: PUSH
21959: FOR_IN
21960: IFFALSE 22194
// begin k = false ;
21962: LD_ADDR_VAR 0 13
21966: PUSH
21967: LD_INT 0
21969: ST_TO_ADDR
// if engineers_vehicles_to_move_drivers < i then
21970: LD_EXP 90
21974: PUSH
21975: LD_VAR 0 2
21979: LESS
21980: IFFALSE 21992
// k = true else
21982: LD_ADDR_VAR 0 13
21986: PUSH
21987: LD_INT 1
21989: ST_TO_ADDR
21990: GO 22019
// if not engineers_vehicles_to_move_drivers [ i ] in engineers_list then
21992: LD_EXP 90
21996: PUSH
21997: LD_VAR 0 2
22001: ARRAY
22002: PUSH
22003: LD_VAR 0 3
22007: IN
22008: NOT
22009: IFFALSE 22019
// k = true ;
22011: LD_ADDR_VAR 0 13
22015: PUSH
22016: LD_INT 1
22018: ST_TO_ADDR
// if k then
22019: LD_VAR 0 13
22023: IFFALSE 22060
// engineers_vehicles_to_move_drivers = Replace ( engineers_vehicles_to_move_drivers , i , AllNearestUnitToUnit ( engineers_list , i ) ) ;
22025: LD_ADDR_EXP 90
22029: PUSH
22030: LD_EXP 90
22034: PPUSH
22035: LD_VAR 0 2
22039: PPUSH
22040: LD_VAR 0 3
22044: PPUSH
22045: LD_VAR 0 2
22049: PPUSH
22050: CALL_OW 75
22054: PPUSH
22055: CALL_OW 1
22059: ST_TO_ADDR
// if engineers_vehicles_to_move_drivers [ i ] > 0 then
22060: LD_EXP 90
22064: PUSH
22065: LD_VAR 0 2
22069: ARRAY
22070: PUSH
22071: LD_INT 0
22073: GREATER
22074: IFFALSE 22192
// begin temp_unit = IsInUnit ( engineers_vehicles_to_move_drivers [ i ] ) ;
22076: LD_ADDR_VAR 0 6
22080: PUSH
22081: LD_EXP 90
22085: PUSH
22086: LD_VAR 0 2
22090: ARRAY
22091: PPUSH
22092: CALL_OW 310
22096: ST_TO_ADDR
// if temp_unit <> i then
22097: LD_VAR 0 6
22101: PUSH
22102: LD_VAR 0 2
22106: NONEQUAL
22107: IFFALSE 22192
// case GetType ( temp_unit ) of unit_vehicle :
22109: LD_VAR 0 6
22113: PPUSH
22114: CALL_OW 247
22118: PUSH
22119: LD_INT 2
22121: DOUBLE
22122: EQUAL
22123: IFTRUE 22127
22125: GO 22145
22127: POP
// ComExitVehicle ( engineers_vehicles_to_move_drivers [ i ] ) ; unit_building :
22128: LD_EXP 90
22132: PUSH
22133: LD_VAR 0 2
22137: ARRAY
22138: PPUSH
22139: CALL_OW 121
22143: GO 22192
22145: LD_INT 3
22147: DOUBLE
22148: EQUAL
22149: IFTRUE 22153
22151: GO 22171
22153: POP
// ComExitBuilding ( engineers_vehicles_to_move_drivers [ i ] ) ; else
22154: LD_EXP 90
22158: PUSH
22159: LD_VAR 0 2
22163: ARRAY
22164: PPUSH
22165: CALL_OW 122
22169: GO 22192
22171: POP
// ComEnterUnit ( engineers_vehicles_to_move_drivers [ i ] , i ) ; end ;
22172: LD_EXP 90
22176: PUSH
22177: LD_VAR 0 2
22181: ARRAY
22182: PPUSH
22183: LD_VAR 0 2
22187: PPUSH
22188: CALL_OW 120
// end ; end ;
22192: GO 21959
22194: POP
22195: POP
// for i in engineers_vehicles_to_move_drivers do
22196: LD_ADDR_VAR 0 2
22200: PUSH
22201: LD_EXP 90
22205: PUSH
22206: FOR_IN
22207: IFFALSE 22237
// if i > 0 then
22209: LD_VAR 0 2
22213: PUSH
22214: LD_INT 0
22216: GREATER
22217: IFFALSE 22235
// engineers_list = engineers_list diff i ;
22219: LD_ADDR_VAR 0 3
22223: PUSH
22224: LD_VAR 0 3
22228: PUSH
22229: LD_VAR 0 2
22233: DIFF
22234: ST_TO_ADDR
22235: GO 22206
22237: POP
22238: POP
// for i in temp_list_2 do
22239: LD_ADDR_VAR 0 2
22243: PUSH
22244: LD_VAR 0 8
22248: PUSH
22249: FOR_IN
22250: IFFALSE 22397
// if free_parking_spots > 0 then
22252: LD_VAR 0 12
22256: PUSH
22257: LD_INT 0
22259: GREATER
22260: IFFALSE 22393
// begin temp_list = [ ] ;
22262: LD_ADDR_VAR 0 4
22266: PUSH
22267: EMPTY
22268: ST_TO_ADDR
// for k in free_parking_spots do
22269: LD_ADDR_VAR 0 13
22273: PUSH
22274: LD_VAR 0 12
22278: PUSH
22279: FOR_IN
22280: IFFALSE 22323
// temp_list = temp_list ^ GetDistUnitXY ( i , k [ 1 ] , k [ 2 ] ) ;
22282: LD_ADDR_VAR 0 4
22286: PUSH
22287: LD_VAR 0 4
22291: PUSH
22292: LD_VAR 0 2
22296: PPUSH
22297: LD_VAR 0 13
22301: PUSH
22302: LD_INT 1
22304: ARRAY
22305: PPUSH
22306: LD_VAR 0 13
22310: PUSH
22311: LD_INT 2
22313: ARRAY
22314: PPUSH
22315: CALL_OW 297
22319: ADD
22320: ST_TO_ADDR
22321: GO 22279
22323: POP
22324: POP
// temp_list = WorstFromListByList ( free_parking_spots , temp_list ) ;
22325: LD_ADDR_VAR 0 4
22329: PUSH
22330: LD_VAR 0 12
22334: PPUSH
22335: LD_VAR 0 4
22339: PPUSH
22340: CALL_OW 78
22344: ST_TO_ADDR
// ComMoveXY ( i , temp_list [ 1 ] , temp_list [ 2 ] ) ;
22345: LD_VAR 0 2
22349: PPUSH
22350: LD_VAR 0 4
22354: PUSH
22355: LD_INT 1
22357: ARRAY
22358: PPUSH
22359: LD_VAR 0 4
22363: PUSH
22364: LD_INT 2
22366: ARRAY
22367: PPUSH
22368: CALL_OW 111
// free_parking_spots = free_parking_spots diff [ temp_list ] ;
22372: LD_ADDR_VAR 0 12
22376: PUSH
22377: LD_VAR 0 12
22381: PUSH
22382: LD_VAR 0 4
22386: PUSH
22387: EMPTY
22388: LIST
22389: DIFF
22390: ST_TO_ADDR
// end else
22391: GO 22395
// break ;
22393: GO 22397
22395: GO 22249
22397: POP
22398: POP
// end ; DistributeHumansToBuildings ( base , engineers_list ^ apemen_engineers_list , UnitFilter ( ai_depot [ base ] , [ [ f_ok ] , [ f_not , [ f_constructed ] ] ] ) , class_engineer , 6 , false , false ) ;
22399: LD_VAR 0 9
22403: PPUSH
22404: LD_VAR 0 3
22408: PUSH
22409: LD_VAR 0 10
22413: ADD
22414: PPUSH
22415: LD_EXP 32
22419: PUSH
22420: LD_VAR 0 9
22424: ARRAY
22425: PPUSH
22426: LD_INT 50
22428: PUSH
22429: EMPTY
22430: LIST
22431: PUSH
22432: LD_INT 3
22434: PUSH
22435: LD_INT 57
22437: PUSH
22438: EMPTY
22439: LIST
22440: PUSH
22441: EMPTY
22442: LIST
22443: LIST
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: PPUSH
22449: CALL_OW 72
22453: PPUSH
22454: LD_INT 2
22456: PPUSH
22457: LD_INT 6
22459: PPUSH
22460: LD_INT 0
22462: PPUSH
22463: LD_INT 0
22465: PPUSH
22466: CALL 18059 0 7
// end ;
22470: GO 18851
22472: POP
22473: POP
// until false ;
22474: LD_INT 0
22476: IFFALSE 18834
// end ;
22478: PPOPN 13
22480: END
// on BuildingStarted ( building , builder ) do var side , base ;
22481: LD_INT 0
22483: PPUSH
22484: PPUSH
// begin side = GetSide ( building ) ;
22485: LD_ADDR_VAR 0 3
22489: PUSH
22490: LD_VAR 0 1
22494: PPUSH
22495: CALL_OW 255
22499: ST_TO_ADDR
// if side <> russians then
22500: LD_VAR 0 3
22504: PUSH
22505: LD_EXP 3
22509: NONEQUAL
22510: IFFALSE 22514
// exit ;
22512: GO 22625
// base = FindBase ( building ) ;
22514: LD_ADDR_VAR 0 4
22518: PUSH
22519: LD_VAR 0 1
22523: PPUSH
22524: CALL 11648 0 1
22528: ST_TO_ADDR
// if base = 0 then
22529: LD_VAR 0 4
22533: PUSH
22534: LD_INT 0
22536: EQUAL
22537: IFFALSE 22541
// exit ;
22539: GO 22625
// ai_building_constructor = Replace ( ai_building_constructor , base , 0 ) ;
22541: LD_ADDR_EXP 44
22545: PUSH
22546: LD_EXP 44
22550: PPUSH
22551: LD_VAR 0 4
22555: PPUSH
22556: LD_INT 0
22558: PPUSH
22559: CALL_OW 1
22563: ST_TO_ADDR
// ai_vehicles_having_been_moved = Replace ( ai_vehicles_having_been_moved , base , [ ] ) ;
22564: LD_ADDR_EXP 67
22568: PUSH
22569: LD_EXP 67
22573: PPUSH
22574: LD_VAR 0 4
22578: PPUSH
22579: EMPTY
22580: PPUSH
22581: CALL_OW 1
22585: ST_TO_ADDR
// ai_building_under_construction = Replace ( ai_building_under_construction , base , building ) ;
22586: LD_ADDR_EXP 41
22590: PUSH
22591: LD_EXP 41
22595: PPUSH
22596: LD_VAR 0 4
22600: PPUSH
22601: LD_VAR 0 1
22605: PPUSH
22606: CALL_OW 1
22610: ST_TO_ADDR
// DoNotAttack ( you , building ) ;
22611: LD_EXP 2
22615: PPUSH
22616: LD_VAR 0 1
22620: PPUSH
22621: CALL_OW 471
// end ;
22625: PPOPN 4
22627: END
// on BuildingComplete ( building ) do var side , base , temp_list ;
22628: LD_INT 0
22630: PPUSH
22631: PPUSH
22632: PPUSH
// begin side = GetSide ( building ) ;
22633: LD_ADDR_VAR 0 2
22637: PUSH
22638: LD_VAR 0 1
22642: PPUSH
22643: CALL_OW 255
22647: ST_TO_ADDR
// if side <> russians then
22648: LD_VAR 0 2
22652: PUSH
22653: LD_EXP 3
22657: NONEQUAL
22658: IFFALSE 22662
// exit ;
22660: GO 22929
// base = FindBase ( building ) ;
22662: LD_ADDR_VAR 0 3
22666: PUSH
22667: LD_VAR 0 1
22671: PPUSH
22672: CALL 11648 0 1
22676: ST_TO_ADDR
// if base = 0 then
22677: LD_VAR 0 3
22681: PUSH
22682: LD_INT 0
22684: EQUAL
22685: IFFALSE 22689
// exit ;
22687: GO 22929
// BuildUpgradeCommon ( base , building ) ;
22689: LD_VAR 0 3
22693: PPUSH
22694: LD_VAR 0 1
22698: PPUSH
22699: CALL 23009 0 2
// temp_list = ai_all_buildings [ base ] ^ building ;
22703: LD_ADDR_VAR 0 4
22707: PUSH
22708: LD_EXP 43
22712: PUSH
22713: LD_VAR 0 3
22717: ARRAY
22718: PUSH
22719: LD_VAR 0 1
22723: ADD
22724: ST_TO_ADDR
// ai_all_buildings = Replace ( ai_all_buildings , base , temp_list ) ;
22725: LD_ADDR_EXP 43
22729: PUSH
22730: LD_EXP 43
22734: PPUSH
22735: LD_VAR 0 3
22739: PPUSH
22740: LD_VAR 0 4
22744: PPUSH
22745: CALL_OW 1
22749: ST_TO_ADDR
// if IsDead ( depot_north ) and GetBType ( building ) = b_depot and not ( GetX ( building ) = ai_buildings_locations [ 1 ] [ 1 ] [ 1 ] and GetY ( building ) = ai_buildings_locations [ 1 ] [ 1 ] [ 2 ] ) then
22750: LD_EXP 86
22754: PPUSH
22755: CALL_OW 301
22759: PUSH
22760: LD_VAR 0 1
22764: PPUSH
22765: CALL_OW 266
22769: PUSH
22770: LD_INT 0
22772: EQUAL
22773: AND
22774: PUSH
22775: LD_VAR 0 1
22779: PPUSH
22780: CALL_OW 250
22784: PUSH
22785: LD_EXP 36
22789: PUSH
22790: LD_INT 1
22792: ARRAY
22793: PUSH
22794: LD_INT 1
22796: ARRAY
22797: PUSH
22798: LD_INT 1
22800: ARRAY
22801: EQUAL
22802: PUSH
22803: LD_VAR 0 1
22807: PPUSH
22808: CALL_OW 251
22812: PUSH
22813: LD_EXP 36
22817: PUSH
22818: LD_INT 1
22820: ARRAY
22821: PUSH
22822: LD_INT 1
22824: ARRAY
22825: PUSH
22826: LD_INT 2
22828: ARRAY
22829: EQUAL
22830: AND
22831: NOT
22832: AND
22833: IFFALSE 22847
// depot_north = building else
22835: LD_ADDR_EXP 86
22839: PUSH
22840: LD_VAR 0 1
22844: ST_TO_ADDR
22845: GO 22929
// if IsDead ( leader_office ) and GetX ( building ) = leader_office_location [ 1 ] and GetY ( building ) = leader_office_location [ 2 ] then
22847: LD_EXP 93
22851: PPUSH
22852: CALL_OW 301
22856: PUSH
22857: LD_VAR 0 1
22861: PPUSH
22862: CALL_OW 250
22866: PUSH
22867: LD_EXP 94
22871: PUSH
22872: LD_INT 1
22874: ARRAY
22875: EQUAL
22876: AND
22877: PUSH
22878: LD_VAR 0 1
22882: PPUSH
22883: CALL_OW 251
22887: PUSH
22888: LD_EXP 94
22892: PUSH
22893: LD_INT 2
22895: ARRAY
22896: EQUAL
22897: AND
22898: IFFALSE 22912
// leader_office = building else
22900: LD_ADDR_EXP 93
22904: PUSH
22905: LD_VAR 0 1
22909: ST_TO_ADDR
22910: GO 22929
// UpdateBuildingBasicVariables ( base , building , true ) ;
22912: LD_VAR 0 3
22916: PPUSH
22917: LD_VAR 0 1
22921: PPUSH
22922: LD_INT 1
22924: PPUSH
22925: CALL 3976 0 3
// end ;
22929: PPOPN 4
22931: END
// on UpgradeComplete ( building ) do var side , base ;
22932: LD_INT 0
22934: PPUSH
22935: PPUSH
// begin side = GetSide ( building ) ;
22936: LD_ADDR_VAR 0 2
22940: PUSH
22941: LD_VAR 0 1
22945: PPUSH
22946: CALL_OW 255
22950: ST_TO_ADDR
// if side <> russians then
22951: LD_VAR 0 2
22955: PUSH
22956: LD_EXP 3
22960: NONEQUAL
22961: IFFALSE 22965
// exit ;
22963: GO 23006
// base = FindBase ( building ) ;
22965: LD_ADDR_VAR 0 3
22969: PUSH
22970: LD_VAR 0 1
22974: PPUSH
22975: CALL 11648 0 1
22979: ST_TO_ADDR
// if base = 0 then
22980: LD_VAR 0 3
22984: PUSH
22985: LD_INT 0
22987: EQUAL
22988: IFFALSE 22992
// exit ;
22990: GO 23006
// BuildUpgradeCommon ( base , building ) ;
22992: LD_VAR 0 3
22996: PPUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL 23009 0 2
// end ;
23006: PPOPN 3
23008: END
// function BuildUpgradeCommon ( base , building ) ; begin
23009: LD_INT 0
23011: PPUSH
// if GetBType ( building ) = ai_upcoming_building_data [ base ] [ 4 ] then
23012: LD_VAR 0 2
23016: PPUSH
23017: CALL_OW 266
23021: PUSH
23022: LD_EXP 46
23026: PUSH
23027: LD_VAR 0 1
23031: ARRAY
23032: PUSH
23033: LD_INT 4
23035: ARRAY
23036: EQUAL
23037: IFFALSE 23061
// ai_upcoming_building_data = Replace ( ai_upcoming_building_data , base , [ ] ) ;
23039: LD_ADDR_EXP 46
23043: PUSH
23044: LD_EXP 46
23048: PPUSH
23049: LD_VAR 0 1
23053: PPUSH
23054: EMPTY
23055: PPUSH
23056: CALL_OW 1
23060: ST_TO_ADDR
// ai_building_under_construction = Replace ( ai_building_under_construction , base , 0 ) ;
23061: LD_ADDR_EXP 41
23065: PUSH
23066: LD_EXP 41
23070: PPUSH
23071: LD_VAR 0 1
23075: PPUSH
23076: LD_INT 0
23078: PPUSH
23079: CALL_OW 1
23083: ST_TO_ADDR
// end ;
23084: LD_VAR 0 3
23088: RET
// on BuildingCaptured ( captured_building , building_former_side , capturing_unit ) do var temp_list , base ;
23089: LD_INT 0
23091: PPUSH
23092: PPUSH
// begin base = FindBase ( captured_building ) ;
23093: LD_ADDR_VAR 0 5
23097: PUSH
23098: LD_VAR 0 1
23102: PPUSH
23103: CALL 11648 0 1
23107: ST_TO_ADDR
// if base = 0 then
23108: LD_VAR 0 5
23112: PUSH
23113: LD_INT 0
23115: EQUAL
23116: IFFALSE 23120
// exit ;
23118: GO 23351
// if building_former_side = GetBaseSide ( base ) then
23120: LD_VAR 0 2
23124: PUSH
23125: LD_VAR 0 5
23129: PPUSH
23130: CALL 11664 0 1
23134: EQUAL
23135: IFFALSE 23218
// begin if captured_building in ai_all_buildings [ base ] then
23137: LD_VAR 0 1
23141: PUSH
23142: LD_EXP 43
23146: PUSH
23147: LD_VAR 0 5
23151: ARRAY
23152: IN
23153: IFFALSE 23216
// begin RemoveBuildingFromVariables ( base , captured_building ) ;
23155: LD_VAR 0 5
23159: PPUSH
23160: LD_VAR 0 1
23164: PPUSH
23165: CALL 10227 0 2
// temp_list = ai_captured_buildings [ base ] ^ captured_building ;
23169: LD_ADDR_VAR 0 4
23173: PUSH
23174: LD_EXP 69
23178: PUSH
23179: LD_VAR 0 5
23183: ARRAY
23184: PUSH
23185: LD_VAR 0 1
23189: ADD
23190: ST_TO_ADDR
// ai_captured_buildings = Replace ( ai_captured_buildings , base , temp_list ) ;
23191: LD_ADDR_EXP 69
23195: PUSH
23196: LD_EXP 69
23200: PPUSH
23201: LD_VAR 0 5
23205: PPUSH
23206: LD_VAR 0 4
23210: PPUSH
23211: CALL_OW 1
23215: ST_TO_ADDR
// end ; end else
23216: GO 23351
// begin if GetSide ( captured_building ) = GetBaseSide ( base ) then
23218: LD_VAR 0 1
23222: PPUSH
23223: CALL_OW 255
23227: PUSH
23228: LD_VAR 0 5
23232: PPUSH
23233: CALL 11664 0 1
23237: EQUAL
23238: IFFALSE 23351
// begin temp_list = ai_all_buildings [ base ] ^ captured_building ;
23240: LD_ADDR_VAR 0 4
23244: PUSH
23245: LD_EXP 43
23249: PUSH
23250: LD_VAR 0 5
23254: ARRAY
23255: PUSH
23256: LD_VAR 0 1
23260: ADD
23261: ST_TO_ADDR
// ai_all_buildings = Replace ( ai_all_buildings , base , temp_list ) ;
23262: LD_ADDR_EXP 43
23266: PUSH
23267: LD_EXP 43
23271: PPUSH
23272: LD_VAR 0 5
23276: PPUSH
23277: LD_VAR 0 4
23281: PPUSH
23282: CALL_OW 1
23286: ST_TO_ADDR
// UpdateBuildingBasicVariables ( base , captured_building , true ) ;
23287: LD_VAR 0 5
23291: PPUSH
23292: LD_VAR 0 1
23296: PPUSH
23297: LD_INT 1
23299: PPUSH
23300: CALL 3976 0 3
// temp_list = ai_captured_buildings [ base ] diff captured_building ;
23304: LD_ADDR_VAR 0 4
23308: PUSH
23309: LD_EXP 69
23313: PUSH
23314: LD_VAR 0 5
23318: ARRAY
23319: PUSH
23320: LD_VAR 0 1
23324: DIFF
23325: ST_TO_ADDR
// ai_captured_buildings = Replace ( ai_captured_buildings , base , temp_list ) ;
23326: LD_ADDR_EXP 69
23330: PUSH
23331: LD_EXP 69
23335: PPUSH
23336: LD_VAR 0 5
23340: PPUSH
23341: LD_VAR 0 4
23345: PPUSH
23346: CALL_OW 1
23350: ST_TO_ADDR
// end ; end ; end ;
23351: PPOPN 5
23353: END
// export function GetHumansOutOfUnits ( un_list ) ; var i ; begin
23354: LD_INT 0
23356: PPUSH
23357: PPUSH
// result = [ ] ;
23358: LD_ADDR_VAR 0 2
23362: PUSH
23363: EMPTY
23364: ST_TO_ADDR
// for i in un_list do
23365: LD_ADDR_VAR 0 3
23369: PUSH
23370: LD_VAR 0 1
23374: PUSH
23375: FOR_IN
23376: IFFALSE 23452
// case GetType ( IsInUnit ( i ) ) of unit_building :
23378: LD_VAR 0 3
23382: PPUSH
23383: CALL_OW 310
23387: PPUSH
23388: CALL_OW 247
23392: PUSH
23393: LD_INT 3
23395: DOUBLE
23396: EQUAL
23397: IFTRUE 23401
23399: GO 23413
23401: POP
// ComExitBuilding ( i ) ; unit_vehicle :
23402: LD_VAR 0 3
23406: PPUSH
23407: CALL_OW 122
23411: GO 23450
23413: LD_INT 2
23415: DOUBLE
23416: EQUAL
23417: IFTRUE 23421
23419: GO 23433
23421: POP
// ComExitVehicle ( i ) ; else
23422: LD_VAR 0 3
23426: PPUSH
23427: CALL_OW 121
23431: GO 23450
23433: POP
// result = result ^ i ; end ;
23434: LD_ADDR_VAR 0 2
23438: PUSH
23439: LD_VAR 0 2
23443: PUSH
23444: LD_VAR 0 3
23448: ADD
23449: ST_TO_ADDR
23450: GO 23375
23452: POP
23453: POP
// end ;
23454: LD_VAR 0 2
23458: RET
// every 0 0$1 do var side , base , i , mechanics_list , temp_list , temp_list_3 , temp_unit , vehicles_list , allowed_to_repair_vehicles ; var under_attack , free_parking_spots , k , vehicles_drivers , temp_list_2 ;
23459: GO 23461
23461: DISABLE
23462: LD_INT 0
23464: PPUSH
23465: PPUSH
23466: PPUSH
23467: PPUSH
23468: PPUSH
23469: PPUSH
23470: PPUSH
23471: PPUSH
23472: PPUSH
23473: PPUSH
23474: PPUSH
23475: PPUSH
23476: PPUSH
23477: PPUSH
// begin side = russians ;
23478: LD_ADDR_VAR 0 1
23482: PUSH
23483: LD_EXP 3
23487: ST_TO_ADDR
// vehicles_drivers = [ ] ;
23488: LD_ADDR_VAR 0 13
23492: PUSH
23493: EMPTY
23494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23495: LD_INT 35
23497: PPUSH
23498: CALL_OW 67
// for base in ai_bases do
23502: LD_ADDR_VAR 0 2
23506: PUSH
23507: LD_EXP 57
23511: PUSH
23512: FOR_IN
23513: IFFALSE 26632
// begin under_attack = code_black ;
23515: LD_ADDR_VAR 0 10
23519: PUSH
23520: LD_EXP 77
23524: ST_TO_ADDR
// for i in ai_vehicles_defend [ base ] do
23525: LD_ADDR_VAR 0 3
23529: PUSH
23530: LD_EXP 37
23534: PUSH
23535: LD_VAR 0 2
23539: ARRAY
23540: PUSH
23541: FOR_IN
23542: IFFALSE 23637
// if vehicles_drivers >= i then
23544: LD_VAR 0 13
23548: PUSH
23549: LD_VAR 0 3
23553: GREATEREQUAL
23554: IFFALSE 23635
// if vehicles_drivers [ i ] > 0 then
23556: LD_VAR 0 13
23560: PUSH
23561: LD_VAR 0 3
23565: ARRAY
23566: PUSH
23567: LD_INT 0
23569: GREATER
23570: IFFALSE 23635
// if IsInUnit ( vehicles_drivers [ i ] ) = i or IsDead ( vehicles_drivers [ i ] ) then
23572: LD_VAR 0 13
23576: PUSH
23577: LD_VAR 0 3
23581: ARRAY
23582: PPUSH
23583: CALL_OW 310
23587: PUSH
23588: LD_VAR 0 3
23592: EQUAL
23593: PUSH
23594: LD_VAR 0 13
23598: PUSH
23599: LD_VAR 0 3
23603: ARRAY
23604: PPUSH
23605: CALL_OW 301
23609: OR
23610: IFFALSE 23635
// vehicles_drivers = Replace ( vehicles_drivers , i , 0 ) ;
23612: LD_ADDR_VAR 0 13
23616: PUSH
23617: LD_VAR 0 13
23621: PPUSH
23622: LD_VAR 0 3
23626: PPUSH
23627: LD_INT 0
23629: PPUSH
23630: CALL_OW 1
23634: ST_TO_ADDR
23635: GO 23541
23637: POP
23638: POP
// mechanics_list = UnitFilter ( ai_mechanics_defend [ base ] diff ai_heal_these_humans [ base ] , [ f_not , [ f_driving ] ] ) ;
23639: LD_ADDR_VAR 0 4
23643: PUSH
23644: LD_EXP 28
23648: PUSH
23649: LD_VAR 0 2
23653: ARRAY
23654: PUSH
23655: LD_EXP 42
23659: PUSH
23660: LD_VAR 0 2
23664: ARRAY
23665: DIFF
23666: PPUSH
23667: LD_INT 3
23669: PUSH
23670: LD_INT 55
23672: PUSH
23673: EMPTY
23674: LIST
23675: PUSH
23676: EMPTY
23677: LIST
23678: LIST
23679: PPUSH
23680: CALL_OW 72
23684: ST_TO_ADDR
// if except_Yakov then
23685: LD_EXP 111
23689: IFFALSE 23707
// mechanics_list = mechanics_list diff Yakov ;
23691: LD_ADDR_VAR 0 4
23695: PUSH
23696: LD_VAR 0 4
23700: PUSH
23701: LD_EXP 15
23705: DIFF
23706: ST_TO_ADDR
// temp_list = ai_heal_these_humans [ base ] ;
23707: LD_ADDR_VAR 0 5
23711: PUSH
23712: LD_EXP 42
23716: PUSH
23717: LD_VAR 0 2
23721: ARRAY
23722: ST_TO_ADDR
// i = 1 ;
23723: LD_ADDR_VAR 0 3
23727: PUSH
23728: LD_INT 1
23730: ST_TO_ADDR
// while i <= mechanics_list do
23731: LD_VAR 0 3
23735: PUSH
23736: LD_VAR 0 4
23740: LESSEQUAL
23741: IFFALSE 23824
// begin if GetLives ( mechanics_list [ i ] ) <= 900 then
23743: LD_VAR 0 4
23747: PUSH
23748: LD_VAR 0 3
23752: ARRAY
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 900
23761: LESSEQUAL
23762: IFFALSE 23808
// begin temp_list = temp_list ^ mechanics_list [ i ] ;
23764: LD_ADDR_VAR 0 5
23768: PUSH
23769: LD_VAR 0 5
23773: PUSH
23774: LD_VAR 0 4
23778: PUSH
23779: LD_VAR 0 3
23783: ARRAY
23784: ADD
23785: ST_TO_ADDR
// mechanics_list = Delete ( mechanics_list , i ) ;
23786: LD_ADDR_VAR 0 4
23790: PUSH
23791: LD_VAR 0 4
23795: PPUSH
23796: LD_VAR 0 3
23800: PPUSH
23801: CALL_OW 3
23805: ST_TO_ADDR
// continue ;
23806: GO 23731
// end ; i = i + 1 ;
23808: LD_ADDR_VAR 0 3
23812: PUSH
23813: LD_VAR 0 3
23817: PUSH
23818: LD_INT 1
23820: PLUS
23821: ST_TO_ADDR
// end ;
23822: GO 23731
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
23824: LD_ADDR_EXP 42
23828: PUSH
23829: LD_EXP 42
23833: PPUSH
23834: LD_VAR 0 2
23838: PPUSH
23839: LD_VAR 0 5
23843: PPUSH
23844: CALL_OW 1
23848: ST_TO_ADDR
// if not code_black and poker_mec in mechanics_list and IsOk ( ai_depot [ base ] ) then
23849: LD_EXP 77
23853: NOT
23854: PUSH
23855: LD_EXP 25
23859: PUSH
23860: LD_VAR 0 4
23864: IN
23865: AND
23866: PUSH
23867: LD_EXP 32
23871: PUSH
23872: LD_VAR 0 2
23876: ARRAY
23877: PPUSH
23878: CALL_OW 302
23882: AND
23883: IFFALSE 24005
// begin temp_unit = IsInUnit ( poker_mec ) ;
23885: LD_ADDR_VAR 0 7
23889: PUSH
23890: LD_EXP 25
23894: PPUSH
23895: CALL_OW 310
23899: ST_TO_ADDR
// case GetType ( temp_unit ) of unit_vehicle :
23900: LD_VAR 0 7
23904: PPUSH
23905: CALL_OW 247
23909: PUSH
23910: LD_INT 2
23912: DOUBLE
23913: EQUAL
23914: IFTRUE 23918
23916: GO 23930
23918: POP
// ComExitVehicle ( poker_mec ) ; unit_building :
23919: LD_EXP 25
23923: PPUSH
23924: CALL_OW 121
23928: GO 23989
23930: LD_INT 3
23932: DOUBLE
23933: EQUAL
23934: IFTRUE 23938
23936: GO 23968
23938: POP
// if temp_unit <> ai_depot [ base ] then
23939: LD_VAR 0 7
23943: PUSH
23944: LD_EXP 32
23948: PUSH
23949: LD_VAR 0 2
23953: ARRAY
23954: NONEQUAL
23955: IFFALSE 23966
// ComExitBuilding ( poker_mec ) ; else
23957: LD_EXP 25
23961: PPUSH
23962: CALL_OW 122
23966: GO 23989
23968: POP
// ComEnterUnit ( poker_mec , ai_depot [ base ] ) ; end ;
23969: LD_EXP 25
23973: PPUSH
23974: LD_EXP 32
23978: PUSH
23979: LD_VAR 0 2
23983: ARRAY
23984: PPUSH
23985: CALL_OW 120
// mechanics_list = mechanics_list diff poker_mec ;
23989: LD_ADDR_VAR 0 4
23993: PUSH
23994: LD_VAR 0 4
23998: PUSH
23999: LD_EXP 25
24003: DIFF
24004: ST_TO_ADDR
// end ; temp_list = [ ] ;
24005: LD_ADDR_VAR 0 5
24009: PUSH
24010: EMPTY
24011: ST_TO_ADDR
// for i in ai_vehicles_being_repaired [ base ] do
24012: LD_ADDR_VAR 0 3
24016: PUSH
24017: LD_EXP 55
24021: PUSH
24022: LD_VAR 0 2
24026: ARRAY
24027: PUSH
24028: FOR_IN
24029: IFFALSE 24064
// if GetLives ( i ) < 1000 then
24031: LD_VAR 0 3
24035: PPUSH
24036: CALL_OW 256
24040: PUSH
24041: LD_INT 1000
24043: LESS
24044: IFFALSE 24062
// temp_list = temp_list ^ i ;
24046: LD_ADDR_VAR 0 5
24050: PUSH
24051: LD_VAR 0 5
24055: PUSH
24056: LD_VAR 0 3
24060: ADD
24061: ST_TO_ADDR
24062: GO 24028
24064: POP
24065: POP
// ai_vehicles_being_repaired = Replace ( ai_vehicles_being_repaired , base , temp_list ) ;
24066: LD_ADDR_EXP 55
24070: PUSH
24071: LD_EXP 55
24075: PPUSH
24076: LD_VAR 0 2
24080: PPUSH
24081: LD_VAR 0 5
24085: PPUSH
24086: CALL_OW 1
24090: ST_TO_ADDR
// temp_list = [ ] ;
24091: LD_ADDR_VAR 0 5
24095: PUSH
24096: EMPTY
24097: ST_TO_ADDR
// for i in ai_retreating_vehicles_defend [ base ] diff ai_vehicles_being_repaired [ base ] do
24098: LD_ADDR_VAR 0 3
24102: PUSH
24103: LD_EXP 52
24107: PUSH
24108: LD_VAR 0 2
24112: ARRAY
24113: PUSH
24114: LD_EXP 55
24118: PUSH
24119: LD_VAR 0 2
24123: ARRAY
24124: DIFF
24125: PUSH
24126: FOR_IN
24127: IFFALSE 24162
// if GetLives ( i ) < 1000 then
24129: LD_VAR 0 3
24133: PPUSH
24134: CALL_OW 256
24138: PUSH
24139: LD_INT 1000
24141: LESS
24142: IFFALSE 24160
// temp_list = temp_list ^ i ;
24144: LD_ADDR_VAR 0 5
24148: PUSH
24149: LD_VAR 0 5
24153: PUSH
24154: LD_VAR 0 3
24158: ADD
24159: ST_TO_ADDR
24160: GO 24126
24162: POP
24163: POP
// ai_retreating_vehicles_defend = Replace ( ai_retreating_vehicles_defend , base , temp_list ) ;
24164: LD_ADDR_EXP 52
24168: PUSH
24169: LD_EXP 52
24173: PPUSH
24174: LD_VAR 0 2
24178: PPUSH
24179: LD_VAR 0 5
24183: PPUSH
24184: CALL_OW 1
24188: ST_TO_ADDR
// temp_list = ai_retreating_vehicles_defend [ base ] ;
24189: LD_ADDR_VAR 0 5
24193: PUSH
24194: LD_EXP 52
24198: PUSH
24199: LD_VAR 0 2
24203: ARRAY
24204: ST_TO_ADDR
// for i in ai_vehicles_defend [ base ] diff ( ai_retreating_vehicles_defend [ base ] ^ ai_vehicles_being_repaired [ base ] ) do
24205: LD_ADDR_VAR 0 3
24209: PUSH
24210: LD_EXP 37
24214: PUSH
24215: LD_VAR 0 2
24219: ARRAY
24220: PUSH
24221: LD_EXP 52
24225: PUSH
24226: LD_VAR 0 2
24230: ARRAY
24231: PUSH
24232: LD_EXP 55
24236: PUSH
24237: LD_VAR 0 2
24241: ARRAY
24242: ADD
24243: DIFF
24244: PUSH
24245: FOR_IN
24246: IFFALSE 24281
// if GetLives ( i ) <= 250 then
24248: LD_VAR 0 3
24252: PPUSH
24253: CALL_OW 256
24257: PUSH
24258: LD_INT 250
24260: LESSEQUAL
24261: IFFALSE 24279
// temp_list = temp_list ^ i ;
24263: LD_ADDR_VAR 0 5
24267: PUSH
24268: LD_VAR 0 5
24272: PUSH
24273: LD_VAR 0 3
24277: ADD
24278: ST_TO_ADDR
24279: GO 24245
24281: POP
24282: POP
// ai_retreating_vehicles_defend = Replace ( ai_retreating_vehicles_defend , base , temp_list ) ;
24283: LD_ADDR_EXP 52
24287: PUSH
24288: LD_EXP 52
24292: PPUSH
24293: LD_VAR 0 2
24297: PPUSH
24298: LD_VAR 0 5
24302: PPUSH
24303: CALL_OW 1
24307: ST_TO_ADDR
// temp_list = [ ] ;
24308: LD_ADDR_VAR 0 5
24312: PUSH
24313: EMPTY
24314: ST_TO_ADDR
// for i in ai_refuel_vehicles_list [ base ] diff ( ai_retreating_vehicles_defend [ base ] ^ ai_vehicles_being_repaired [ base ] ^ ai_vehicle_being_moved [ base ] ^ ai_vehicles_having_been_moved [ base ] ) do
24315: LD_ADDR_VAR 0 3
24319: PUSH
24320: LD_EXP 54
24324: PUSH
24325: LD_VAR 0 2
24329: ARRAY
24330: PUSH
24331: LD_EXP 52
24335: PUSH
24336: LD_VAR 0 2
24340: ARRAY
24341: PUSH
24342: LD_EXP 55
24346: PUSH
24347: LD_VAR 0 2
24351: ARRAY
24352: ADD
24353: PUSH
24354: LD_EXP 45
24358: PUSH
24359: LD_VAR 0 2
24363: ARRAY
24364: ADD
24365: PUSH
24366: LD_EXP 67
24370: PUSH
24371: LD_VAR 0 2
24375: ARRAY
24376: ADD
24377: DIFF
24378: PUSH
24379: FOR_IN
24380: IFFALSE 24415
// if GetFuel ( i ) < 95 then
24382: LD_VAR 0 3
24386: PPUSH
24387: CALL_OW 261
24391: PUSH
24392: LD_INT 95
24394: LESS
24395: IFFALSE 24413
// temp_list = temp_list ^ i ;
24397: LD_ADDR_VAR 0 5
24401: PUSH
24402: LD_VAR 0 5
24406: PUSH
24407: LD_VAR 0 3
24411: ADD
24412: ST_TO_ADDR
24413: GO 24379
24415: POP
24416: POP
// ai_refuel_vehicles_list = Replace ( ai_refuel_vehicles_list , base , temp_list ) ;
24417: LD_ADDR_EXP 54
24421: PUSH
24422: LD_EXP 54
24426: PPUSH
24427: LD_VAR 0 2
24431: PPUSH
24432: LD_VAR 0 5
24436: PPUSH
24437: CALL_OW 1
24441: ST_TO_ADDR
// if under_attack then
24442: LD_VAR 0 10
24446: IFFALSE 24636
// begin vehicles_list = ai_vehicles_defend [ base ] diff ( ai_retreating_vehicles_defend [ base ] ^ ai_vehicles_being_repaired [ base ] ^ ai_vehicle_being_moved [ base ] ^ ai_vehicles_having_been_moved [ base ] ) ;
24448: LD_ADDR_VAR 0 8
24452: PUSH
24453: LD_EXP 37
24457: PUSH
24458: LD_VAR 0 2
24462: ARRAY
24463: PUSH
24464: LD_EXP 52
24468: PUSH
24469: LD_VAR 0 2
24473: ARRAY
24474: PUSH
24475: LD_EXP 55
24479: PUSH
24480: LD_VAR 0 2
24484: ARRAY
24485: ADD
24486: PUSH
24487: LD_EXP 45
24491: PUSH
24492: LD_VAR 0 2
24496: ARRAY
24497: ADD
24498: PUSH
24499: LD_EXP 67
24503: PUSH
24504: LD_VAR 0 2
24508: ARRAY
24509: ADD
24510: DIFF
24511: ST_TO_ADDR
// temp_list = UnitFilter ( vehicles_list , [ [ f_control , control_manual ] , [ f_ok ] , [ f_empty ] , [ f_inarea , GetBaseArea ( base ) ] ] ) ;
24512: LD_ADDR_VAR 0 5
24516: PUSH
24517: LD_VAR 0 8
24521: PPUSH
24522: LD_INT 33
24524: PUSH
24525: LD_INT 1
24527: PUSH
24528: EMPTY
24529: LIST
24530: LIST
24531: PUSH
24532: LD_INT 50
24534: PUSH
24535: EMPTY
24536: LIST
24537: PUSH
24538: LD_INT 58
24540: PUSH
24541: EMPTY
24542: LIST
24543: PUSH
24544: LD_INT 95
24546: PUSH
24547: LD_VAR 0 2
24551: PPUSH
24552: CALL 11682 0 1
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: LIST
24565: LIST
24566: PPUSH
24567: CALL_OW 72
24571: ST_TO_ADDR
// temp_list = FindDriverHelper ( temp_list , mechanics_list , vehicles_drivers ) ;
24572: LD_ADDR_VAR 0 5
24576: PUSH
24577: LD_VAR 0 5
24581: PPUSH
24582: LD_VAR 0 4
24586: PPUSH
24587: LD_VAR 0 13
24591: PPUSH
24592: CALL 26641 0 3
24596: ST_TO_ADDR
// mechanics_list = temp_list [ 1 ] ;
24597: LD_ADDR_VAR 0 4
24601: PUSH
24602: LD_VAR 0 5
24606: PUSH
24607: LD_INT 1
24609: ARRAY
24610: ST_TO_ADDR
// vehicles_drivers = temp_list [ 2 ] ;
24611: LD_ADDR_VAR 0 13
24615: PUSH
24616: LD_VAR 0 5
24620: PUSH
24621: LD_INT 2
24623: ARRAY
24624: ST_TO_ADDR
// ControlCodeBlackUnits ( vehicles_list ) ;
24625: LD_VAR 0 8
24629: PPUSH
24630: CALL 14545 0 1
// end else
24634: GO 25012
// if IsOk ( ai_depot [ base ] ) then
24636: LD_EXP 32
24640: PUSH
24641: LD_VAR 0 2
24645: ARRAY
24646: PPUSH
24647: CALL_OW 302
24651: IFFALSE 25012
// begin temp_list = ai_refuel_vehicles_list [ base ] ;
24653: LD_ADDR_VAR 0 5
24657: PUSH
24658: LD_EXP 54
24662: PUSH
24663: LD_VAR 0 2
24667: ARRAY
24668: ST_TO_ADDR
// for i in ai_vehicles_defend [ base ] diff ai_refuel_vehicles_list [ base ] do
24669: LD_ADDR_VAR 0 3
24673: PUSH
24674: LD_EXP 37
24678: PUSH
24679: LD_VAR 0 2
24683: ARRAY
24684: PUSH
24685: LD_EXP 54
24689: PUSH
24690: LD_VAR 0 2
24694: ARRAY
24695: DIFF
24696: PUSH
24697: FOR_IN
24698: IFFALSE 24748
// if GetFuel ( i ) < 70 and GetEngine ( i ) = engine_combustion then
24700: LD_VAR 0 3
24704: PPUSH
24705: CALL_OW 261
24709: PUSH
24710: LD_INT 70
24712: LESS
24713: PUSH
24714: LD_VAR 0 3
24718: PPUSH
24719: CALL_OW 262
24723: PUSH
24724: LD_INT 1
24726: EQUAL
24727: AND
24728: IFFALSE 24746
// temp_list = temp_list ^ i ;
24730: LD_ADDR_VAR 0 5
24734: PUSH
24735: LD_VAR 0 5
24739: PUSH
24740: LD_VAR 0 3
24744: ADD
24745: ST_TO_ADDR
24746: GO 24697
24748: POP
24749: POP
// temp_list = temp_list diff ( ai_retreating_vehicles_defend [ base ] ^ ai_vehicles_being_repaired [ base ] ^ ai_vehicle_being_moved [ base ] ^ ai_vehicles_having_been_moved [ base ] ) ;
24750: LD_ADDR_VAR 0 5
24754: PUSH
24755: LD_VAR 0 5
24759: PUSH
24760: LD_EXP 52
24764: PUSH
24765: LD_VAR 0 2
24769: ARRAY
24770: PUSH
24771: LD_EXP 55
24775: PUSH
24776: LD_VAR 0 2
24780: ARRAY
24781: ADD
24782: PUSH
24783: LD_EXP 45
24787: PUSH
24788: LD_VAR 0 2
24792: ARRAY
24793: ADD
24794: PUSH
24795: LD_EXP 67
24799: PUSH
24800: LD_VAR 0 2
24804: ARRAY
24805: ADD
24806: DIFF
24807: ST_TO_ADDR
// ai_refuel_vehicles_list = Replace ( ai_refuel_vehicles_list , base , temp_list ) ;
24808: LD_ADDR_EXP 54
24812: PUSH
24813: LD_EXP 54
24817: PPUSH
24818: LD_VAR 0 2
24822: PPUSH
24823: LD_VAR 0 5
24827: PPUSH
24828: CALL_OW 1
24832: ST_TO_ADDR
// temp_list = UnitFilter ( ai_refuel_vehicles_list [ base ] , [ [ f_empty ] , [ f_ok ] ] ) ;
24833: LD_ADDR_VAR 0 5
24837: PUSH
24838: LD_EXP 54
24842: PUSH
24843: LD_VAR 0 2
24847: ARRAY
24848: PPUSH
24849: LD_INT 58
24851: PUSH
24852: EMPTY
24853: LIST
24854: PUSH
24855: LD_INT 50
24857: PUSH
24858: EMPTY
24859: LIST
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PPUSH
24865: CALL_OW 72
24869: ST_TO_ADDR
// temp_list_2 = mechanics_list diff [ Mikhail , Natalya ] ;
24870: LD_ADDR_VAR 0 14
24874: PUSH
24875: LD_VAR 0 4
24879: PUSH
24880: LD_EXP 17
24884: PUSH
24885: LD_EXP 16
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: DIFF
24894: ST_TO_ADDR
// temp_list = FindDriverHelper ( temp_list , temp_list_2 , vehicles_drivers ) ;
24895: LD_ADDR_VAR 0 5
24899: PUSH
24900: LD_VAR 0 5
24904: PPUSH
24905: LD_VAR 0 14
24909: PPUSH
24910: LD_VAR 0 13
24914: PPUSH
24915: CALL 26641 0 3
24919: ST_TO_ADDR
// mechanics_list = mechanics_list diff ( temp_list_2 diff temp_list [ 1 ] ) ;
24920: LD_ADDR_VAR 0 4
24924: PUSH
24925: LD_VAR 0 4
24929: PUSH
24930: LD_VAR 0 14
24934: PUSH
24935: LD_VAR 0 5
24939: PUSH
24940: LD_INT 1
24942: ARRAY
24943: DIFF
24944: DIFF
24945: ST_TO_ADDR
// vehicles_drivers = temp_list [ 2 ] ;
24946: LD_ADDR_VAR 0 13
24950: PUSH
24951: LD_VAR 0 5
24955: PUSH
24956: LD_INT 2
24958: ARRAY
24959: ST_TO_ADDR
// ComMoveUnit ( ai_refuel_vehicles_list [ base ] , ai_depot [ base ] ) ;
24960: LD_EXP 54
24964: PUSH
24965: LD_VAR 0 2
24969: ARRAY
24970: PPUSH
24971: LD_EXP 32
24975: PUSH
24976: LD_VAR 0 2
24980: ARRAY
24981: PPUSH
24982: CALL_OW 112
// AddComRefuel ( ai_refuel_vehicles_list [ base ] , ai_depot [ base ] ) ;
24986: LD_EXP 54
24990: PUSH
24991: LD_VAR 0 2
24995: ARRAY
24996: PPUSH
24997: LD_EXP 32
25001: PUSH
25002: LD_VAR 0 2
25006: ARRAY
25007: PPUSH
25008: CALL_OW 210
// end ; free_parking_spots = [ ] ;
25012: LD_ADDR_VAR 0 11
25016: PUSH
25017: EMPTY
25018: ST_TO_ADDR
// temp_list_3 = [ ] ;
25019: LD_ADDR_VAR 0 6
25023: PUSH
25024: EMPTY
25025: ST_TO_ADDR
// for i in ai_vehicle_pullback_hexes [ base ] do
25026: LD_ADDR_VAR 0 3
25030: PUSH
25031: LD_EXP 39
25035: PUSH
25036: LD_VAR 0 2
25040: ARRAY
25041: PUSH
25042: FOR_IN
25043: IFFALSE 25332
// begin temp_unit = HexInfo ( i [ 1 ] , i [ 2 ] ) ;
25045: LD_ADDR_VAR 0 7
25049: PUSH
25050: LD_VAR 0 3
25054: PUSH
25055: LD_INT 1
25057: ARRAY
25058: PPUSH
25059: LD_VAR 0 3
25063: PUSH
25064: LD_INT 2
25066: ARRAY
25067: PPUSH
25068: CALL_OW 428
25072: ST_TO_ADDR
// if temp_unit in ai_vehicles_defend [ base ] then
25073: LD_VAR 0 7
25077: PUSH
25078: LD_EXP 37
25082: PUSH
25083: LD_VAR 0 2
25087: ARRAY
25088: IN
25089: IFFALSE 25206
// begin temp_list_3 = temp_list_3 ^ temp_unit ;
25091: LD_ADDR_VAR 0 6
25095: PUSH
25096: LD_VAR 0 6
25100: PUSH
25101: LD_VAR 0 7
25105: ADD
25106: ST_TO_ADDR
// if not under_attack and not temp_unit in ( ai_refuel_vehicles_list [ base ] ^ ai_vehicles_attack [ base ] ^ ai_vehicle_being_moved [ base ] ^ ai_vehicles_having_been_moved [ base ] ^ cargo_bays_being_moved ) then
25107: LD_VAR 0 10
25111: NOT
25112: PUSH
25113: LD_VAR 0 7
25117: PUSH
25118: LD_EXP 54
25122: PUSH
25123: LD_VAR 0 2
25127: ARRAY
25128: PUSH
25129: LD_EXP 38
25133: PUSH
25134: LD_VAR 0 2
25138: ARRAY
25139: ADD
25140: PUSH
25141: LD_EXP 45
25145: PUSH
25146: LD_VAR 0 2
25150: ARRAY
25151: ADD
25152: PUSH
25153: LD_EXP 67
25157: PUSH
25158: LD_VAR 0 2
25162: ARRAY
25163: ADD
25164: PUSH
25165: LD_EXP 123
25169: ADD
25170: IN
25171: NOT
25172: AND
25173: IFFALSE 25204
// begin if GetControl ( temp_unit ) = control_manual then
25175: LD_VAR 0 7
25179: PPUSH
25180: CALL_OW 263
25184: PUSH
25185: LD_INT 1
25187: EQUAL
25188: IFFALSE 25204
// begin ComExitVehicle ( IsDrivenBy ( temp_unit ) ) ;
25190: LD_VAR 0 7
25194: PPUSH
25195: CALL_OW 311
25199: PPUSH
25200: CALL_OW 121
// end ; end ; end else
25204: GO 25330
// if temp_unit = 0 or not ( GetType ( temp_unit ) = unit_building or ( GetType ( temp_unit ) = unit_vehicle and ( ( GetControl ( temp_unit ) = control_manual and IsDrivenBy ( temp_unit ) = 0 ) or ( GetControl ( temp_unit ) = control_remote and IsControledBy ( temp_unit ) = 0 ) ) ) ) then
25206: LD_VAR 0 7
25210: PUSH
25211: LD_INT 0
25213: EQUAL
25214: PUSH
25215: LD_VAR 0 7
25219: PPUSH
25220: CALL_OW 247
25224: PUSH
25225: LD_INT 3
25227: EQUAL
25228: PUSH
25229: LD_VAR 0 7
25233: PPUSH
25234: CALL_OW 247
25238: PUSH
25239: LD_INT 2
25241: EQUAL
25242: PUSH
25243: LD_VAR 0 7
25247: PPUSH
25248: CALL_OW 263
25252: PUSH
25253: LD_INT 1
25255: EQUAL
25256: PUSH
25257: LD_VAR 0 7
25261: PPUSH
25262: CALL_OW 311
25266: PUSH
25267: LD_INT 0
25269: EQUAL
25270: AND
25271: PUSH
25272: LD_VAR 0 7
25276: PPUSH
25277: CALL_OW 263
25281: PUSH
25282: LD_INT 2
25284: EQUAL
25285: PUSH
25286: LD_VAR 0 7
25290: PPUSH
25291: CALL_OW 312
25295: PUSH
25296: LD_INT 0
25298: EQUAL
25299: AND
25300: OR
25301: AND
25302: OR
25303: NOT
25304: OR
25305: IFFALSE 25330
// free_parking_spots = Insert ( free_parking_spots , 1 , i ) ;
25307: LD_ADDR_VAR 0 11
25311: PUSH
25312: LD_VAR 0 11
25316: PPUSH
25317: LD_INT 1
25319: PPUSH
25320: LD_VAR 0 3
25324: PPUSH
25325: CALL_OW 2
25329: ST_TO_ADDR
// end ;
25330: GO 25042
25332: POP
25333: POP
// if under_attack then
25334: LD_VAR 0 10
25338: IFFALSE 25748
// begin allowed_to_repair_vehicles = temp_list_3 ;
25340: LD_ADDR_VAR 0 9
25344: PUSH
25345: LD_VAR 0 6
25349: ST_TO_ADDR
// vehicles_list = UnitFilter ( ( ai_vehicles_being_repaired [ base ] ^ ai_retreating_vehicles_defend [ base ] ) diff temp_list_3 , [ f_ok ] ) ;
25350: LD_ADDR_VAR 0 8
25354: PUSH
25355: LD_EXP 55
25359: PUSH
25360: LD_VAR 0 2
25364: ARRAY
25365: PUSH
25366: LD_EXP 52
25370: PUSH
25371: LD_VAR 0 2
25375: ARRAY
25376: ADD
25377: PUSH
25378: LD_VAR 0 6
25382: DIFF
25383: PPUSH
25384: LD_INT 50
25386: PUSH
25387: EMPTY
25388: LIST
25389: PPUSH
25390: CALL_OW 72
25394: ST_TO_ADDR
// temp_list = [ ] ;
25395: LD_ADDR_VAR 0 5
25399: PUSH
25400: EMPTY
25401: ST_TO_ADDR
// temp_list_3 = temp_list_3 isect UnitFilter ( ai_vehicles_being_repaired [ base ] ^ ai_retreating_vehicles_defend [ base ] , [ f_ok ] ) ;
25402: LD_ADDR_VAR 0 6
25406: PUSH
25407: LD_VAR 0 6
25411: PUSH
25412: LD_EXP 55
25416: PUSH
25417: LD_VAR 0 2
25421: ARRAY
25422: PUSH
25423: LD_EXP 52
25427: PUSH
25428: LD_VAR 0 2
25432: ARRAY
25433: ADD
25434: PPUSH
25435: LD_INT 50
25437: PUSH
25438: EMPTY
25439: LIST
25440: PPUSH
25441: CALL_OW 72
25445: ISECT
25446: ST_TO_ADDR
// for i in temp_list_3 do
25447: LD_ADDR_VAR 0 3
25451: PUSH
25452: LD_VAR 0 6
25456: PUSH
25457: FOR_IN
25458: IFFALSE 25515
// if UnitShoot ( i ) > 0 and GetSide ( UnitShoot ( i ) ) <> side then
25460: LD_VAR 0 3
25464: PPUSH
25465: CALL_OW 504
25469: PUSH
25470: LD_INT 0
25472: GREATER
25473: PUSH
25474: LD_VAR 0 3
25478: PPUSH
25479: CALL_OW 504
25483: PPUSH
25484: CALL_OW 255
25488: PUSH
25489: LD_VAR 0 1
25493: NONEQUAL
25494: AND
25495: IFFALSE 25513
// temp_list = temp_list ^ i ;
25497: LD_ADDR_VAR 0 5
25501: PUSH
25502: LD_VAR 0 5
25506: PUSH
25507: LD_VAR 0 3
25511: ADD
25512: ST_TO_ADDR
25513: GO 25457
25515: POP
25516: POP
// for i in ai_mechanics_defend [ base ] do
25517: LD_ADDR_VAR 0 3
25521: PUSH
25522: LD_EXP 28
25526: PUSH
25527: LD_VAR 0 2
25531: ARRAY
25532: PUSH
25533: FOR_IN
25534: IFFALSE 25618
// if UnitShoot ( i ) > 0 and GetSide ( UnitShoot ( i ) ) <> side then
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL_OW 504
25545: PUSH
25546: LD_INT 0
25548: GREATER
25549: PUSH
25550: LD_VAR 0 3
25554: PPUSH
25555: CALL_OW 504
25559: PPUSH
25560: CALL_OW 255
25564: PUSH
25565: LD_VAR 0 1
25569: NONEQUAL
25570: AND
25571: IFFALSE 25616
// temp_list = temp_list ^ UnitFilter ( temp_list_3 diff temp_list , [ f_dist , i , 5 ] ) ;
25573: LD_ADDR_VAR 0 5
25577: PUSH
25578: LD_VAR 0 5
25582: PUSH
25583: LD_VAR 0 6
25587: PUSH
25588: LD_VAR 0 5
25592: DIFF
25593: PPUSH
25594: LD_INT 91
25596: PUSH
25597: LD_VAR 0 3
25601: PUSH
25602: LD_INT 5
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: LIST
25609: PPUSH
25610: CALL_OW 72
25614: ADD
25615: ST_TO_ADDR
25616: GO 25533
25618: POP
25619: POP
// for i in temp_list_3 diff temp_list do
25620: LD_ADDR_VAR 0 3
25624: PUSH
25625: LD_VAR 0 6
25629: PUSH
25630: LD_VAR 0 5
25634: DIFF
25635: PUSH
25636: FOR_IN
25637: IFFALSE 25670
// if GetControl ( i ) = control_manual then
25639: LD_VAR 0 3
25643: PPUSH
25644: CALL_OW 263
25648: PUSH
25649: LD_INT 1
25651: EQUAL
25652: IFFALSE 25668
// begin ComExitVehicle ( IsDrivenBy ( i ) ) ;
25654: LD_VAR 0 3
25658: PPUSH
25659: CALL_OW 311
25663: PPUSH
25664: CALL_OW 121
// end ;
25668: GO 25636
25670: POP
25671: POP
// temp_list = FindDriverHelper ( UnitFilter ( temp_list , [ [ f_empty ] , [ f_ok ] ] ) , mechanics_list , vehicles_drivers ) ;
25672: LD_ADDR_VAR 0 5
25676: PUSH
25677: LD_VAR 0 5
25681: PPUSH
25682: LD_INT 58
25684: PUSH
25685: EMPTY
25686: LIST
25687: PUSH
25688: LD_INT 50
25690: PUSH
25691: EMPTY
25692: LIST
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PPUSH
25698: CALL_OW 72
25702: PPUSH
25703: LD_VAR 0 4
25707: PPUSH
25708: LD_VAR 0 13
25712: PPUSH
25713: CALL 26641 0 3
25717: ST_TO_ADDR
// mechanics_list = temp_list [ 1 ] ;
25718: LD_ADDR_VAR 0 4
25722: PUSH
25723: LD_VAR 0 5
25727: PUSH
25728: LD_INT 1
25730: ARRAY
25731: ST_TO_ADDR
// vehicles_drivers = temp_list [ 2 ] ;
25732: LD_ADDR_VAR 0 13
25736: PUSH
25737: LD_VAR 0 5
25741: PUSH
25742: LD_INT 2
25744: ARRAY
25745: ST_TO_ADDR
// end else
25746: GO 26011
// begin allowed_to_repair_vehicles = ai_vehicles_defend [ base ] diff ( ai_refuel_vehicles_list [ base ] ^ ai_vehicles_having_been_moved [ base ] ^ ai_vehicle_being_moved [ base ] ) ;
25748: LD_ADDR_VAR 0 9
25752: PUSH
25753: LD_EXP 37
25757: PUSH
25758: LD_VAR 0 2
25762: ARRAY
25763: PUSH
25764: LD_EXP 54
25768: PUSH
25769: LD_VAR 0 2
25773: ARRAY
25774: PUSH
25775: LD_EXP 67
25779: PUSH
25780: LD_VAR 0 2
25784: ARRAY
25785: ADD
25786: PUSH
25787: LD_EXP 45
25791: PUSH
25792: LD_VAR 0 2
25796: ARRAY
25797: ADD
25798: DIFF
25799: ST_TO_ADDR
// i = 1 ;
25800: LD_ADDR_VAR 0 3
25804: PUSH
25805: LD_INT 1
25807: ST_TO_ADDR
// while i <= allowed_to_repair_vehicles do
25808: LD_VAR 0 3
25812: PUSH
25813: LD_VAR 0 9
25817: LESSEQUAL
25818: IFFALSE 25900
// begin if not IsOk ( allowed_to_repair_vehicles [ i ] ) and GetDistUnitArea ( allowed_to_repair_vehicles [ i ] , ru_base_area ) > 7 then
25820: LD_VAR 0 9
25824: PUSH
25825: LD_VAR 0 3
25829: ARRAY
25830: PPUSH
25831: CALL_OW 302
25835: NOT
25836: PUSH
25837: LD_VAR 0 9
25841: PUSH
25842: LD_VAR 0 3
25846: ARRAY
25847: PPUSH
25848: LD_INT 2
25850: PPUSH
25851: CALL_OW 299
25855: PUSH
25856: LD_INT 7
25858: GREATER
25859: AND
25860: IFFALSE 25884
// begin allowed_to_repair_vehicles = Delete ( allowed_to_repair_vehicles , i ) ;
25862: LD_ADDR_VAR 0 9
25866: PUSH
25867: LD_VAR 0 9
25871: PPUSH
25872: LD_VAR 0 3
25876: PPUSH
25877: CALL_OW 3
25881: ST_TO_ADDR
// continue ;
25882: GO 25808
// end ; i = i + 1 ;
25884: LD_ADDR_VAR 0 3
25888: PUSH
25889: LD_VAR 0 3
25893: PUSH
25894: LD_INT 1
25896: PLUS
25897: ST_TO_ADDR
// end ;
25898: GO 25808
// vehicles_list = UnitFilter ( allowed_to_repair_vehicles diff temp_list_3 , [ f_ok ] ) ;
25900: LD_ADDR_VAR 0 8
25904: PUSH
25905: LD_VAR 0 9
25909: PUSH
25910: LD_VAR 0 6
25914: DIFF
25915: PPUSH
25916: LD_INT 50
25918: PUSH
25919: EMPTY
25920: LIST
25921: PPUSH
25922: CALL_OW 72
25926: ST_TO_ADDR
// temp_list = UnitFilter ( vehicles_list , [ [ f_empty ] , [ f_ok ] ] ) ;
25927: LD_ADDR_VAR 0 5
25931: PUSH
25932: LD_VAR 0 8
25936: PPUSH
25937: LD_INT 58
25939: PUSH
25940: EMPTY
25941: LIST
25942: PUSH
25943: LD_INT 50
25945: PUSH
25946: EMPTY
25947: LIST
25948: PUSH
25949: EMPTY
25950: LIST
25951: LIST
25952: PPUSH
25953: CALL_OW 72
25957: ST_TO_ADDR
// temp_list = FindDriverHelper ( temp_list , mechanics_list , vehicles_drivers ) ;
25958: LD_ADDR_VAR 0 5
25962: PUSH
25963: LD_VAR 0 5
25967: PPUSH
25968: LD_VAR 0 4
25972: PPUSH
25973: LD_VAR 0 13
25977: PPUSH
25978: CALL 26641 0 3
25982: ST_TO_ADDR
// mechanics_list = temp_list [ 1 ] ;
25983: LD_ADDR_VAR 0 4
25987: PUSH
25988: LD_VAR 0 5
25992: PUSH
25993: LD_INT 1
25995: ARRAY
25996: ST_TO_ADDR
// vehicles_drivers = temp_list [ 2 ] ;
25997: LD_ADDR_VAR 0 13
26001: PUSH
26002: LD_VAR 0 5
26006: PUSH
26007: LD_INT 2
26009: ARRAY
26010: ST_TO_ADDR
// end ; for i in vehicles_list do
26011: LD_ADDR_VAR 0 3
26015: PUSH
26016: LD_VAR 0 8
26020: PUSH
26021: FOR_IN
26022: IFFALSE 26178
// if free_parking_spots > 0 then
26024: LD_VAR 0 11
26028: PUSH
26029: LD_INT 0
26031: GREATER
26032: IFFALSE 26174
// begin temp_list = [ ] ;
26034: LD_ADDR_VAR 0 5
26038: PUSH
26039: EMPTY
26040: ST_TO_ADDR
// for k in free_parking_spots do
26041: LD_ADDR_VAR 0 12
26045: PUSH
26046: LD_VAR 0 11
26050: PUSH
26051: FOR_IN
26052: IFFALSE 26095
// temp_list = temp_list ^ GetDistUnitXY ( i , k [ 1 ] , k [ 2 ] ) ;
26054: LD_ADDR_VAR 0 5
26058: PUSH
26059: LD_VAR 0 5
26063: PUSH
26064: LD_VAR 0 3
26068: PPUSH
26069: LD_VAR 0 12
26073: PUSH
26074: LD_INT 1
26076: ARRAY
26077: PPUSH
26078: LD_VAR 0 12
26082: PUSH
26083: LD_INT 2
26085: ARRAY
26086: PPUSH
26087: CALL_OW 297
26091: ADD
26092: ST_TO_ADDR
26093: GO 26051
26095: POP
26096: POP
// temp_list = WorstFromListByList ( free_parking_spots , temp_list ) ;
26097: LD_ADDR_VAR 0 5
26101: PUSH
26102: LD_VAR 0 11
26106: PPUSH
26107: LD_VAR 0 5
26111: PPUSH
26112: CALL_OW 78
26116: ST_TO_ADDR
// ComMoveXY ( i , temp_list [ 1 ] , temp_list [ 2 ] ) ;
26117: LD_VAR 0 3
26121: PPUSH
26122: LD_VAR 0 5
26126: PUSH
26127: LD_INT 1
26129: ARRAY
26130: PPUSH
26131: LD_VAR 0 5
26135: PUSH
26136: LD_INT 2
26138: ARRAY
26139: PPUSH
26140: CALL_OW 111
// AddComHold ( i ) ;
26144: LD_VAR 0 3
26148: PPUSH
26149: CALL_OW 200
// free_parking_spots = free_parking_spots diff [ temp_list ] ;
26153: LD_ADDR_VAR 0 11
26157: PUSH
26158: LD_VAR 0 11
26162: PUSH
26163: LD_VAR 0 5
26167: PUSH
26168: EMPTY
26169: LIST
26170: DIFF
26171: ST_TO_ADDR
// end else
26172: GO 26176
// break ;
26174: GO 26178
26176: GO 26021
26178: POP
26179: POP
// if mechanics_list = 0 then
26180: LD_VAR 0 4
26184: PUSH
26185: LD_INT 0
26187: EQUAL
26188: IFFALSE 26192
// continue ;
26190: GO 23512
// allowed_to_repair_vehicles = UnitFilter ( allowed_to_repair_vehicles , [ f_not , [ f_lives , 1000 ] ] ) diff ai_vehicles_being_repaired [ base ] ;
26192: LD_ADDR_VAR 0 9
26196: PUSH
26197: LD_VAR 0 9
26201: PPUSH
26202: LD_INT 3
26204: PUSH
26205: LD_INT 24
26207: PUSH
26208: LD_INT 1000
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: PUSH
26215: EMPTY
26216: LIST
26217: LIST
26218: PPUSH
26219: CALL_OW 72
26223: PUSH
26224: LD_EXP 55
26228: PUSH
26229: LD_VAR 0 2
26233: ARRAY
26234: DIFF
26235: ST_TO_ADDR
// if allowed_to_repair_vehicles > 0 or ai_vehicles_being_repaired [ base ] > 0 then
26236: LD_VAR 0 9
26240: PUSH
26241: LD_INT 0
26243: GREATER
26244: PUSH
26245: LD_EXP 55
26249: PUSH
26250: LD_VAR 0 2
26254: ARRAY
26255: PUSH
26256: LD_INT 0
26258: GREATER
26259: OR
26260: IFFALSE 26565
// begin if allowed_to_repair_vehicles > 0 then
26262: LD_VAR 0 9
26266: PUSH
26267: LD_INT 0
26269: GREATER
26270: IFFALSE 26534
// begin k = false ;
26272: LD_ADDR_VAR 0 12
26276: PUSH
26277: LD_INT 0
26279: ST_TO_ADDR
// if ai_vehicles_being_repaired [ base ] = 0 then
26280: LD_EXP 55
26284: PUSH
26285: LD_VAR 0 2
26289: ARRAY
26290: PUSH
26291: LD_INT 0
26293: EQUAL
26294: IFFALSE 26306
// k = true else
26296: LD_ADDR_VAR 0 12
26300: PUSH
26301: LD_INT 1
26303: ST_TO_ADDR
26304: GO 26369
// if IsOk ( ai_vehicles_being_repaired [ base ] [ 1 ] ) then
26306: LD_EXP 55
26310: PUSH
26311: LD_VAR 0 2
26315: ARRAY
26316: PUSH
26317: LD_INT 1
26319: ARRAY
26320: PPUSH
26321: CALL_OW 302
26325: IFFALSE 26369
// begin allowed_to_repair_vehicles = UnitFilter ( allowed_to_repair_vehicles , [ f_not , [ f_ok ] ] ) ;
26327: LD_ADDR_VAR 0 9
26331: PUSH
26332: LD_VAR 0 9
26336: PPUSH
26337: LD_INT 3
26339: PUSH
26340: LD_INT 50
26342: PUSH
26343: EMPTY
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: PPUSH
26350: CALL_OW 72
26354: ST_TO_ADDR
// k := allowed_to_repair_vehicles > 0 ;
26355: LD_ADDR_VAR 0 12
26359: PUSH
26360: LD_VAR 0 9
26364: PUSH
26365: LD_INT 0
26367: GREATER
26368: ST_TO_ADDR
// end ; if k then
26369: LD_VAR 0 12
26373: IFFALSE 26534
// begin temp_list = [ ] ;
26375: LD_ADDR_VAR 0 5
26379: PUSH
26380: EMPTY
26381: ST_TO_ADDR
// for i in allowed_to_repair_vehicles do
26382: LD_ADDR_VAR 0 3
26386: PUSH
26387: LD_VAR 0 9
26391: PUSH
26392: FOR_IN
26393: IFFALSE 26418
// temp_list = temp_list ^ GetLives ( i ) ;
26395: LD_ADDR_VAR 0 5
26399: PUSH
26400: LD_VAR 0 5
26404: PUSH
26405: LD_VAR 0 3
26409: PPUSH
26410: CALL_OW 256
26414: ADD
26415: ST_TO_ADDR
26416: GO 26392
26418: POP
26419: POP
// temp_unit = WorstFromListByList ( allowed_to_repair_vehicles , temp_list ) ;
26420: LD_ADDR_VAR 0 7
26424: PUSH
26425: LD_VAR 0 9
26429: PPUSH
26430: LD_VAR 0 5
26434: PPUSH
26435: CALL_OW 78
26439: ST_TO_ADDR
// temp_list = temp_unit ^ ai_vehicles_being_repaired [ base ] ;
26440: LD_ADDR_VAR 0 5
26444: PUSH
26445: LD_VAR 0 7
26449: PUSH
26450: LD_EXP 55
26454: PUSH
26455: LD_VAR 0 2
26459: ARRAY
26460: ADD
26461: ST_TO_ADDR
// ai_vehicles_being_repaired = Replace ( ai_vehicles_being_repaired , base , temp_list ) ;
26462: LD_ADDR_EXP 55
26466: PUSH
26467: LD_EXP 55
26471: PPUSH
26472: LD_VAR 0 2
26476: PPUSH
26477: LD_VAR 0 5
26481: PPUSH
26482: CALL_OW 1
26486: ST_TO_ADDR
// temp_list = ai_retreating_vehicles_defend [ base ] diff temp_unit ;
26487: LD_ADDR_VAR 0 5
26491: PUSH
26492: LD_EXP 52
26496: PUSH
26497: LD_VAR 0 2
26501: ARRAY
26502: PUSH
26503: LD_VAR 0 7
26507: DIFF
26508: ST_TO_ADDR
// ai_retreating_vehicles_defend = Replace ( ai_retreating_vehicles_defend , base , temp_list ) ;
26509: LD_ADDR_EXP 52
26513: PUSH
26514: LD_EXP 52
26518: PPUSH
26519: LD_VAR 0 2
26523: PPUSH
26524: LD_VAR 0 5
26528: PPUSH
26529: CALL_OW 1
26533: ST_TO_ADDR
// end ; end ; ComRepairVehicle ( GetHumansOutOfUnits ( mechanics_list ) , ai_vehicles_being_repaired [ base ] [ 1 ] ) ;
26534: LD_VAR 0 4
26538: PPUSH
26539: CALL 23354 0 1
26543: PPUSH
26544: LD_EXP 55
26548: PUSH
26549: LD_VAR 0 2
26553: ARRAY
26554: PUSH
26555: LD_INT 1
26557: ARRAY
26558: PPUSH
26559: CALL_OW 129
// end else
26563: GO 26630
// begin DistributeHumansToBuildings ( base , mechanics_list , UnitFilter ( ai_facts [ base ] , [ [ f_ok ] , [ f_not , [ f_constructed ] ] ] ) , class_mechanic , 6 , true , false ) ;
26565: LD_VAR 0 2
26569: PPUSH
26570: LD_VAR 0 4
26574: PPUSH
26575: LD_EXP 47
26579: PUSH
26580: LD_VAR 0 2
26584: ARRAY
26585: PPUSH
26586: LD_INT 50
26588: PUSH
26589: EMPTY
26590: LIST
26591: PUSH
26592: LD_INT 3
26594: PUSH
26595: LD_INT 57
26597: PUSH
26598: EMPTY
26599: LIST
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PPUSH
26609: CALL_OW 72
26613: PPUSH
26614: LD_INT 3
26616: PPUSH
26617: LD_INT 6
26619: PPUSH
26620: LD_INT 1
26622: PPUSH
26623: LD_INT 0
26625: PPUSH
26626: CALL 18059 0 7
// end ; end ;
26630: GO 23512
26632: POP
26633: POP
// until false ;
26634: LD_INT 0
26636: IFFALSE 23495
// end ;
26638: PPOPN 14
26640: END
// function FindDriverHelper ( vehicles_list , mechanics_list , vehicles_drivers ) ; var i , k , temp_unit ; begin
26641: LD_INT 0
26643: PPUSH
26644: PPUSH
26645: PPUSH
26646: PPUSH
// for i in vehicles_list do
26647: LD_ADDR_VAR 0 5
26651: PUSH
26652: LD_VAR 0 1
26656: PUSH
26657: FOR_IN
26658: IFFALSE 26926
// begin if mechanics_list = 0 then
26660: LD_VAR 0 2
26664: PUSH
26665: LD_INT 0
26667: EQUAL
26668: IFFALSE 26672
// break ;
26670: GO 26926
// k = false ;
26672: LD_ADDR_VAR 0 6
26676: PUSH
26677: LD_INT 0
26679: ST_TO_ADDR
// if vehicles_drivers < i then
26680: LD_VAR 0 3
26684: PUSH
26685: LD_VAR 0 5
26689: LESS
26690: IFFALSE 26702
// k = true else
26692: LD_ADDR_VAR 0 6
26696: PUSH
26697: LD_INT 1
26699: ST_TO_ADDR
26700: GO 26729
// if not vehicles_drivers [ i ] in mechanics_list then
26702: LD_VAR 0 3
26706: PUSH
26707: LD_VAR 0 5
26711: ARRAY
26712: PUSH
26713: LD_VAR 0 2
26717: IN
26718: NOT
26719: IFFALSE 26729
// k = true ;
26721: LD_ADDR_VAR 0 6
26725: PUSH
26726: LD_INT 1
26728: ST_TO_ADDR
// if k then
26729: LD_VAR 0 6
26733: IFFALSE 26770
// vehicles_drivers = Replace ( vehicles_drivers , i , AllNearestUnitToUnit ( mechanics_list , i ) ) ;
26735: LD_ADDR_VAR 0 3
26739: PUSH
26740: LD_VAR 0 3
26744: PPUSH
26745: LD_VAR 0 5
26749: PPUSH
26750: LD_VAR 0 2
26754: PPUSH
26755: LD_VAR 0 5
26759: PPUSH
26760: CALL_OW 75
26764: PPUSH
26765: CALL_OW 1
26769: ST_TO_ADDR
// if vehicles_drivers [ i ] > 0 then
26770: LD_VAR 0 3
26774: PUSH
26775: LD_VAR 0 5
26779: ARRAY
26780: PUSH
26781: LD_INT 0
26783: GREATER
26784: IFFALSE 26924
// begin temp_unit = IsInUnit ( vehicles_drivers [ i ] ) ;
26786: LD_ADDR_VAR 0 7
26790: PUSH
26791: LD_VAR 0 3
26795: PUSH
26796: LD_VAR 0 5
26800: ARRAY
26801: PPUSH
26802: CALL_OW 310
26806: ST_TO_ADDR
// if temp_unit <> i then
26807: LD_VAR 0 7
26811: PUSH
26812: LD_VAR 0 5
26816: NONEQUAL
26817: IFFALSE 26902
// case GetType ( temp_unit ) of unit_vehicle :
26819: LD_VAR 0 7
26823: PPUSH
26824: CALL_OW 247
26828: PUSH
26829: LD_INT 2
26831: DOUBLE
26832: EQUAL
26833: IFTRUE 26837
26835: GO 26855
26837: POP
// ComExitVehicle ( vehicles_drivers [ i ] ) ; unit_building :
26838: LD_VAR 0 3
26842: PUSH
26843: LD_VAR 0 5
26847: ARRAY
26848: PPUSH
26849: CALL_OW 121
26853: GO 26902
26855: LD_INT 3
26857: DOUBLE
26858: EQUAL
26859: IFTRUE 26863
26861: GO 26881
26863: POP
// ComExitBuilding ( vehicles_drivers [ i ] ) ; else
26864: LD_VAR 0 3
26868: PUSH
26869: LD_VAR 0 5
26873: ARRAY
26874: PPUSH
26875: CALL_OW 122
26879: GO 26902
26881: POP
// ComEnterUnit ( vehicles_drivers [ i ] , i ) ; end ;
26882: LD_VAR 0 3
26886: PUSH
26887: LD_VAR 0 5
26891: ARRAY
26892: PPUSH
26893: LD_VAR 0 5
26897: PPUSH
26898: CALL_OW 120
// mechanics_list = mechanics_list diff vehicles_drivers [ i ] ;
26902: LD_ADDR_VAR 0 2
26906: PUSH
26907: LD_VAR 0 2
26911: PUSH
26912: LD_VAR 0 3
26916: PUSH
26917: LD_VAR 0 5
26921: ARRAY
26922: DIFF
26923: ST_TO_ADDR
// end ; end ;
26924: GO 26657
26926: POP
26927: POP
// result = [ mechanics_list , vehicles_drivers ] ;
26928: LD_ADDR_VAR 0 4
26932: PUSH
26933: LD_VAR 0 2
26937: PUSH
26938: LD_VAR 0 3
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: ST_TO_ADDR
// end ;
26947: LD_VAR 0 4
26951: RET
// every 0 0$1 + 0 0$0.1 do var side , i , temp_value , temp_unit , temp_list , base , idle_factories , fact ;
26952: GO 26954
26954: DISABLE
26955: LD_INT 0
26957: PPUSH
26958: PPUSH
26959: PPUSH
26960: PPUSH
26961: PPUSH
26962: PPUSH
26963: PPUSH
26964: PPUSH
// begin side = russians ;
26965: LD_ADDR_VAR 0 1
26969: PUSH
26970: LD_EXP 3
26974: ST_TO_ADDR
// for base in ai_bases do
26975: LD_ADDR_VAR 0 6
26979: PUSH
26980: LD_EXP 57
26984: PUSH
26985: FOR_IN
26986: IFFALSE 27460
// begin idle_factories = [ ] ;
26988: LD_ADDR_VAR 0 7
26992: PUSH
26993: EMPTY
26994: ST_TO_ADDR
// for i in ai_facts [ base ] do
26995: LD_ADDR_VAR 0 2
26999: PUSH
27000: LD_EXP 47
27004: PUSH
27005: LD_VAR 0 6
27009: ARRAY
27010: PUSH
27011: FOR_IN
27012: IFFALSE 27073
// if BuildingStatus ( i ) = bs_idle and IsOk ( i ) and GetBType ( i ) = b_factory then
27014: LD_VAR 0 2
27018: PPUSH
27019: CALL_OW 461
27023: PUSH
27024: LD_INT 2
27026: EQUAL
27027: PUSH
27028: LD_VAR 0 2
27032: PPUSH
27033: CALL_OW 302
27037: AND
27038: PUSH
27039: LD_VAR 0 2
27043: PPUSH
27044: CALL_OW 266
27048: PUSH
27049: LD_INT 3
27051: EQUAL
27052: AND
27053: IFFALSE 27071
// idle_factories = idle_factories ^ i ;
27055: LD_ADDR_VAR 0 7
27059: PUSH
27060: LD_VAR 0 7
27064: PUSH
27065: LD_VAR 0 2
27069: ADD
27070: ST_TO_ADDR
27071: GO 27011
27073: POP
27074: POP
// if idle_factories = 0 then
27075: LD_VAR 0 7
27079: PUSH
27080: LD_INT 0
27082: EQUAL
27083: IFFALSE 27087
// continue ;
27085: GO 26985
// temp_value = false ;
27087: LD_ADDR_VAR 0 3
27091: PUSH
27092: LD_INT 0
27094: ST_TO_ADDR
// for i in ai_buildings_locations [ base ] do
27095: LD_ADDR_VAR 0 2
27099: PUSH
27100: LD_EXP 36
27104: PUSH
27105: LD_VAR 0 6
27109: ARRAY
27110: PUSH
27111: FOR_IN
27112: IFFALSE 27284
// if i [ 4 ] in [ b_bunker , b_turret ] then
27114: LD_VAR 0 2
27118: PUSH
27119: LD_INT 4
27121: ARRAY
27122: PUSH
27123: LD_INT 32
27125: PUSH
27126: LD_INT 33
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: IN
27133: IFFALSE 27282
// begin temp_unit = HexInfo ( i [ 1 ] , i [ 2 ] ) ;
27135: LD_ADDR_VAR 0 4
27139: PUSH
27140: LD_VAR 0 2
27144: PUSH
27145: LD_INT 1
27147: ARRAY
27148: PPUSH
27149: LD_VAR 0 2
27153: PUSH
27154: LD_INT 2
27156: ARRAY
27157: PPUSH
27158: CALL_OW 428
27162: ST_TO_ADDR
// if GetBType ( temp_unit ) in [ b_bunker , b_turret ] and not IsConstructed ( temp_unit ) and GetBWeapon ( temp_unit ) <> i [ 7 ] then
27163: LD_VAR 0 4
27167: PPUSH
27168: CALL_OW 266
27172: PUSH
27173: LD_INT 32
27175: PUSH
27176: LD_INT 33
27178: PUSH
27179: EMPTY
27180: LIST
27181: LIST
27182: IN
27183: PUSH
27184: LD_VAR 0 4
27188: PPUSH
27189: CALL_OW 304
27193: NOT
27194: AND
27195: PUSH
27196: LD_VAR 0 4
27200: PPUSH
27201: CALL_OW 269
27205: PUSH
27206: LD_VAR 0 2
27210: PUSH
27211: LD_INT 7
27213: ARRAY
27214: NONEQUAL
27215: AND
27216: IFFALSE 27274
// for fact in idle_factories do
27218: LD_ADDR_VAR 0 8
27222: PUSH
27223: LD_VAR 0 7
27227: PUSH
27228: FOR_IN
27229: IFFALSE 27272
// if IsWeaponFactory ( fact ) then
27231: LD_VAR 0 8
27235: PPUSH
27236: CALL 27466 0 1
27240: IFFALSE 27270
// begin ComPlaceWeapon ( temp_unit , i [ 7 ] ) ;
27242: LD_VAR 0 4
27246: PPUSH
27247: LD_VAR 0 2
27251: PUSH
27252: LD_INT 7
27254: ARRAY
27255: PPUSH
27256: CALL_OW 148
// temp_value = true ;
27260: LD_ADDR_VAR 0 3
27264: PUSH
27265: LD_INT 1
27267: ST_TO_ADDR
// break ;
27268: GO 27272
// end ;
27270: GO 27228
27272: POP
27273: POP
// if temp_value then
27274: LD_VAR 0 3
27278: IFFALSE 27282
// break ;
27280: GO 27284
// end ;
27282: GO 27111
27284: POP
27285: POP
// if temp_value then
27286: LD_VAR 0 3
27290: IFFALSE 27294
// continue ;
27292: GO 26985
// if ai_vehicles_defend [ base ] + ai_vehicles_attack [ base ] < 3 then
27294: LD_EXP 37
27298: PUSH
27299: LD_VAR 0 6
27303: ARRAY
27304: PUSH
27305: LD_EXP 38
27309: PUSH
27310: LD_VAR 0 6
27314: ARRAY
27315: PLUS
27316: PUSH
27317: LD_INT 3
27319: LESS
27320: IFFALSE 27458
// case side of russians :
27322: LD_VAR 0 1
27326: PUSH
27327: LD_EXP 3
27331: DOUBLE
27332: EQUAL
27333: IFTRUE 27337
27335: GO 27457
27337: POP
// begin if Rand ( 1 , 3 ) = 1 then
27338: LD_INT 1
27340: PPUSH
27341: LD_INT 3
27343: PPUSH
27344: CALL_OW 12
27348: PUSH
27349: LD_INT 1
27351: EQUAL
27352: IFFALSE 27396
// begin if Rand ( 1 , 1 + difficulty ) = 1 then
27354: LD_INT 1
27356: PPUSH
27357: LD_INT 1
27359: PUSH
27360: LD_OWVAR 67
27364: PLUS
27365: PPUSH
27366: CALL_OW 12
27370: PUSH
27371: LD_INT 1
27373: EQUAL
27374: IFFALSE 27386
// temp_value = ru_heavy_machine_gun else
27376: LD_ADDR_VAR 0 3
27380: PUSH
27381: LD_INT 42
27383: ST_TO_ADDR
27384: GO 27394
// temp_value = ru_gatling_gun ;
27386: LD_ADDR_VAR 0 3
27390: PUSH
27391: LD_INT 43
27393: ST_TO_ADDR
// end else
27394: GO 27404
// temp_value = ru_gun ;
27396: LD_ADDR_VAR 0 3
27400: PUSH
27401: LD_INT 44
27403: ST_TO_ADDR
// if not IsWeaponFactory ( idle_factories [ 1 ] ) then
27404: LD_VAR 0 7
27408: PUSH
27409: LD_INT 1
27411: ARRAY
27412: PPUSH
27413: CALL 27466 0 1
27417: NOT
27418: IFFALSE 27428
// temp_value = ru_heavy_machine_gun ;
27420: LD_ADDR_VAR 0 3
27424: PUSH
27425: LD_INT 42
27427: ST_TO_ADDR
// ComConstruct ( idle_factories [ 1 ] , ru_medium_wheeled , engine_siberite , control_manual , temp_value ) ;
27428: LD_VAR 0 7
27432: PUSH
27433: LD_INT 1
27435: ARRAY
27436: PPUSH
27437: LD_INT 21
27439: PPUSH
27440: LD_INT 3
27442: PPUSH
27443: LD_INT 1
27445: PPUSH
27446: LD_VAR 0 3
27450: PPUSH
27451: CALL_OW 125
// end ; end ;
27455: GO 27458
27457: POP
// end ;
27458: GO 26985
27460: POP
27461: POP
// enable ;
27462: ENABLE
// end ;
27463: PPOPN 8
27465: END
// function IsWeaponFactory ( factory ) ; begin
27466: LD_INT 0
27468: PPUSH
// if FilterAllUnits ( [ [ f_dist , factory , 4 ] , [ f_btype , b_ext_gun ] ] ) > 0 then
27469: LD_INT 91
27471: PUSH
27472: LD_VAR 0 1
27476: PUSH
27477: LD_INT 4
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: LIST
27484: PUSH
27485: LD_INT 30
27487: PUSH
27488: LD_INT 17
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: PPUSH
27499: CALL_OW 69
27503: PUSH
27504: LD_INT 0
27506: GREATER
27507: IFFALSE 27519
// result = true else
27509: LD_ADDR_VAR 0 2
27513: PUSH
27514: LD_INT 1
27516: ST_TO_ADDR
27517: GO 27527
// result = false ;
27519: LD_ADDR_VAR 0 2
27523: PUSH
27524: LD_INT 0
27526: ST_TO_ADDR
// end ;
27527: LD_VAR 0 2
27531: RET
// on VehicleCaptured ( new_identifier , old_identifier , old_side , capturing_unit ) do var temp_unit , base , val ;
27532: LD_INT 0
27534: PPUSH
27535: PPUSH
27536: PPUSH
// begin if old_side = russians_alt and GetWeapon ( new_identifier ) = ru_cargo_bay and the_cargo_bay_captured = 0 then
27537: LD_VAR 0 3
27541: PUSH
27542: LD_EXP 6
27546: EQUAL
27547: PUSH
27548: LD_VAR 0 1
27552: PPUSH
27553: CALL_OW 264
27557: PUSH
27558: LD_INT 51
27560: EQUAL
27561: AND
27562: PUSH
27563: LD_EXP 98
27567: PUSH
27568: LD_INT 0
27570: EQUAL
27571: AND
27572: IFFALSE 27584
// the_cargo_bay_captured = new_identifier ;
27574: LD_ADDR_EXP 98
27578: PUSH
27579: LD_VAR 0 1
27583: ST_TO_ADDR
// if old_side = russians then
27584: LD_VAR 0 3
27588: PUSH
27589: LD_EXP 3
27593: EQUAL
27594: IFFALSE 27683
// begin if capturing_unit = Heike and heike_undercover = 2 and old_identifier in ai_vehicles_defend [ 1 ] ^ ai_vehicles_attack [ 1 ] then
27596: LD_VAR 0 4
27600: PUSH
27601: LD_EXP 7
27605: EQUAL
27606: PUSH
27607: LD_EXP 83
27611: PUSH
27612: LD_INT 2
27614: EQUAL
27615: AND
27616: PUSH
27617: LD_VAR 0 2
27621: PUSH
27622: LD_EXP 37
27626: PUSH
27627: LD_INT 1
27629: ARRAY
27630: PUSH
27631: LD_EXP 38
27635: PUSH
27636: LD_INT 1
27638: ARRAY
27639: ADD
27640: IN
27641: AND
27642: IFFALSE 27652
// heike_undercover_entered_war_vehicle = true ;
27644: LD_ADDR_EXP 91
27648: PUSH
27649: LD_INT 1
27651: ST_TO_ADDR
// for base in ai_bases do
27652: LD_ADDR_VAR 0 6
27656: PUSH
27657: LD_EXP 57
27661: PUSH
27662: FOR_IN
27663: IFFALSE 27681
// RemoveVehicleFromVariables ( base , old_identifier ) ;
27665: LD_VAR 0 6
27669: PPUSH
27670: LD_VAR 0 2
27674: PPUSH
27675: CALL 10341 0 2
27679: GO 27662
27681: POP
27682: POP
// end ; if GetWeapon ( new_identifier ) = ru_cargo_bay then
27683: LD_VAR 0 1
27687: PPUSH
27688: CALL_OW 264
27692: PUSH
27693: LD_INT 51
27695: EQUAL
27696: IFFALSE 27751
// begin if cargo_bays_origin >= old_identifier then
27698: LD_EXP 102
27702: PUSH
27703: LD_VAR 0 2
27707: GREATEREQUAL
27708: IFFALSE 27751
// begin val = cargo_bays_origin [ old_identifier ] ;
27710: LD_ADDR_VAR 0 7
27714: PUSH
27715: LD_EXP 102
27719: PUSH
27720: LD_VAR 0 2
27724: ARRAY
27725: ST_TO_ADDR
// cargo_bays_origin = Replace ( cargo_bays_origin , new_identifier , val ) ;
27726: LD_ADDR_EXP 102
27730: PUSH
27731: LD_EXP 102
27735: PPUSH
27736: LD_VAR 0 1
27740: PPUSH
27741: LD_VAR 0 7
27745: PPUSH
27746: CALL_OW 1
27750: ST_TO_ADDR
// end ; end ; if engineers_vehicles_to_move_drivers >= old_identifier then
27751: LD_EXP 90
27755: PUSH
27756: LD_VAR 0 2
27760: GREATEREQUAL
27761: IFFALSE 27843
// if engineers_vehicles_to_move_drivers [ old_identifier ] > 0 then
27763: LD_EXP 90
27767: PUSH
27768: LD_VAR 0 2
27772: ARRAY
27773: PUSH
27774: LD_INT 0
27776: GREATER
27777: IFFALSE 27843
// begin temp_unit = engineers_vehicles_to_move_drivers [ old_identifier ] ;
27779: LD_ADDR_VAR 0 5
27783: PUSH
27784: LD_EXP 90
27788: PUSH
27789: LD_VAR 0 2
27793: ARRAY
27794: ST_TO_ADDR
// engineers_vehicles_to_move_drivers = Replace ( engineers_vehicles_to_move_drivers , old_identifier , 0 ) ;
27795: LD_ADDR_EXP 90
27799: PUSH
27800: LD_EXP 90
27804: PPUSH
27805: LD_VAR 0 2
27809: PPUSH
27810: LD_INT 0
27812: PPUSH
27813: CALL_OW 1
27817: ST_TO_ADDR
// engineers_vehicles_to_move_drivers = Replace ( engineers_vehicles_to_move_drivers , new_identifier , temp_unit ) ;
27818: LD_ADDR_EXP 90
27822: PUSH
27823: LD_EXP 90
27827: PPUSH
27828: LD_VAR 0 1
27832: PPUSH
27833: LD_VAR 0 5
27837: PPUSH
27838: CALL_OW 1
27842: ST_TO_ADDR
// end ; if capturing_unit = Heike and heike_undercover in [ 2 , 3 ] and GetWeapon ( new_identifier ) = ru_cargo_bay then
27843: LD_VAR 0 4
27847: PUSH
27848: LD_EXP 7
27852: EQUAL
27853: PUSH
27854: LD_EXP 83
27858: PUSH
27859: LD_INT 2
27861: PUSH
27862: LD_INT 3
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: IN
27869: AND
27870: PUSH
27871: LD_VAR 0 1
27875: PPUSH
27876: CALL_OW 264
27880: PUSH
27881: LD_INT 51
27883: EQUAL
27884: AND
27885: IFFALSE 27922
// begin wait ( 1 ) ;
27887: LD_INT 1
27889: PPUSH
27890: CALL_OW 67
// DoNotAttack ( russians , new_identifier ) ;
27894: LD_EXP 3
27898: PPUSH
27899: LD_VAR 0 1
27903: PPUSH
27904: CALL_OW 471
// DoNotAttack ( russians_alt , new_identifier ) ;
27908: LD_EXP 6
27912: PPUSH
27913: LD_VAR 0 1
27917: PPUSH
27918: CALL_OW 471
// end ; if GetSide ( new_identifier ) = russians then
27922: LD_VAR 0 1
27926: PPUSH
27927: CALL_OW 255
27931: PUSH
27932: LD_EXP 3
27936: EQUAL
27937: IFFALSE 27960
// begin wait ( 1 ) ;
27939: LD_INT 1
27941: PPUSH
27942: CALL_OW 67
// DoNotAttack ( you , new_identifier ) ;
27946: LD_EXP 2
27950: PPUSH
27951: LD_VAR 0 1
27955: PPUSH
27956: CALL_OW 471
// end ; if old_identifier in intel_party_vehicles then
27960: LD_VAR 0 2
27964: PUSH
27965: LD_EXP 114
27969: IN
27970: IFFALSE 28108
// begin intel_party_vehicles = intel_party_vehicles diff old_identifier ;
27972: LD_ADDR_EXP 114
27976: PUSH
27977: LD_EXP 114
27981: PUSH
27982: LD_VAR 0 2
27986: DIFF
27987: ST_TO_ADDR
// intel_party_vehicles = intel_party_vehicles ^ new_identifier ;
27988: LD_ADDR_EXP 114
27992: PUSH
27993: LD_EXP 114
27997: PUSH
27998: LD_VAR 0 1
28002: ADD
28003: ST_TO_ADDR
// if capturing_unit = Heike and heike_undercover = 2 then
28004: LD_VAR 0 4
28008: PUSH
28009: LD_EXP 7
28013: EQUAL
28014: PUSH
28015: LD_EXP 83
28019: PUSH
28020: LD_INT 2
28022: EQUAL
28023: AND
28024: IFFALSE 28061
// begin wait ( 1 ) ;
28026: LD_INT 1
28028: PPUSH
28029: CALL_OW 67
// DoNotAttack ( russians , new_identifier ) ;
28033: LD_EXP 3
28037: PPUSH
28038: LD_VAR 0 1
28042: PPUSH
28043: CALL_OW 471
// DoNotAttack ( russians_alt , new_identifier ) ;
28047: LD_EXP 6
28051: PPUSH
28052: LD_VAR 0 1
28056: PPUSH
28057: CALL_OW 471
// end ; if GetSide ( new_identifier ) in [ russians_alt , russians ] then
28061: LD_VAR 0 1
28065: PPUSH
28066: CALL_OW 255
28070: PUSH
28071: LD_EXP 6
28075: PUSH
28076: LD_EXP 3
28080: PUSH
28081: EMPTY
28082: LIST
28083: LIST
28084: IN
28085: IFFALSE 28108
// begin wait ( 1 ) ;
28087: LD_INT 1
28089: PPUSH
28090: CALL_OW 67
// DoNotAttack ( you , new_identifier ) ;
28094: LD_EXP 2
28098: PPUSH
28099: LD_VAR 0 1
28103: PPUSH
28104: CALL_OW 471
// end ; end ; end ;
28108: PPOPN 7
28110: END
// on VehicleConstructed ( vehicle , factory ) do var side , temp_list , base ;
28111: LD_INT 0
28113: PPUSH
28114: PPUSH
28115: PPUSH
// begin side = GetSide ( vehicle ) ;
28116: LD_ADDR_VAR 0 3
28120: PUSH
28121: LD_VAR 0 1
28125: PPUSH
28126: CALL_OW 255
28130: ST_TO_ADDR
// if side <> russians then
28131: LD_VAR 0 3
28135: PUSH
28136: LD_EXP 3
28140: NONEQUAL
28141: IFFALSE 28145
// exit ;
28143: GO 28279
// base = 1 ;
28145: LD_ADDR_VAR 0 5
28149: PUSH
28150: LD_INT 1
28152: ST_TO_ADDR
// if GetWeapon ( vehicle ) <> ru_cargo_bay then
28153: LD_VAR 0 1
28157: PPUSH
28158: CALL_OW 264
28162: PUSH
28163: LD_INT 51
28165: NONEQUAL
28166: IFFALSE 28217
// begin temp_list = ai_vehicles_defend [ base ] ^ vehicle ;
28168: LD_ADDR_VAR 0 4
28172: PUSH
28173: LD_EXP 37
28177: PUSH
28178: LD_VAR 0 5
28182: ARRAY
28183: PUSH
28184: LD_VAR 0 1
28188: ADD
28189: ST_TO_ADDR
// ai_vehicles_defend = Replace ( ai_vehicles_defend , base , temp_list ) ;
28190: LD_ADDR_EXP 37
28194: PUSH
28195: LD_EXP 37
28199: PPUSH
28200: LD_VAR 0 5
28204: PPUSH
28205: LD_VAR 0 4
28209: PPUSH
28210: CALL_OW 1
28214: ST_TO_ADDR
// end else
28215: GO 28265
// begin ai_cargo_bay = Replace ( ai_cargo_bay , base , vehicle ) ;
28217: LD_ADDR_EXP 59
28221: PUSH
28222: LD_EXP 59
28226: PPUSH
28227: LD_VAR 0 5
28231: PPUSH
28232: LD_VAR 0 1
28236: PPUSH
28237: CALL_OW 1
28241: ST_TO_ADDR
// ai_cargo_bay_under_construction = Replace ( ai_cargo_bay_under_construction , base , false ) ;
28242: LD_ADDR_EXP 60
28246: PUSH
28247: LD_EXP 60
28251: PPUSH
28252: LD_VAR 0 5
28256: PPUSH
28257: LD_INT 0
28259: PPUSH
28260: CALL_OW 1
28264: ST_TO_ADDR
// end ; DoNotAttack ( you , vehicle ) ;
28265: LD_EXP 2
28269: PPUSH
28270: LD_VAR 0 1
28274: PPUSH
28275: CALL_OW 471
// end ;
28279: PPOPN 5
28281: END
// every 0 0$1 + 0 0$0.6 do var side , base , i , attack_vehicles_list , attack_mechanics_list , retreat_vehicles_list , retreat_mechanics_list , temp_list , k , temp_unit ; var attack_hexes , first , temp_value , base_area , dist , temp_list_2 ; var left_road_hexes , right_road_hexes , unit_target_hex_index , left_units , right_units ;
28282: GO 28284
28284: DISABLE
28285: LD_INT 0
28287: PPUSH
28288: PPUSH
28289: PPUSH
28290: PPUSH
28291: PPUSH
28292: PPUSH
28293: PPUSH
28294: PPUSH
28295: PPUSH
28296: PPUSH
28297: PPUSH
28298: PPUSH
28299: PPUSH
28300: PPUSH
28301: PPUSH
28302: PPUSH
28303: PPUSH
28304: PPUSH
28305: PPUSH
28306: PPUSH
28307: PPUSH
// begin temp_list = [ [ 74 , 86 ] , [ 64 , 84 ] , [ 54 , 76 ] , [ 44 , 69 ] ] ;
28308: LD_ADDR_VAR 0 8
28312: PUSH
28313: LD_INT 74
28315: PUSH
28316: LD_INT 86
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 64
28325: PUSH
28326: LD_INT 84
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 54
28335: PUSH
28336: LD_INT 76
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: PUSH
28343: LD_INT 44
28345: PUSH
28346: LD_INT 69
28348: PUSH
28349: EMPTY
28350: LIST
28351: LIST
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: LIST
28357: LIST
28358: ST_TO_ADDR
// temp_list_2 = [ ] ;
28359: LD_ADDR_VAR 0 16
28363: PUSH
28364: EMPTY
28365: ST_TO_ADDR
// for i in temp_list do
28366: LD_ADDR_VAR 0 3
28370: PUSH
28371: LD_VAR 0 8
28375: PUSH
28376: FOR_IN
28377: IFFALSE 28404
// temp_list_2 = Insert ( temp_list_2 , 1 , i ) ;
28379: LD_ADDR_VAR 0 16
28383: PUSH
28384: LD_VAR 0 16
28388: PPUSH
28389: LD_INT 1
28391: PPUSH
28392: LD_VAR 0 3
28396: PPUSH
28397: CALL_OW 2
28401: ST_TO_ADDR
28402: GO 28376
28404: POP
28405: POP
// left_road_hexes = [ [ 79 , 71 ] ] ^ temp_list ^ [ [ 36 , 64 ] ] ^ temp_list_2 ;
28406: LD_ADDR_VAR 0 17
28410: PUSH
28411: LD_INT 79
28413: PUSH
28414: LD_INT 71
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: PUSH
28421: EMPTY
28422: LIST
28423: PUSH
28424: LD_VAR 0 8
28428: ADD
28429: PUSH
28430: LD_INT 36
28432: PUSH
28433: LD_INT 64
28435: PUSH
28436: EMPTY
28437: LIST
28438: LIST
28439: PUSH
28440: EMPTY
28441: LIST
28442: ADD
28443: PUSH
28444: LD_VAR 0 16
28448: ADD
28449: ST_TO_ADDR
// temp_list = [ [ 106 , 74 ] , [ 108 , 62 ] , [ 115 , 59 ] , [ 122 , 60 ] , [ 140 , 77 ] , [ 151 , 83 ] , [ 162 , 85 ] ] ;
28450: LD_ADDR_VAR 0 8
28454: PUSH
28455: LD_INT 106
28457: PUSH
28458: LD_INT 74
28460: PUSH
28461: EMPTY
28462: LIST
28463: LIST
28464: PUSH
28465: LD_INT 108
28467: PUSH
28468: LD_INT 62
28470: PUSH
28471: EMPTY
28472: LIST
28473: LIST
28474: PUSH
28475: LD_INT 115
28477: PUSH
28478: LD_INT 59
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PUSH
28485: LD_INT 122
28487: PUSH
28488: LD_INT 60
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PUSH
28495: LD_INT 140
28497: PUSH
28498: LD_INT 77
28500: PUSH
28501: EMPTY
28502: LIST
28503: LIST
28504: PUSH
28505: LD_INT 151
28507: PUSH
28508: LD_INT 83
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 162
28517: PUSH
28518: LD_INT 85
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: EMPTY
28526: LIST
28527: LIST
28528: LIST
28529: LIST
28530: LIST
28531: LIST
28532: LIST
28533: ST_TO_ADDR
// temp_list_2 = [ ] ;
28534: LD_ADDR_VAR 0 16
28538: PUSH
28539: EMPTY
28540: ST_TO_ADDR
// for i in temp_list do
28541: LD_ADDR_VAR 0 3
28545: PUSH
28546: LD_VAR 0 8
28550: PUSH
28551: FOR_IN
28552: IFFALSE 28579
// temp_list_2 = Insert ( temp_list_2 , 1 , i ) ;
28554: LD_ADDR_VAR 0 16
28558: PUSH
28559: LD_VAR 0 16
28563: PPUSH
28564: LD_INT 1
28566: PPUSH
28567: LD_VAR 0 3
28571: PPUSH
28572: CALL_OW 2
28576: ST_TO_ADDR
28577: GO 28551
28579: POP
28580: POP
// right_road_hexes = [ [ 87 , 74 ] ] ^ temp_list ^ [ [ 171 , 89 ] ] ^ temp_list_2 ;
28581: LD_ADDR_VAR 0 18
28585: PUSH
28586: LD_INT 87
28588: PUSH
28589: LD_INT 74
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: EMPTY
28597: LIST
28598: PUSH
28599: LD_VAR 0 8
28603: ADD
28604: PUSH
28605: LD_INT 171
28607: PUSH
28608: LD_INT 89
28610: PUSH
28611: EMPTY
28612: LIST
28613: LIST
28614: PUSH
28615: EMPTY
28616: LIST
28617: ADD
28618: PUSH
28619: LD_VAR 0 16
28623: ADD
28624: ST_TO_ADDR
// unit_target_hex_index = [ ] ;
28625: LD_ADDR_VAR 0 19
28629: PUSH
28630: EMPTY
28631: ST_TO_ADDR
// left_units = [ ] ;
28632: LD_ADDR_VAR 0 20
28636: PUSH
28637: EMPTY
28638: ST_TO_ADDR
// right_units = [ ] ;
28639: LD_ADDR_VAR 0 21
28643: PUSH
28644: EMPTY
28645: ST_TO_ADDR
// side = russians ;
28646: LD_ADDR_VAR 0 1
28650: PUSH
28651: LD_EXP 3
28655: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28656: LD_INT 35
28658: PPUSH
28659: CALL_OW 67
// for base in ai_bases do
28663: LD_ADDR_VAR 0 2
28667: PUSH
28668: LD_EXP 57
28672: PUSH
28673: FOR_IN
28674: IFFALSE 29929
// begin if ai_mechanics_attack [ base ] = 0 then
28676: LD_EXP 29
28680: PUSH
28681: LD_VAR 0 2
28685: ARRAY
28686: PUSH
28687: LD_INT 0
28689: EQUAL
28690: IFFALSE 28694
// continue ;
28692: GO 28673
// retreat_vehicles_list = [ ] ;
28694: LD_ADDR_VAR 0 6
28698: PUSH
28699: EMPTY
28700: ST_TO_ADDR
// if not code_red then
28701: LD_EXP 76
28705: NOT
28706: IFFALSE 28726
// retreat_vehicles_list = ai_vehicles_attack [ base ] else
28708: LD_ADDR_VAR 0 6
28712: PUSH
28713: LD_EXP 38
28717: PUSH
28718: LD_VAR 0 2
28722: ARRAY
28723: ST_TO_ADDR
28724: GO 28780
// for i in ai_vehicles_attack [ base ] do
28726: LD_ADDR_VAR 0 3
28730: PUSH
28731: LD_EXP 38
28735: PUSH
28736: LD_VAR 0 2
28740: ARRAY
28741: PUSH
28742: FOR_IN
28743: IFFALSE 28778
// if GetLives ( i ) <= 500 then
28745: LD_VAR 0 3
28749: PPUSH
28750: CALL_OW 256
28754: PUSH
28755: LD_INT 500
28757: LESSEQUAL
28758: IFFALSE 28776
// retreat_vehicles_list = retreat_vehicles_list ^ i ;
28760: LD_ADDR_VAR 0 6
28764: PUSH
28765: LD_VAR 0 6
28769: PUSH
28770: LD_VAR 0 3
28774: ADD
28775: ST_TO_ADDR
28776: GO 28742
28778: POP
28779: POP
// retreat_mechanics_list = [ ] ;
28780: LD_ADDR_VAR 0 7
28784: PUSH
28785: EMPTY
28786: ST_TO_ADDR
// temp_list = [ ] ;
28787: LD_ADDR_VAR 0 8
28791: PUSH
28792: EMPTY
28793: ST_TO_ADDR
// for i = 1 to ai_mechanics_attack [ base ] - UnitFilter ( ai_vehicles_attack [ base ] , [ f_ok ] ) do
28794: LD_ADDR_VAR 0 3
28798: PUSH
28799: DOUBLE
28800: LD_INT 1
28802: DEC
28803: ST_TO_ADDR
28804: LD_EXP 29
28808: PUSH
28809: LD_VAR 0 2
28813: ARRAY
28814: PUSH
28815: LD_EXP 38
28819: PUSH
28820: LD_VAR 0 2
28824: ARRAY
28825: PPUSH
28826: LD_INT 50
28828: PUSH
28829: EMPTY
28830: LIST
28831: PPUSH
28832: CALL_OW 72
28836: MINUS
28837: PUSH
28838: FOR_TO
28839: IFFALSE 28958
// begin temp_unit = 0 ;
28841: LD_ADDR_VAR 0 10
28845: PUSH
28846: LD_INT 0
28848: ST_TO_ADDR
// for k in ai_mechanics_attack [ base ] diff temp_list do
28849: LD_ADDR_VAR 0 9
28853: PUSH
28854: LD_EXP 29
28858: PUSH
28859: LD_VAR 0 2
28863: ARRAY
28864: PUSH
28865: LD_VAR 0 8
28869: DIFF
28870: PUSH
28871: FOR_IN
28872: IFFALSE 28912
// if not IsInUnit ( k ) in ai_vehicles_attack [ base ] then
28874: LD_VAR 0 9
28878: PPUSH
28879: CALL_OW 310
28883: PUSH
28884: LD_EXP 38
28888: PUSH
28889: LD_VAR 0 2
28893: ARRAY
28894: IN
28895: NOT
28896: IFFALSE 28910
// begin temp_unit = k ;
28898: LD_ADDR_VAR 0 10
28902: PUSH
28903: LD_VAR 0 9
28907: ST_TO_ADDR
// break ;
28908: GO 28912
// end ;
28910: GO 28871
28912: POP
28913: POP
// if temp_unit > 0 then
28914: LD_VAR 0 10
28918: PUSH
28919: LD_INT 0
28921: GREATER
28922: IFFALSE 28956
// begin retreat_mechanics_list = retreat_mechanics_list ^ temp_unit ;
28924: LD_ADDR_VAR 0 7
28928: PUSH
28929: LD_VAR 0 7
28933: PUSH
28934: LD_VAR 0 10
28938: ADD
28939: ST_TO_ADDR
// temp_list = temp_list ^ temp_unit ;
28940: LD_ADDR_VAR 0 8
28944: PUSH
28945: LD_VAR 0 8
28949: PUSH
28950: LD_VAR 0 10
28954: ADD
28955: ST_TO_ADDR
// end ; end ;
28956: GO 28838
28958: POP
28959: POP
// k = ru_base_area ;
28960: LD_ADDR_VAR 0 9
28964: PUSH
28965: LD_INT 2
28967: ST_TO_ADDR
// for i in retreat_vehicles_list ^ retreat_mechanics_list do
28968: LD_ADDR_VAR 0 3
28972: PUSH
28973: LD_VAR 0 6
28977: PUSH
28978: LD_VAR 0 7
28982: ADD
28983: PUSH
28984: FOR_IN
28985: IFFALSE 29263
// if IsInArea ( i , k ) then
28987: LD_VAR 0 3
28991: PPUSH
28992: LD_VAR 0 9
28996: PPUSH
28997: CALL_OW 308
29001: IFFALSE 29222
// begin if GetType ( i ) = unit_vehicle then
29003: LD_VAR 0 3
29007: PPUSH
29008: CALL_OW 247
29012: PUSH
29013: LD_INT 2
29015: EQUAL
29016: IFFALSE 29126
// begin RemoveVehicleFromVariables ( base , i ) ;
29018: LD_VAR 0 2
29022: PPUSH
29023: LD_VAR 0 3
29027: PPUSH
29028: CALL 10341 0 2
// left_units = left_units diff i ;
29032: LD_ADDR_VAR 0 20
29036: PUSH
29037: LD_VAR 0 20
29041: PUSH
29042: LD_VAR 0 3
29046: DIFF
29047: ST_TO_ADDR
// right_units = right_units diff i ;
29048: LD_ADDR_VAR 0 21
29052: PUSH
29053: LD_VAR 0 21
29057: PUSH
29058: LD_VAR 0 3
29062: DIFF
29063: ST_TO_ADDR
// temp_list = ai_vehicles_defend [ base ] ^ i ;
29064: LD_ADDR_VAR 0 8
29068: PUSH
29069: LD_EXP 37
29073: PUSH
29074: LD_VAR 0 2
29078: ARRAY
29079: PUSH
29080: LD_VAR 0 3
29084: ADD
29085: ST_TO_ADDR
// ai_vehicles_defend = Replace ( ai_vehicles_defend , base , temp_list ) ;
29086: LD_ADDR_EXP 37
29090: PUSH
29091: LD_EXP 37
29095: PPUSH
29096: LD_VAR 0 2
29100: PPUSH
29101: LD_VAR 0 8
29105: PPUSH
29106: CALL_OW 1
29110: ST_TO_ADDR
// i = UnitsInside ( i ) ;
29111: LD_ADDR_VAR 0 3
29115: PUSH
29116: LD_VAR 0 3
29120: PPUSH
29121: CALL_OW 313
29125: ST_TO_ADDR
// end ; temp_list = ai_mechanics_attack [ base ] diff i ;
29126: LD_ADDR_VAR 0 8
29130: PUSH
29131: LD_EXP 29
29135: PUSH
29136: LD_VAR 0 2
29140: ARRAY
29141: PUSH
29142: LD_VAR 0 3
29146: DIFF
29147: ST_TO_ADDR
// ai_mechanics_attack = Replace ( ai_mechanics_attack , base , temp_list ) ;
29148: LD_ADDR_EXP 29
29152: PUSH
29153: LD_EXP 29
29157: PPUSH
29158: LD_VAR 0 2
29162: PPUSH
29163: LD_VAR 0 8
29167: PPUSH
29168: CALL_OW 1
29172: ST_TO_ADDR
// temp_list = ai_mechanics_defend [ base ] ^ i ;
29173: LD_ADDR_VAR 0 8
29177: PUSH
29178: LD_EXP 28
29182: PUSH
29183: LD_VAR 0 2
29187: ARRAY
29188: PUSH
29189: LD_VAR 0 3
29193: ADD
29194: ST_TO_ADDR
// ai_mechanics_defend = Replace ( ai_mechanics_defend , base , temp_list ) ;
29195: LD_ADDR_EXP 28
29199: PUSH
29200: LD_EXP 28
29204: PPUSH
29205: LD_VAR 0 2
29209: PPUSH
29210: LD_VAR 0 8
29214: PPUSH
29215: CALL_OW 1
29219: ST_TO_ADDR
// end else
29220: GO 29261
// ComMoveXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
29222: LD_VAR 0 3
29226: PPUSH
29227: LD_EXP 40
29231: PUSH
29232: LD_VAR 0 2
29236: ARRAY
29237: PUSH
29238: LD_INT 1
29240: ARRAY
29241: PPUSH
29242: LD_EXP 40
29246: PUSH
29247: LD_VAR 0 2
29251: ARRAY
29252: PUSH
29253: LD_INT 2
29255: ARRAY
29256: PPUSH
29257: CALL_OW 111
29261: GO 28984
29263: POP
29264: POP
// attack_vehicles_list = ai_vehicles_attack [ base ] diff retreat_vehicles_list ;
29265: LD_ADDR_VAR 0 4
29269: PUSH
29270: LD_EXP 38
29274: PUSH
29275: LD_VAR 0 2
29279: ARRAY
29280: PUSH
29281: LD_VAR 0 6
29285: DIFF
29286: ST_TO_ADDR
// for i in UnitFilter ( attack_vehicles_list , [ f_not , [ f_empty ] ] ) do
29287: LD_ADDR_VAR 0 3
29291: PUSH
29292: LD_VAR 0 4
29296: PPUSH
29297: LD_INT 3
29299: PUSH
29300: LD_INT 58
29302: PUSH
29303: EMPTY
29304: LIST
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PPUSH
29310: CALL_OW 72
29314: PUSH
29315: FOR_IN
29316: IFFALSE 29367
// begin temp_unit = UnitsInside ( i ) [ 1 ] ;
29318: LD_ADDR_VAR 0 10
29322: PUSH
29323: LD_VAR 0 3
29327: PPUSH
29328: CALL_OW 313
29332: PUSH
29333: LD_INT 1
29335: ARRAY
29336: ST_TO_ADDR
// if not temp_unit in ai_mechanics_attack [ base ] then
29337: LD_VAR 0 10
29341: PUSH
29342: LD_EXP 29
29346: PUSH
29347: LD_VAR 0 2
29351: ARRAY
29352: IN
29353: NOT
29354: IFFALSE 29365
// ComExitVehicle ( temp_unit ) ;
29356: LD_VAR 0 10
29360: PPUSH
29361: CALL_OW 121
// end ;
29365: GO 29315
29367: POP
29368: POP
// temp_list = UnitFilter ( attack_vehicles_list , [ f_empty ] ) ;
29369: LD_ADDR_VAR 0 8
29373: PUSH
29374: LD_VAR 0 4
29378: PPUSH
29379: LD_INT 58
29381: PUSH
29382: EMPTY
29383: LIST
29384: PPUSH
29385: CALL_OW 72
29389: ST_TO_ADDR
// if temp_list > 0 then
29390: LD_VAR 0 8
29394: PUSH
29395: LD_INT 0
29397: GREATER
29398: IFFALSE 29597
// begin attack_mechanics_list = UnitFilter ( ai_mechanics_attack [ base ] diff retreat_mechanics_list , [ f_not , [ f_driving ] ] ) ;
29400: LD_ADDR_VAR 0 5
29404: PUSH
29405: LD_EXP 29
29409: PUSH
29410: LD_VAR 0 2
29414: ARRAY
29415: PUSH
29416: LD_VAR 0 7
29420: DIFF
29421: PPUSH
29422: LD_INT 3
29424: PUSH
29425: LD_INT 55
29427: PUSH
29428: EMPTY
29429: LIST
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PPUSH
29435: CALL_OW 72
29439: ST_TO_ADDR
// for i in temp_list do
29440: LD_ADDR_VAR 0 3
29444: PUSH
29445: LD_VAR 0 8
29449: PUSH
29450: FOR_IN
29451: IFFALSE 29595
// begin if attack_mechanics_list = 0 then
29453: LD_VAR 0 5
29457: PUSH
29458: LD_INT 0
29460: EQUAL
29461: IFFALSE 29465
// break ;
29463: GO 29595
// temp_unit = AllNearestUnitToUnit ( attack_mechanics_list , i ) ;
29465: LD_ADDR_VAR 0 10
29469: PUSH
29470: LD_VAR 0 5
29474: PPUSH
29475: LD_VAR 0 3
29479: PPUSH
29480: CALL_OW 75
29484: ST_TO_ADDR
// k = IsInUnit ( temp_unit ) ;
29485: LD_ADDR_VAR 0 9
29489: PUSH
29490: LD_VAR 0 10
29494: PPUSH
29495: CALL_OW 310
29499: ST_TO_ADDR
// if k <> i then
29500: LD_VAR 0 9
29504: PUSH
29505: LD_VAR 0 3
29509: NONEQUAL
29510: IFFALSE 29577
// case GetType ( k ) of unit_vehicle :
29512: LD_VAR 0 9
29516: PPUSH
29517: CALL_OW 247
29521: PUSH
29522: LD_INT 2
29524: DOUBLE
29525: EQUAL
29526: IFTRUE 29530
29528: GO 29542
29530: POP
// ComExitVehicle ( temp_unit ) ; unit_building :
29531: LD_VAR 0 10
29535: PPUSH
29536: CALL_OW 121
29540: GO 29577
29542: LD_INT 3
29544: DOUBLE
29545: EQUAL
29546: IFTRUE 29550
29548: GO 29562
29550: POP
// ComExitBuilding ( temp_unit ) ; else
29551: LD_VAR 0 10
29555: PPUSH
29556: CALL_OW 122
29560: GO 29577
29562: POP
// ComEnterUnit ( temp_unit , i ) ; end ;
29563: LD_VAR 0 10
29567: PPUSH
29568: LD_VAR 0 3
29572: PPUSH
29573: CALL_OW 120
// attack_mechanics_list = attack_mechanics_list diff temp_unit ;
29577: LD_ADDR_VAR 0 5
29581: PUSH
29582: LD_VAR 0 5
29586: PUSH
29587: LD_VAR 0 10
29591: DIFF
29592: ST_TO_ADDR
// end ;
29593: GO 29450
29595: POP
29596: POP
// end ; for i in attack_vehicles_list do
29597: LD_ADDR_VAR 0 3
29601: PUSH
29602: LD_VAR 0 4
29606: PUSH
29607: FOR_IN
29608: IFFALSE 29925
// begin if not i in right_units and not i in left_units then
29610: LD_VAR 0 3
29614: PUSH
29615: LD_VAR 0 21
29619: IN
29620: NOT
29621: PUSH
29622: LD_VAR 0 3
29626: PUSH
29627: LD_VAR 0 20
29631: IN
29632: NOT
29633: AND
29634: IFFALSE 29705
// begin if left_units > right_units then
29636: LD_VAR 0 20
29640: PUSH
29641: LD_VAR 0 21
29645: GREATER
29646: IFFALSE 29666
// right_units = right_units ^ i else
29648: LD_ADDR_VAR 0 21
29652: PUSH
29653: LD_VAR 0 21
29657: PUSH
29658: LD_VAR 0 3
29662: ADD
29663: ST_TO_ADDR
29664: GO 29682
// left_units = left_units ^ i ;
29666: LD_ADDR_VAR 0 20
29670: PUSH
29671: LD_VAR 0 20
29675: PUSH
29676: LD_VAR 0 3
29680: ADD
29681: ST_TO_ADDR
// unit_target_hex_index = Replace ( unit_target_hex_index , i , 1 ) ;
29682: LD_ADDR_VAR 0 19
29686: PUSH
29687: LD_VAR 0 19
29691: PPUSH
29692: LD_VAR 0 3
29696: PPUSH
29697: LD_INT 1
29699: PPUSH
29700: CALL_OW 1
29704: ST_TO_ADDR
// end ; if i in right_units then
29705: LD_VAR 0 3
29709: PUSH
29710: LD_VAR 0 21
29714: IN
29715: IFFALSE 29729
// attack_hexes = right_road_hexes else
29717: LD_ADDR_VAR 0 11
29721: PUSH
29722: LD_VAR 0 18
29726: ST_TO_ADDR
29727: GO 29739
// attack_hexes = left_road_hexes ;
29729: LD_ADDR_VAR 0 11
29733: PUSH
29734: LD_VAR 0 17
29738: ST_TO_ADDR
// if GetDistUnitXY ( i , attack_hexes [ unit_target_hex_index [ i ] ] [ 1 ] , attack_hexes [ unit_target_hex_index [ i ] ] [ 2 ] ) < 3 then
29739: LD_VAR 0 3
29743: PPUSH
29744: LD_VAR 0 11
29748: PUSH
29749: LD_VAR 0 19
29753: PUSH
29754: LD_VAR 0 3
29758: ARRAY
29759: ARRAY
29760: PUSH
29761: LD_INT 1
29763: ARRAY
29764: PPUSH
29765: LD_VAR 0 11
29769: PUSH
29770: LD_VAR 0 19
29774: PUSH
29775: LD_VAR 0 3
29779: ARRAY
29780: ARRAY
29781: PUSH
29782: LD_INT 2
29784: ARRAY
29785: PPUSH
29786: CALL_OW 297
29790: PUSH
29791: LD_INT 3
29793: LESS
29794: IFFALSE 29872
// begin unit_target_hex_index = Replace ( unit_target_hex_index , i , unit_target_hex_index [ i ] + 1 ) ;
29796: LD_ADDR_VAR 0 19
29800: PUSH
29801: LD_VAR 0 19
29805: PPUSH
29806: LD_VAR 0 3
29810: PPUSH
29811: LD_VAR 0 19
29815: PUSH
29816: LD_VAR 0 3
29820: ARRAY
29821: PUSH
29822: LD_INT 1
29824: PLUS
29825: PPUSH
29826: CALL_OW 1
29830: ST_TO_ADDR
// if unit_target_hex_index [ i ] > attack_hexes then
29831: LD_VAR 0 19
29835: PUSH
29836: LD_VAR 0 3
29840: ARRAY
29841: PUSH
29842: LD_VAR 0 11
29846: GREATER
29847: IFFALSE 29872
// unit_target_hex_index = Replace ( unit_target_hex_index , i , 1 ) ;
29849: LD_ADDR_VAR 0 19
29853: PUSH
29854: LD_VAR 0 19
29858: PPUSH
29859: LD_VAR 0 3
29863: PPUSH
29864: LD_INT 1
29866: PPUSH
29867: CALL_OW 1
29871: ST_TO_ADDR
// end ; ComAgressiveMove ( i , attack_hexes [ unit_target_hex_index [ i ] ] [ 1 ] , attack_hexes [ unit_target_hex_index [ i ] ] [ 2 ] ) ;
29872: LD_VAR 0 3
29876: PPUSH
29877: LD_VAR 0 11
29881: PUSH
29882: LD_VAR 0 19
29886: PUSH
29887: LD_VAR 0 3
29891: ARRAY
29892: ARRAY
29893: PUSH
29894: LD_INT 1
29896: ARRAY
29897: PPUSH
29898: LD_VAR 0 11
29902: PUSH
29903: LD_VAR 0 19
29907: PUSH
29908: LD_VAR 0 3
29912: ARRAY
29913: ARRAY
29914: PUSH
29915: LD_INT 2
29917: ARRAY
29918: PPUSH
29919: CALL_OW 114
// end ;
29923: GO 29607
29925: POP
29926: POP
// end ;
29927: GO 28673
29929: POP
29930: POP
// until false ;
29931: LD_INT 0
29933: IFFALSE 28656
// end ;
29935: PPOPN 21
29937: END
// every 0 0$5 do var base , i ;
29938: GO 29940
29940: DISABLE
29941: LD_INT 0
29943: PPUSH
29944: PPUSH
// begin for base in ai_bases do
29945: LD_ADDR_VAR 0 1
29949: PUSH
29950: LD_EXP 57
29954: PUSH
29955: FOR_IN
29956: IFFALSE 30069
// for i in ai_vehicles_attack [ base ] ^ ai_vehicles_defend [ base ] ^ FilterAllUnits ( [ [ f_side , russians ] , [ f_weapon , ru_cargo_bay ] ] ) do
29958: LD_ADDR_VAR 0 2
29962: PUSH
29963: LD_EXP 38
29967: PUSH
29968: LD_VAR 0 1
29972: ARRAY
29973: PUSH
29974: LD_EXP 37
29978: PUSH
29979: LD_VAR 0 1
29983: ARRAY
29984: ADD
29985: PUSH
29986: LD_INT 22
29988: PUSH
29989: LD_EXP 3
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 34
30000: PUSH
30001: LD_INT 51
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PPUSH
30012: CALL_OW 69
30016: ADD
30017: PUSH
30018: FOR_IN
30019: IFFALSE 30065
// if GetFuel ( i ) < 10 and GetEngine ( i ) = engine_combustion then
30021: LD_VAR 0 2
30025: PPUSH
30026: CALL_OW 261
30030: PUSH
30031: LD_INT 10
30033: LESS
30034: PUSH
30035: LD_VAR 0 2
30039: PPUSH
30040: CALL_OW 262
30044: PUSH
30045: LD_INT 1
30047: EQUAL
30048: AND
30049: IFFALSE 30063
// SetFuel ( i , 10 ) ;
30051: LD_VAR 0 2
30055: PPUSH
30056: LD_INT 10
30058: PPUSH
30059: CALL_OW 240
30063: GO 30018
30065: POP
30066: POP
30067: GO 29955
30069: POP
30070: POP
// enable ;
30071: ENABLE
// end ;
30072: PPOPN 2
30074: END
// every 0 0$1 do var side , i , scientists_list , temp_list , temp_unit , base , k , temp_list_3 , free_spaces , area , val , j ; var wandering_scientists , wander_timer ;
30075: GO 30077
30077: DISABLE
30078: LD_INT 0
30080: PPUSH
30081: PPUSH
30082: PPUSH
30083: PPUSH
30084: PPUSH
30085: PPUSH
30086: PPUSH
30087: PPUSH
30088: PPUSH
30089: PPUSH
30090: PPUSH
30091: PPUSH
30092: PPUSH
30093: PPUSH
// begin side = russians ;
30094: LD_ADDR_VAR 0 1
30098: PUSH
30099: LD_EXP 3
30103: ST_TO_ADDR
// wandering_scientists = [ ] ;
30104: LD_ADDR_VAR 0 13
30108: PUSH
30109: EMPTY
30110: ST_TO_ADDR
// wander_timer = 1 1$0 ;
30111: LD_ADDR_VAR 0 14
30115: PUSH
30116: LD_INT 2100
30118: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30119: LD_INT 35
30121: PPUSH
30122: CALL_OW 67
// for base in ai_bases do
30126: LD_ADDR_VAR 0 6
30130: PUSH
30131: LD_EXP 57
30135: PUSH
30136: FOR_IN
30137: IFFALSE 32224
// begin scientists_list = ai_scientists [ base ] diff ai_heal_these_humans [ base ] ;
30139: LD_ADDR_VAR 0 3
30143: PUSH
30144: LD_EXP 30
30148: PUSH
30149: LD_VAR 0 6
30153: ARRAY
30154: PUSH
30155: LD_EXP 42
30159: PUSH
30160: LD_VAR 0 6
30164: ARRAY
30165: DIFF
30166: ST_TO_ADDR
// temp_list = ai_heal_these_humans [ base ] ;
30167: LD_ADDR_VAR 0 4
30171: PUSH
30172: LD_EXP 42
30176: PUSH
30177: LD_VAR 0 6
30181: ARRAY
30182: ST_TO_ADDR
// i = 1 ;
30183: LD_ADDR_VAR 0 2
30187: PUSH
30188: LD_INT 1
30190: ST_TO_ADDR
// while i <= scientists_list do
30191: LD_VAR 0 2
30195: PUSH
30196: LD_VAR 0 3
30200: LESSEQUAL
30201: IFFALSE 30296
// begin if GetLives ( scientists_list [ i ] ) <= 700 then
30203: LD_VAR 0 3
30207: PUSH
30208: LD_VAR 0 2
30212: ARRAY
30213: PPUSH
30214: CALL_OW 256
30218: PUSH
30219: LD_INT 700
30221: LESSEQUAL
30222: IFFALSE 30280
// begin temp_list = temp_list ^ scientists_list [ i ] ;
30224: LD_ADDR_VAR 0 4
30228: PUSH
30229: LD_VAR 0 4
30233: PUSH
30234: LD_VAR 0 3
30238: PUSH
30239: LD_VAR 0 2
30243: ARRAY
30244: ADD
30245: ST_TO_ADDR
// scientists_list = Delete ( scientists_list , i ) ;
30246: LD_ADDR_VAR 0 3
30250: PUSH
30251: LD_VAR 0 3
30255: PPUSH
30256: LD_VAR 0 2
30260: PPUSH
30261: CALL_OW 3
30265: ST_TO_ADDR
// i = i - 1 ;
30266: LD_ADDR_VAR 0 2
30270: PUSH
30271: LD_VAR 0 2
30275: PUSH
30276: LD_INT 1
30278: MINUS
30279: ST_TO_ADDR
// end ; i = i + 1 ;
30280: LD_ADDR_VAR 0 2
30284: PUSH
30285: LD_VAR 0 2
30289: PUSH
30290: LD_INT 1
30292: PLUS
30293: ST_TO_ADDR
// end ;
30294: GO 30191
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
30296: LD_ADDR_EXP 42
30300: PUSH
30301: LD_EXP 42
30305: PPUSH
30306: LD_VAR 0 6
30310: PPUSH
30311: LD_VAR 0 4
30315: PPUSH
30316: CALL_OW 1
30320: ST_TO_ADDR
// temp_list = [ ] ;
30321: LD_ADDR_VAR 0 4
30325: PUSH
30326: EMPTY
30327: ST_TO_ADDR
// for i in ai_heal_these_humans [ base ] do
30328: LD_ADDR_VAR 0 2
30332: PUSH
30333: LD_EXP 42
30337: PUSH
30338: LD_VAR 0 6
30342: ARRAY
30343: PUSH
30344: FOR_IN
30345: IFFALSE 30395
// if GetLives ( i ) < 1000 and IsInUnit ( i ) = 0 then
30347: LD_VAR 0 2
30351: PPUSH
30352: CALL_OW 256
30356: PUSH
30357: LD_INT 1000
30359: LESS
30360: PUSH
30361: LD_VAR 0 2
30365: PPUSH
30366: CALL_OW 310
30370: PUSH
30371: LD_INT 0
30373: EQUAL
30374: AND
30375: IFFALSE 30393
// temp_list = temp_list ^ i ;
30377: LD_ADDR_VAR 0 4
30381: PUSH
30382: LD_VAR 0 4
30386: PUSH
30387: LD_VAR 0 2
30391: ADD
30392: ST_TO_ADDR
30393: GO 30344
30395: POP
30396: POP
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
30397: LD_ADDR_EXP 42
30401: PUSH
30402: LD_EXP 42
30406: PPUSH
30407: LD_VAR 0 6
30411: PPUSH
30412: LD_VAR 0 4
30416: PPUSH
30417: CALL_OW 1
30421: ST_TO_ADDR
// for i in ai_heal_these_humans [ base ] do
30422: LD_ADDR_VAR 0 2
30426: PUSH
30427: LD_EXP 42
30431: PUSH
30432: LD_VAR 0 6
30436: ARRAY
30437: PUSH
30438: FOR_IN
30439: IFFALSE 30613
// if ( not code_black or not GetClass ( i ) in [ class_soldier , class_bazooker ] ) and GetDistUnitXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) > 4 then
30441: LD_EXP 77
30445: NOT
30446: PUSH
30447: LD_VAR 0 2
30451: PPUSH
30452: CALL_OW 257
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: LD_INT 9
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: IN
30467: NOT
30468: OR
30469: PUSH
30470: LD_VAR 0 2
30474: PPUSH
30475: LD_EXP 40
30479: PUSH
30480: LD_VAR 0 6
30484: ARRAY
30485: PUSH
30486: LD_INT 1
30488: ARRAY
30489: PPUSH
30490: LD_EXP 40
30494: PUSH
30495: LD_VAR 0 6
30499: ARRAY
30500: PUSH
30501: LD_INT 2
30503: ARRAY
30504: PPUSH
30505: CALL_OW 297
30509: PUSH
30510: LD_INT 4
30512: GREATER
30513: AND
30514: IFFALSE 30611
// case GetType ( IsInUnit ( i ) ) of unit_vehicle :
30516: LD_VAR 0 2
30520: PPUSH
30521: CALL_OW 310
30525: PPUSH
30526: CALL_OW 247
30530: PUSH
30531: LD_INT 2
30533: DOUBLE
30534: EQUAL
30535: IFTRUE 30539
30537: GO 30551
30539: POP
// ComExitVehicle ( i ) ; unit_building :
30540: LD_VAR 0 2
30544: PPUSH
30545: CALL_OW 121
30549: GO 30611
30551: LD_INT 3
30553: DOUBLE
30554: EQUAL
30555: IFTRUE 30559
30557: GO 30571
30559: POP
// ComExitBuilding ( i ) ; else
30560: LD_VAR 0 2
30564: PPUSH
30565: CALL_OW 122
30569: GO 30611
30571: POP
// ComMoveXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ; end ;
30572: LD_VAR 0 2
30576: PPUSH
30577: LD_EXP 40
30581: PUSH
30582: LD_VAR 0 6
30586: ARRAY
30587: PUSH
30588: LD_INT 1
30590: ARRAY
30591: PPUSH
30592: LD_EXP 40
30596: PUSH
30597: LD_VAR 0 6
30601: ARRAY
30602: PUSH
30603: LD_INT 2
30605: ARRAY
30606: PPUSH
30607: CALL_OW 111
30611: GO 30438
30613: POP
30614: POP
// if scientists_list = 0 then
30615: LD_VAR 0 3
30619: PUSH
30620: LD_INT 0
30622: EQUAL
30623: IFFALSE 30627
// continue ;
30625: GO 30136
// if ai_heal_these_humans [ base ] > 0 then
30627: LD_EXP 42
30631: PUSH
30632: LD_VAR 0 6
30636: ARRAY
30637: PUSH
30638: LD_INT 0
30640: GREATER
30641: IFFALSE 30804
// begin temp_list = ai_heal_these_humans [ base ] ;
30643: LD_ADDR_VAR 0 4
30647: PUSH
30648: LD_EXP 42
30652: PUSH
30653: LD_VAR 0 6
30657: ARRAY
30658: ST_TO_ADDR
// if temp_list > 0 then
30659: LD_VAR 0 4
30663: PUSH
30664: LD_INT 0
30666: GREATER
30667: IFFALSE 30804
// begin scientists_list = GetHumansOutOfUnits ( scientists_list ) ;
30669: LD_ADDR_VAR 0 3
30673: PUSH
30674: LD_VAR 0 3
30678: PPUSH
30679: CALL 23354 0 1
30683: ST_TO_ADDR
// repeat i = 1 ;
30684: LD_ADDR_VAR 0 2
30688: PUSH
30689: LD_INT 1
30691: ST_TO_ADDR
// while i <= temp_list do
30692: LD_VAR 0 2
30696: PUSH
30697: LD_VAR 0 4
30701: LESSEQUAL
30702: IFFALSE 30794
// begin if scientists_list = 0 then
30704: LD_VAR 0 3
30708: PUSH
30709: LD_INT 0
30711: EQUAL
30712: IFFALSE 30716
// break ;
30714: GO 30794
// temp_unit = NearestUnitToUnit ( scientists_list , temp_list [ i ] ) ;
30716: LD_ADDR_VAR 0 5
30720: PUSH
30721: LD_VAR 0 3
30725: PPUSH
30726: LD_VAR 0 4
30730: PUSH
30731: LD_VAR 0 2
30735: ARRAY
30736: PPUSH
30737: CALL_OW 74
30741: ST_TO_ADDR
// ComHeal ( temp_unit , temp_list [ i ] ) ;
30742: LD_VAR 0 5
30746: PPUSH
30747: LD_VAR 0 4
30751: PUSH
30752: LD_VAR 0 2
30756: ARRAY
30757: PPUSH
30758: CALL_OW 128
// scientists_list = scientists_list diff temp_unit ;
30762: LD_ADDR_VAR 0 3
30766: PUSH
30767: LD_VAR 0 3
30771: PUSH
30772: LD_VAR 0 5
30776: DIFF
30777: ST_TO_ADDR
// i = i + 1 ;
30778: LD_ADDR_VAR 0 2
30782: PUSH
30783: LD_VAR 0 2
30787: PUSH
30788: LD_INT 1
30790: PLUS
30791: ST_TO_ADDR
// end ;
30792: GO 30692
// until scientists_list = 0 ;
30794: LD_VAR 0 3
30798: PUSH
30799: LD_INT 0
30801: EQUAL
30802: IFFALSE 30684
// end ; end ; if IsLive ( Barovnin ) and IsOk ( the_archive ) and Barovnin in scientists_list then
30804: LD_EXP 13
30808: PPUSH
30809: CALL_OW 300
30813: PUSH
30814: LD_EXP 75
30818: PPUSH
30819: CALL_OW 302
30823: AND
30824: PUSH
30825: LD_EXP 13
30829: PUSH
30830: LD_VAR 0 3
30834: IN
30835: AND
30836: IFFALSE 30946
// begin scientists_list = scientists_list diff Barovnin ;
30838: LD_ADDR_VAR 0 3
30842: PUSH
30843: LD_VAR 0 3
30847: PUSH
30848: LD_EXP 13
30852: DIFF
30853: ST_TO_ADDR
// temp_unit = IsinUnit ( Barovnin ) ;
30854: LD_ADDR_VAR 0 5
30858: PUSH
30859: LD_EXP 13
30863: PPUSH
30864: CALL_OW 310
30868: ST_TO_ADDR
// case GetType ( temp_unit ) of unit_vehicle :
30869: LD_VAR 0 5
30873: PPUSH
30874: CALL_OW 247
30878: PUSH
30879: LD_INT 2
30881: DOUBLE
30882: EQUAL
30883: IFTRUE 30887
30885: GO 30899
30887: POP
// ComExitVehicle ( Barovnin ) ; unit_building :
30888: LD_EXP 13
30892: PPUSH
30893: CALL_OW 121
30897: GO 30946
30899: LD_INT 3
30901: DOUBLE
30902: EQUAL
30903: IFTRUE 30907
30905: GO 30931
30907: POP
// if temp_unit <> the_archive then
30908: LD_VAR 0 5
30912: PUSH
30913: LD_EXP 75
30917: NONEQUAL
30918: IFFALSE 30929
// ComExitBuilding ( Barovnin ) ; else
30920: LD_EXP 13
30924: PPUSH
30925: CALL_OW 122
30929: GO 30946
30931: POP
// ComEnterUnit ( Barovnin , the_archive ) ; end ;
30932: LD_EXP 13
30936: PPUSH
30937: LD_EXP 75
30941: PPUSH
30942: CALL_OW 120
// end ; if not code_black then
30946: LD_EXP 77
30950: NOT
30951: IFFALSE 32073
// begin wander_timer = wander_timer - 0 0$1 ;
30953: LD_ADDR_VAR 0 14
30957: PUSH
30958: LD_VAR 0 14
30962: PUSH
30963: LD_INT 35
30965: MINUS
30966: ST_TO_ADDR
// if wander_timer <= 0 0$0 then
30967: LD_VAR 0 14
30971: PUSH
30972: LD_INT 0
30974: LESSEQUAL
30975: IFFALSE 31456
// begin temp_list_3 = [ ] ;
30977: LD_ADDR_VAR 0 8
30981: PUSH
30982: EMPTY
30983: ST_TO_ADDR
// for i in wandering_scientists do
30984: LD_ADDR_VAR 0 2
30988: PUSH
30989: LD_VAR 0 13
30993: PUSH
30994: FOR_IN
30995: IFFALSE 31019
// temp_list_3 = temp_list_3 ^ i [ 1 ] ;
30997: LD_ADDR_VAR 0 8
31001: PUSH
31002: LD_VAR 0 8
31006: PUSH
31007: LD_VAR 0 2
31011: PUSH
31012: LD_INT 1
31014: ARRAY
31015: ADD
31016: ST_TO_ADDR
31017: GO 30994
31019: POP
31020: POP
// temp_list_3 = scientists_list diff temp_list_3 ;
31021: LD_ADDR_VAR 0 8
31025: PUSH
31026: LD_VAR 0 3
31030: PUSH
31031: LD_VAR 0 8
31035: DIFF
31036: ST_TO_ADDR
// temp_list = [ ] ;
31037: LD_ADDR_VAR 0 4
31041: PUSH
31042: EMPTY
31043: ST_TO_ADDR
// for i in temp_list_3 do
31044: LD_ADDR_VAR 0 2
31048: PUSH
31049: LD_VAR 0 8
31053: PUSH
31054: FOR_IN
31055: IFFALSE 31096
// if IsInUnit ( i ) in ai_labs [ 1 ] then
31057: LD_VAR 0 2
31061: PPUSH
31062: CALL_OW 310
31066: PUSH
31067: LD_EXP 33
31071: PUSH
31072: LD_INT 1
31074: ARRAY
31075: IN
31076: IFFALSE 31094
// temp_list = temp_list ^ i ;
31078: LD_ADDR_VAR 0 4
31082: PUSH
31083: LD_VAR 0 4
31087: PUSH
31088: LD_VAR 0 2
31092: ADD
31093: ST_TO_ADDR
31094: GO 31054
31096: POP
31097: POP
// if temp_list > 0 then
31098: LD_VAR 0 4
31102: PUSH
31103: LD_INT 0
31105: GREATER
31106: IFFALSE 31456
// begin wander_timer = Rand ( 0 0$30 , 0 0$45 ) ;
31108: LD_ADDR_VAR 0 14
31112: PUSH
31113: LD_INT 1050
31115: PPUSH
31116: LD_INT 1575
31118: PPUSH
31119: CALL_OW 12
31123: ST_TO_ADDR
// temp_list_3 = [ ] ;
31124: LD_ADDR_VAR 0 8
31128: PUSH
31129: EMPTY
31130: ST_TO_ADDR
// for i in temp_list do
31131: LD_ADDR_VAR 0 2
31135: PUSH
31136: LD_VAR 0 4
31140: PUSH
31141: FOR_IN
31142: IFFALSE 31179
// if IsInUnit ( i ) = the_archive then
31144: LD_VAR 0 2
31148: PPUSH
31149: CALL_OW 310
31153: PUSH
31154: LD_EXP 75
31158: EQUAL
31159: IFFALSE 31177
// temp_list_3 = temp_list_3 ^ i ;
31161: LD_ADDR_VAR 0 8
31165: PUSH
31166: LD_VAR 0 8
31170: PUSH
31171: LD_VAR 0 2
31175: ADD
31176: ST_TO_ADDR
31177: GO 31141
31179: POP
31180: POP
// if Rand ( 1 , 9 ) = 1 and temp_list_3 > 0 then
31181: LD_INT 1
31183: PPUSH
31184: LD_INT 9
31186: PPUSH
31187: CALL_OW 12
31191: PUSH
31192: LD_INT 1
31194: EQUAL
31195: PUSH
31196: LD_VAR 0 8
31200: PUSH
31201: LD_INT 0
31203: GREATER
31204: AND
31205: IFFALSE 31219
// temp_list = temp_list_3 else
31207: LD_ADDR_VAR 0 4
31211: PUSH
31212: LD_VAR 0 8
31216: ST_TO_ADDR
31217: GO 31255
// begin temp_list = temp_list diff temp_list_3 ;
31219: LD_ADDR_VAR 0 4
31223: PUSH
31224: LD_VAR 0 4
31228: PUSH
31229: LD_VAR 0 8
31233: DIFF
31234: ST_TO_ADDR
// if temp_list = 0 then
31235: LD_VAR 0 4
31239: PUSH
31240: LD_INT 0
31242: EQUAL
31243: IFFALSE 31255
// temp_list = temp_list_3 ;
31245: LD_ADDR_VAR 0 4
31249: PUSH
31250: LD_VAR 0 8
31254: ST_TO_ADDR
// end ; temp_unit = temp_list [ Rand ( 1 , temp_list ) ] ;
31255: LD_ADDR_VAR 0 5
31259: PUSH
31260: LD_VAR 0 4
31264: PUSH
31265: LD_INT 1
31267: PPUSH
31268: LD_VAR 0 4
31272: PPUSH
31273: CALL_OW 12
31277: ARRAY
31278: ST_TO_ADDR
// k = 0 ;
31279: LD_ADDR_VAR 0 7
31283: PUSH
31284: LD_INT 0
31286: ST_TO_ADDR
// if Rand ( 1 , 9 ) = 1 or IsInUnit ( temp_unit ) = the_archive then
31287: LD_INT 1
31289: PPUSH
31290: LD_INT 9
31292: PPUSH
31293: CALL_OW 12
31297: PUSH
31298: LD_INT 1
31300: EQUAL
31301: PUSH
31302: LD_VAR 0 5
31306: PPUSH
31307: CALL_OW 310
31311: PUSH
31312: LD_EXP 75
31316: EQUAL
31317: OR
31318: IFFALSE 31381
// begin temp_list = ai_labs [ 1 ] diff IsInUnit ( temp_unit ) ;
31320: LD_ADDR_VAR 0 4
31324: PUSH
31325: LD_EXP 33
31329: PUSH
31330: LD_INT 1
31332: ARRAY
31333: PUSH
31334: LD_VAR 0 5
31338: PPUSH
31339: CALL_OW 310
31343: DIFF
31344: ST_TO_ADDR
// if temp_list > 0 then
31345: LD_VAR 0 4
31349: PUSH
31350: LD_INT 0
31352: GREATER
31353: IFFALSE 31379
// k = temp_list [ Rand ( 1 , temp_list ) ] ;
31355: LD_ADDR_VAR 0 7
31359: PUSH
31360: LD_VAR 0 4
31364: PUSH
31365: LD_INT 1
31367: PPUSH
31368: LD_VAR 0 4
31372: PPUSH
31373: CALL_OW 12
31377: ARRAY
31378: ST_TO_ADDR
// end else
31379: GO 31391
// k = the_archive ;
31381: LD_ADDR_VAR 0 7
31385: PUSH
31386: LD_EXP 75
31390: ST_TO_ADDR
// if k > 0 then
31391: LD_VAR 0 7
31395: PUSH
31396: LD_INT 0
31398: GREATER
31399: IFFALSE 31456
// wandering_scientists = wandering_scientists ^ [ [ temp_unit , k , Rand ( 0 0$5 , 0 0$10 ) , false , IsInUnit ( temp_unit ) ] ] ;
31401: LD_ADDR_VAR 0 13
31405: PUSH
31406: LD_VAR 0 13
31410: PUSH
31411: LD_VAR 0 5
31415: PUSH
31416: LD_VAR 0 7
31420: PUSH
31421: LD_INT 175
31423: PPUSH
31424: LD_INT 350
31426: PPUSH
31427: CALL_OW 12
31431: PUSH
31432: LD_INT 0
31434: PUSH
31435: LD_VAR 0 5
31439: PPUSH
31440: CALL_OW 310
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: LIST
31449: LIST
31450: LIST
31451: PUSH
31452: EMPTY
31453: LIST
31454: ADD
31455: ST_TO_ADDR
// end ; end ; i = 1 ;
31456: LD_ADDR_VAR 0 2
31460: PUSH
31461: LD_INT 1
31463: ST_TO_ADDR
// while i <= wandering_scientists do
31464: LD_VAR 0 2
31468: PUSH
31469: LD_VAR 0 13
31473: LESSEQUAL
31474: IFFALSE 32036
// begin if not wandering_scientists [ i ] [ 1 ] in scientists_list then
31476: LD_VAR 0 13
31480: PUSH
31481: LD_VAR 0 2
31485: ARRAY
31486: PUSH
31487: LD_INT 1
31489: ARRAY
31490: PUSH
31491: LD_VAR 0 3
31495: IN
31496: NOT
31497: IFFALSE 31515
// begin i = i + 1 ;
31499: LD_ADDR_VAR 0 2
31503: PUSH
31504: LD_VAR 0 2
31508: PUSH
31509: LD_INT 1
31511: PLUS
31512: ST_TO_ADDR
// continue ;
31513: GO 31464
// end ; temp_unit = IsInUnit ( wandering_scientists [ i ] [ 1 ] ) ;
31515: LD_ADDR_VAR 0 5
31519: PUSH
31520: LD_VAR 0 13
31524: PUSH
31525: LD_VAR 0 2
31529: ARRAY
31530: PUSH
31531: LD_INT 1
31533: ARRAY
31534: PPUSH
31535: CALL_OW 310
31539: ST_TO_ADDR
// if wandering_scientists [ i ] [ 4 ] then
31540: LD_VAR 0 13
31544: PUSH
31545: LD_VAR 0 2
31549: ARRAY
31550: PUSH
31551: LD_INT 4
31553: ARRAY
31554: IFFALSE 31578
// k = wandering_scientists [ i ] [ 5 ] else
31556: LD_ADDR_VAR 0 7
31560: PUSH
31561: LD_VAR 0 13
31565: PUSH
31566: LD_VAR 0 2
31570: ARRAY
31571: PUSH
31572: LD_INT 5
31574: ARRAY
31575: ST_TO_ADDR
31576: GO 31598
// k = wandering_scientists [ i ] [ 2 ] ;
31578: LD_ADDR_VAR 0 7
31582: PUSH
31583: LD_VAR 0 13
31587: PUSH
31588: LD_VAR 0 2
31592: ARRAY
31593: PUSH
31594: LD_INT 2
31596: ARRAY
31597: ST_TO_ADDR
// if temp_unit <> k then
31598: LD_VAR 0 5
31602: PUSH
31603: LD_VAR 0 7
31607: NONEQUAL
31608: IFFALSE 31827
// begin case GetType ( temp_unit ) of unit_vehicle :
31610: LD_VAR 0 5
31614: PPUSH
31615: CALL_OW 247
31619: PUSH
31620: LD_INT 2
31622: DOUBLE
31623: EQUAL
31624: IFTRUE 31628
31626: GO 31650
31628: POP
// ComExitVehicle ( wandering_scientists [ i ] [ 1 ] ) ; unit_building :
31629: LD_VAR 0 13
31633: PUSH
31634: LD_VAR 0 2
31638: ARRAY
31639: PUSH
31640: LD_INT 1
31642: ARRAY
31643: PPUSH
31644: CALL_OW 121
31648: GO 31825
31650: LD_INT 3
31652: DOUBLE
31653: EQUAL
31654: IFTRUE 31658
31656: GO 31680
31658: POP
// ComExitBuilding ( wandering_scientists [ i ] [ 1 ] ) ; else
31659: LD_VAR 0 13
31663: PUSH
31664: LD_VAR 0 2
31668: ARRAY
31669: PUSH
31670: LD_INT 1
31672: ARRAY
31673: PPUSH
31674: CALL_OW 122
31678: GO 31825
31680: POP
// begin if GetDistUnits ( wandering_scientists [ i ] [ 1 ] , k ) <= 5 then
31681: LD_VAR 0 13
31685: PUSH
31686: LD_VAR 0 2
31690: ARRAY
31691: PUSH
31692: LD_INT 1
31694: ARRAY
31695: PPUSH
31696: LD_VAR 0 7
31700: PPUSH
31701: CALL_OW 296
31705: PUSH
31706: LD_INT 5
31708: LESSEQUAL
31709: IFFALSE 31801
// begin temp_list = UnitsInside ( k ) ;
31711: LD_ADDR_VAR 0 4
31715: PUSH
31716: LD_VAR 0 7
31720: PPUSH
31721: CALL_OW 313
31725: ST_TO_ADDR
// if temp_list = 6 then
31726: LD_VAR 0 4
31730: PUSH
31731: LD_INT 6
31733: EQUAL
31734: IFFALSE 31801
// begin val = 0 ;
31736: LD_ADDR_VAR 0 11
31740: PUSH
31741: LD_INT 0
31743: ST_TO_ADDR
// for j in temp_list do
31744: LD_ADDR_VAR 0 12
31748: PUSH
31749: LD_VAR 0 4
31753: PUSH
31754: FOR_IN
31755: IFFALSE 31783
// if j <> Barovnin then
31757: LD_VAR 0 12
31761: PUSH
31762: LD_EXP 13
31766: NONEQUAL
31767: IFFALSE 31781
// begin val = j ;
31769: LD_ADDR_VAR 0 11
31773: PUSH
31774: LD_VAR 0 12
31778: ST_TO_ADDR
// break ;
31779: GO 31783
// end ;
31781: GO 31754
31783: POP
31784: POP
// ComExitBuilding ( val ) ;
31785: LD_VAR 0 11
31789: PPUSH
31790: CALL_OW 122
// wait ( 3 ) ;
31794: LD_INT 3
31796: PPUSH
31797: CALL_OW 67
// end ; end ; ComEnterUnit ( wandering_scientists [ i ] [ 1 ] , k ) ;
31801: LD_VAR 0 13
31805: PUSH
31806: LD_VAR 0 2
31810: ARRAY
31811: PUSH
31812: LD_INT 1
31814: ARRAY
31815: PPUSH
31816: LD_VAR 0 7
31820: PPUSH
31821: CALL_OW 120
// end ; end ; end else
31825: GO 32020
// if not wandering_scientists [ i ] [ 4 ] then
31827: LD_VAR 0 13
31831: PUSH
31832: LD_VAR 0 2
31836: ARRAY
31837: PUSH
31838: LD_INT 4
31840: ARRAY
31841: NOT
31842: IFFALSE 31986
// begin temp_list = Replace ( wandering_scientists [ i ] , 3 , wandering_scientists [ i ] [ 3 ] - 0 0$1 ) ;
31844: LD_ADDR_VAR 0 4
31848: PUSH
31849: LD_VAR 0 13
31853: PUSH
31854: LD_VAR 0 2
31858: ARRAY
31859: PPUSH
31860: LD_INT 3
31862: PPUSH
31863: LD_VAR 0 13
31867: PUSH
31868: LD_VAR 0 2
31872: ARRAY
31873: PUSH
31874: LD_INT 3
31876: ARRAY
31877: PUSH
31878: LD_INT 35
31880: MINUS
31881: PPUSH
31882: CALL_OW 1
31886: ST_TO_ADDR
// wandering_scientists = Replace ( wandering_scientists , i , temp_list ) ;
31887: LD_ADDR_VAR 0 13
31891: PUSH
31892: LD_VAR 0 13
31896: PPUSH
31897: LD_VAR 0 2
31901: PPUSH
31902: LD_VAR 0 4
31906: PPUSH
31907: CALL_OW 1
31911: ST_TO_ADDR
// if wandering_scientists [ i ] [ 3 ] <= 0 0$0 then
31912: LD_VAR 0 13
31916: PUSH
31917: LD_VAR 0 2
31921: ARRAY
31922: PUSH
31923: LD_INT 3
31925: ARRAY
31926: PUSH
31927: LD_INT 0
31929: LESSEQUAL
31930: IFFALSE 31984
// begin temp_list = Replace ( wandering_scientists [ i ] , 4 , true ) ;
31932: LD_ADDR_VAR 0 4
31936: PUSH
31937: LD_VAR 0 13
31941: PUSH
31942: LD_VAR 0 2
31946: ARRAY
31947: PPUSH
31948: LD_INT 4
31950: PPUSH
31951: LD_INT 1
31953: PPUSH
31954: CALL_OW 1
31958: ST_TO_ADDR
// wandering_scientists = Replace ( wandering_scientists , i , temp_list ) ;
31959: LD_ADDR_VAR 0 13
31963: PUSH
31964: LD_VAR 0 13
31968: PPUSH
31969: LD_VAR 0 2
31973: PPUSH
31974: LD_VAR 0 4
31978: PPUSH
31979: CALL_OW 1
31983: ST_TO_ADDR
// end ; end else
31984: GO 32020
// begin wandering_scientists = Delete ( wandering_scientists , i ) ;
31986: LD_ADDR_VAR 0 13
31990: PUSH
31991: LD_VAR 0 13
31995: PPUSH
31996: LD_VAR 0 2
32000: PPUSH
32001: CALL_OW 3
32005: ST_TO_ADDR
// i = i - 1 ;
32006: LD_ADDR_VAR 0 2
32010: PUSH
32011: LD_VAR 0 2
32015: PUSH
32016: LD_INT 1
32018: MINUS
32019: ST_TO_ADDR
// end ; i = i + 1 ;
32020: LD_ADDR_VAR 0 2
32024: PUSH
32025: LD_VAR 0 2
32029: PUSH
32030: LD_INT 1
32032: PLUS
32033: ST_TO_ADDR
// end ;
32034: GO 31464
// for i in wandering_scientists do
32036: LD_ADDR_VAR 0 2
32040: PUSH
32041: LD_VAR 0 13
32045: PUSH
32046: FOR_IN
32047: IFFALSE 32071
// scientists_list = scientists_list diff i [ 1 ] ;
32049: LD_ADDR_VAR 0 3
32053: PUSH
32054: LD_VAR 0 3
32058: PUSH
32059: LD_VAR 0 2
32063: PUSH
32064: LD_INT 1
32066: ARRAY
32067: DIFF
32068: ST_TO_ADDR
32069: GO 32046
32071: POP
32072: POP
// end ; if wandering_scientists > 0 then
32073: LD_VAR 0 13
32077: PUSH
32078: LD_INT 0
32080: GREATER
32081: IFFALSE 32147
// begin temp_list = [ ] ;
32083: LD_ADDR_VAR 0 4
32087: PUSH
32088: EMPTY
32089: ST_TO_ADDR
// for i in scientists_list do
32090: LD_ADDR_VAR 0 2
32094: PUSH
32095: LD_VAR 0 3
32099: PUSH
32100: FOR_IN
32101: IFFALSE 32143
// if not IsInUnit ( i ) in ai_labs [ 1 ] then
32103: LD_VAR 0 2
32107: PPUSH
32108: CALL_OW 310
32112: PUSH
32113: LD_EXP 33
32117: PUSH
32118: LD_INT 1
32120: ARRAY
32121: IN
32122: NOT
32123: IFFALSE 32141
// temp_list = temp_list ^ i ;
32125: LD_ADDR_VAR 0 4
32129: PUSH
32130: LD_VAR 0 4
32134: PUSH
32135: LD_VAR 0 2
32139: ADD
32140: ST_TO_ADDR
32141: GO 32100
32143: POP
32144: POP
// end else
32145: GO 32157
// temp_list = scientists_list ;
32147: LD_ADDR_VAR 0 4
32151: PUSH
32152: LD_VAR 0 3
32156: ST_TO_ADDR
// DistributeHumansToBuildings ( base , temp_list , UnitFilter ( ai_labs [ base ] , [ [ f_ok ] , [ f_not , [ f_constructed ] ] ] ) , class_scientistic , 6 , true , false ) ;
32157: LD_VAR 0 6
32161: PPUSH
32162: LD_VAR 0 4
32166: PPUSH
32167: LD_EXP 33
32171: PUSH
32172: LD_VAR 0 6
32176: ARRAY
32177: PPUSH
32178: LD_INT 50
32180: PUSH
32181: EMPTY
32182: LIST
32183: PUSH
32184: LD_INT 3
32186: PUSH
32187: LD_INT 57
32189: PUSH
32190: EMPTY
32191: LIST
32192: PUSH
32193: EMPTY
32194: LIST
32195: LIST
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PPUSH
32201: CALL_OW 72
32205: PPUSH
32206: LD_INT 4
32208: PPUSH
32209: LD_INT 6
32211: PPUSH
32212: LD_INT 1
32214: PPUSH
32215: LD_INT 0
32217: PPUSH
32218: CALL 18059 0 7
// end ;
32222: GO 30136
32224: POP
32225: POP
// until false ;
32226: LD_INT 0
32228: IFFALSE 30119
// end ;
32230: PPOPN 14
32232: END
// every 0 0$1 + 0 0$0.3 do var lab , first_time ;
32233: GO 32235
32235: DISABLE
32236: LD_INT 0
32238: PPUSH
32239: PPUSH
// begin first_time = true ;
32240: LD_ADDR_VAR 0 2
32244: PUSH
32245: LD_INT 1
32247: ST_TO_ADDR
// repeat wait ( 0 0$5 ) ;
32248: LD_INT 175
32250: PPUSH
32251: CALL_OW 67
// for lab in ai_labs [ 1 ] do
32255: LD_ADDR_VAR 0 1
32259: PUSH
32260: LD_EXP 33
32264: PUSH
32265: LD_INT 1
32267: ARRAY
32268: PUSH
32269: FOR_IN
32270: IFFALSE 32312
// if BuildingStatus ( lab ) = bs_idle then
32272: LD_VAR 0 1
32276: PPUSH
32277: CALL_OW 461
32281: PUSH
32282: LD_INT 2
32284: EQUAL
32285: IFFALSE 32310
// SetSpecResearch ( lab , Rand ( 400 , 700 ) , true ) ;
32287: LD_VAR 0 1
32291: PPUSH
32292: LD_INT 400
32294: PPUSH
32295: LD_INT 700
32297: PPUSH
32298: CALL_OW 12
32302: PPUSH
32303: LD_INT 1
32305: PPUSH
32306: CALL_OW 486
32310: GO 32269
32312: POP
32313: POP
// if first_time then
32314: LD_VAR 0 2
32318: IFFALSE 32376
// begin wait ( 0 0$1 ) ;
32320: LD_INT 35
32322: PPUSH
32323: CALL_OW 67
// for lab in ai_labs [ 1 ] do
32327: LD_ADDR_VAR 0 1
32331: PUSH
32332: LD_EXP 33
32336: PUSH
32337: LD_INT 1
32339: ARRAY
32340: PUSH
32341: FOR_IN
32342: IFFALSE 32366
// SetWorkingProgress ( lab , Rand ( 1 , 90 ) ) ;
32344: LD_VAR 0 1
32348: PPUSH
32349: LD_INT 1
32351: PPUSH
32352: LD_INT 90
32354: PPUSH
32355: CALL_OW 12
32359: PPUSH
32360: CALL_OW 329
32364: GO 32341
32366: POP
32367: POP
// first_time = false ;
32368: LD_ADDR_VAR 0 2
32372: PUSH
32373: LD_INT 0
32375: ST_TO_ADDR
// end ; until false ;
32376: LD_INT 0
32378: IFFALSE 32248
// end ; end_of_file
32380: PPOPN 2
32382: END
// export function AI_GetAwayFromXY ( unit1 , x , y , dist , add ) ; var list_nearest , list_coords , temp_dir , dir_list , b , min_dist , temp_dist , c , rand_num , rand_near_hex , attempts ; begin
32383: LD_INT 0
32385: PPUSH
32386: PPUSH
32387: PPUSH
32388: PPUSH
32389: PPUSH
32390: PPUSH
32391: PPUSH
32392: PPUSH
32393: PPUSH
32394: PPUSH
32395: PPUSH
32396: PPUSH
// if not IsOk ( unit1 ) or dist = 1 or not ValidHex ( x , y ) or GetDistUnitXY ( unit1 , x , y ) >= dist or not add in [ true , false ] then
32397: LD_VAR 0 1
32401: PPUSH
32402: CALL_OW 302
32406: NOT
32407: PUSH
32408: LD_VAR 0 4
32412: PUSH
32413: LD_INT 1
32415: EQUAL
32416: OR
32417: PUSH
32418: LD_VAR 0 2
32422: PPUSH
32423: LD_VAR 0 3
32427: PPUSH
32428: CALL_OW 488
32432: NOT
32433: OR
32434: PUSH
32435: LD_VAR 0 1
32439: PPUSH
32440: LD_VAR 0 2
32444: PPUSH
32445: LD_VAR 0 3
32449: PPUSH
32450: CALL_OW 297
32454: PUSH
32455: LD_VAR 0 4
32459: GREATEREQUAL
32460: OR
32461: PUSH
32462: LD_VAR 0 5
32466: PUSH
32467: LD_INT 1
32469: PUSH
32470: LD_INT 0
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: IN
32477: NOT
32478: OR
32479: IFFALSE 32483
// exit ;
32481: GO 34040
// attempts = 0 ;
32483: LD_ADDR_VAR 0 17
32487: PUSH
32488: LD_INT 0
32490: ST_TO_ADDR
// repeat list_nearest = [ ] ;
32491: LD_ADDR_VAR 0 7
32495: PUSH
32496: EMPTY
32497: ST_TO_ADDR
// list_coords = [ ] ;
32498: LD_ADDR_VAR 0 8
32502: PUSH
32503: EMPTY
32504: ST_TO_ADDR
// temp_dir = AI_GetTurnDirection ( x , y , GetX ( unit1 ) , GetY ( unit1 ) ) ;
32505: LD_ADDR_VAR 0 9
32509: PUSH
32510: LD_VAR 0 2
32514: PPUSH
32515: LD_VAR 0 3
32519: PPUSH
32520: LD_VAR 0 1
32524: PPUSH
32525: CALL_OW 250
32529: PPUSH
32530: LD_VAR 0 1
32534: PPUSH
32535: CALL_OW 251
32539: PPUSH
32540: CALL 34045 0 4
32544: ST_TO_ADDR
// if attempts = 0 then
32545: LD_VAR 0 17
32549: PUSH
32550: LD_INT 0
32552: EQUAL
32553: IFFALSE 32661
// begin dir_list = [ temp_dir , temp_dir + 1 , temp_dir - 1 ] ;
32555: LD_ADDR_VAR 0 10
32559: PUSH
32560: LD_VAR 0 9
32564: PUSH
32565: LD_VAR 0 9
32569: PUSH
32570: LD_INT 1
32572: PLUS
32573: PUSH
32574: LD_VAR 0 9
32578: PUSH
32579: LD_INT 1
32581: MINUS
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: LIST
32587: ST_TO_ADDR
// if dir_list [ 2 ] = 6 then
32588: LD_VAR 0 10
32592: PUSH
32593: LD_INT 2
32595: ARRAY
32596: PUSH
32597: LD_INT 6
32599: EQUAL
32600: IFFALSE 32623
// dir_list = Replace ( dir_list , 2 , 0 ) ;
32602: LD_ADDR_VAR 0 10
32606: PUSH
32607: LD_VAR 0 10
32611: PPUSH
32612: LD_INT 2
32614: PPUSH
32615: LD_INT 0
32617: PPUSH
32618: CALL_OW 1
32622: ST_TO_ADDR
// if dir_list [ 3 ] = - 1 then
32623: LD_VAR 0 10
32627: PUSH
32628: LD_INT 3
32630: ARRAY
32631: PUSH
32632: LD_INT 1
32634: NEG
32635: EQUAL
32636: IFFALSE 32659
// dir_list = Replace ( dir_list , 3 , 5 ) ;
32638: LD_ADDR_VAR 0 10
32642: PUSH
32643: LD_VAR 0 10
32647: PPUSH
32648: LD_INT 3
32650: PPUSH
32651: LD_INT 5
32653: PPUSH
32654: CALL_OW 1
32658: ST_TO_ADDR
// end else
32659: GO 32698
// dir_list = [ 0 , 1 , 2 , 3 , 4 , 5 ] diff temp_dir ;
32661: LD_ADDR_VAR 0 10
32665: PUSH
32666: LD_INT 0
32668: PUSH
32669: LD_INT 1
32671: PUSH
32672: LD_INT 2
32674: PUSH
32675: LD_INT 3
32677: PUSH
32678: LD_INT 4
32680: PUSH
32681: LD_INT 5
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: PUSH
32692: LD_VAR 0 9
32696: DIFF
32697: ST_TO_ADDR
// for c = 1 to ( dir_list + 0 ) do
32698: LD_ADDR_VAR 0 14
32702: PUSH
32703: DOUBLE
32704: LD_INT 1
32706: DEC
32707: ST_TO_ADDR
32708: LD_VAR 0 10
32712: PUSH
32713: LD_INT 0
32715: PLUS
32716: PUSH
32717: FOR_TO
32718: IFFALSE 33040
// case dir_list [ c ] of 0 :
32720: LD_VAR 0 10
32724: PUSH
32725: LD_VAR 0 14
32729: ARRAY
32730: PUSH
32731: LD_INT 0
32733: DOUBLE
32734: EQUAL
32735: IFTRUE 32739
32737: GO 32780
32739: POP
// list_coords = Insert ( list_coords , 1 , [ x , y - dist ] ) ; 1 :
32740: LD_ADDR_VAR 0 8
32744: PUSH
32745: LD_VAR 0 8
32749: PPUSH
32750: LD_INT 1
32752: PPUSH
32753: LD_VAR 0 2
32757: PUSH
32758: LD_VAR 0 3
32762: PUSH
32763: LD_VAR 0 4
32767: MINUS
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PPUSH
32773: CALL_OW 2
32777: ST_TO_ADDR
32778: GO 33038
32780: LD_INT 1
32782: DOUBLE
32783: EQUAL
32784: IFTRUE 32788
32786: GO 32829
32788: POP
// list_coords = Insert ( list_coords , 1 , [ x + dist , y ] ) ; 2 :
32789: LD_ADDR_VAR 0 8
32793: PUSH
32794: LD_VAR 0 8
32798: PPUSH
32799: LD_INT 1
32801: PPUSH
32802: LD_VAR 0 2
32806: PUSH
32807: LD_VAR 0 4
32811: PLUS
32812: PUSH
32813: LD_VAR 0 3
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PPUSH
32822: CALL_OW 2
32826: ST_TO_ADDR
32827: GO 33038
32829: LD_INT 2
32831: DOUBLE
32832: EQUAL
32833: IFTRUE 32837
32835: GO 32884
32837: POP
// list_coords = Insert ( list_coords , 1 , [ x + dist , y + dist ] ) ; 3 :
32838: LD_ADDR_VAR 0 8
32842: PUSH
32843: LD_VAR 0 8
32847: PPUSH
32848: LD_INT 1
32850: PPUSH
32851: LD_VAR 0 2
32855: PUSH
32856: LD_VAR 0 4
32860: PLUS
32861: PUSH
32862: LD_VAR 0 3
32866: PUSH
32867: LD_VAR 0 4
32871: PLUS
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PPUSH
32877: CALL_OW 2
32881: ST_TO_ADDR
32882: GO 33038
32884: LD_INT 3
32886: DOUBLE
32887: EQUAL
32888: IFTRUE 32892
32890: GO 32933
32892: POP
// list_coords = Insert ( list_coords , 1 , [ x , y + dist ] ) ; 4 :
32893: LD_ADDR_VAR 0 8
32897: PUSH
32898: LD_VAR 0 8
32902: PPUSH
32903: LD_INT 1
32905: PPUSH
32906: LD_VAR 0 2
32910: PUSH
32911: LD_VAR 0 3
32915: PUSH
32916: LD_VAR 0 4
32920: PLUS
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: PPUSH
32926: CALL_OW 2
32930: ST_TO_ADDR
32931: GO 33038
32933: LD_INT 4
32935: DOUBLE
32936: EQUAL
32937: IFTRUE 32941
32939: GO 32982
32941: POP
// list_coords = Insert ( list_coords , 1 , [ x - dist , y ] ) ; 5 :
32942: LD_ADDR_VAR 0 8
32946: PUSH
32947: LD_VAR 0 8
32951: PPUSH
32952: LD_INT 1
32954: PPUSH
32955: LD_VAR 0 2
32959: PUSH
32960: LD_VAR 0 4
32964: MINUS
32965: PUSH
32966: LD_VAR 0 3
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PPUSH
32975: CALL_OW 2
32979: ST_TO_ADDR
32980: GO 33038
32982: LD_INT 5
32984: DOUBLE
32985: EQUAL
32986: IFTRUE 32990
32988: GO 33037
32990: POP
// list_coords = Insert ( list_coords , 1 , [ x - dist , y - dist ] ) ; end ;
32991: LD_ADDR_VAR 0 8
32995: PUSH
32996: LD_VAR 0 8
33000: PPUSH
33001: LD_INT 1
33003: PPUSH
33004: LD_VAR 0 2
33008: PUSH
33009: LD_VAR 0 4
33013: MINUS
33014: PUSH
33015: LD_VAR 0 3
33019: PUSH
33020: LD_VAR 0 4
33024: MINUS
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PPUSH
33030: CALL_OW 2
33034: ST_TO_ADDR
33035: GO 33038
33037: POP
33038: GO 32717
33040: POP
33041: POP
// if dist < 30 then
33042: LD_VAR 0 4
33046: PUSH
33047: LD_INT 30
33049: LESS
33050: IFFALSE 33062
// c = 1 else
33052: LD_ADDR_VAR 0 14
33056: PUSH
33057: LD_INT 1
33059: ST_TO_ADDR
33060: GO 33070
// c = 2 ;
33062: LD_ADDR_VAR 0 14
33066: PUSH
33067: LD_INT 2
33069: ST_TO_ADDR
// b = 1 ;
33070: LD_ADDR_VAR 0 11
33074: PUSH
33075: LD_INT 1
33077: ST_TO_ADDR
// while b <= ( dist - 1 ) do
33078: LD_VAR 0 11
33082: PUSH
33083: LD_VAR 0 4
33087: PUSH
33088: LD_INT 1
33090: MINUS
33091: LESSEQUAL
33092: IFFALSE 33520
// begin if 0 in dir_list and 1 in dir_list then
33094: LD_INT 0
33096: PUSH
33097: LD_VAR 0 10
33101: IN
33102: PUSH
33103: LD_INT 1
33105: PUSH
33106: LD_VAR 0 10
33110: IN
33111: AND
33112: IFFALSE 33164
// list_coords = Insert ( list_coords , 1 , [ x + b , y - dist + b ] ) ;
33114: LD_ADDR_VAR 0 8
33118: PUSH
33119: LD_VAR 0 8
33123: PPUSH
33124: LD_INT 1
33126: PPUSH
33127: LD_VAR 0 2
33131: PUSH
33132: LD_VAR 0 11
33136: PLUS
33137: PUSH
33138: LD_VAR 0 3
33142: PUSH
33143: LD_VAR 0 4
33147: MINUS
33148: PUSH
33149: LD_VAR 0 11
33153: PLUS
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PPUSH
33159: CALL_OW 2
33163: ST_TO_ADDR
// if 1 in dir_list and 2 in dir_list then
33164: LD_INT 1
33166: PUSH
33167: LD_VAR 0 10
33171: IN
33172: PUSH
33173: LD_INT 2
33175: PUSH
33176: LD_VAR 0 10
33180: IN
33181: AND
33182: IFFALSE 33228
// list_coords = Insert ( list_coords , 1 , [ x + dist , y + b ] ) ;
33184: LD_ADDR_VAR 0 8
33188: PUSH
33189: LD_VAR 0 8
33193: PPUSH
33194: LD_INT 1
33196: PPUSH
33197: LD_VAR 0 2
33201: PUSH
33202: LD_VAR 0 4
33206: PLUS
33207: PUSH
33208: LD_VAR 0 3
33212: PUSH
33213: LD_VAR 0 11
33217: PLUS
33218: PUSH
33219: EMPTY
33220: LIST
33221: LIST
33222: PPUSH
33223: CALL_OW 2
33227: ST_TO_ADDR
// if 2 in dir_list and 3 in dir_list then
33228: LD_INT 2
33230: PUSH
33231: LD_VAR 0 10
33235: IN
33236: PUSH
33237: LD_INT 3
33239: PUSH
33240: LD_VAR 0 10
33244: IN
33245: AND
33246: IFFALSE 33298
// list_coords = Insert ( list_coords , 1 , [ x + dist - b , y + dist ] ) ;
33248: LD_ADDR_VAR 0 8
33252: PUSH
33253: LD_VAR 0 8
33257: PPUSH
33258: LD_INT 1
33260: PPUSH
33261: LD_VAR 0 2
33265: PUSH
33266: LD_VAR 0 4
33270: PLUS
33271: PUSH
33272: LD_VAR 0 11
33276: MINUS
33277: PUSH
33278: LD_VAR 0 3
33282: PUSH
33283: LD_VAR 0 4
33287: PLUS
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PPUSH
33293: CALL_OW 2
33297: ST_TO_ADDR
// if 3 in dir_list and 4 in dir_list then
33298: LD_INT 3
33300: PUSH
33301: LD_VAR 0 10
33305: IN
33306: PUSH
33307: LD_INT 4
33309: PUSH
33310: LD_VAR 0 10
33314: IN
33315: AND
33316: IFFALSE 33368
// list_coords = Insert ( list_coords , 1 , [ x - b , y + dist - b ] ) ;
33318: LD_ADDR_VAR 0 8
33322: PUSH
33323: LD_VAR 0 8
33327: PPUSH
33328: LD_INT 1
33330: PPUSH
33331: LD_VAR 0 2
33335: PUSH
33336: LD_VAR 0 11
33340: MINUS
33341: PUSH
33342: LD_VAR 0 3
33346: PUSH
33347: LD_VAR 0 4
33351: PLUS
33352: PUSH
33353: LD_VAR 0 11
33357: MINUS
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PPUSH
33363: CALL_OW 2
33367: ST_TO_ADDR
// if 4 in dir_list and 5 in dir_list then
33368: LD_INT 4
33370: PUSH
33371: LD_VAR 0 10
33375: IN
33376: PUSH
33377: LD_INT 5
33379: PUSH
33380: LD_VAR 0 10
33384: IN
33385: AND
33386: IFFALSE 33432
// list_coords = Insert ( list_coords , 1 , [ x - dist , y - b ] ) ;
33388: LD_ADDR_VAR 0 8
33392: PUSH
33393: LD_VAR 0 8
33397: PPUSH
33398: LD_INT 1
33400: PPUSH
33401: LD_VAR 0 2
33405: PUSH
33406: LD_VAR 0 4
33410: MINUS
33411: PUSH
33412: LD_VAR 0 3
33416: PUSH
33417: LD_VAR 0 11
33421: MINUS
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PPUSH
33427: CALL_OW 2
33431: ST_TO_ADDR
// if 5 in dir_list and 0 in dir_list then
33432: LD_INT 5
33434: PUSH
33435: LD_VAR 0 10
33439: IN
33440: PUSH
33441: LD_INT 0
33443: PUSH
33444: LD_VAR 0 10
33448: IN
33449: AND
33450: IFFALSE 33502
// list_coords = Insert ( list_coords , 1 , [ x - dist + b , y - dist ] ) ;
33452: LD_ADDR_VAR 0 8
33456: PUSH
33457: LD_VAR 0 8
33461: PPUSH
33462: LD_INT 1
33464: PPUSH
33465: LD_VAR 0 2
33469: PUSH
33470: LD_VAR 0 4
33474: MINUS
33475: PUSH
33476: LD_VAR 0 11
33480: PLUS
33481: PUSH
33482: LD_VAR 0 3
33486: PUSH
33487: LD_VAR 0 4
33491: MINUS
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PPUSH
33497: CALL_OW 2
33501: ST_TO_ADDR
// b = b + c end ;
33502: LD_ADDR_VAR 0 11
33506: PUSH
33507: LD_VAR 0 11
33511: PUSH
33512: LD_VAR 0 14
33516: PLUS
33517: ST_TO_ADDR
33518: GO 33078
// if list_coords = 0 then
33520: LD_VAR 0 8
33524: PUSH
33525: LD_INT 0
33527: EQUAL
33528: IFFALSE 33532
// exit ;
33530: GO 34040
// repeat min_dist = 5000 ;
33532: LD_ADDR_VAR 0 12
33536: PUSH
33537: LD_INT 5000
33539: ST_TO_ADDR
// for b in list_coords do
33540: LD_ADDR_VAR 0 11
33544: PUSH
33545: LD_VAR 0 8
33549: PUSH
33550: FOR_IN
33551: IFFALSE 33610
// begin temp_dist = GetDistUnitXY ( unit1 , b [ 1 ] , b [ 2 ] ) ;
33553: LD_ADDR_VAR 0 13
33557: PUSH
33558: LD_VAR 0 1
33562: PPUSH
33563: LD_VAR 0 11
33567: PUSH
33568: LD_INT 1
33570: ARRAY
33571: PPUSH
33572: LD_VAR 0 11
33576: PUSH
33577: LD_INT 2
33579: ARRAY
33580: PPUSH
33581: CALL_OW 297
33585: ST_TO_ADDR
// if temp_dist < min_dist then
33586: LD_VAR 0 13
33590: PUSH
33591: LD_VAR 0 12
33595: LESS
33596: IFFALSE 33608
// min_dist = temp_dist ;
33598: LD_ADDR_VAR 0 12
33602: PUSH
33603: LD_VAR 0 13
33607: ST_TO_ADDR
// end ;
33608: GO 33550
33610: POP
33611: POP
// c = 0 ;
33612: LD_ADDR_VAR 0 14
33616: PUSH
33617: LD_INT 0
33619: ST_TO_ADDR
// repeat c = c + 1 ;
33620: LD_ADDR_VAR 0 14
33624: PUSH
33625: LD_VAR 0 14
33629: PUSH
33630: LD_INT 1
33632: PLUS
33633: ST_TO_ADDR
// if GetDistUnitXY ( unit1 , list_coords [ c ] [ 1 ] , list_coords [ c ] [ 2 ] ) = min_dist then
33634: LD_VAR 0 1
33638: PPUSH
33639: LD_VAR 0 8
33643: PUSH
33644: LD_VAR 0 14
33648: ARRAY
33649: PUSH
33650: LD_INT 1
33652: ARRAY
33653: PPUSH
33654: LD_VAR 0 8
33658: PUSH
33659: LD_VAR 0 14
33663: ARRAY
33664: PUSH
33665: LD_INT 2
33667: ARRAY
33668: PPUSH
33669: CALL_OW 297
33673: PUSH
33674: LD_VAR 0 12
33678: EQUAL
33679: IFFALSE 33744
// begin list_nearest = Insert ( list_nearest , 1 , list_coords [ c ] ) ;
33681: LD_ADDR_VAR 0 7
33685: PUSH
33686: LD_VAR 0 7
33690: PPUSH
33691: LD_INT 1
33693: PPUSH
33694: LD_VAR 0 8
33698: PUSH
33699: LD_VAR 0 14
33703: ARRAY
33704: PPUSH
33705: CALL_OW 2
33709: ST_TO_ADDR
// list_coords = Delete ( list_coords , c ) ;
33710: LD_ADDR_VAR 0 8
33714: PUSH
33715: LD_VAR 0 8
33719: PPUSH
33720: LD_VAR 0 14
33724: PPUSH
33725: CALL_OW 3
33729: ST_TO_ADDR
// c = c - 1 ;
33730: LD_ADDR_VAR 0 14
33734: PUSH
33735: LD_VAR 0 14
33739: PUSH
33740: LD_INT 1
33742: MINUS
33743: ST_TO_ADDR
// end ; until c = list_coords ;
33744: LD_VAR 0 14
33748: PUSH
33749: LD_VAR 0 8
33753: EQUAL
33754: IFFALSE 33620
// c = 0 ;
33756: LD_ADDR_VAR 0 14
33760: PUSH
33761: LD_INT 0
33763: ST_TO_ADDR
// if list_nearest > 0 then
33764: LD_VAR 0 7
33768: PUSH
33769: LD_INT 0
33771: GREATER
33772: IFFALSE 33914
// begin repeat rand_num = Rand ( 1 , list_nearest ) ;
33774: LD_ADDR_VAR 0 15
33778: PUSH
33779: LD_INT 1
33781: PPUSH
33782: LD_VAR 0 7
33786: PPUSH
33787: CALL_OW 12
33791: ST_TO_ADDR
// rand_near_hex = list_nearest [ rand_num ] ;
33792: LD_ADDR_VAR 0 16
33796: PUSH
33797: LD_VAR 0 7
33801: PUSH
33802: LD_VAR 0 15
33806: ARRAY
33807: ST_TO_ADDR
// if ValidHex ( rand_near_hex [ 1 ] , rand_near_hex [ 2 ] ) > 0 and HexInfo ( rand_near_hex [ 1 ] , rand_near_hex [ 2 ] ) = 0 then
33808: LD_VAR 0 16
33812: PUSH
33813: LD_INT 1
33815: ARRAY
33816: PPUSH
33817: LD_VAR 0 16
33821: PUSH
33822: LD_INT 2
33824: ARRAY
33825: PPUSH
33826: CALL_OW 488
33830: PUSH
33831: LD_INT 0
33833: GREATER
33834: PUSH
33835: LD_VAR 0 16
33839: PUSH
33840: LD_INT 1
33842: ARRAY
33843: PPUSH
33844: LD_VAR 0 16
33848: PUSH
33849: LD_INT 2
33851: ARRAY
33852: PPUSH
33853: CALL_OW 428
33857: PUSH
33858: LD_INT 0
33860: EQUAL
33861: AND
33862: IFFALSE 33874
// c = 1 else
33864: LD_ADDR_VAR 0 14
33868: PUSH
33869: LD_INT 1
33871: ST_TO_ADDR
33872: GO 33894
// list_nearest = Delete ( list_nearest , rand_num ) ;
33874: LD_ADDR_VAR 0 7
33878: PUSH
33879: LD_VAR 0 7
33883: PPUSH
33884: LD_VAR 0 15
33888: PPUSH
33889: CALL_OW 3
33893: ST_TO_ADDR
// until c = 1 or list_nearest = 0 ;
33894: LD_VAR 0 14
33898: PUSH
33899: LD_INT 1
33901: EQUAL
33902: PUSH
33903: LD_VAR 0 7
33907: PUSH
33908: LD_INT 0
33910: EQUAL
33911: OR
33912: IFFALSE 33774
// end ; until c = 1 or list_coords = 0 ;
33914: LD_VAR 0 14
33918: PUSH
33919: LD_INT 1
33921: EQUAL
33922: PUSH
33923: LD_VAR 0 8
33927: PUSH
33928: LD_INT 0
33930: EQUAL
33931: OR
33932: IFFALSE 33532
// attempts = attempts + 1 ;
33934: LD_ADDR_VAR 0 17
33938: PUSH
33939: LD_VAR 0 17
33943: PUSH
33944: LD_INT 1
33946: PLUS
33947: ST_TO_ADDR
// until c = 1 or attempts > 1 ;
33948: LD_VAR 0 14
33952: PUSH
33953: LD_INT 1
33955: EQUAL
33956: PUSH
33957: LD_VAR 0 17
33961: PUSH
33962: LD_INT 1
33964: GREATER
33965: OR
33966: IFFALSE 32491
// if c = 1 then
33968: LD_VAR 0 14
33972: PUSH
33973: LD_INT 1
33975: EQUAL
33976: IFFALSE 34040
// if add then
33978: LD_VAR 0 5
33982: IFFALSE 34013
// AddComMoveXY ( unit1 , rand_near_hex [ 1 ] , rand_near_hex [ 2 ] ) else
33984: LD_VAR 0 1
33988: PPUSH
33989: LD_VAR 0 16
33993: PUSH
33994: LD_INT 1
33996: ARRAY
33997: PPUSH
33998: LD_VAR 0 16
34002: PUSH
34003: LD_INT 2
34005: ARRAY
34006: PPUSH
34007: CALL_OW 171
34011: GO 34040
// ComMoveXY ( unit1 , rand_near_hex [ 1 ] , rand_near_hex [ 2 ] ) ;
34013: LD_VAR 0 1
34017: PPUSH
34018: LD_VAR 0 16
34022: PUSH
34023: LD_INT 1
34025: ARRAY
34026: PPUSH
34027: LD_VAR 0 16
34031: PUSH
34032: LD_INT 2
34034: ARRAY
34035: PPUSH
34036: CALL_OW 111
// end ;
34040: LD_VAR 0 6
34044: RET
// export function AI_GetTurnDirection ( x1 , y1 , x , y ) ; var dist_1 , dist_2 , b , temp_dist , dir ; begin
34045: LD_INT 0
34047: PPUSH
34048: PPUSH
34049: PPUSH
34050: PPUSH
34051: PPUSH
34052: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x , y ) then
34053: LD_VAR 0 1
34057: PPUSH
34058: LD_VAR 0 2
34062: PPUSH
34063: CALL_OW 488
34067: NOT
34068: PUSH
34069: LD_VAR 0 3
34073: PPUSH
34074: LD_VAR 0 4
34078: PPUSH
34079: CALL_OW 488
34083: NOT
34084: OR
34085: IFFALSE 34098
// begin result = - 1 ;
34087: LD_ADDR_VAR 0 5
34091: PUSH
34092: LD_INT 1
34094: NEG
34095: ST_TO_ADDR
// exit ;
34096: GO 34258
// end ; dist_1 = GetDistXY ( x1 , y1 , x , y ) ;
34098: LD_ADDR_VAR 0 6
34102: PUSH
34103: LD_VAR 0 1
34107: PPUSH
34108: LD_VAR 0 2
34112: PPUSH
34113: LD_VAR 0 3
34117: PPUSH
34118: LD_VAR 0 4
34122: PPUSH
34123: CALL_OW 298
34127: ST_TO_ADDR
// dist_2 = 99999 ;
34128: LD_ADDR_VAR 0 7
34132: PUSH
34133: LD_INT 99999
34135: ST_TO_ADDR
// for b = 0 to 5 do
34136: LD_ADDR_VAR 0 8
34140: PUSH
34141: DOUBLE
34142: LD_INT 0
34144: DEC
34145: ST_TO_ADDR
34146: LD_INT 5
34148: PUSH
34149: FOR_TO
34150: IFFALSE 34246
// begin temp_dist = GetDistXY ( ShiftX ( x1 , b , dist_1 ) , ShiftY ( y1 , b , dist_1 ) , x , y ) ;
34152: LD_ADDR_VAR 0 9
34156: PUSH
34157: LD_VAR 0 1
34161: PPUSH
34162: LD_VAR 0 8
34166: PPUSH
34167: LD_VAR 0 6
34171: PPUSH
34172: CALL_OW 272
34176: PPUSH
34177: LD_VAR 0 2
34181: PPUSH
34182: LD_VAR 0 8
34186: PPUSH
34187: LD_VAR 0 6
34191: PPUSH
34192: CALL_OW 273
34196: PPUSH
34197: LD_VAR 0 3
34201: PPUSH
34202: LD_VAR 0 4
34206: PPUSH
34207: CALL_OW 298
34211: ST_TO_ADDR
// if temp_dist < dist_2 then
34212: LD_VAR 0 9
34216: PUSH
34217: LD_VAR 0 7
34221: LESS
34222: IFFALSE 34244
// begin dist_2 = temp_dist ;
34224: LD_ADDR_VAR 0 7
34228: PUSH
34229: LD_VAR 0 9
34233: ST_TO_ADDR
// dir = b ;
34234: LD_ADDR_VAR 0 10
34238: PUSH
34239: LD_VAR 0 8
34243: ST_TO_ADDR
// end ; end ;
34244: GO 34149
34246: POP
34247: POP
// result = dir ;
34248: LD_ADDR_VAR 0 5
34252: PUSH
34253: LD_VAR 0 10
34257: ST_TO_ADDR
// end ;
34258: LD_VAR 0 5
34262: RET
// export function AI_InvertDirection ( direction ) ; var dir ; begin
34263: LD_INT 0
34265: PPUSH
34266: PPUSH
// dir = direction - 3 ;
34267: LD_ADDR_VAR 0 3
34271: PUSH
34272: LD_VAR 0 1
34276: PUSH
34277: LD_INT 3
34279: MINUS
34280: ST_TO_ADDR
// if dir < 0 then
34281: LD_VAR 0 3
34285: PUSH
34286: LD_INT 0
34288: LESS
34289: IFFALSE 34305
// dir = dir + 6 ;
34291: LD_ADDR_VAR 0 3
34295: PUSH
34296: LD_VAR 0 3
34300: PUSH
34301: LD_INT 6
34303: PLUS
34304: ST_TO_ADDR
// result = dir ;
34305: LD_ADDR_VAR 0 2
34309: PUSH
34310: LD_VAR 0 3
34314: ST_TO_ADDR
// end ;
34315: LD_VAR 0 2
34319: RET
// var disp_strings ; export function AddOrUpdateDisplayStrings ( str , param_list ) ; var i , k ; begin
34320: LD_INT 0
34322: PPUSH
34323: PPUSH
34324: PPUSH
// if disp_strings = 0 then
34325: LD_LOC 1
34329: PUSH
34330: LD_INT 0
34332: EQUAL
34333: IFFALSE 34342
// disp_strings = [ ] ;
34335: LD_ADDR_LOC 1
34339: PUSH
34340: EMPTY
34341: ST_TO_ADDR
// for i = 1 to display_strings do
34342: LD_ADDR_VAR 0 4
34346: PUSH
34347: DOUBLE
34348: LD_INT 1
34350: DEC
34351: ST_TO_ADDR
34352: LD_OWVAR 47
34356: PUSH
34357: FOR_TO
34358: IFFALSE 34444
// begin if display_strings [ i ] = str then
34360: LD_OWVAR 47
34364: PUSH
34365: LD_VAR 0 4
34369: ARRAY
34370: PUSH
34371: LD_VAR 0 1
34375: EQUAL
34376: IFFALSE 34442
// begin for k in param_list do
34378: LD_ADDR_VAR 0 5
34382: PUSH
34383: LD_VAR 0 2
34387: PUSH
34388: FOR_IN
34389: IFFALSE 34436
// begin display_strings = Replace ( display_strings , i + 1 , k ) ;
34391: LD_ADDR_OWVAR 47
34395: PUSH
34396: LD_OWVAR 47
34400: PPUSH
34401: LD_VAR 0 4
34405: PUSH
34406: LD_INT 1
34408: PLUS
34409: PPUSH
34410: LD_VAR 0 5
34414: PPUSH
34415: CALL_OW 1
34419: ST_TO_ADDR
// i = i + 1 ;
34420: LD_ADDR_VAR 0 4
34424: PUSH
34425: LD_VAR 0 4
34429: PUSH
34430: LD_INT 1
34432: PLUS
34433: ST_TO_ADDR
// end ;
34434: GO 34388
34436: POP
34437: POP
// exit ;
34438: POP
34439: POP
34440: GO 34484
// end ; end ;
34442: GO 34357
34444: POP
34445: POP
// disp_strings = disp_strings ^ str ;
34446: LD_ADDR_LOC 1
34450: PUSH
34451: LD_LOC 1
34455: PUSH
34456: LD_VAR 0 1
34460: ADD
34461: ST_TO_ADDR
// display_strings = display_strings ^ str ^ param_list ;
34462: LD_ADDR_OWVAR 47
34466: PUSH
34467: LD_OWVAR 47
34471: PUSH
34472: LD_VAR 0 1
34476: ADD
34477: PUSH
34478: LD_VAR 0 2
34482: ADD
34483: ST_TO_ADDR
// end ;
34484: LD_VAR 0 3
34488: RET
// export function DeleteDisplayStrings ( str ) ; var i ; begin
34489: LD_INT 0
34491: PPUSH
34492: PPUSH
// for i = 1 to display_strings do
34493: LD_ADDR_VAR 0 3
34497: PUSH
34498: DOUBLE
34499: LD_INT 1
34501: DEC
34502: ST_TO_ADDR
34503: LD_OWVAR 47
34507: PUSH
34508: FOR_TO
34509: IFFALSE 34601
// begin if display_strings [ i ] = str then
34511: LD_OWVAR 47
34515: PUSH
34516: LD_VAR 0 3
34520: ARRAY
34521: PUSH
34522: LD_VAR 0 1
34526: EQUAL
34527: IFFALSE 34599
// begin disp_strings = disp_strings diff str ;
34529: LD_ADDR_LOC 1
34533: PUSH
34534: LD_LOC 1
34538: PUSH
34539: LD_VAR 0 1
34543: DIFF
34544: ST_TO_ADDR
// repeat display_strings = Delete ( display_strings , i ) ;
34545: LD_ADDR_OWVAR 47
34549: PUSH
34550: LD_OWVAR 47
34554: PPUSH
34555: LD_VAR 0 3
34559: PPUSH
34560: CALL_OW 3
34564: ST_TO_ADDR
// if i > display_strings then
34565: LD_VAR 0 3
34569: PUSH
34570: LD_OWVAR 47
34574: GREATER
34575: IFFALSE 34579
// break ;
34577: GO 34597
// until display_strings [ i ] in disp_strings ;
34579: LD_OWVAR 47
34583: PUSH
34584: LD_VAR 0 3
34588: ARRAY
34589: PUSH
34590: LD_LOC 1
34594: IN
34595: IFFALSE 34545
// break ;
34597: GO 34601
// end ; end ;
34599: GO 34508
34601: POP
34602: POP
// end ; end_of_file
34603: LD_VAR 0 2
34607: RET
// every 0 0$1 + 0 0$0.8 do var temp_list , i , res , hex , temp_list_2 ; var player_units_with_mine_in_base , oil_barrels , timed_mines , player_soldiers_pos ;
34608: GO 34610
34610: DISABLE
34611: LD_INT 0
34613: PPUSH
34614: PPUSH
34615: PPUSH
34616: PPUSH
34617: PPUSH
34618: PPUSH
34619: PPUSH
34620: PPUSH
34621: PPUSH
// begin player_units_with_mine_in_base = [ ] ;
34622: LD_ADDR_VAR 0 6
34626: PUSH
34627: EMPTY
34628: ST_TO_ADDR
// timed_mines = [ ] ;
34629: LD_ADDR_VAR 0 8
34633: PUSH
34634: EMPTY
34635: ST_TO_ADDR
// player_soldiers_pos = [ ] ;
34636: LD_ADDR_VAR 0 9
34640: PUSH
34641: EMPTY
34642: ST_TO_ADDR
// oil_barrels = [ [ 48 , 4 ] , [ 50 , 4 ] , [ 48 , 2 ] , [ 49 , 2 ] , [ 50 , 2 ] ] ;
34643: LD_ADDR_VAR 0 7
34647: PUSH
34648: LD_INT 48
34650: PUSH
34651: LD_INT 4
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 50
34660: PUSH
34661: LD_INT 4
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 48
34670: PUSH
34671: LD_INT 2
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 49
34680: PUSH
34681: LD_INT 2
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 50
34690: PUSH
34691: LD_INT 2
34693: PUSH
34694: EMPTY
34695: LIST
34696: LIST
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34705: LD_INT 35
34707: PPUSH
34708: CALL_OW 67
// res = false ;
34712: LD_ADDR_VAR 0 3
34716: PUSH
34717: LD_INT 0
34719: ST_TO_ADDR
// i = 1 ;
34720: LD_ADDR_VAR 0 2
34724: PUSH
34725: LD_INT 1
34727: ST_TO_ADDR
// while i <= oil_barrels do
34728: LD_VAR 0 2
34732: PUSH
34733: LD_VAR 0 7
34737: LESSEQUAL
34738: IFFALSE 34842
// begin if GetResourceAmountXY ( oil_barrels [ i ] [ 1 ] , oil_barrels [ i ] [ 2 ] ) = 0 then
34740: LD_VAR 0 7
34744: PUSH
34745: LD_VAR 0 2
34749: ARRAY
34750: PUSH
34751: LD_INT 1
34753: ARRAY
34754: PPUSH
34755: LD_VAR 0 7
34759: PUSH
34760: LD_VAR 0 2
34764: ARRAY
34765: PUSH
34766: LD_INT 2
34768: ARRAY
34769: PPUSH
34770: CALL_OW 284
34774: PUSH
34775: LD_INT 0
34777: EQUAL
34778: IFFALSE 34826
// begin res = true ;
34780: LD_ADDR_VAR 0 3
34784: PUSH
34785: LD_INT 1
34787: ST_TO_ADDR
// last_known_enemy_hex = oil_barrels [ i ] ;
34788: LD_ADDR_EXP 122
34792: PUSH
34793: LD_VAR 0 7
34797: PUSH
34798: LD_VAR 0 2
34802: ARRAY
34803: ST_TO_ADDR
// oil_barrels = Delete ( oil_barrels , i ) ;
34804: LD_ADDR_VAR 0 7
34808: PUSH
34809: LD_VAR 0 7
34813: PPUSH
34814: LD_VAR 0 2
34818: PPUSH
34819: CALL_OW 3
34823: ST_TO_ADDR
// continue ;
34824: GO 34728
// end ; i = i + 1 ;
34826: LD_ADDR_VAR 0 2
34830: PUSH
34831: LD_VAR 0 2
34835: PUSH
34836: LD_INT 1
34838: PLUS
34839: ST_TO_ADDR
// end ;
34840: GO 34728
// i = 1 ;
34842: LD_ADDR_VAR 0 2
34846: PUSH
34847: LD_INT 1
34849: ST_TO_ADDR
// while i <= player_units_with_mine_in_base do
34850: LD_VAR 0 2
34854: PUSH
34855: LD_VAR 0 6
34859: LESSEQUAL
34860: IFFALSE 34947
// begin if not IsLive ( player_units_with_mine_in_base [ i ] [ 1 ] ) or GetClass ( player_units_with_mine_in_base [ i ] [ 1 ] ) <> class_soldier then
34862: LD_VAR 0 6
34866: PUSH
34867: LD_VAR 0 2
34871: ARRAY
34872: PUSH
34873: LD_INT 1
34875: ARRAY
34876: PPUSH
34877: CALL_OW 300
34881: NOT
34882: PUSH
34883: LD_VAR 0 6
34887: PUSH
34888: LD_VAR 0 2
34892: ARRAY
34893: PUSH
34894: LD_INT 1
34896: ARRAY
34897: PPUSH
34898: CALL_OW 257
34902: PUSH
34903: LD_INT 1
34905: NONEQUAL
34906: OR
34907: IFFALSE 34931
// begin player_units_with_mine_in_base = Delete ( player_units_with_mine_in_base , i ) ;
34909: LD_ADDR_VAR 0 6
34913: PUSH
34914: LD_VAR 0 6
34918: PPUSH
34919: LD_VAR 0 2
34923: PPUSH
34924: CALL_OW 3
34928: ST_TO_ADDR
// continue ;
34929: GO 34850
// end ; i = i + 1 ;
34931: LD_ADDR_VAR 0 2
34935: PUSH
34936: LD_VAR 0 2
34940: PUSH
34941: LD_INT 1
34943: PLUS
34944: ST_TO_ADDR
// end ;
34945: GO 34850
// temp_list = [ ] ;
34947: LD_ADDR_VAR 0 1
34951: PUSH
34952: EMPTY
34953: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_class , class_soldier ] ] ) do
34954: LD_ADDR_VAR 0 2
34958: PUSH
34959: LD_INT 22
34961: PUSH
34962: LD_EXP 2
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 25
34973: PUSH
34974: LD_INT 1
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PPUSH
34985: CALL_OW 69
34989: PUSH
34990: FOR_IN
34991: IFFALSE 35089
// begin hex = MineOfUnit ( i ) ;
34993: LD_ADDR_VAR 0 4
34997: PUSH
34998: LD_VAR 0 2
35002: PPUSH
35003: CALL_OW 459
35007: ST_TO_ADDR
// if hex > 0 then
35008: LD_VAR 0 4
35012: PUSH
35013: LD_INT 0
35015: GREATER
35016: IFFALSE 35087
// if InArea ( hex [ 1 ] , hex [ 2 ] , ru_base_area ) then
35018: LD_VAR 0 4
35022: PUSH
35023: LD_INT 1
35025: ARRAY
35026: PPUSH
35027: LD_VAR 0 4
35031: PUSH
35032: LD_INT 2
35034: ARRAY
35035: PPUSH
35036: LD_INT 2
35038: PPUSH
35039: CALL_OW 309
35043: IFFALSE 35087
// temp_list = temp_list ^ [ [ i , hex [ 1 ] , hex [ 2 ] ] ] ;
35045: LD_ADDR_VAR 0 1
35049: PUSH
35050: LD_VAR 0 1
35054: PUSH
35055: LD_VAR 0 2
35059: PUSH
35060: LD_VAR 0 4
35064: PUSH
35065: LD_INT 1
35067: ARRAY
35068: PUSH
35069: LD_VAR 0 4
35073: PUSH
35074: LD_INT 2
35076: ARRAY
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: LIST
35082: PUSH
35083: EMPTY
35084: LIST
35085: ADD
35086: ST_TO_ADDR
// end ;
35087: GO 34990
35089: POP
35090: POP
// temp_list_2 = player_units_with_mine_in_base diff temp_list ;
35091: LD_ADDR_VAR 0 5
35095: PUSH
35096: LD_VAR 0 6
35100: PUSH
35101: LD_VAR 0 1
35105: DIFF
35106: ST_TO_ADDR
// if temp_list_2 > 0 then
35107: LD_VAR 0 5
35111: PUSH
35112: LD_INT 0
35114: GREATER
35115: IFFALSE 35160
// begin res = true ;
35117: LD_ADDR_VAR 0 3
35121: PUSH
35122: LD_INT 1
35124: ST_TO_ADDR
// last_known_enemy_hex = [ temp_list_2 [ 1 ] [ 2 ] , temp_list_2 [ 1 ] [ 3 ] ] ;
35125: LD_ADDR_EXP 122
35129: PUSH
35130: LD_VAR 0 5
35134: PUSH
35135: LD_INT 1
35137: ARRAY
35138: PUSH
35139: LD_INT 2
35141: ARRAY
35142: PUSH
35143: LD_VAR 0 5
35147: PUSH
35148: LD_INT 1
35150: ARRAY
35151: PUSH
35152: LD_INT 3
35154: ARRAY
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: ST_TO_ADDR
// end ; player_units_with_mine_in_base = temp_list ;
35160: LD_ADDR_VAR 0 6
35164: PUSH
35165: LD_VAR 0 1
35169: ST_TO_ADDR
// i = 1 ;
35170: LD_ADDR_VAR 0 2
35174: PUSH
35175: LD_INT 1
35177: ST_TO_ADDR
// while i <= timed_mines do
35178: LD_VAR 0 2
35182: PUSH
35183: LD_VAR 0 8
35187: LESSEQUAL
35188: IFFALSE 35292
// begin if MineAtPos ( timed_mines [ i ] [ 1 ] , timed_mines [ i ] [ 2 ] ) = 0 then
35190: LD_VAR 0 8
35194: PUSH
35195: LD_VAR 0 2
35199: ARRAY
35200: PUSH
35201: LD_INT 1
35203: ARRAY
35204: PPUSH
35205: LD_VAR 0 8
35209: PUSH
35210: LD_VAR 0 2
35214: ARRAY
35215: PUSH
35216: LD_INT 2
35218: ARRAY
35219: PPUSH
35220: CALL_OW 458
35224: PUSH
35225: LD_INT 0
35227: EQUAL
35228: IFFALSE 35276
// begin res = true ;
35230: LD_ADDR_VAR 0 3
35234: PUSH
35235: LD_INT 1
35237: ST_TO_ADDR
// last_known_enemy_hex = timed_mines [ i ] ;
35238: LD_ADDR_EXP 122
35242: PUSH
35243: LD_VAR 0 8
35247: PUSH
35248: LD_VAR 0 2
35252: ARRAY
35253: ST_TO_ADDR
// timed_mines = Delete ( timed_mines , i ) ;
35254: LD_ADDR_VAR 0 8
35258: PUSH
35259: LD_VAR 0 8
35263: PPUSH
35264: LD_VAR 0 2
35268: PPUSH
35269: CALL_OW 3
35273: ST_TO_ADDR
// continue ;
35274: GO 35178
// end ; i = i + 1 ;
35276: LD_ADDR_VAR 0 2
35280: PUSH
35281: LD_VAR 0 2
35285: PUSH
35286: LD_INT 1
35288: PLUS
35289: ST_TO_ADDR
// end ;
35290: GO 35178
// for i in player_soldiers_pos do
35292: LD_ADDR_VAR 0 2
35296: PUSH
35297: LD_VAR 0 9
35301: PUSH
35302: FOR_IN
35303: IFFALSE 35388
// if MineAtPos ( i [ 2 ] , i [ 3 ] ) and not i [ 1 ] in player_units_with_mine_in_base then
35305: LD_VAR 0 2
35309: PUSH
35310: LD_INT 2
35312: ARRAY
35313: PPUSH
35314: LD_VAR 0 2
35318: PUSH
35319: LD_INT 3
35321: ARRAY
35322: PPUSH
35323: CALL_OW 458
35327: PUSH
35328: LD_VAR 0 2
35332: PUSH
35333: LD_INT 1
35335: ARRAY
35336: PUSH
35337: LD_VAR 0 6
35341: IN
35342: NOT
35343: AND
35344: IFFALSE 35386
// timed_mines = Insert ( timed_mines , 1 , [ i [ 2 ] , i [ 3 ] ] ) ;
35346: LD_ADDR_VAR 0 8
35350: PUSH
35351: LD_VAR 0 8
35355: PPUSH
35356: LD_INT 1
35358: PPUSH
35359: LD_VAR 0 2
35363: PUSH
35364: LD_INT 2
35366: ARRAY
35367: PUSH
35368: LD_VAR 0 2
35372: PUSH
35373: LD_INT 3
35375: ARRAY
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PPUSH
35381: CALL_OW 2
35385: ST_TO_ADDR
35386: GO 35302
35388: POP
35389: POP
// player_soldiers_pos = [ ] ;
35390: LD_ADDR_VAR 0 9
35394: PUSH
35395: EMPTY
35396: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_class , class_soldier ] , [ f_inarea , ru_base_area ] ] ) do
35397: LD_ADDR_VAR 0 2
35401: PUSH
35402: LD_INT 22
35404: PUSH
35405: LD_EXP 2
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 25
35416: PUSH
35417: LD_INT 1
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 95
35426: PUSH
35427: LD_INT 2
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: LIST
35438: PPUSH
35439: CALL_OW 69
35443: PUSH
35444: FOR_IN
35445: IFFALSE 35497
// player_soldiers_pos = Insert ( player_soldiers_pos , 1 , [ i , GetX ( i ) , GetY ( i ) ] ) ;
35447: LD_ADDR_VAR 0 9
35451: PUSH
35452: LD_VAR 0 9
35456: PPUSH
35457: LD_INT 1
35459: PPUSH
35460: LD_VAR 0 2
35464: PUSH
35465: LD_VAR 0 2
35469: PPUSH
35470: CALL_OW 250
35474: PUSH
35475: LD_VAR 0 2
35479: PPUSH
35480: CALL_OW 251
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: LIST
35489: PPUSH
35490: CALL_OW 2
35494: ST_TO_ADDR
35495: GO 35444
35497: POP
35498: POP
// if not res then
35499: LD_VAR 0 3
35503: NOT
35504: IFFALSE 35681
// begin temp_list = FilterAllUnits ( [ [ f_side , you ] , [ f_inarea , ru_base_area ] , [ f_not , [ f_inarea , sneaky_area ] ] , [ f_see , russians ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_occupied ] ] ] ] ) ;
35506: LD_ADDR_VAR 0 1
35510: PUSH
35511: LD_INT 22
35513: PUSH
35514: LD_EXP 2
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 95
35525: PUSH
35526: LD_INT 2
35528: PUSH
35529: EMPTY
35530: LIST
35531: LIST
35532: PUSH
35533: LD_INT 3
35535: PUSH
35536: LD_INT 95
35538: PUSH
35539: LD_INT 3
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 101
35552: PUSH
35553: LD_EXP 3
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: LD_INT 2
35564: PUSH
35565: LD_INT 21
35567: PUSH
35568: LD_INT 1
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: PUSH
35578: LD_INT 21
35580: PUSH
35581: LD_INT 2
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: LD_INT 59
35590: PUSH
35591: EMPTY
35592: LIST
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: LIST
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: LIST
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: LIST
35608: LIST
35609: LIST
35610: PPUSH
35611: CALL_OW 69
35615: ST_TO_ADDR
// if heike_undercover = 2 then
35616: LD_EXP 83
35620: PUSH
35621: LD_INT 2
35623: EQUAL
35624: IFFALSE 35663
// begin temp_list = temp_list diff Heike ;
35626: LD_ADDR_VAR 0 1
35630: PUSH
35631: LD_VAR 0 1
35635: PUSH
35636: LD_EXP 7
35640: DIFF
35641: ST_TO_ADDR
// temp_list = temp_list diff IsInUnit ( Heike ) ;
35642: LD_ADDR_VAR 0 1
35646: PUSH
35647: LD_VAR 0 1
35651: PUSH
35652: LD_EXP 7
35656: PPUSH
35657: CALL_OW 310
35661: DIFF
35662: ST_TO_ADDR
// end ; if temp_list > 0 then
35663: LD_VAR 0 1
35667: PUSH
35668: LD_INT 0
35670: GREATER
35671: IFFALSE 35681
// res = true ;
35673: LD_ADDR_VAR 0 3
35677: PUSH
35678: LD_INT 1
35680: ST_TO_ADDR
// end ; if not res then
35681: LD_VAR 0 3
35685: NOT
35686: IFFALSE 35922
// begin if ContactTime ( [ you , russians ] ) <= 0 0$2 then
35688: LD_EXP 2
35692: PUSH
35693: LD_EXP 3
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PPUSH
35702: CALL_OW 462
35706: PUSH
35707: LD_INT 70
35709: LESSEQUAL
35710: IFFALSE 35922
// begin temp_list = FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_inarea , ru_base_area ] , [ f_inarea , near_vulerable_ru_base_area ] ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_occupied ] ] ] ] ) ;
35712: LD_ADDR_VAR 0 1
35716: PUSH
35717: LD_INT 22
35719: PUSH
35720: LD_EXP 2
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: PUSH
35729: LD_INT 2
35731: PUSH
35732: LD_INT 95
35734: PUSH
35735: LD_INT 2
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 95
35744: PUSH
35745: LD_INT 17
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: PUSH
35757: LD_INT 2
35759: PUSH
35760: LD_INT 21
35762: PUSH
35763: LD_INT 1
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 1
35772: PUSH
35773: LD_INT 21
35775: PUSH
35776: LD_INT 2
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 59
35785: PUSH
35786: EMPTY
35787: LIST
35788: PUSH
35789: EMPTY
35790: LIST
35791: LIST
35792: LIST
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: LIST
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: LIST
35803: PPUSH
35804: CALL_OW 69
35808: ST_TO_ADDR
// if heike_undercover = 2 then
35809: LD_EXP 83
35813: PUSH
35814: LD_INT 2
35816: EQUAL
35817: IFFALSE 35856
// begin temp_list = temp_list diff Heike ;
35819: LD_ADDR_VAR 0 1
35823: PUSH
35824: LD_VAR 0 1
35828: PUSH
35829: LD_EXP 7
35833: DIFF
35834: ST_TO_ADDR
// temp_list = temp_list diff IsInUnit ( Heike ) ;
35835: LD_ADDR_VAR 0 1
35839: PUSH
35840: LD_VAR 0 1
35844: PUSH
35845: LD_EXP 7
35849: PPUSH
35850: CALL_OW 310
35854: DIFF
35855: ST_TO_ADDR
// end ; temp_list_2 = FilterAllUnits ( [ f_side , russians ] ) ;
35856: LD_ADDR_VAR 0 5
35860: PUSH
35861: LD_INT 22
35863: PUSH
35864: LD_EXP 3
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PPUSH
35873: CALL_OW 69
35877: ST_TO_ADDR
// for i in temp_list do
35878: LD_ADDR_VAR 0 2
35882: PUSH
35883: LD_VAR 0 1
35887: PUSH
35888: FOR_IN
35889: IFFALSE 35920
// if Attacks ( i ) in temp_list_2 then
35891: LD_VAR 0 2
35895: PPUSH
35896: CALL_OW 320
35900: PUSH
35901: LD_VAR 0 5
35905: IN
35906: IFFALSE 35918
// begin res = true ;
35908: LD_ADDR_VAR 0 3
35912: PUSH
35913: LD_INT 1
35915: ST_TO_ADDR
// break ;
35916: GO 35920
// end ;
35918: GO 35888
35920: POP
35921: POP
// end ; end ; if res then
35922: LD_VAR 0 3
35926: IFFALSE 35979
// begin if code_black then
35928: LD_EXP 77
35932: IFFALSE 35944
// code_black_renew = true else
35934: LD_ADDR_EXP 124
35938: PUSH
35939: LD_INT 1
35941: ST_TO_ADDR
35942: GO 35979
// begin wait ( 0 0$1 ) ;
35944: LD_INT 35
35946: PPUSH
35947: CALL_OW 67
// code_black = true ;
35951: LD_ADDR_EXP 77
35955: PUSH
35956: LD_INT 1
35958: ST_TO_ADDR
// DialogueOn ;
35959: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-1 ) ;
35963: LD_EXP 14
35967: PPUSH
35968: LD_STRING D7-Leader-1
35970: PPUSH
35971: CALL_OW 94
// DialogueOff ;
35975: CALL_OW 7
// end ; end ; until false ;
35979: LD_INT 0
35981: IFFALSE 34705
// end ;
35983: PPOPN 9
35985: END
// every 0 0$1 + 0 0$0.8 do var i , k , temp_list_2 , temp_list , def_building , un ;
35986: GO 35988
35988: DISABLE
35989: LD_INT 0
35991: PPUSH
35992: PPUSH
35993: PPUSH
35994: PPUSH
35995: PPUSH
35996: PPUSH
// begin repeat wait ( 0 0$1 ) ;
35997: LD_INT 35
35999: PPUSH
36000: CALL_OW 67
// if heike_undercover in [ 0 , 1 ] then
36004: LD_EXP 83
36008: PUSH
36009: LD_INT 0
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: IN
36019: IFFALSE 36025
// continue else
36021: GO 35997
36023: GO 36050
// if heike_undercover in [ 3 , 4 ] or entrance_guard_dialogue_played then
36025: LD_EXP 83
36029: PUSH
36030: LD_INT 3
36032: PUSH
36033: LD_INT 4
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: IN
36040: PUSH
36041: LD_EXP 84
36045: OR
36046: IFFALSE 36050
// exit ;
36048: GO 37179
// if IsInArea ( Heike , ru_base_area ) and IsInUnit ( Heike ) = 0 and See ( russians , Heike ) then
36050: LD_EXP 7
36054: PPUSH
36055: LD_INT 2
36057: PPUSH
36058: CALL_OW 308
36062: PUSH
36063: LD_EXP 7
36067: PPUSH
36068: CALL_OW 310
36072: PUSH
36073: LD_INT 0
36075: EQUAL
36076: AND
36077: PUSH
36078: LD_EXP 3
36082: PPUSH
36083: LD_EXP 7
36087: PPUSH
36088: CALL_OW 292
36092: AND
36093: IFFALSE 37175
// begin CenterOnUnits ( Heike ) ;
36095: LD_EXP 7
36099: PPUSH
36100: CALL_OW 85
// DialogueOn ;
36104: CALL_OW 6
// un = 0 ;
36108: LD_ADDR_VAR 0 6
36112: PUSH
36113: LD_INT 0
36115: ST_TO_ADDR
// def_building = 0 ;
36116: LD_ADDR_VAR 0 5
36120: PUSH
36121: LD_INT 0
36123: ST_TO_ADDR
// for i in ai_armouries [ 1 ] ^ ai_bunkers [ 1 ] do
36124: LD_ADDR_VAR 0 1
36128: PUSH
36129: LD_EXP 48
36133: PUSH
36134: LD_INT 1
36136: ARRAY
36137: PUSH
36138: LD_EXP 49
36142: PUSH
36143: LD_INT 1
36145: ARRAY
36146: ADD
36147: PUSH
36148: FOR_IN
36149: IFFALSE 36185
// if GetDistUnits ( Heike , i ) <= 10 then
36151: LD_EXP 7
36155: PPUSH
36156: LD_VAR 0 1
36160: PPUSH
36161: CALL_OW 296
36165: PUSH
36166: LD_INT 10
36168: LESSEQUAL
36169: IFFALSE 36183
// begin def_building = i ;
36171: LD_ADDR_VAR 0 5
36175: PUSH
36176: LD_VAR 0 1
36180: ST_TO_ADDR
// break ;
36181: GO 36185
// end ;
36183: GO 36148
36185: POP
36186: POP
// if def_building > 0 then
36187: LD_VAR 0 5
36191: PUSH
36192: LD_INT 0
36194: GREATER
36195: IFFALSE 36399
// begin temp_list = [ ] ;
36197: LD_ADDR_VAR 0 4
36201: PUSH
36202: EMPTY
36203: ST_TO_ADDR
// if GetBType ( def_building ) = b_breastwork then
36204: LD_VAR 0 5
36208: PPUSH
36209: CALL_OW 266
36213: PUSH
36214: LD_INT 31
36216: EQUAL
36217: IFFALSE 36263
// begin for k in ai_bunkers [ 1 ] do
36219: LD_ADDR_VAR 0 2
36223: PUSH
36224: LD_EXP 49
36228: PUSH
36229: LD_INT 1
36231: ARRAY
36232: PUSH
36233: FOR_IN
36234: IFFALSE 36259
// temp_list = temp_list ^ UnitsInside ( k ) ;
36236: LD_ADDR_VAR 0 4
36240: PUSH
36241: LD_VAR 0 4
36245: PUSH
36246: LD_VAR 0 2
36250: PPUSH
36251: CALL_OW 313
36255: ADD
36256: ST_TO_ADDR
36257: GO 36233
36259: POP
36260: POP
// end else
36261: GO 36278
// temp_list = UnitsInside ( def_building ) ;
36263: LD_ADDR_VAR 0 4
36267: PUSH
36268: LD_VAR 0 5
36272: PPUSH
36273: CALL_OW 313
36277: ST_TO_ADDR
// temp_list = temp_list diff [ Stanimir , Barovnin , Yefibachev , Yakov , Natalya , Mikhail , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_eng , poker_sol , poker_mec ] ;
36278: LD_ADDR_VAR 0 4
36282: PUSH
36283: LD_VAR 0 4
36287: PUSH
36288: LD_EXP 12
36292: PUSH
36293: LD_EXP 13
36297: PUSH
36298: LD_EXP 14
36302: PUSH
36303: LD_EXP 15
36307: PUSH
36308: LD_EXP 16
36312: PUSH
36313: LD_EXP 17
36317: PUSH
36318: LD_EXP 18
36322: PUSH
36323: LD_EXP 19
36327: PUSH
36328: LD_EXP 20
36332: PUSH
36333: LD_EXP 21
36337: PUSH
36338: LD_EXP 22
36342: PUSH
36343: LD_EXP 23
36347: PUSH
36348: LD_EXP 24
36352: PUSH
36353: LD_EXP 25
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: LIST
36362: LIST
36363: LIST
36364: LIST
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: DIFF
36374: ST_TO_ADDR
// if temp_list > 0 then
36375: LD_VAR 0 4
36379: PUSH
36380: LD_INT 0
36382: GREATER
36383: IFFALSE 36399
// un = temp_list [ 1 ] ;
36385: LD_ADDR_VAR 0 6
36389: PUSH
36390: LD_VAR 0 4
36394: PUSH
36395: LD_INT 1
36397: ARRAY
36398: ST_TO_ADDR
// end ; if un = 0 and IsOk ( Yefibachev ) then
36399: LD_VAR 0 6
36403: PUSH
36404: LD_INT 0
36406: EQUAL
36407: PUSH
36408: LD_EXP 14
36412: PPUSH
36413: CALL_OW 302
36417: AND
36418: IFFALSE 36430
// un = Yefibachev ;
36420: LD_ADDR_VAR 0 6
36424: PUSH
36425: LD_EXP 14
36429: ST_TO_ADDR
// if un = 0 then
36430: LD_VAR 0 6
36434: PUSH
36435: LD_INT 0
36437: EQUAL
36438: IFFALSE 36751
// begin temp_list_2 = [ ] ;
36440: LD_ADDR_VAR 0 3
36444: PUSH
36445: EMPTY
36446: ST_TO_ADDR
// for k in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_ok ] ] ) do
36447: LD_ADDR_VAR 0 2
36451: PUSH
36452: LD_INT 22
36454: PUSH
36455: LD_EXP 3
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: PUSH
36464: LD_INT 21
36466: PUSH
36467: LD_INT 1
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 50
36476: PUSH
36477: EMPTY
36478: LIST
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: LIST
36484: PPUSH
36485: CALL_OW 69
36489: PUSH
36490: FOR_IN
36491: IFFALSE 36605
// if not k in [ Stanimir , Barovnin , Yefibachev , Yakov , Natalya , Mikhail , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_eng , poker_sol , poker_mec ] then
36493: LD_VAR 0 2
36497: PUSH
36498: LD_EXP 12
36502: PUSH
36503: LD_EXP 13
36507: PUSH
36508: LD_EXP 14
36512: PUSH
36513: LD_EXP 15
36517: PUSH
36518: LD_EXP 16
36522: PUSH
36523: LD_EXP 17
36527: PUSH
36528: LD_EXP 18
36532: PUSH
36533: LD_EXP 19
36537: PUSH
36538: LD_EXP 20
36542: PUSH
36543: LD_EXP 21
36547: PUSH
36548: LD_EXP 22
36552: PUSH
36553: LD_EXP 23
36557: PUSH
36558: LD_EXP 24
36562: PUSH
36563: LD_EXP 25
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: LIST
36572: LIST
36573: LIST
36574: LIST
36575: LIST
36576: LIST
36577: LIST
36578: LIST
36579: LIST
36580: LIST
36581: LIST
36582: LIST
36583: IN
36584: NOT
36585: IFFALSE 36603
// temp_list_2 = temp_list_2 ^ k ;
36587: LD_ADDR_VAR 0 3
36591: PUSH
36592: LD_VAR 0 3
36596: PUSH
36597: LD_VAR 0 2
36601: ADD
36602: ST_TO_ADDR
36603: GO 36490
36605: POP
36606: POP
// temp_list = UnitFilter ( temp_list_2 , [ f_class , class_soldier ] ) ;
36607: LD_ADDR_VAR 0 4
36611: PUSH
36612: LD_VAR 0 3
36616: PPUSH
36617: LD_INT 25
36619: PUSH
36620: LD_INT 1
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PPUSH
36627: CALL_OW 72
36631: ST_TO_ADDR
// if temp_list > 0 then
36632: LD_VAR 0 4
36636: PUSH
36637: LD_INT 0
36639: GREATER
36640: IFFALSE 36658
// un = temp_list [ 1 ] else
36642: LD_ADDR_VAR 0 6
36646: PUSH
36647: LD_VAR 0 4
36651: PUSH
36652: LD_INT 1
36654: ARRAY
36655: ST_TO_ADDR
36656: GO 36751
// if temp_list_2 > 0 then
36658: LD_VAR 0 3
36662: PUSH
36663: LD_INT 0
36665: GREATER
36666: IFFALSE 36684
// un = temp_list_2 [ 1 ] else
36668: LD_ADDR_VAR 0 6
36672: PUSH
36673: LD_VAR 0 3
36677: PUSH
36678: LD_INT 1
36680: ARRAY
36681: ST_TO_ADDR
36682: GO 36751
// begin temp_list = FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
36684: LD_ADDR_VAR 0 4
36688: PUSH
36689: LD_INT 22
36691: PUSH
36692: LD_EXP 3
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 21
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 50
36713: PUSH
36714: EMPTY
36715: LIST
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: LIST
36721: PPUSH
36722: CALL_OW 69
36726: ST_TO_ADDR
// if temp_list > 0 then
36727: LD_VAR 0 4
36731: PUSH
36732: LD_INT 0
36734: GREATER
36735: IFFALSE 36751
// un = temp_list [ 1 ] ;
36737: LD_ADDR_VAR 0 6
36741: PUSH
36742: LD_VAR 0 4
36746: PUSH
36747: LD_INT 1
36749: ARRAY
36750: ST_TO_ADDR
// end ; end ; if un > 0 then
36751: LD_VAR 0 6
36755: PUSH
36756: LD_INT 0
36758: GREATER
36759: IFFALSE 37138
// begin if un = Yefibachev then
36761: LD_VAR 0 6
36765: PUSH
36766: LD_EXP 14
36770: EQUAL
36771: IFFALSE 36787
// Say ( Yefibachev , D22-Leader-1 ) else
36773: LD_EXP 14
36777: PPUSH
36778: LD_STRING D22-Leader-1
36780: PPUSH
36781: CALL_OW 88
36785: GO 36828
// if GetSex ( un ) = sex_male then
36787: LD_VAR 0 6
36791: PPUSH
36792: CALL_OW 258
36796: PUSH
36797: LD_INT 1
36799: EQUAL
36800: IFFALSE 36816
// Say ( un , D22-SolM-1 ) else
36802: LD_VAR 0 6
36806: PPUSH
36807: LD_STRING D22-SolM-1
36809: PPUSH
36810: CALL_OW 88
36814: GO 36828
// Say ( un , D22-SolF-1 ) ;
36816: LD_VAR 0 6
36820: PPUSH
36821: LD_STRING D22-SolF-1
36823: PPUSH
36824: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
36828: LD_INT 10
36830: PPUSH
36831: CALL_OW 68
// case Query ( QOnFootName ) of 1 :
36835: LD_STRING QOnFootName
36837: PPUSH
36838: CALL_OW 97
36842: PUSH
36843: LD_INT 1
36845: DOUBLE
36846: EQUAL
36847: IFTRUE 36851
36849: GO 36866
36851: POP
// Say ( Heike , D22-1-H-1 ) ; 2 :
36852: LD_EXP 7
36856: PPUSH
36857: LD_STRING D22-1-H-1
36859: PPUSH
36860: CALL_OW 88
36864: GO 36913
36866: LD_INT 2
36868: DOUBLE
36869: EQUAL
36870: IFTRUE 36874
36872: GO 36889
36874: POP
// Say ( Heike , D22-2-H-1 ) ; 3 :
36875: LD_EXP 7
36879: PPUSH
36880: LD_STRING D22-2-H-1
36882: PPUSH
36883: CALL_OW 88
36887: GO 36913
36889: LD_INT 3
36891: DOUBLE
36892: EQUAL
36893: IFTRUE 36897
36895: GO 36912
36897: POP
// Say ( Heike , D22-3-H-1 ) ; end ;
36898: LD_EXP 7
36902: PPUSH
36903: LD_STRING D22-3-H-1
36905: PPUSH
36906: CALL_OW 88
36910: GO 36913
36912: POP
// if un = Yefibachev then
36913: LD_VAR 0 6
36917: PUSH
36918: LD_EXP 14
36922: EQUAL
36923: IFFALSE 36939
// Say ( Yefibachev , D22-g-Leader-1 ) else
36925: LD_EXP 14
36929: PPUSH
36930: LD_STRING D22-g-Leader-1
36932: PPUSH
36933: CALL_OW 88
36937: GO 36980
// if GetSex ( un ) = sex_male then
36939: LD_VAR 0 6
36943: PPUSH
36944: CALL_OW 258
36948: PUSH
36949: LD_INT 1
36951: EQUAL
36952: IFFALSE 36968
// Say ( un , D22-g-SolM-1 ) else
36954: LD_VAR 0 6
36958: PPUSH
36959: LD_STRING D22-g-SolM-1
36961: PPUSH
36962: CALL_OW 88
36966: GO 36980
// Say ( un , D22-g-SolF-1 ) ;
36968: LD_VAR 0 6
36972: PPUSH
36973: LD_STRING D22-g-SolF-1
36975: PPUSH
36976: CALL_OW 88
// Say ( Heike , D22-g-H-1 ) ;
36980: LD_EXP 7
36984: PPUSH
36985: LD_STRING D22-g-H-1
36987: PPUSH
36988: CALL_OW 88
// if un = Yefibachev then
36992: LD_VAR 0 6
36996: PUSH
36997: LD_EXP 14
37001: EQUAL
37002: IFFALSE 37018
// Say ( Yefibachev , D22-g-Leader-2 ) else
37004: LD_EXP 14
37008: PPUSH
37009: LD_STRING D22-g-Leader-2
37011: PPUSH
37012: CALL_OW 88
37016: GO 37059
// if GetSex ( un ) = sex_male then
37018: LD_VAR 0 6
37022: PPUSH
37023: CALL_OW 258
37027: PUSH
37028: LD_INT 1
37030: EQUAL
37031: IFFALSE 37047
// Say ( un , D22-g-SolM-2 ) else
37033: LD_VAR 0 6
37037: PPUSH
37038: LD_STRING D22-g-SolM-2
37040: PPUSH
37041: CALL_OW 88
37045: GO 37059
// Say ( un , D22-g-SolF-2 ) ;
37047: LD_VAR 0 6
37051: PPUSH
37052: LD_STRING D22-g-SolF-2
37054: PPUSH
37055: CALL_OW 88
// Say ( Heike , D22-g-H-2 ) ;
37059: LD_EXP 7
37063: PPUSH
37064: LD_STRING D22-g-H-2
37066: PPUSH
37067: CALL_OW 88
// if un = Yefibachev then
37071: LD_VAR 0 6
37075: PUSH
37076: LD_EXP 14
37080: EQUAL
37081: IFFALSE 37097
// Say ( Yefibachev , D22-g-Leader-3 ) else
37083: LD_EXP 14
37087: PPUSH
37088: LD_STRING D22-g-Leader-3
37090: PPUSH
37091: CALL_OW 88
37095: GO 37138
// if GetSex ( un ) = sex_male then
37097: LD_VAR 0 6
37101: PPUSH
37102: CALL_OW 258
37106: PUSH
37107: LD_INT 1
37109: EQUAL
37110: IFFALSE 37126
// Say ( un , D22-g-SolM-3 ) else
37112: LD_VAR 0 6
37116: PPUSH
37117: LD_STRING D22-g-SolM-3
37119: PPUSH
37120: CALL_OW 88
37124: GO 37138
// Say ( un , D22-g-SolF-3 ) ;
37126: LD_VAR 0 6
37130: PPUSH
37131: LD_STRING D22-g-SolF-3
37133: PPUSH
37134: CALL_OW 88
// end ; DialogueOff ;
37138: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
37142: LD_INT 4
37144: PPUSH
37145: CALL 42004 0 1
// if code_black then
37149: LD_EXP 77
37153: IFFALSE 37165
// code_black_renew = true else
37155: LD_ADDR_EXP 124
37159: PUSH
37160: LD_INT 1
37162: ST_TO_ADDR
37163: GO 37173
// code_black = true ;
37165: LD_ADDR_EXP 77
37169: PUSH
37170: LD_INT 1
37172: ST_TO_ADDR
// exit ;
37173: GO 37179
// end ; until false ;
37175: LD_INT 0
37177: IFFALSE 35997
// end ;
37179: PPOPN 6
37181: END
// every 0 0$1 + 0 0$0.3 do var did_it ; var times_shoot ;
37182: GO 37184
37184: DISABLE
37185: LD_INT 0
37187: PPUSH
37188: PPUSH
// begin times_shoot = 0 ;
37189: LD_ADDR_VAR 0 2
37193: PUSH
37194: LD_INT 0
37196: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37197: LD_INT 35
37199: PPUSH
37200: CALL_OW 67
// if heike_undercover = 0 then
37204: LD_EXP 83
37208: PUSH
37209: LD_INT 0
37211: EQUAL
37212: IFFALSE 37218
// continue else
37214: GO 37197
37216: GO 37241
// if heike_undercover in [ 1 , 3 , 4 ] then
37218: LD_EXP 83
37222: PUSH
37223: LD_INT 1
37225: PUSH
37226: LD_INT 3
37228: PUSH
37229: LD_INT 4
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: LIST
37236: IN
37237: IFFALSE 37241
// exit ;
37239: GO 37447
// did_it = false ;
37241: LD_ADDR_VAR 0 1
37245: PUSH
37246: LD_INT 0
37248: ST_TO_ADDR
// if heike_undercover_entered_war_vehicle then
37249: LD_EXP 91
37253: IFFALSE 37265
// did_it = true else
37255: LD_ADDR_VAR 0 1
37259: PUSH
37260: LD_INT 1
37262: ST_TO_ADDR
37263: GO 37374
// if Attacks ( Heike ) in FilterAllUnits ( [ [ f_side , russians ] , [ f_inarea , ru_base_area ] ] ) and ContactTime ( [ you , russians ] ) <= 0 0$2 then
37265: LD_EXP 7
37269: PPUSH
37270: CALL_OW 320
37274: PUSH
37275: LD_INT 22
37277: PUSH
37278: LD_EXP 3
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: LD_INT 95
37289: PUSH
37290: LD_INT 2
37292: PUSH
37293: EMPTY
37294: LIST
37295: LIST
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PPUSH
37301: CALL_OW 69
37305: IN
37306: PUSH
37307: LD_EXP 2
37311: PUSH
37312: LD_EXP 3
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: PPUSH
37321: CALL_OW 462
37325: PUSH
37326: LD_INT 70
37328: LESSEQUAL
37329: AND
37330: IFFALSE 37366
// begin times_shoot = times_shoot + 1 ;
37332: LD_ADDR_VAR 0 2
37336: PUSH
37337: LD_VAR 0 2
37341: PUSH
37342: LD_INT 1
37344: PLUS
37345: ST_TO_ADDR
// if times_shoot >= 3 then
37346: LD_VAR 0 2
37350: PUSH
37351: LD_INT 3
37353: GREATEREQUAL
37354: IFFALSE 37364
// did_it = true ;
37356: LD_ADDR_VAR 0 1
37360: PUSH
37361: LD_INT 1
37363: ST_TO_ADDR
// end else
37364: GO 37374
// times_shoot = 0 ;
37366: LD_ADDR_VAR 0 2
37370: PUSH
37371: LD_INT 0
37373: ST_TO_ADDR
// if did_it then
37374: LD_VAR 0 1
37378: IFFALSE 37443
// begin if heike_undercover <> 4 then
37380: LD_EXP 83
37384: PUSH
37385: LD_INT 4
37387: NONEQUAL
37388: IFFALSE 37417
// begin DialogueOn ;
37390: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-2a ) ;
37394: LD_EXP 14
37398: PPUSH
37399: LD_STRING D7-Leader-2a
37401: PPUSH
37402: CALL_OW 94
// DialogueOff ;
37406: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
37410: LD_INT 4
37412: PPUSH
37413: CALL 42004 0 1
// end ; if code_black then
37417: LD_EXP 77
37421: IFFALSE 37433
// code_black_renew = true else
37423: LD_ADDR_EXP 124
37427: PUSH
37428: LD_INT 1
37430: ST_TO_ADDR
37431: GO 37441
// code_black = true ;
37433: LD_ADDR_EXP 77
37437: PUSH
37438: LD_INT 1
37440: ST_TO_ADDR
// exit ;
37441: GO 37447
// end ; until false ;
37443: LD_INT 0
37445: IFFALSE 37197
// end ;
37447: PPOPN 2
37449: END
// every 0 0$1 + 0 0$0.2 do var timer , wait_time , temp_list , i ;
37450: GO 37452
37452: DISABLE
37453: LD_INT 0
37455: PPUSH
37456: PPUSH
37457: PPUSH
37458: PPUSH
// begin wait_time = [ 1 1$05 , 1 1$05 , 0 0$40 ] [ difficulty ] ;
37459: LD_ADDR_VAR 0 2
37463: PUSH
37464: LD_INT 2275
37466: PUSH
37467: LD_INT 2275
37469: PUSH
37470: LD_INT 1400
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: LIST
37477: PUSH
37478: LD_OWVAR 67
37482: ARRAY
37483: ST_TO_ADDR
// timer = wait_time ;
37484: LD_ADDR_VAR 0 1
37488: PUSH
37489: LD_VAR 0 2
37493: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37494: LD_INT 35
37496: PPUSH
37497: CALL_OW 67
// if not code_black then
37501: LD_EXP 77
37505: NOT
37506: IFFALSE 37520
// begin timer = wait_time ;
37508: LD_ADDR_VAR 0 1
37512: PUSH
37513: LD_VAR 0 2
37517: ST_TO_ADDR
// continue ;
37518: GO 37494
// end ; if code_black_renew then
37520: LD_EXP 124
37524: IFFALSE 37544
// begin timer = wait_time ;
37526: LD_ADDR_VAR 0 1
37530: PUSH
37531: LD_VAR 0 2
37535: ST_TO_ADDR
// code_black_renew = false ;
37536: LD_ADDR_EXP 124
37540: PUSH
37541: LD_INT 0
37543: ST_TO_ADDR
// end ; temp_list = FilterAllUnits ( [ [ f_side , you ] , [ f_inarea , ru_base_area ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) ;
37544: LD_ADDR_VAR 0 3
37548: PUSH
37549: LD_INT 22
37551: PUSH
37552: LD_EXP 2
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PUSH
37561: LD_INT 95
37563: PUSH
37564: LD_INT 2
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 3
37573: PUSH
37574: LD_INT 34
37576: PUSH
37577: LD_INT 51
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: LIST
37592: PPUSH
37593: CALL_OW 69
37597: ST_TO_ADDR
// for i in player_units_in_russian_buildings do
37598: LD_ADDR_VAR 0 4
37602: PUSH
37603: LD_EXP 88
37607: PUSH
37608: FOR_IN
37609: IFFALSE 37633
// temp_list = temp_list ^ i [ 1 ] ;
37611: LD_ADDR_VAR 0 3
37615: PUSH
37616: LD_VAR 0 3
37620: PUSH
37621: LD_VAR 0 4
37625: PUSH
37626: LD_INT 1
37628: ARRAY
37629: ADD
37630: ST_TO_ADDR
37631: GO 37608
37633: POP
37634: POP
// if heike_undercover = 2 then
37635: LD_EXP 83
37639: PUSH
37640: LD_INT 2
37642: EQUAL
37643: IFFALSE 37682
// begin temp_list = temp_list diff Heike ;
37645: LD_ADDR_VAR 0 3
37649: PUSH
37650: LD_VAR 0 3
37654: PUSH
37655: LD_EXP 7
37659: DIFF
37660: ST_TO_ADDR
// temp_list = temp_list diff IsInUnit ( Heike ) ;
37661: LD_ADDR_VAR 0 3
37665: PUSH
37666: LD_VAR 0 3
37670: PUSH
37671: LD_EXP 7
37675: PPUSH
37676: CALL_OW 310
37680: DIFF
37681: ST_TO_ADDR
// end ; if temp_list = 0 and ContactTime ( [ you , russians ] ) > 0 0$2 then
37682: LD_VAR 0 3
37686: PUSH
37687: LD_INT 0
37689: EQUAL
37690: PUSH
37691: LD_EXP 2
37695: PUSH
37696: LD_EXP 3
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PPUSH
37705: CALL_OW 462
37709: PUSH
37710: LD_INT 70
37712: GREATER
37713: AND
37714: IFFALSE 37730
// timer = timer - 0 0$1 ;
37716: LD_ADDR_VAR 0 1
37720: PUSH
37721: LD_VAR 0 1
37725: PUSH
37726: LD_INT 35
37728: MINUS
37729: ST_TO_ADDR
// if timer <= 0 0$0 then
37730: LD_VAR 0 1
37734: PUSH
37735: LD_INT 0
37737: LESSEQUAL
37738: IFFALSE 37820
// begin code_black = false ;
37740: LD_ADDR_EXP 77
37744: PUSH
37745: LD_INT 0
37747: ST_TO_ADDR
// timer = wait_time ;
37748: LD_ADDR_VAR 0 1
37752: PUSH
37753: LD_VAR 0 2
37757: ST_TO_ADDR
// DialogueOn ;
37758: CALL_OW 6
// SayRadio ( Yefibachev , D6-Leader-2 ) ;
37762: LD_EXP 14
37766: PPUSH
37767: LD_STRING D6-Leader-2
37769: PPUSH
37770: CALL_OW 94
// DialogueOff ;
37774: CALL_OW 7
// last_known_enemy_hex = ai_human_pullback_hex [ 1 ] ;
37778: LD_ADDR_EXP 122
37782: PUSH
37783: LD_EXP 40
37787: PUSH
37788: LD_INT 1
37790: ARRAY
37791: ST_TO_ADDR
// if not code_red then
37792: LD_EXP 76
37796: NOT
37797: IFFALSE 37820
// begin code_red = true ;
37799: LD_ADDR_EXP 76
37803: PUSH
37804: LD_INT 1
37806: ST_TO_ADDR
// CreateCodeRedPatrols ( difficulty - 1 ) ;
37807: LD_OWVAR 67
37811: PUSH
37812: LD_INT 1
37814: MINUS
37815: PPUSH
37816: CALL 38894 0 1
// end ; end ; until false ;
37820: LD_INT 0
37822: IFFALSE 37494
// end ;
37824: PPOPN 4
37826: END
// every 0 0$1 + 0 0$0.8 do var i , temp_list , val , temp_list_2 , k ; var remembered_contact_time ;
37827: GO 37829
37829: DISABLE
37830: LD_INT 0
37832: PPUSH
37833: PPUSH
37834: PPUSH
37835: PPUSH
37836: PPUSH
37837: PPUSH
// begin remembered_contact_time = ContactTime ( [ you , russians ] ) ;
37838: LD_ADDR_VAR 0 6
37842: PUSH
37843: LD_EXP 2
37847: PUSH
37848: LD_EXP 3
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: PPUSH
37857: CALL_OW 462
37861: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37862: LD_INT 35
37864: PPUSH
37865: CALL_OW 67
// if code_red then
37869: LD_EXP 76
37873: IFFALSE 37877
// continue ;
37875: GO 37862
// if ContactTime ( [ you , russians ] ) <= 0 0$2 then
37877: LD_EXP 2
37881: PUSH
37882: LD_EXP 3
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PPUSH
37891: CALL_OW 462
37895: PUSH
37896: LD_INT 70
37898: LESSEQUAL
37899: IFFALSE 38376
// begin temp_list = [ ] ;
37901: LD_ADDR_VAR 0 2
37905: PUSH
37906: EMPTY
37907: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_ok ] ] ) do
37908: LD_ADDR_VAR 0 1
37912: PUSH
37913: LD_INT 22
37915: PUSH
37916: LD_EXP 3
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 21
37927: PUSH
37928: LD_INT 1
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 50
37937: PUSH
37938: EMPTY
37939: LIST
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: LIST
37945: PPUSH
37946: CALL_OW 69
37950: PUSH
37951: FOR_IN
37952: IFFALSE 38003
// if IsInUnit ( i ) in ai_bunkers [ 1 ] ^ ai_armouries [ 1 ] then
37954: LD_VAR 0 1
37958: PPUSH
37959: CALL_OW 310
37963: PUSH
37964: LD_EXP 49
37968: PUSH
37969: LD_INT 1
37971: ARRAY
37972: PUSH
37973: LD_EXP 48
37977: PUSH
37978: LD_INT 1
37980: ARRAY
37981: ADD
37982: IN
37983: IFFALSE 38001
// temp_list = temp_list ^ i ;
37985: LD_ADDR_VAR 0 2
37989: PUSH
37990: LD_VAR 0 2
37994: PUSH
37995: LD_VAR 0 1
37999: ADD
38000: ST_TO_ADDR
38001: GO 37951
38003: POP
38004: POP
// temp_list_2 = FilterAllUnits ( [ [ f_side , you ] , [ f_not , [ f_inarea , ru_base_area ] ] ] ) ;
38005: LD_ADDR_VAR 0 4
38009: PUSH
38010: LD_INT 22
38012: PUSH
38013: LD_EXP 2
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 3
38024: PUSH
38025: LD_INT 95
38027: PUSH
38028: LD_INT 2
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PPUSH
38043: CALL_OW 69
38047: ST_TO_ADDR
// for i in temp_list do
38048: LD_ADDR_VAR 0 1
38052: PUSH
38053: LD_VAR 0 2
38057: PUSH
38058: FOR_IN
38059: IFFALSE 38374
// if Attacks ( i ) in temp_list_2 then
38061: LD_VAR 0 1
38065: PPUSH
38066: CALL_OW 320
38070: PUSH
38071: LD_VAR 0 4
38075: IN
38076: IFFALSE 38372
// begin Wait ( 0 0$0.5 ) ;
38078: LD_INT 18
38080: PPUSH
38081: CALL_OW 67
// temp_list_2 = [ ] ;
38085: LD_ADDR_VAR 0 4
38089: PUSH
38090: EMPTY
38091: ST_TO_ADDR
// for k in temp_list do
38092: LD_ADDR_VAR 0 5
38096: PUSH
38097: LD_VAR 0 2
38101: PUSH
38102: FOR_IN
38103: IFFALSE 38217
// if not k in [ Stanimir , Barovnin , Yefibachev , Yakov , Natalya , Mikhail , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_eng , poker_sol , poker_mec ] then
38105: LD_VAR 0 5
38109: PUSH
38110: LD_EXP 12
38114: PUSH
38115: LD_EXP 13
38119: PUSH
38120: LD_EXP 14
38124: PUSH
38125: LD_EXP 15
38129: PUSH
38130: LD_EXP 16
38134: PUSH
38135: LD_EXP 17
38139: PUSH
38140: LD_EXP 18
38144: PUSH
38145: LD_EXP 19
38149: PUSH
38150: LD_EXP 20
38154: PUSH
38155: LD_EXP 21
38159: PUSH
38160: LD_EXP 22
38164: PUSH
38165: LD_EXP 23
38169: PUSH
38170: LD_EXP 24
38174: PUSH
38175: LD_EXP 25
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: LIST
38194: LIST
38195: IN
38196: NOT
38197: IFFALSE 38215
// temp_list_2 = temp_list_2 ^ k ;
38199: LD_ADDR_VAR 0 4
38203: PUSH
38204: LD_VAR 0 4
38208: PUSH
38209: LD_VAR 0 5
38213: ADD
38214: ST_TO_ADDR
38215: GO 38102
38217: POP
38218: POP
// if remembered_contact_time > 0 0$2 then
38219: LD_VAR 0 6
38223: PUSH
38224: LD_INT 70
38226: GREATER
38227: IFFALSE 38316
// begin DialogueOn ;
38229: CALL_OW 6
// if temp_list_2 > 0 then
38233: LD_VAR 0 4
38237: PUSH
38238: LD_INT 0
38240: GREATER
38241: IFFALSE 38300
// begin k = temp_list_2 [ 1 ] ;
38243: LD_ADDR_VAR 0 5
38247: PUSH
38248: LD_VAR 0 4
38252: PUSH
38253: LD_INT 1
38255: ARRAY
38256: ST_TO_ADDR
// if GetSex ( k ) = sex_male then
38257: LD_VAR 0 5
38261: PPUSH
38262: CALL_OW 258
38266: PUSH
38267: LD_INT 1
38269: EQUAL
38270: IFFALSE 38286
// Say ( k , D6-GuardM-1 ) else
38272: LD_VAR 0 5
38276: PPUSH
38277: LD_STRING D6-GuardM-1
38279: PPUSH
38280: CALL_OW 88
38284: GO 38298
// Say ( k , D6-GuardF-1 ) ;
38286: LD_VAR 0 5
38290: PPUSH
38291: LD_STRING D6-GuardF-1
38293: PPUSH
38294: CALL_OW 88
// end else
38298: GO 38312
// SayRadio ( Yefibachev , D6-Leader-1 ) ;
38300: LD_EXP 14
38304: PPUSH
38305: LD_STRING D6-Leader-1
38307: PPUSH
38308: CALL_OW 94
// DialogueOff ;
38312: CALL_OW 7
// end ; code_red = true ;
38316: LD_ADDR_EXP 76
38320: PUSH
38321: LD_INT 1
38323: ST_TO_ADDR
// while ContactTime ( [ you , russians ] ) <= 0 0$10 do
38324: LD_EXP 2
38328: PUSH
38329: LD_EXP 3
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PPUSH
38338: CALL_OW 462
38342: PUSH
38343: LD_INT 350
38345: LESSEQUAL
38346: IFFALSE 38357
// wait ( 0 0$2 ) ;
38348: LD_INT 70
38350: PPUSH
38351: CALL_OW 67
38355: GO 38324
// CreateCodeRedPatrols ( difficulty - 1 ) ;
38357: LD_OWVAR 67
38361: PUSH
38362: LD_INT 1
38364: MINUS
38365: PPUSH
38366: CALL 38894 0 1
// break ;
38370: GO 38374
// end ;
38372: GO 38058
38374: POP
38375: POP
// end ; remembered_contact_time = ContactTime ( [ you , russians ] ) ;
38376: LD_ADDR_VAR 0 6
38380: PUSH
38381: LD_EXP 2
38385: PUSH
38386: LD_EXP 3
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PPUSH
38395: CALL_OW 462
38399: ST_TO_ADDR
// until false ;
38400: LD_INT 0
38402: IFFALSE 37862
// end ;
38404: PPOPN 6
38406: END
// every 0 0$1 + 0 0$0.2 do var temp_list_2 , k , temp_list , i ;
38407: GO 38409
38409: DISABLE
38410: LD_INT 0
38412: PPUSH
38413: PPUSH
38414: PPUSH
38415: PPUSH
// begin repeat wait ( 0 0$1 ) ;
38416: LD_INT 35
38418: PPUSH
38419: CALL_OW 67
// if heike_undercover in [ 0 , 1 ] then
38423: LD_EXP 83
38427: PUSH
38428: LD_INT 0
38430: PUSH
38431: LD_INT 1
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: IN
38438: IFFALSE 38444
// continue else
38440: GO 38416
38442: GO 38463
// if heike_undercover in [ 2 , 4 ] then
38444: LD_EXP 83
38448: PUSH
38449: LD_INT 2
38451: PUSH
38452: LD_INT 4
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: IN
38459: IFFALSE 38463
// exit ;
38461: GO 38891
// k = IsInUnit ( Heike ) ;
38463: LD_ADDR_VAR 0 2
38467: PUSH
38468: LD_EXP 7
38472: PPUSH
38473: CALL_OW 310
38477: ST_TO_ADDR
// if k = 0 then
38478: LD_VAR 0 2
38482: PUSH
38483: LD_INT 0
38485: EQUAL
38486: IFFALSE 38498
// k = Heike ;
38488: LD_ADDR_VAR 0 2
38492: PUSH
38493: LD_EXP 7
38497: ST_TO_ADDR
// if See ( russians , k ) and GetDistUnitArea ( k , ru_base_area ) <= 6 then
38498: LD_EXP 3
38502: PPUSH
38503: LD_VAR 0 2
38507: PPUSH
38508: CALL_OW 292
38512: PUSH
38513: LD_VAR 0 2
38517: PPUSH
38518: LD_INT 2
38520: PPUSH
38521: CALL_OW 299
38525: PUSH
38526: LD_INT 6
38528: LESSEQUAL
38529: AND
38530: IFFALSE 38887
// begin temp_list = [ ] ;
38532: LD_ADDR_VAR 0 3
38536: PUSH
38537: EMPTY
38538: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_ok ] ] ) do
38539: LD_ADDR_VAR 0 4
38543: PUSH
38544: LD_INT 22
38546: PUSH
38547: LD_EXP 3
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 21
38558: PUSH
38559: LD_INT 1
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 50
38568: PUSH
38569: EMPTY
38570: LIST
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: LIST
38576: PPUSH
38577: CALL_OW 69
38581: PUSH
38582: FOR_IN
38583: IFFALSE 38634
// if IsInUnit ( i ) in ai_bunkers [ 1 ] ^ ai_armouries [ 1 ] then
38585: LD_VAR 0 4
38589: PPUSH
38590: CALL_OW 310
38594: PUSH
38595: LD_EXP 49
38599: PUSH
38600: LD_INT 1
38602: ARRAY
38603: PUSH
38604: LD_EXP 48
38608: PUSH
38609: LD_INT 1
38611: ARRAY
38612: ADD
38613: IN
38614: IFFALSE 38632
// temp_list = temp_list ^ i ;
38616: LD_ADDR_VAR 0 3
38620: PUSH
38621: LD_VAR 0 3
38625: PUSH
38626: LD_VAR 0 4
38630: ADD
38631: ST_TO_ADDR
38632: GO 38582
38634: POP
38635: POP
// temp_list_2 = [ ] ;
38636: LD_ADDR_VAR 0 1
38640: PUSH
38641: EMPTY
38642: ST_TO_ADDR
// for k in temp_list do
38643: LD_ADDR_VAR 0 2
38647: PUSH
38648: LD_VAR 0 3
38652: PUSH
38653: FOR_IN
38654: IFFALSE 38768
// if not k in [ Stanimir , Barovnin , Yefibachev , Yakov , Natalya , Mikhail , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_eng , poker_sol , poker_mec ] then
38656: LD_VAR 0 2
38660: PUSH
38661: LD_EXP 12
38665: PUSH
38666: LD_EXP 13
38670: PUSH
38671: LD_EXP 14
38675: PUSH
38676: LD_EXP 15
38680: PUSH
38681: LD_EXP 16
38685: PUSH
38686: LD_EXP 17
38690: PUSH
38691: LD_EXP 18
38695: PUSH
38696: LD_EXP 19
38700: PUSH
38701: LD_EXP 20
38705: PUSH
38706: LD_EXP 21
38710: PUSH
38711: LD_EXP 22
38715: PUSH
38716: LD_EXP 23
38720: PUSH
38721: LD_EXP 24
38725: PUSH
38726: LD_EXP 25
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: IN
38747: NOT
38748: IFFALSE 38766
// temp_list_2 = temp_list_2 ^ k ;
38750: LD_ADDR_VAR 0 1
38754: PUSH
38755: LD_VAR 0 1
38759: PUSH
38760: LD_VAR 0 2
38764: ADD
38765: ST_TO_ADDR
38766: GO 38653
38768: POP
38769: POP
// DialogueOn ;
38770: CALL_OW 6
// if temp_list_2 > 0 then
38774: LD_VAR 0 1
38778: PUSH
38779: LD_INT 0
38781: GREATER
38782: IFFALSE 38841
// begin k = temp_list_2 [ 1 ] ;
38784: LD_ADDR_VAR 0 2
38788: PUSH
38789: LD_VAR 0 1
38793: PUSH
38794: LD_INT 1
38796: ARRAY
38797: ST_TO_ADDR
// if GetSex ( k ) = sex_male then
38798: LD_VAR 0 2
38802: PPUSH
38803: CALL_OW 258
38807: PUSH
38808: LD_INT 1
38810: EQUAL
38811: IFFALSE 38827
// Say ( k , D6-GuardM-2 ) else
38813: LD_VAR 0 2
38817: PPUSH
38818: LD_STRING D6-GuardM-2
38820: PPUSH
38821: CALL_OW 88
38825: GO 38839
// Say ( k , D6-GuardF-2 ) ;
38827: LD_VAR 0 2
38831: PPUSH
38832: LD_STRING D6-GuardF-2
38834: PPUSH
38835: CALL_OW 88
// end else
38839: GO 38853
// SayRadio ( Yefibachev , D6-Leader-3 ) ;
38841: LD_EXP 14
38845: PPUSH
38846: LD_STRING D6-Leader-3
38848: PPUSH
38849: CALL_OW 94
// DialogueOff ;
38853: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
38857: LD_INT 4
38859: PPUSH
38860: CALL 42004 0 1
// code_red = true ;
38864: LD_ADDR_EXP 76
38868: PUSH
38869: LD_INT 1
38871: ST_TO_ADDR
// CreateCodeRedPatrols ( difficulty - 1 ) ;
38872: LD_OWVAR 67
38876: PUSH
38877: LD_INT 1
38879: MINUS
38880: PPUSH
38881: CALL 38894 0 1
// exit ;
38885: GO 38891
// end ; until false ;
38887: LD_INT 0
38889: IFFALSE 38416
// end ;
38891: PPOPN 4
38893: END
// export function CreateCodeRedPatrols ( num_pat ) ; var i , temp_list , j , num , temp_list_2 , num_low , boolean_num , picked , num_pat_list , allowed_num , val ; begin
38894: LD_INT 0
38896: PPUSH
38897: PPUSH
38898: PPUSH
38899: PPUSH
38900: PPUSH
38901: PPUSH
38902: PPUSH
38903: PPUSH
38904: PPUSH
38905: PPUSH
38906: PPUSH
38907: PPUSH
// allowed_num = [ ] ;
38908: LD_ADDR_VAR 0 12
38912: PUSH
38913: EMPTY
38914: ST_TO_ADDR
// val = 0 ;
38915: LD_ADDR_VAR 0 13
38919: PUSH
38920: LD_INT 0
38922: ST_TO_ADDR
// for i = 1 to patrols do
38923: LD_ADDR_VAR 0 3
38927: PUSH
38928: DOUBLE
38929: LD_INT 1
38931: DEC
38932: ST_TO_ADDR
38933: LD_EXP 78
38937: PUSH
38938: FOR_TO
38939: IFFALSE 38991
// if patrols [ i ] = 0 then
38941: LD_EXP 78
38945: PUSH
38946: LD_VAR 0 3
38950: ARRAY
38951: PUSH
38952: LD_INT 0
38954: EQUAL
38955: IFFALSE 38975
// allowed_num = allowed_num ^ i else
38957: LD_ADDR_VAR 0 12
38961: PUSH
38962: LD_VAR 0 12
38966: PUSH
38967: LD_VAR 0 3
38971: ADD
38972: ST_TO_ADDR
38973: GO 38989
// val = val + 1 ;
38975: LD_ADDR_VAR 0 13
38979: PUSH
38980: LD_VAR 0 13
38984: PUSH
38985: LD_INT 1
38987: PLUS
38988: ST_TO_ADDR
38989: GO 38938
38991: POP
38992: POP
// if num_pat < 1 then
38993: LD_VAR 0 1
38997: PUSH
38998: LD_INT 1
39000: LESS
39001: IFFALSE 39013
// num_pat = 1 else
39003: LD_ADDR_VAR 0 1
39007: PUSH
39008: LD_INT 1
39010: ST_TO_ADDR
39011: GO 39031
// if num_pat > 2 then
39013: LD_VAR 0 1
39017: PUSH
39018: LD_INT 2
39020: GREATER
39021: IFFALSE 39031
// num_pat = 2 ;
39023: LD_ADDR_VAR 0 1
39027: PUSH
39028: LD_INT 2
39030: ST_TO_ADDR
// if allowed_num = 0 or val >= num_pat then
39031: LD_VAR 0 12
39035: PUSH
39036: LD_INT 0
39038: EQUAL
39039: PUSH
39040: LD_VAR 0 13
39044: PUSH
39045: LD_VAR 0 1
39049: GREATEREQUAL
39050: OR
39051: IFFALSE 39055
// exit ;
39053: GO 39851
// if num_pat > allowed_num + 0 then
39055: LD_VAR 0 1
39059: PUSH
39060: LD_VAR 0 12
39064: PUSH
39065: LD_INT 0
39067: PLUS
39068: GREATER
39069: IFFALSE 39085
// num_pat = allowed_num + 0 ;
39071: LD_ADDR_VAR 0 1
39075: PUSH
39076: LD_VAR 0 12
39080: PUSH
39081: LD_INT 0
39083: PLUS
39084: ST_TO_ADDR
// num_pat_list = [ ] ;
39085: LD_ADDR_VAR 0 11
39089: PUSH
39090: EMPTY
39091: ST_TO_ADDR
// for i = 1 to num_pat do
39092: LD_ADDR_VAR 0 3
39096: PUSH
39097: DOUBLE
39098: LD_INT 1
39100: DEC
39101: ST_TO_ADDR
39102: LD_VAR 0 1
39106: PUSH
39107: FOR_TO
39108: IFFALSE 39134
// num_pat_list = num_pat_list ^ allowed_num [ i ] ;
39110: LD_ADDR_VAR 0 11
39114: PUSH
39115: LD_VAR 0 11
39119: PUSH
39120: LD_VAR 0 12
39124: PUSH
39125: LD_VAR 0 3
39129: ARRAY
39130: ADD
39131: ST_TO_ADDR
39132: GO 39107
39134: POP
39135: POP
// boolean_num = Rand ( 1 , 2 ) ;
39136: LD_ADDR_VAR 0 9
39140: PUSH
39141: LD_INT 1
39143: PPUSH
39144: LD_INT 2
39146: PPUSH
39147: CALL_OW 12
39151: ST_TO_ADDR
// for i in num_pat_list do
39152: LD_ADDR_VAR 0 3
39156: PUSH
39157: LD_VAR 0 11
39161: PUSH
39162: FOR_IN
39163: IFFALSE 39849
// begin num_low = 4 ;
39165: LD_ADDR_VAR 0 8
39169: PUSH
39170: LD_INT 4
39172: ST_TO_ADDR
// if not terminate_internal_patrol then
39173: LD_EXP 82
39177: NOT
39178: IFFALSE 39194
// num_low = num_low + 2 ;
39180: LD_ADDR_VAR 0 8
39184: PUSH
39185: LD_VAR 0 8
39189: PUSH
39190: LD_INT 2
39192: PLUS
39193: ST_TO_ADDR
// if ai_soldiers [ 1 ] < num_low + 2 then
39194: LD_EXP 26
39198: PUSH
39199: LD_INT 1
39201: ARRAY
39202: PUSH
39203: LD_VAR 0 8
39207: PUSH
39208: LD_INT 2
39210: PLUS
39211: LESS
39212: IFFALSE 39216
// break ;
39214: GO 39849
// num = [ 2 , 3 , 4 ] [ difficulty ] + Rand ( 0 , 1 ) ;
39216: LD_ADDR_VAR 0 6
39220: PUSH
39221: LD_INT 2
39223: PUSH
39224: LD_INT 3
39226: PUSH
39227: LD_INT 4
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: LIST
39234: PUSH
39235: LD_OWVAR 67
39239: ARRAY
39240: PUSH
39241: LD_INT 0
39243: PPUSH
39244: LD_INT 1
39246: PPUSH
39247: CALL_OW 12
39251: PLUS
39252: ST_TO_ADDR
// if num > ai_soldiers [ 1 ] - num_low then
39253: LD_VAR 0 6
39257: PUSH
39258: LD_EXP 26
39262: PUSH
39263: LD_INT 1
39265: ARRAY
39266: PUSH
39267: LD_VAR 0 8
39271: MINUS
39272: GREATER
39273: IFFALSE 39295
// num = ai_soldiers [ 1 ] - num_low ;
39275: LD_ADDR_VAR 0 6
39279: PUSH
39280: LD_EXP 26
39284: PUSH
39285: LD_INT 1
39287: ARRAY
39288: PUSH
39289: LD_VAR 0 8
39293: MINUS
39294: ST_TO_ADDR
// temp_list_2 = [ Yefibachev ] ;
39295: LD_ADDR_VAR 0 7
39299: PUSH
39300: LD_EXP 14
39304: PUSH
39305: EMPTY
39306: LIST
39307: ST_TO_ADDR
// if not entrance_guard_dialogue_played and heike_undercover in [ 0 , 2 ] then
39308: LD_EXP 84
39312: NOT
39313: PUSH
39314: LD_EXP 83
39318: PUSH
39319: LD_INT 0
39321: PUSH
39322: LD_INT 2
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: IN
39329: AND
39330: IFFALSE 39374
// begin for j in ai_bunkers [ 1 ] do
39332: LD_ADDR_VAR 0 5
39336: PUSH
39337: LD_EXP 49
39341: PUSH
39342: LD_INT 1
39344: ARRAY
39345: PUSH
39346: FOR_IN
39347: IFFALSE 39372
// temp_list_2 = temp_list_2 ^ UnitsInside ( j ) ;
39349: LD_ADDR_VAR 0 7
39353: PUSH
39354: LD_VAR 0 7
39358: PUSH
39359: LD_VAR 0 5
39363: PPUSH
39364: CALL_OW 313
39368: ADD
39369: ST_TO_ADDR
39370: GO 39346
39372: POP
39373: POP
// end ; temp_list = [ ] ;
39374: LD_ADDR_VAR 0 4
39378: PUSH
39379: EMPTY
39380: ST_TO_ADDR
// j = 1 ;
39381: LD_ADDR_VAR 0 5
39385: PUSH
39386: LD_INT 1
39388: ST_TO_ADDR
// while temp_list < num do
39389: LD_VAR 0 4
39393: PUSH
39394: LD_VAR 0 6
39398: LESS
39399: IFFALSE 39466
// begin if not ai_soldiers [ 1 ] [ j ] in temp_list_2 then
39401: LD_EXP 26
39405: PUSH
39406: LD_INT 1
39408: ARRAY
39409: PUSH
39410: LD_VAR 0 5
39414: ARRAY
39415: PUSH
39416: LD_VAR 0 7
39420: IN
39421: NOT
39422: IFFALSE 39450
// temp_list = temp_list ^ ai_soldiers [ 1 ] [ j ] ;
39424: LD_ADDR_VAR 0 4
39428: PUSH
39429: LD_VAR 0 4
39433: PUSH
39434: LD_EXP 26
39438: PUSH
39439: LD_INT 1
39441: ARRAY
39442: PUSH
39443: LD_VAR 0 5
39447: ARRAY
39448: ADD
39449: ST_TO_ADDR
// j = j + 1 ;
39450: LD_ADDR_VAR 0 5
39454: PUSH
39455: LD_VAR 0 5
39459: PUSH
39460: LD_INT 1
39462: PLUS
39463: ST_TO_ADDR
// end ;
39464: GO 39389
// temp_list_2 = ai_soldiers [ 1 ] diff temp_list ;
39466: LD_ADDR_VAR 0 7
39470: PUSH
39471: LD_EXP 26
39475: PUSH
39476: LD_INT 1
39478: ARRAY
39479: PUSH
39480: LD_VAR 0 4
39484: DIFF
39485: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , 1 , temp_list_2 ) ;
39486: LD_ADDR_EXP 26
39490: PUSH
39491: LD_EXP 26
39495: PPUSH
39496: LD_INT 1
39498: PPUSH
39499: LD_VAR 0 7
39503: PPUSH
39504: CALL_OW 1
39508: ST_TO_ADDR
// num = [ 0 , 1 , 2 ] [ difficulty ] + Rand ( 0 , 1 ) ;
39509: LD_ADDR_VAR 0 6
39513: PUSH
39514: LD_INT 0
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: LD_INT 2
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: LIST
39527: PUSH
39528: LD_OWVAR 67
39532: ARRAY
39533: PUSH
39534: LD_INT 0
39536: PPUSH
39537: LD_INT 1
39539: PPUSH
39540: CALL_OW 12
39544: PLUS
39545: ST_TO_ADDR
// if num > ai_scientists [ 1 ] - 8 then
39546: LD_VAR 0 6
39550: PUSH
39551: LD_EXP 30
39555: PUSH
39556: LD_INT 1
39558: ARRAY
39559: PUSH
39560: LD_INT 8
39562: MINUS
39563: GREATER
39564: IFFALSE 39584
// num = ai_scientists [ 1 ] - 8 ;
39566: LD_ADDR_VAR 0 6
39570: PUSH
39571: LD_EXP 30
39575: PUSH
39576: LD_INT 1
39578: ARRAY
39579: PUSH
39580: LD_INT 8
39582: MINUS
39583: ST_TO_ADDR
// if num > 0 then
39584: LD_VAR 0 6
39588: PUSH
39589: LD_INT 0
39591: GREATER
39592: IFFALSE 39743
// begin j = 1 ;
39594: LD_ADDR_VAR 0 5
39598: PUSH
39599: LD_INT 1
39601: ST_TO_ADDR
// picked = 0 ;
39602: LD_ADDR_VAR 0 10
39606: PUSH
39607: LD_INT 0
39609: ST_TO_ADDR
// while picked < num do
39610: LD_VAR 0 10
39614: PUSH
39615: LD_VAR 0 6
39619: LESS
39620: IFFALSE 39700
// begin if ai_scientists [ 1 ] [ j ] <> Barovnin then
39622: LD_EXP 30
39626: PUSH
39627: LD_INT 1
39629: ARRAY
39630: PUSH
39631: LD_VAR 0 5
39635: ARRAY
39636: PUSH
39637: LD_EXP 13
39641: NONEQUAL
39642: IFFALSE 39684
// begin temp_list = temp_list ^ ai_scientists [ 1 ] [ j ] ;
39644: LD_ADDR_VAR 0 4
39648: PUSH
39649: LD_VAR 0 4
39653: PUSH
39654: LD_EXP 30
39658: PUSH
39659: LD_INT 1
39661: ARRAY
39662: PUSH
39663: LD_VAR 0 5
39667: ARRAY
39668: ADD
39669: ST_TO_ADDR
// picked = picked + 1 ;
39670: LD_ADDR_VAR 0 10
39674: PUSH
39675: LD_VAR 0 10
39679: PUSH
39680: LD_INT 1
39682: PLUS
39683: ST_TO_ADDR
// end ; j = j + 1 ;
39684: LD_ADDR_VAR 0 5
39688: PUSH
39689: LD_VAR 0 5
39693: PUSH
39694: LD_INT 1
39696: PLUS
39697: ST_TO_ADDR
// end ;
39698: GO 39610
// temp_list_2 = ai_scientists [ 1 ] diff temp_list ;
39700: LD_ADDR_VAR 0 7
39704: PUSH
39705: LD_EXP 30
39709: PUSH
39710: LD_INT 1
39712: ARRAY
39713: PUSH
39714: LD_VAR 0 4
39718: DIFF
39719: ST_TO_ADDR
// ai_scientists = Replace ( ai_scientists , 1 , temp_list_2 ) ;
39720: LD_ADDR_EXP 30
39724: PUSH
39725: LD_EXP 30
39729: PPUSH
39730: LD_INT 1
39732: PPUSH
39733: LD_VAR 0 7
39737: PPUSH
39738: CALL_OW 1
39742: ST_TO_ADDR
// end ; temp_list_2 = ai_heal_these_humans [ 1 ] diff temp_list ;
39743: LD_ADDR_VAR 0 7
39747: PUSH
39748: LD_EXP 42
39752: PUSH
39753: LD_INT 1
39755: ARRAY
39756: PUSH
39757: LD_VAR 0 4
39761: DIFF
39762: ST_TO_ADDR
// ai_heal_these_humans = Replace ( ai_heal_these_humans , 1 , temp_list_2 ) ;
39763: LD_ADDR_EXP 42
39767: PUSH
39768: LD_EXP 42
39772: PPUSH
39773: LD_INT 1
39775: PPUSH
39776: LD_VAR 0 7
39780: PPUSH
39781: CALL_OW 1
39785: ST_TO_ADDR
// patrols = Replace ( patrols , i , temp_list ) ;
39786: LD_ADDR_EXP 78
39790: PUSH
39791: LD_EXP 78
39795: PPUSH
39796: LD_VAR 0 3
39800: PPUSH
39801: LD_VAR 0 4
39805: PPUSH
39806: CALL_OW 1
39810: ST_TO_ADDR
// patrols_path = Replace ( patrols_path , i , CreatePatrolPath ( i = boolean_num ) ) ;
39811: LD_ADDR_EXP 79
39815: PUSH
39816: LD_EXP 79
39820: PPUSH
39821: LD_VAR 0 3
39825: PPUSH
39826: LD_VAR 0 3
39830: PUSH
39831: LD_VAR 0 9
39835: EQUAL
39836: PPUSH
39837: CALL 16317 0 1
39841: PPUSH
39842: CALL_OW 1
39846: ST_TO_ADDR
// end ;
39847: GO 39162
39849: POP
39850: POP
// end ;
39851: LD_VAR 0 2
39855: RET
// every 0 0$1 + 0 0$0.3 do var val , i , temp_list , k , j , temp_list_2 , all_rus_pats , player_list ; var pat_say_cooldown ;
39856: GO 39858
39858: DISABLE
39859: LD_INT 0
39861: PPUSH
39862: PPUSH
39863: PPUSH
39864: PPUSH
39865: PPUSH
39866: PPUSH
39867: PPUSH
39868: PPUSH
39869: PPUSH
// begin pat_say_cooldown = [ ] ;
39870: LD_ADDR_VAR 0 9
39874: PUSH
39875: EMPTY
39876: ST_TO_ADDR
// for i = 1 to patrols + 1 do
39877: LD_ADDR_VAR 0 2
39881: PUSH
39882: DOUBLE
39883: LD_INT 1
39885: DEC
39886: ST_TO_ADDR
39887: LD_EXP 78
39891: PUSH
39892: LD_INT 1
39894: PLUS
39895: PUSH
39896: FOR_TO
39897: IFFALSE 39915
// pat_say_cooldown = pat_say_cooldown ^ 0 0$0 ;
39899: LD_ADDR_VAR 0 9
39903: PUSH
39904: LD_VAR 0 9
39908: PUSH
39909: LD_INT 0
39911: ADD
39912: ST_TO_ADDR
39913: GO 39896
39915: POP
39916: POP
// repeat wait ( 0 0$1 ) ;
39917: LD_INT 35
39919: PPUSH
39920: CALL_OW 67
// val = false ;
39924: LD_ADDR_VAR 0 1
39928: PUSH
39929: LD_INT 0
39931: ST_TO_ADDR
// for i in patrols do
39932: LD_ADDR_VAR 0 2
39936: PUSH
39937: LD_EXP 78
39941: PUSH
39942: FOR_IN
39943: IFFALSE 39967
// if i > 0 then
39945: LD_VAR 0 2
39949: PUSH
39950: LD_INT 0
39952: GREATER
39953: IFFALSE 39965
// begin val = true ;
39955: LD_ADDR_VAR 0 1
39959: PUSH
39960: LD_INT 1
39962: ST_TO_ADDR
// break ;
39963: GO 39967
// end ;
39965: GO 39942
39967: POP
39968: POP
// if not val then
39969: LD_VAR 0 1
39973: NOT
39974: IFFALSE 39978
// continue ;
39976: GO 39917
// player_list = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_see , russians ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_occupied ] ] ] ] ) ;
39978: LD_ADDR_VAR 0 8
39982: PUSH
39983: LD_INT 22
39985: PUSH
39986: LD_EXP 2
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 50
39997: PUSH
39998: EMPTY
39999: LIST
40000: PUSH
40001: LD_INT 101
40003: PUSH
40004: LD_EXP 3
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 2
40015: PUSH
40016: LD_INT 21
40018: PUSH
40019: LD_INT 1
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 1
40028: PUSH
40029: LD_INT 21
40031: PUSH
40032: LD_INT 2
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 59
40041: PUSH
40042: EMPTY
40043: LIST
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: LIST
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: LIST
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: PPUSH
40061: CALL_OW 69
40065: ST_TO_ADDR
// if heike_undercover = 2 then
40066: LD_EXP 83
40070: PUSH
40071: LD_INT 2
40073: EQUAL
40074: IFFALSE 40113
// begin begin player_list = player_list diff Heike ;
40076: LD_ADDR_VAR 0 8
40080: PUSH
40081: LD_VAR 0 8
40085: PUSH
40086: LD_EXP 7
40090: DIFF
40091: ST_TO_ADDR
// player_list = player_list diff IsInUnit ( Heike ) ;
40092: LD_ADDR_VAR 0 8
40096: PUSH
40097: LD_VAR 0 8
40101: PUSH
40102: LD_EXP 7
40106: PPUSH
40107: CALL_OW 310
40111: DIFF
40112: ST_TO_ADDR
// end ; end ; if player_list = 0 then
40113: LD_VAR 0 8
40117: PUSH
40118: LD_INT 0
40120: EQUAL
40121: IFFALSE 40125
// continue ;
40123: GO 39917
// all_rus_pats = patrols ;
40125: LD_ADDR_VAR 0 7
40129: PUSH
40130: LD_EXP 78
40134: ST_TO_ADDR
// temp_list = [ ] ;
40135: LD_ADDR_VAR 0 3
40139: PUSH
40140: EMPTY
40141: ST_TO_ADDR
// for i in ai_vehicles_attack [ 1 ] do
40142: LD_ADDR_VAR 0 2
40146: PUSH
40147: LD_EXP 38
40151: PUSH
40152: LD_INT 1
40154: ARRAY
40155: PUSH
40156: FOR_IN
40157: IFFALSE 40206
// begin k = UnitsInside ( i ) ;
40159: LD_ADDR_VAR 0 4
40163: PUSH
40164: LD_VAR 0 2
40168: PPUSH
40169: CALL_OW 313
40173: ST_TO_ADDR
// if k > 0 then
40174: LD_VAR 0 4
40178: PUSH
40179: LD_INT 0
40181: GREATER
40182: IFFALSE 40204
// temp_list = temp_list ^ k [ 1 ] ;
40184: LD_ADDR_VAR 0 3
40188: PUSH
40189: LD_VAR 0 3
40193: PUSH
40194: LD_VAR 0 4
40198: PUSH
40199: LD_INT 1
40201: ARRAY
40202: ADD
40203: ST_TO_ADDR
// end ;
40204: GO 40156
40206: POP
40207: POP
// all_rus_pats = all_rus_pats ^ [ temp_list ] ;
40208: LD_ADDR_VAR 0 7
40212: PUSH
40213: LD_VAR 0 7
40217: PUSH
40218: LD_VAR 0 3
40222: PUSH
40223: EMPTY
40224: LIST
40225: ADD
40226: ST_TO_ADDR
// for i = 1 to all_rus_pats do
40227: LD_ADDR_VAR 0 2
40231: PUSH
40232: DOUBLE
40233: LD_INT 1
40235: DEC
40236: ST_TO_ADDR
40237: LD_VAR 0 7
40241: PUSH
40242: FOR_TO
40243: IFFALSE 40957
// begin if i < all_rus_pats then
40245: LD_VAR 0 2
40249: PUSH
40250: LD_VAR 0 7
40254: LESS
40255: IFFALSE 40275
// temp_list = all_rus_pats [ i ] else
40257: LD_ADDR_VAR 0 3
40261: PUSH
40262: LD_VAR 0 7
40266: PUSH
40267: LD_VAR 0 2
40271: ARRAY
40272: ST_TO_ADDR
40273: GO 40326
// begin temp_list = [ ] ;
40275: LD_ADDR_VAR 0 3
40279: PUSH
40280: EMPTY
40281: ST_TO_ADDR
// for k in all_rus_pats [ i ] do
40282: LD_ADDR_VAR 0 4
40286: PUSH
40287: LD_VAR 0 7
40291: PUSH
40292: LD_VAR 0 2
40296: ARRAY
40297: PUSH
40298: FOR_IN
40299: IFFALSE 40324
// temp_list = temp_list ^ IsInUnit ( k ) ;
40301: LD_ADDR_VAR 0 3
40305: PUSH
40306: LD_VAR 0 3
40310: PUSH
40311: LD_VAR 0 4
40315: PPUSH
40316: CALL_OW 310
40320: ADD
40321: ST_TO_ADDR
40322: GO 40298
40324: POP
40325: POP
// end ; if UnitFilter ( temp_list , [ f_see , you ] ) > 0 then
40326: LD_VAR 0 3
40330: PPUSH
40331: LD_INT 101
40333: PUSH
40334: LD_EXP 2
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PPUSH
40343: CALL_OW 72
40347: PUSH
40348: LD_INT 0
40350: GREATER
40351: IFFALSE 40904
// begin val = false ;
40353: LD_ADDR_VAR 0 1
40357: PUSH
40358: LD_INT 0
40360: ST_TO_ADDR
// for j in player_list do
40361: LD_ADDR_VAR 0 5
40365: PUSH
40366: LD_VAR 0 8
40370: PUSH
40371: FOR_IN
40372: IFFALSE 40437
// begin for k in all_rus_pats [ i ] do
40374: LD_ADDR_VAR 0 4
40378: PUSH
40379: LD_VAR 0 7
40383: PUSH
40384: LD_VAR 0 2
40388: ARRAY
40389: PUSH
40390: FOR_IN
40391: IFFALSE 40425
// begin if GetDistUnits ( j , k ) <= 13 then
40393: LD_VAR 0 5
40397: PPUSH
40398: LD_VAR 0 4
40402: PPUSH
40403: CALL_OW 296
40407: PUSH
40408: LD_INT 13
40410: LESSEQUAL
40411: IFFALSE 40423
// begin val = true ;
40413: LD_ADDR_VAR 0 1
40417: PUSH
40418: LD_INT 1
40420: ST_TO_ADDR
// break ;
40421: GO 40425
// end ; end ;
40423: GO 40390
40425: POP
40426: POP
// if val then
40427: LD_VAR 0 1
40431: IFFALSE 40435
// break ;
40433: GO 40437
// end ;
40435: GO 40371
40437: POP
40438: POP
// if not val and pat_say_cooldown [ i ] > 0 0$0 then
40439: LD_VAR 0 1
40443: NOT
40444: PUSH
40445: LD_VAR 0 9
40449: PUSH
40450: LD_VAR 0 2
40454: ARRAY
40455: PUSH
40456: LD_INT 0
40458: GREATER
40459: AND
40460: IFFALSE 40497
// pat_say_cooldown = Replace ( pat_say_cooldown , i , pat_say_cooldown [ i ] - 0 0$1 ) ;
40462: LD_ADDR_VAR 0 9
40466: PUSH
40467: LD_VAR 0 9
40471: PPUSH
40472: LD_VAR 0 2
40476: PPUSH
40477: LD_VAR 0 9
40481: PUSH
40482: LD_VAR 0 2
40486: ARRAY
40487: PUSH
40488: LD_INT 35
40490: MINUS
40491: PPUSH
40492: CALL_OW 1
40496: ST_TO_ADDR
// if val and pat_say_cooldown [ i ] > 0 0$0 then
40497: LD_VAR 0 1
40501: PUSH
40502: LD_VAR 0 9
40506: PUSH
40507: LD_VAR 0 2
40511: ARRAY
40512: PUSH
40513: LD_INT 0
40515: GREATER
40516: AND
40517: IFFALSE 40544
// begin pat_say_cooldown = Replace ( pat_say_cooldown , i , 0 0$30 ) ;
40519: LD_ADDR_VAR 0 9
40523: PUSH
40524: LD_VAR 0 9
40528: PPUSH
40529: LD_VAR 0 2
40533: PPUSH
40534: LD_INT 1050
40536: PPUSH
40537: CALL_OW 1
40541: ST_TO_ADDR
// continue ;
40542: GO 40242
// end ; if val then
40544: LD_VAR 0 1
40548: IFFALSE 40902
// begin temp_list_2 = [ ] ;
40550: LD_ADDR_VAR 0 6
40554: PUSH
40555: EMPTY
40556: ST_TO_ADDR
// for k in all_rus_pats [ i ] do
40557: LD_ADDR_VAR 0 4
40561: PUSH
40562: LD_VAR 0 7
40566: PUSH
40567: LD_VAR 0 2
40571: ARRAY
40572: PUSH
40573: FOR_IN
40574: IFFALSE 40688
// if not k in [ Stanimir , Barovnin , Yefibachev , Yakov , Natalya , Mikhail , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_eng , poker_sol , poker_mec ] then
40576: LD_VAR 0 4
40580: PUSH
40581: LD_EXP 12
40585: PUSH
40586: LD_EXP 13
40590: PUSH
40591: LD_EXP 14
40595: PUSH
40596: LD_EXP 15
40600: PUSH
40601: LD_EXP 16
40605: PUSH
40606: LD_EXP 17
40610: PUSH
40611: LD_EXP 18
40615: PUSH
40616: LD_EXP 19
40620: PUSH
40621: LD_EXP 20
40625: PUSH
40626: LD_EXP 21
40630: PUSH
40631: LD_EXP 22
40635: PUSH
40636: LD_EXP 23
40640: PUSH
40641: LD_EXP 24
40645: PUSH
40646: LD_EXP 25
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: LIST
40658: LIST
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: LIST
40666: IN
40667: NOT
40668: IFFALSE 40686
// temp_list_2 = temp_list_2 ^ k ;
40670: LD_ADDR_VAR 0 6
40674: PUSH
40675: LD_VAR 0 6
40679: PUSH
40680: LD_VAR 0 4
40684: ADD
40685: ST_TO_ADDR
40686: GO 40573
40688: POP
40689: POP
// if temp_list_2 > 0 then
40690: LD_VAR 0 6
40694: PUSH
40695: LD_INT 0
40697: GREATER
40698: IFFALSE 40877
// begin DialogueOn ;
40700: CALL_OW 6
// j = temp_list_2 [ 1 ] ;
40704: LD_ADDR_VAR 0 5
40708: PUSH
40709: LD_VAR 0 6
40713: PUSH
40714: LD_INT 1
40716: ARRAY
40717: ST_TO_ADDR
// if not code_red then
40718: LD_EXP 76
40722: NOT
40723: IFFALSE 40789
// begin if GetSex ( j ) = sex_male then
40725: LD_VAR 0 5
40729: PPUSH
40730: CALL_OW 258
40734: PUSH
40735: LD_INT 1
40737: EQUAL
40738: IFFALSE 40754
// SayRadio ( j , D6-PatM-1 ) else
40740: LD_VAR 0 5
40744: PPUSH
40745: LD_STRING D6-PatM-1
40747: PPUSH
40748: CALL_OW 94
40752: GO 40766
// SayRadio ( j , D6-PatF-1 ) ;
40754: LD_VAR 0 5
40758: PPUSH
40759: LD_STRING D6-PatF-1
40761: PPUSH
40762: CALL_OW 94
// code_red = true ;
40766: LD_ADDR_EXP 76
40770: PUSH
40771: LD_INT 1
40773: ST_TO_ADDR
// CreateCodeRedPatrols ( difficulty - 1 ) ;
40774: LD_OWVAR 67
40778: PUSH
40779: LD_INT 1
40781: MINUS
40782: PPUSH
40783: CALL 38894 0 1
// end else
40787: GO 40873
// begin val = [ a , b , c ] [ Rand ( 1 , 3 ) ] ;
40789: LD_ADDR_VAR 0 1
40793: PUSH
40794: LD_STRING a
40796: PUSH
40797: LD_STRING b
40799: PUSH
40800: LD_STRING c
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 1
40810: PPUSH
40811: LD_INT 3
40813: PPUSH
40814: CALL_OW 12
40818: ARRAY
40819: ST_TO_ADDR
// if GetSex ( j ) = sex_male then
40820: LD_VAR 0 5
40824: PPUSH
40825: CALL_OW 258
40829: PUSH
40830: LD_INT 1
40832: EQUAL
40833: IFFALSE 40855
// SayRadio ( j , D6-SolM-1 & val ) else
40835: LD_VAR 0 5
40839: PPUSH
40840: LD_STRING D6-SolM-1
40842: PUSH
40843: LD_VAR 0 1
40847: STR
40848: PPUSH
40849: CALL_OW 94
40853: GO 40873
// SayRadio ( j , D6-SolF-1 & val ) ;
40855: LD_VAR 0 5
40859: PPUSH
40860: LD_STRING D6-SolF-1
40862: PUSH
40863: LD_VAR 0 1
40867: STR
40868: PPUSH
40869: CALL_OW 94
// end ; DialogueOff ;
40873: CALL_OW 7
// end ; pat_say_cooldown = Replace ( pat_say_cooldown , i , 0 0$30 ) ;
40877: LD_ADDR_VAR 0 9
40881: PUSH
40882: LD_VAR 0 9
40886: PPUSH
40887: LD_VAR 0 2
40891: PPUSH
40892: LD_INT 1050
40894: PPUSH
40895: CALL_OW 1
40899: ST_TO_ADDR
// break ;
40900: GO 40957
// end ; end else
40902: GO 40955
// if pat_say_cooldown [ i ] > 0 0$0 then
40904: LD_VAR 0 9
40908: PUSH
40909: LD_VAR 0 2
40913: ARRAY
40914: PUSH
40915: LD_INT 0
40917: GREATER
40918: IFFALSE 40955
// pat_say_cooldown = Replace ( pat_say_cooldown , i , pat_say_cooldown [ i ] - 0 0$1 ) ;
40920: LD_ADDR_VAR 0 9
40924: PUSH
40925: LD_VAR 0 9
40929: PPUSH
40930: LD_VAR 0 2
40934: PPUSH
40935: LD_VAR 0 9
40939: PUSH
40940: LD_VAR 0 2
40944: ARRAY
40945: PUSH
40946: LD_INT 35
40948: MINUS
40949: PPUSH
40950: CALL_OW 1
40954: ST_TO_ADDR
// end ;
40955: GO 40242
40957: POP
40958: POP
// until false ;
40959: LD_INT 0
40961: IFFALSE 39917
// end ;
40963: PPOPN 9
40965: END
// every 0 0$1 + 0 0$0.4 do var i , temp_list , driver , vehicle , j ;
40966: GO 40968
40968: DISABLE
40969: LD_INT 0
40971: PPUSH
40972: PPUSH
40973: PPUSH
40974: PPUSH
40975: PPUSH
// begin repeat wait ( 0 0$1 ) ;
40976: LD_INT 35
40978: PPUSH
40979: CALL_OW 67
// if not code_red then
40983: LD_EXP 76
40987: NOT
40988: IFFALSE 40992
// continue ;
40990: GO 40976
// for i = 1 to 2 - ai_mechanics_attack [ 1 ] do
40992: LD_ADDR_VAR 0 1
40996: PUSH
40997: DOUBLE
40998: LD_INT 1
41000: DEC
41001: ST_TO_ADDR
41002: LD_INT 2
41004: PUSH
41005: LD_EXP 29
41009: PUSH
41010: LD_INT 1
41012: ARRAY
41013: MINUS
41014: PUSH
41015: FOR_TO
41016: IFFALSE 41433
// begin temp_list = [ Mikhail , Natalya ] ;
41018: LD_ADDR_VAR 0 2
41022: PUSH
41023: LD_EXP 17
41027: PUSH
41028: LD_EXP 16
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: ST_TO_ADDR
// if except_Yakov then
41037: LD_EXP 111
41041: IFFALSE 41059
// temp_list = temp_list ^ Yakov ;
41043: LD_ADDR_VAR 0 2
41047: PUSH
41048: LD_VAR 0 2
41052: PUSH
41053: LD_EXP 15
41057: ADD
41058: ST_TO_ADDR
// driver = 0 ;
41059: LD_ADDR_VAR 0 3
41063: PUSH
41064: LD_INT 0
41066: ST_TO_ADDR
// for j in ai_mechanics_defend [ 1 ] do
41067: LD_ADDR_VAR 0 5
41071: PUSH
41072: LD_EXP 28
41076: PUSH
41077: LD_INT 1
41079: ARRAY
41080: PUSH
41081: FOR_IN
41082: IFFALSE 41121
// if not j in temp_list ^ ai_heal_these_humans [ 1 ] then
41084: LD_VAR 0 5
41088: PUSH
41089: LD_VAR 0 2
41093: PUSH
41094: LD_EXP 42
41098: PUSH
41099: LD_INT 1
41101: ARRAY
41102: ADD
41103: IN
41104: NOT
41105: IFFALSE 41119
// begin driver = j ;
41107: LD_ADDR_VAR 0 3
41111: PUSH
41112: LD_VAR 0 5
41116: ST_TO_ADDR
// break ;
41117: GO 41121
// end ;
41119: GO 41081
41121: POP
41122: POP
// if driver = 0 then
41123: LD_VAR 0 3
41127: PUSH
41128: LD_INT 0
41130: EQUAL
41131: IFFALSE 41135
// break ;
41133: GO 41433
// vehicle = 0 ;
41135: LD_ADDR_VAR 0 4
41139: PUSH
41140: LD_INT 0
41142: ST_TO_ADDR
// temp_list = [ ] ;
41143: LD_ADDR_VAR 0 2
41147: PUSH
41148: EMPTY
41149: ST_TO_ADDR
// for j in ai_vehicle_pullback_hexes [ 1 ] do
41150: LD_ADDR_VAR 0 5
41154: PUSH
41155: LD_EXP 39
41159: PUSH
41160: LD_INT 1
41162: ARRAY
41163: PUSH
41164: FOR_IN
41165: IFFALSE 41203
// temp_list = temp_list ^ HexInfo ( j [ 1 ] , j [ 2 ] ) ;
41167: LD_ADDR_VAR 0 2
41171: PUSH
41172: LD_VAR 0 2
41176: PUSH
41177: LD_VAR 0 5
41181: PUSH
41182: LD_INT 1
41184: ARRAY
41185: PPUSH
41186: LD_VAR 0 5
41190: PUSH
41191: LD_INT 2
41193: ARRAY
41194: PPUSH
41195: CALL_OW 428
41199: ADD
41200: ST_TO_ADDR
41201: GO 41164
41203: POP
41204: POP
// temp_list = temp_list diff 0 ;
41205: LD_ADDR_VAR 0 2
41209: PUSH
41210: LD_VAR 0 2
41214: PUSH
41215: LD_INT 0
41217: DIFF
41218: ST_TO_ADDR
// for j in ai_vehicles_defend [ 1 ] do
41219: LD_ADDR_VAR 0 5
41223: PUSH
41224: LD_EXP 37
41228: PUSH
41229: LD_INT 1
41231: ARRAY
41232: PUSH
41233: FOR_IN
41234: IFFALSE 41304
// if not j in ai_refuel_vehicles_list [ 1 ] ^ ai_vehicle_being_moved [ 1 ] and GetLives ( j ) = 1000 and j in temp_list then
41236: LD_VAR 0 5
41240: PUSH
41241: LD_EXP 54
41245: PUSH
41246: LD_INT 1
41248: ARRAY
41249: PUSH
41250: LD_EXP 45
41254: PUSH
41255: LD_INT 1
41257: ARRAY
41258: ADD
41259: IN
41260: NOT
41261: PUSH
41262: LD_VAR 0 5
41266: PPUSH
41267: CALL_OW 256
41271: PUSH
41272: LD_INT 1000
41274: EQUAL
41275: AND
41276: PUSH
41277: LD_VAR 0 5
41281: PUSH
41282: LD_VAR 0 2
41286: IN
41287: AND
41288: IFFALSE 41302
// begin vehicle = j ;
41290: LD_ADDR_VAR 0 4
41294: PUSH
41295: LD_VAR 0 5
41299: ST_TO_ADDR
// break ;
41300: GO 41304
// end ;
41302: GO 41233
41304: POP
41305: POP
// if vehicle = 0 then
41306: LD_VAR 0 4
41310: PUSH
41311: LD_INT 0
41313: EQUAL
41314: IFFALSE 41318
// break ;
41316: GO 41433
// RemoveHumanFromVariables ( 1 , driver , false ) ;
41318: LD_INT 1
41320: PPUSH
41321: LD_VAR 0 3
41325: PPUSH
41326: LD_INT 0
41328: PPUSH
41329: CALL 10822 0 3
// temp_list = ai_mechanics_attack [ 1 ] ^ driver ;
41333: LD_ADDR_VAR 0 2
41337: PUSH
41338: LD_EXP 29
41342: PUSH
41343: LD_INT 1
41345: ARRAY
41346: PUSH
41347: LD_VAR 0 3
41351: ADD
41352: ST_TO_ADDR
// ai_mechanics_attack = Replace ( ai_mechanics_attack , 1 , temp_list ) ;
41353: LD_ADDR_EXP 29
41357: PUSH
41358: LD_EXP 29
41362: PPUSH
41363: LD_INT 1
41365: PPUSH
41366: LD_VAR 0 2
41370: PPUSH
41371: CALL_OW 1
41375: ST_TO_ADDR
// RemoveVehicleFromVariables ( 1 , vehicle ) ;
41376: LD_INT 1
41378: PPUSH
41379: LD_VAR 0 4
41383: PPUSH
41384: CALL 10341 0 2
// temp_list = ai_vehicles_attack [ 1 ] ^ vehicle ;
41388: LD_ADDR_VAR 0 2
41392: PUSH
41393: LD_EXP 38
41397: PUSH
41398: LD_INT 1
41400: ARRAY
41401: PUSH
41402: LD_VAR 0 4
41406: ADD
41407: ST_TO_ADDR
// ai_vehicles_attack = Replace ( ai_vehicles_attack , 1 , temp_list ) ;
41408: LD_ADDR_EXP 38
41412: PUSH
41413: LD_EXP 38
41417: PPUSH
41418: LD_INT 1
41420: PPUSH
41421: LD_VAR 0 2
41425: PPUSH
41426: CALL_OW 1
41430: ST_TO_ADDR
// end ;
41431: GO 41015
41433: POP
41434: POP
// until false ;
41435: LD_INT 0
41437: IFFALSE 40976
// end ;
41439: PPOPN 5
41441: END
// every 0 0$1 + 0 0$0.5 do var i , val ; var timer , no_patrols , patrols_check ;
41442: GO 41444
41444: DISABLE
41445: LD_INT 0
41447: PPUSH
41448: PPUSH
41449: PPUSH
41450: PPUSH
41451: PPUSH
// begin no_patrols = false ;
41452: LD_ADDR_VAR 0 4
41456: PUSH
41457: LD_INT 0
41459: ST_TO_ADDR
// patrols_check = true ;
41460: LD_ADDR_VAR 0 5
41464: PUSH
41465: LD_INT 1
41467: ST_TO_ADDR
// timer = 2 2$30 ;
41468: LD_ADDR_VAR 0 3
41472: PUSH
41473: LD_INT 5250
41475: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41476: LD_INT 35
41478: PPUSH
41479: CALL_OW 67
// if not code_red then
41483: LD_EXP 76
41487: NOT
41488: IFFALSE 41500
// begin patrols_check = true ;
41490: LD_ADDR_VAR 0 5
41494: PUSH
41495: LD_INT 1
41497: ST_TO_ADDR
// continue ;
41498: GO 41476
// end ; if patrols_check then
41500: LD_VAR 0 5
41504: IFFALSE 41584
// begin val = false ;
41506: LD_ADDR_VAR 0 2
41510: PUSH
41511: LD_INT 0
41513: ST_TO_ADDR
// for i in patrols do
41514: LD_ADDR_VAR 0 1
41518: PUSH
41519: LD_EXP 78
41523: PUSH
41524: FOR_IN
41525: IFFALSE 41549
// if i > 0 then
41527: LD_VAR 0 1
41531: PUSH
41532: LD_INT 0
41534: GREATER
41535: IFFALSE 41547
// begin val = true ;
41537: LD_ADDR_VAR 0 2
41541: PUSH
41542: LD_INT 1
41544: ST_TO_ADDR
// break ;
41545: GO 41549
// end ;
41547: GO 41524
41549: POP
41550: POP
// if not val then
41551: LD_VAR 0 2
41555: NOT
41556: IFFALSE 41568
// no_patrols = true else
41558: LD_ADDR_VAR 0 4
41562: PUSH
41563: LD_INT 1
41565: ST_TO_ADDR
41566: GO 41576
// no_patrols = false ;
41568: LD_ADDR_VAR 0 4
41572: PUSH
41573: LD_INT 0
41575: ST_TO_ADDR
// patrols_check = false ;
41576: LD_ADDR_VAR 0 5
41580: PUSH
41581: LD_INT 0
41583: ST_TO_ADDR
// end ; if no_patrols then
41584: LD_VAR 0 4
41588: IFFALSE 41632
// begin timer = timer - 0 0$1 ;
41590: LD_ADDR_VAR 0 3
41594: PUSH
41595: LD_VAR 0 3
41599: PUSH
41600: LD_INT 35
41602: MINUS
41603: ST_TO_ADDR
// if timer <= 0 then
41604: LD_VAR 0 3
41608: PUSH
41609: LD_INT 0
41611: LESSEQUAL
41612: IFFALSE 41630
// begin code_red = false ;
41614: LD_ADDR_EXP 76
41618: PUSH
41619: LD_INT 0
41621: ST_TO_ADDR
// timer = 2 2$30 ;
41622: LD_ADDR_VAR 0 3
41626: PUSH
41627: LD_INT 5250
41629: ST_TO_ADDR
// end ; end else
41630: GO 41692
// begin val = false ;
41632: LD_ADDR_VAR 0 2
41636: PUSH
41637: LD_INT 0
41639: ST_TO_ADDR
// for i in patrols do
41640: LD_ADDR_VAR 0 1
41644: PUSH
41645: LD_EXP 78
41649: PUSH
41650: FOR_IN
41651: IFFALSE 41675
// if i > 0 then
41653: LD_VAR 0 1
41657: PUSH
41658: LD_INT 0
41660: GREATER
41661: IFFALSE 41673
// begin val = true ;
41663: LD_ADDR_VAR 0 2
41667: PUSH
41668: LD_INT 1
41670: ST_TO_ADDR
// break ;
41671: GO 41675
// end ;
41673: GO 41650
41675: POP
41676: POP
// if not val then
41677: LD_VAR 0 2
41681: NOT
41682: IFFALSE 41692
// code_red = false ;
41684: LD_ADDR_EXP 76
41688: PUSH
41689: LD_INT 0
41691: ST_TO_ADDR
// end ; until false ;
41692: LD_INT 0
41694: IFFALSE 41476
// end ;
41696: PPOPN 5
41698: END
// every 0 0$1 + 0 0$0.2 do var i , val ; var num_pats ;
41699: GO 41701
41701: DISABLE
41702: LD_INT 0
41704: PPUSH
41705: PPUSH
41706: PPUSH
// begin num_pats = [ 0 , 1 , 2 ] [ difficulty ] ;
41707: LD_ADDR_VAR 0 3
41711: PUSH
41712: LD_INT 0
41714: PUSH
41715: LD_INT 1
41717: PUSH
41718: LD_INT 2
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: LIST
41725: PUSH
41726: LD_OWVAR 67
41730: ARRAY
41731: ST_TO_ADDR
// if difficulty = 1 then
41732: LD_OWVAR 67
41736: PUSH
41737: LD_INT 1
41739: EQUAL
41740: IFFALSE 41744
// exit ;
41742: GO 42001
// repeat wait ( 0 0$0.5 ) ;
41744: LD_INT 18
41746: PPUSH
41747: CALL_OW 67
// if code_red or code_black then
41751: LD_EXP 76
41755: PUSH
41756: LD_EXP 77
41760: OR
41761: IFFALSE 41765
// continue ;
41763: GO 41744
// val = 0 ;
41765: LD_ADDR_VAR 0 2
41769: PUSH
41770: LD_INT 0
41772: ST_TO_ADDR
// for i in patrols do
41773: LD_ADDR_VAR 0 1
41777: PUSH
41778: LD_EXP 78
41782: PUSH
41783: FOR_IN
41784: IFFALSE 41812
// if i > 0 then
41786: LD_VAR 0 1
41790: PUSH
41791: LD_INT 0
41793: GREATER
41794: IFFALSE 41810
// val = val + 1 ;
41796: LD_ADDR_VAR 0 2
41800: PUSH
41801: LD_VAR 0 2
41805: PUSH
41806: LD_INT 1
41808: PLUS
41809: ST_TO_ADDR
41810: GO 41783
41812: POP
41813: POP
// if val >= num_pats then
41814: LD_VAR 0 2
41818: PUSH
41819: LD_VAR 0 3
41823: GREATEREQUAL
41824: IFFALSE 41828
// continue ;
41826: GO 41744
// if ContactTime ( [ you , russians_alt ] ) <= 0 0$1 then
41828: LD_EXP 2
41832: PUSH
41833: LD_EXP 6
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PPUSH
41842: CALL_OW 462
41846: PUSH
41847: LD_INT 35
41849: LESSEQUAL
41850: IFFALSE 41997
// begin val = false ;
41852: LD_ADDR_VAR 0 2
41856: PUSH
41857: LD_INT 0
41859: ST_TO_ADDR
// for i in in_out_russian_units do
41860: LD_ADDR_VAR 0 1
41864: PUSH
41865: LD_EXP 119
41869: PUSH
41870: FOR_IN
41871: IFFALSE 41907
// if GetSide ( Attacks ( i ) ) = you then
41873: LD_VAR 0 1
41877: PPUSH
41878: CALL_OW 320
41882: PPUSH
41883: CALL_OW 255
41887: PUSH
41888: LD_EXP 2
41892: EQUAL
41893: IFFALSE 41905
// begin val = true ;
41895: LD_ADDR_VAR 0 2
41899: PUSH
41900: LD_INT 1
41902: ST_TO_ADDR
// break ;
41903: GO 41907
// end ;
41905: GO 41870
41907: POP
41908: POP
// if not val then
41909: LD_VAR 0 2
41913: NOT
41914: IFFALSE 41958
// for i in in_out_russian_units do
41916: LD_ADDR_VAR 0 1
41920: PUSH
41921: LD_EXP 119
41925: PUSH
41926: FOR_IN
41927: IFFALSE 41956
// if GetLives ( i ) < 1000 then
41929: LD_VAR 0 1
41933: PPUSH
41934: CALL_OW 256
41938: PUSH
41939: LD_INT 1000
41941: LESS
41942: IFFALSE 41954
// begin val = true ;
41944: LD_ADDR_VAR 0 2
41948: PUSH
41949: LD_INT 1
41951: ST_TO_ADDR
// break ;
41952: GO 41956
// end ;
41954: GO 41926
41956: POP
41957: POP
// if val then
41958: LD_VAR 0 2
41962: IFFALSE 41997
// begin if heike_undercover in [ 0 , 1 ] then
41964: LD_EXP 83
41968: PUSH
41969: LD_INT 0
41971: PUSH
41972: LD_INT 1
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: IN
41979: IFFALSE 41988
// wait ( 0 0$30 ) ;
41981: LD_INT 1050
41983: PPUSH
41984: CALL_OW 67
// CreateCodeRedPatrols ( num_pats ) ;
41988: LD_VAR 0 3
41992: PPUSH
41993: CALL 38894 0 1
// end ; end ; until false ;
41997: LD_INT 0
41999: IFFALSE 41744
// end ;
42001: PPOPN 3
42003: END
// export function ChangeHeikeUndercoverStatus ( new_status ) ; var un ; begin
42004: LD_INT 0
42006: PPUSH
42007: PPUSH
// heike_undercover = new_status ;
42008: LD_ADDR_EXP 83
42012: PUSH
42013: LD_VAR 0 1
42017: ST_TO_ADDR
// un = IsInUnit ( Heike ) ;
42018: LD_ADDR_VAR 0 3
42022: PUSH
42023: LD_EXP 7
42027: PPUSH
42028: CALL_OW 310
42032: ST_TO_ADDR
// if new_status in [ 0 , 1 , 4 ] then
42033: LD_VAR 0 1
42037: PUSH
42038: LD_INT 0
42040: PUSH
42041: LD_INT 1
42043: PUSH
42044: LD_INT 4
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: LIST
42051: IN
42052: IFFALSE 42126
// begin EnableExclamations ;
42054: CALL_OW 473
// NormalAttack ( russians , Heike ) ;
42058: LD_EXP 3
42062: PPUSH
42063: LD_EXP 7
42067: PPUSH
42068: CALL_OW 472
// NormalAttack ( russians_alt , Heike ) ;
42072: LD_EXP 6
42076: PPUSH
42077: LD_EXP 7
42081: PPUSH
42082: CALL_OW 472
// if un > 0 then
42086: LD_VAR 0 3
42090: PUSH
42091: LD_INT 0
42093: GREATER
42094: IFFALSE 42124
// begin NormalAttack ( russians , un ) ;
42096: LD_EXP 3
42100: PPUSH
42101: LD_VAR 0 3
42105: PPUSH
42106: CALL_OW 472
// NormalAttack ( russians_alt , un ) ;
42110: LD_EXP 6
42114: PPUSH
42115: LD_VAR 0 3
42119: PPUSH
42120: CALL_OW 472
// end ; end else
42124: GO 42196
// begin DisableExclamations ;
42126: CALL_OW 474
// DoNotAttack ( russians , Heike ) ;
42130: LD_EXP 3
42134: PPUSH
42135: LD_EXP 7
42139: PPUSH
42140: CALL_OW 471
// DoNotAttack ( russians_alt , Heike ) ;
42144: LD_EXP 6
42148: PPUSH
42149: LD_EXP 7
42153: PPUSH
42154: CALL_OW 471
// if un > 0 then
42158: LD_VAR 0 3
42162: PUSH
42163: LD_INT 0
42165: GREATER
42166: IFFALSE 42196
// begin DoNotAttack ( russians , un ) ;
42168: LD_EXP 3
42172: PPUSH
42173: LD_VAR 0 3
42177: PPUSH
42178: CALL_OW 471
// DoNotAttack ( russians_alt , un ) ;
42182: LD_EXP 6
42186: PPUSH
42187: LD_VAR 0 3
42191: PPUSH
42192: CALL_OW 471
// end ; end ; end ; end_of_file
42196: LD_VAR 0 2
42200: RET
// every 0 0$1 + 0 0$0.3 do var times_seen , un ;
42201: GO 42203
42203: DISABLE
42204: LD_INT 0
42206: PPUSH
42207: PPUSH
// begin times_seen = 0 ;
42208: LD_ADDR_VAR 0 1
42212: PUSH
42213: LD_INT 0
42215: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42216: LD_INT 35
42218: PPUSH
42219: CALL_OW 67
// if heike_undercover in [ 1 , 2 , 3 , 4 ] then
42223: LD_EXP 83
42227: PUSH
42228: LD_INT 1
42230: PUSH
42231: LD_INT 2
42233: PUSH
42234: LD_INT 3
42236: PUSH
42237: LD_INT 4
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: IN
42246: IFFALSE 42250
// exit ;
42248: GO 42401
// un = IsInUnit ( Heike ) ;
42250: LD_ADDR_VAR 0 2
42254: PUSH
42255: LD_EXP 7
42259: PPUSH
42260: CALL_OW 310
42264: ST_TO_ADDR
// if un = 0 then
42265: LD_VAR 0 2
42269: PUSH
42270: LD_INT 0
42272: EQUAL
42273: IFFALSE 42285
// un = Heike ;
42275: LD_ADDR_VAR 0 2
42279: PUSH
42280: LD_EXP 7
42284: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_dist , un , 10 ] ] ) > 0 then
42285: LD_INT 22
42287: PUSH
42288: LD_EXP 3
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 21
42299: PUSH
42300: LD_INT 1
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 91
42309: PUSH
42310: LD_VAR 0 2
42314: PUSH
42315: LD_INT 10
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: LIST
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: LIST
42327: PPUSH
42328: CALL_OW 69
42332: PUSH
42333: LD_INT 0
42335: GREATER
42336: IFFALSE 42354
// times_seen = times_seen + 1 else
42338: LD_ADDR_VAR 0 1
42342: PUSH
42343: LD_VAR 0 1
42347: PUSH
42348: LD_INT 1
42350: PLUS
42351: ST_TO_ADDR
42352: GO 42378
// if times_seen > 0 then
42354: LD_VAR 0 1
42358: PUSH
42359: LD_INT 0
42361: GREATER
42362: IFFALSE 42378
// times_seen = times_seen - 1 ;
42364: LD_ADDR_VAR 0 1
42368: PUSH
42369: LD_VAR 0 1
42373: PUSH
42374: LD_INT 1
42376: MINUS
42377: ST_TO_ADDR
// if times_seen >= 3 then
42378: LD_VAR 0 1
42382: PUSH
42383: LD_INT 3
42385: GREATEREQUAL
42386: IFFALSE 42397
// begin ChangeHeikeUndercoverStatus ( 1 ) ;
42388: LD_INT 1
42390: PPUSH
42391: CALL 42004 0 1
// exit ;
42395: GO 42401
// end ; until false ;
42397: LD_INT 0
42399: IFFALSE 42216
// end ;
42401: PPOPN 2
42403: END
// every 0 0$1 + 0 0$0.7 do var temp_list ;
42404: GO 42406
42406: DISABLE
42407: LD_INT 0
42409: PPUSH
// begin repeat wait ( 0 0$0.3 ) ;
42410: LD_INT 10
42412: PPUSH
42413: CALL_OW 67
// if heike_undercover in [ 2 , 3 , 4 ] then
42417: LD_EXP 83
42421: PUSH
42422: LD_INT 2
42424: PUSH
42425: LD_INT 3
42427: PUSH
42428: LD_INT 4
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: LIST
42435: IN
42436: IFFALSE 42440
// exit ;
42438: GO 42557
// temp_list = FilterAllUnits ( [ [ f_side , russians ] , [ f_see , you ] , [ f_inarea , ru_base_area ] , [ f_type , unit_building ] ] ) ;
42440: LD_ADDR_VAR 0 1
42444: PUSH
42445: LD_INT 22
42447: PUSH
42448: LD_EXP 3
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: PUSH
42457: LD_INT 101
42459: PUSH
42460: LD_EXP 2
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 95
42471: PUSH
42472: LD_INT 2
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 21
42481: PUSH
42482: LD_INT 3
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: PPUSH
42495: CALL_OW 69
42499: ST_TO_ADDR
// if temp_list > 0 then
42500: LD_VAR 0 1
42504: PUSH
42505: LD_INT 0
42507: GREATER
42508: IFFALSE 42553
// begin CenterOnUnits ( temp_list ) ;
42510: LD_VAR 0 1
42514: PPUSH
42515: CALL_OW 85
// DialogueOn ;
42519: CALL_OW 6
// Say ( Dwayne , D2-Dw-1 ) ;
42523: LD_EXP 8
42527: PPUSH
42528: LD_STRING D2-Dw-1
42530: PPUSH
42531: CALL_OW 88
// Say ( Heike , D2-H-1 ) ;
42535: LD_EXP 7
42539: PPUSH
42540: LD_STRING D2-H-1
42542: PPUSH
42543: CALL_OW 88
// DialogueOff ;
42547: CALL_OW 7
// exit ;
42551: GO 42557
// end ; until false ;
42553: LD_INT 0
42555: IFFALSE 42410
// end ;
42557: PPOPN 1
42559: END
// every 0 0$1 + 0 0$0.1 do var i , driver_sex , temp_list , k , cargo_bay , path , name ; var vehicle , driver , path_east_west , path_west_east , countdown , chosen_path , path_index ;
42560: GO 42562
42562: DISABLE
42563: LD_INT 0
42565: PPUSH
42566: PPUSH
42567: PPUSH
42568: PPUSH
42569: PPUSH
42570: PPUSH
42571: PPUSH
42572: PPUSH
42573: PPUSH
42574: PPUSH
42575: PPUSH
42576: PPUSH
42577: PPUSH
42578: PPUSH
// begin vehicle = 0 ;
42579: LD_ADDR_VAR 0 8
42583: PUSH
42584: LD_INT 0
42586: ST_TO_ADDR
// driver = 0 ;
42587: LD_ADDR_VAR 0 9
42591: PUSH
42592: LD_INT 0
42594: ST_TO_ADDR
// path_east_west = [ [ 172 , 90 ] , [ 168 , 88 ] , [ 161 , 85 ] , [ 155 , 84 ] , [ 149 , 82 ] , [ 143 , 78 ] , [ 137 , 74 ] , [ 121 , 60 ] , [ 112 , 59 ] , [ 106 , 65 ] , [ 106 , 74 ] , [ 77 , 75 ] , [ 74 , 85 ] , [ 66 , 85 ] , [ 52 , 74 ] , [ 43 , 68 ] , [ 34 , 63 ] ] ;
42595: LD_ADDR_VAR 0 10
42599: PUSH
42600: LD_INT 172
42602: PUSH
42603: LD_INT 90
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: LD_INT 168
42612: PUSH
42613: LD_INT 88
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: LD_INT 161
42622: PUSH
42623: LD_INT 85
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 155
42632: PUSH
42633: LD_INT 84
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 149
42642: PUSH
42643: LD_INT 82
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 143
42652: PUSH
42653: LD_INT 78
42655: PUSH
42656: EMPTY
42657: LIST
42658: LIST
42659: PUSH
42660: LD_INT 137
42662: PUSH
42663: LD_INT 74
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: LD_INT 121
42672: PUSH
42673: LD_INT 60
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 112
42682: PUSH
42683: LD_INT 59
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 106
42692: PUSH
42693: LD_INT 65
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 106
42702: PUSH
42703: LD_INT 74
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 77
42712: PUSH
42713: LD_INT 75
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 74
42722: PUSH
42723: LD_INT 85
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 66
42732: PUSH
42733: LD_INT 85
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 52
42742: PUSH
42743: LD_INT 74
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: PUSH
42750: LD_INT 43
42752: PUSH
42753: LD_INT 68
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 34
42762: PUSH
42763: LD_INT 63
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: ST_TO_ADDR
// path_west_east = [ ] ;
42789: LD_ADDR_VAR 0 11
42793: PUSH
42794: EMPTY
42795: ST_TO_ADDR
// for i in path_east_west do
42796: LD_ADDR_VAR 0 1
42800: PUSH
42801: LD_VAR 0 10
42805: PUSH
42806: FOR_IN
42807: IFFALSE 42834
// path_west_east = Insert ( path_west_east , 1 , i ) ;
42809: LD_ADDR_VAR 0 11
42813: PUSH
42814: LD_VAR 0 11
42818: PPUSH
42819: LD_INT 1
42821: PPUSH
42822: LD_VAR 0 1
42826: PPUSH
42827: CALL_OW 2
42831: ST_TO_ADDR
42832: GO 42806
42834: POP
42835: POP
// path_east_west = Delete ( path_east_west , 1 ) ;
42836: LD_ADDR_VAR 0 10
42840: PUSH
42841: LD_VAR 0 10
42845: PPUSH
42846: LD_INT 1
42848: PPUSH
42849: CALL_OW 3
42853: ST_TO_ADDR
// path_west_east = Delete ( path_west_east , 1 ) ;
42854: LD_ADDR_VAR 0 11
42858: PUSH
42859: LD_VAR 0 11
42863: PPUSH
42864: LD_INT 1
42866: PPUSH
42867: CALL_OW 3
42871: ST_TO_ADDR
// chosen_path = [ ] ;
42872: LD_ADDR_VAR 0 13
42876: PUSH
42877: EMPTY
42878: ST_TO_ADDR
// path_index = 1 ;
42879: LD_ADDR_VAR 0 14
42883: PUSH
42884: LD_INT 1
42886: ST_TO_ADDR
// countdown = Rand ( 0 0$10 , 0 0$20 ) ;
42887: LD_ADDR_VAR 0 12
42891: PUSH
42892: LD_INT 350
42894: PPUSH
42895: LD_INT 700
42897: PPUSH
42898: CALL_OW 12
42902: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42903: LD_INT 35
42905: PPUSH
42906: CALL_OW 67
// if IsDead ( vehicle ) then
42910: LD_VAR 0 8
42914: PPUSH
42915: CALL_OW 301
42919: IFFALSE 42945
// begin in_out_russian_units = in_out_russian_units diff vehicle ;
42921: LD_ADDR_EXP 119
42925: PUSH
42926: LD_EXP 119
42930: PUSH
42931: LD_VAR 0 8
42935: DIFF
42936: ST_TO_ADDR
// vehicle = 0 ;
42937: LD_ADDR_VAR 0 8
42941: PUSH
42942: LD_INT 0
42944: ST_TO_ADDR
// end ; if IsDead ( driver ) then
42945: LD_VAR 0 9
42949: PPUSH
42950: CALL_OW 301
42954: IFFALSE 42997
// begin in_out_russian_units = in_out_russian_units diff [ driver , vehicle ] ;
42956: LD_ADDR_EXP 119
42960: PUSH
42961: LD_EXP 119
42965: PUSH
42966: LD_VAR 0 9
42970: PUSH
42971: LD_VAR 0 8
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: DIFF
42980: ST_TO_ADDR
// driver = 0 ;
42981: LD_ADDR_VAR 0 9
42985: PUSH
42986: LD_INT 0
42988: ST_TO_ADDR
// vehicle = 0 ;
42989: LD_ADDR_VAR 0 8
42993: PUSH
42994: LD_INT 0
42996: ST_TO_ADDR
// end ; if driver = 0 then
42997: LD_VAR 0 9
43001: PUSH
43002: LD_INT 0
43004: EQUAL
43005: IFFALSE 43678
// begin if countdown > 0 0$0 then
43007: LD_VAR 0 12
43011: PUSH
43012: LD_INT 0
43014: GREATER
43015: IFFALSE 43033
// begin countdown = countdown - 0 0$1 ;
43017: LD_ADDR_VAR 0 12
43021: PUSH
43022: LD_VAR 0 12
43026: PUSH
43027: LD_INT 35
43029: MINUS
43030: ST_TO_ADDR
// continue ;
43031: GO 42903
// end ; driver_sex = false ;
43033: LD_ADDR_VAR 0 2
43037: PUSH
43038: LD_INT 0
43040: ST_TO_ADDR
// name =  ;
43041: LD_ADDR_VAR 0 7
43045: PUSH
43046: LD_STRING 
43048: ST_TO_ADDR
// if heike_undercover in [ 0 , 1 ] then
43049: LD_EXP 83
43053: PUSH
43054: LD_INT 0
43056: PUSH
43057: LD_INT 1
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: IN
43064: IFFALSE 43092
// begin cargo_bay = true ;
43066: LD_ADDR_VAR 0 5
43070: PUSH
43071: LD_INT 1
43073: ST_TO_ADDR
// driver_sex = sex_female ;
43074: LD_ADDR_VAR 0 2
43078: PUSH
43079: LD_INT 2
43081: ST_TO_ADDR
// name =   ;
43082: LD_ADDR_VAR 0 7
43086: PUSH
43087: LD_STRING  
43089: ST_TO_ADDR
// end else
43090: GO 43126
// if Rand ( 1 , 2 ) = 1 then
43092: LD_INT 1
43094: PPUSH
43095: LD_INT 2
43097: PPUSH
43098: CALL_OW 12
43102: PUSH
43103: LD_INT 1
43105: EQUAL
43106: IFFALSE 43118
// cargo_bay = true else
43108: LD_ADDR_VAR 0 5
43112: PUSH
43113: LD_INT 1
43115: ST_TO_ADDR
43116: GO 43126
// cargo_bay = false ;
43118: LD_ADDR_VAR 0 5
43122: PUSH
43123: LD_INT 0
43125: ST_TO_ADDR
// vehicle = CreateRussianVehicle ( cargo_bay ) ;
43126: LD_ADDR_VAR 0 8
43130: PUSH
43131: LD_VAR 0 5
43135: PPUSH
43136: CALL 44266 0 1
43140: ST_TO_ADDR
// driver = CreateUnitsWithClass ( 1 , class_mechanic , driver_sex , name , russians_alt ) [ 1 ] ;
43141: LD_ADDR_VAR 0 9
43145: PUSH
43146: LD_INT 1
43148: PPUSH
43149: LD_INT 3
43151: PPUSH
43152: LD_VAR 0 2
43156: PPUSH
43157: LD_VAR 0 7
43161: PPUSH
43162: LD_EXP 6
43166: PPUSH
43167: CALL 7857 0 5
43171: PUSH
43172: LD_INT 1
43174: ARRAY
43175: ST_TO_ADDR
// path = Rand ( 1 , 2 ) ;
43176: LD_ADDR_VAR 0 6
43180: PUSH
43181: LD_INT 1
43183: PPUSH
43184: LD_INT 2
43186: PPUSH
43187: CALL_OW 12
43191: ST_TO_ADDR
// if path = 1 then
43192: LD_VAR 0 6
43196: PUSH
43197: LD_INT 1
43199: EQUAL
43200: IFFALSE 43214
// chosen_path = path_east_west else
43202: LD_ADDR_VAR 0 13
43206: PUSH
43207: LD_VAR 0 10
43211: ST_TO_ADDR
43212: GO 43224
// chosen_path = path_west_east ;
43214: LD_ADDR_VAR 0 13
43218: PUSH
43219: LD_VAR 0 11
43223: ST_TO_ADDR
// if cargo_bay then
43224: LD_VAR 0 5
43228: IFFALSE 43288
// if path = 1 then
43230: LD_VAR 0 6
43234: PUSH
43235: LD_INT 1
43237: EQUAL
43238: IFFALSE 43265
// cargo_bays_origin = Replace ( cargo_bays_origin , vehicle , 3 ) else
43240: LD_ADDR_EXP 102
43244: PUSH
43245: LD_EXP 102
43249: PPUSH
43250: LD_VAR 0 8
43254: PPUSH
43255: LD_INT 3
43257: PPUSH
43258: CALL_OW 1
43262: ST_TO_ADDR
43263: GO 43288
// cargo_bays_origin = Replace ( cargo_bays_origin , vehicle , 1 ) ;
43265: LD_ADDR_EXP 102
43269: PUSH
43270: LD_EXP 102
43274: PPUSH
43275: LD_VAR 0 8
43279: PPUSH
43280: LD_INT 1
43282: PPUSH
43283: CALL_OW 1
43287: ST_TO_ADDR
// if path = 1 then
43288: LD_VAR 0 6
43292: PUSH
43293: LD_INT 1
43295: EQUAL
43296: IFFALSE 43319
// temp_list = [ east1 , east2 , east3 ] else
43298: LD_ADDR_VAR 0 3
43302: PUSH
43303: LD_INT 4
43305: PUSH
43306: LD_INT 5
43308: PUSH
43309: LD_INT 6
43311: PUSH
43312: EMPTY
43313: LIST
43314: LIST
43315: LIST
43316: ST_TO_ADDR
43317: GO 43338
// temp_list = [ west1 , west2 , west3 ] ;
43319: LD_ADDR_VAR 0 3
43323: PUSH
43324: LD_INT 7
43326: PUSH
43327: LD_INT 8
43329: PUSH
43330: LD_INT 9
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: LIST
43337: ST_TO_ADDR
// for k = 4 to 9 do
43338: LD_ADDR_VAR 0 4
43342: PUSH
43343: DOUBLE
43344: LD_INT 4
43346: DEC
43347: ST_TO_ADDR
43348: LD_INT 9
43350: PUSH
43351: FOR_TO
43352: IFFALSE 43382
// temp_list = temp_list ^ temp_list [ k - 3 ] ;
43354: LD_ADDR_VAR 0 3
43358: PUSH
43359: LD_VAR 0 3
43363: PUSH
43364: LD_VAR 0 3
43368: PUSH
43369: LD_VAR 0 4
43373: PUSH
43374: LD_INT 3
43376: MINUS
43377: ARRAY
43378: ADD
43379: ST_TO_ADDR
43380: GO 43351
43382: POP
43383: POP
// for k = 1 to temp_list do
43384: LD_ADDR_VAR 0 4
43388: PUSH
43389: DOUBLE
43390: LD_INT 1
43392: DEC
43393: ST_TO_ADDR
43394: LD_VAR 0 3
43398: PUSH
43399: FOR_TO
43400: IFFALSE 43483
// begin if k > 1 then
43402: LD_VAR 0 4
43406: PUSH
43407: LD_INT 1
43409: GREATER
43410: IFFALSE 43434
// SetAreaMapShow ( temp_list [ k - 1 ] , 0 ) ;
43412: LD_VAR 0 3
43416: PUSH
43417: LD_VAR 0 4
43421: PUSH
43422: LD_INT 1
43424: MINUS
43425: ARRAY
43426: PPUSH
43427: LD_INT 0
43429: PPUSH
43430: CALL_OW 424
// if SeeArea ( you , temp_list [ k ] ) then
43434: LD_EXP 2
43438: PPUSH
43439: LD_VAR 0 3
43443: PUSH
43444: LD_VAR 0 4
43448: ARRAY
43449: PPUSH
43450: CALL_OW 294
43454: IFFALSE 43474
// SetAreaMapShow ( temp_list [ k ] , 3 ) ;
43456: LD_VAR 0 3
43460: PUSH
43461: LD_VAR 0 4
43465: ARRAY
43466: PPUSH
43467: LD_INT 3
43469: PPUSH
43470: CALL_OW 424
// wait ( 0 0$1 ) ;
43474: LD_INT 35
43476: PPUSH
43477: CALL_OW 67
// end ;
43481: GO 43399
43483: POP
43484: POP
// SetAreaMapShow ( temp_list [ temp_list + 0 ] , 0 ) ;
43485: LD_VAR 0 3
43489: PUSH
43490: LD_VAR 0 3
43494: PUSH
43495: LD_INT 0
43497: PLUS
43498: ARRAY
43499: PPUSH
43500: LD_INT 0
43502: PPUSH
43503: CALL_OW 424
// if path = 1 then
43507: LD_VAR 0 6
43511: PUSH
43512: LD_INT 1
43514: EQUAL
43515: IFFALSE 43539
// begin k = in_out_area_east ;
43517: LD_ADDR_VAR 0 4
43521: PUSH
43522: LD_INT 11
43524: ST_TO_ADDR
// SetDir ( vehicle , 4 ) ;
43525: LD_VAR 0 8
43529: PPUSH
43530: LD_INT 4
43532: PPUSH
43533: CALL_OW 233
// end else
43537: GO 43559
// begin k = in_out_area_west ;
43539: LD_ADDR_VAR 0 4
43543: PUSH
43544: LD_INT 10
43546: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
43547: LD_VAR 0 8
43551: PPUSH
43552: LD_INT 1
43554: PPUSH
43555: CALL_OW 233
// end ; PlaceHumanInUnit ( driver , vehicle ) ;
43559: LD_VAR 0 9
43563: PPUSH
43564: LD_VAR 0 8
43568: PPUSH
43569: CALL_OW 52
// while not PlaceUnitArea ( vehicle , k , false ) do
43573: LD_VAR 0 8
43577: PPUSH
43578: LD_VAR 0 4
43582: PPUSH
43583: LD_INT 0
43585: PPUSH
43586: CALL_OW 49
43590: NOT
43591: IFFALSE 43602
// wait ( 0 0$1 ) ;
43593: LD_INT 35
43595: PPUSH
43596: CALL_OW 67
43600: GO 43573
// in_out_russian_units = in_out_russian_units ^ [ driver , vehicle ] ;
43602: LD_ADDR_EXP 119
43606: PUSH
43607: LD_EXP 119
43611: PUSH
43612: LD_VAR 0 9
43616: PUSH
43617: LD_VAR 0 8
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: ADD
43626: ST_TO_ADDR
// if heike_undercover in [ 0 , 1 ] then
43627: LD_EXP 83
43631: PUSH
43632: LD_INT 0
43634: PUSH
43635: LD_INT 1
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: IN
43642: IFFALSE 43662
// countdown = Rand ( 0 0$10 , 0 0$20 ) else
43644: LD_ADDR_VAR 0 12
43648: PUSH
43649: LD_INT 350
43651: PPUSH
43652: LD_INT 700
43654: PPUSH
43655: CALL_OW 12
43659: ST_TO_ADDR
43660: GO 43678
// countdown = Rand ( 0 0$20 , 0 0$40 ) ;
43662: LD_ADDR_VAR 0 12
43666: PUSH
43667: LD_INT 700
43669: PPUSH
43670: LD_INT 1400
43672: PPUSH
43673: CALL_OW 12
43677: ST_TO_ADDR
// end ; k = false ;
43678: LD_ADDR_VAR 0 4
43682: PUSH
43683: LD_INT 0
43685: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , you ] ) do
43686: LD_ADDR_VAR 0 1
43690: PUSH
43691: LD_INT 22
43693: PUSH
43694: LD_EXP 2
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PPUSH
43703: CALL_OW 69
43707: PUSH
43708: FOR_IN
43709: IFFALSE 43749
// if Attacks ( i ) in [ vehicle , driver ] then
43711: LD_VAR 0 1
43715: PPUSH
43716: CALL_OW 320
43720: PUSH
43721: LD_VAR 0 8
43725: PUSH
43726: LD_VAR 0 9
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: IN
43735: IFFALSE 43747
// begin k = true ;
43737: LD_ADDR_VAR 0 4
43741: PUSH
43742: LD_INT 1
43744: ST_TO_ADDR
// break ;
43745: GO 43749
// end ;
43747: GO 43708
43749: POP
43750: POP
// if k then
43751: LD_VAR 0 4
43755: IFFALSE 43767
// i = 6 else
43757: LD_ADDR_VAR 0 1
43761: PUSH
43762: LD_INT 6
43764: ST_TO_ADDR
43765: GO 43775
// i = 2 ;
43767: LD_ADDR_VAR 0 1
43771: PUSH
43772: LD_INT 2
43774: ST_TO_ADDR
// if GetDistUnitXY ( driver , chosen_path [ path_index ] [ 1 ] , chosen_path [ path_index ] [ 2 ] ) <= i then
43775: LD_VAR 0 9
43779: PPUSH
43780: LD_VAR 0 13
43784: PUSH
43785: LD_VAR 0 14
43789: ARRAY
43790: PUSH
43791: LD_INT 1
43793: ARRAY
43794: PPUSH
43795: LD_VAR 0 13
43799: PUSH
43800: LD_VAR 0 14
43804: ARRAY
43805: PUSH
43806: LD_INT 2
43808: ARRAY
43809: PPUSH
43810: CALL_OW 297
43814: PUSH
43815: LD_VAR 0 1
43819: LESSEQUAL
43820: IFFALSE 43949
// begin path_index = path_index + 1 ;
43822: LD_ADDR_VAR 0 14
43826: PUSH
43827: LD_VAR 0 14
43831: PUSH
43832: LD_INT 1
43834: PLUS
43835: ST_TO_ADDR
// if path_index > chosen_path then
43836: LD_VAR 0 14
43840: PUSH
43841: LD_VAR 0 13
43845: GREATER
43846: IFFALSE 43949
// begin path_index = 1 ;
43848: LD_ADDR_VAR 0 14
43852: PUSH
43853: LD_INT 1
43855: ST_TO_ADDR
// k = IsInUnit ( driver ) ;
43856: LD_ADDR_VAR 0 4
43860: PUSH
43861: LD_VAR 0 9
43865: PPUSH
43866: CALL_OW 310
43870: ST_TO_ADDR
// in_out_russian_units = in_out_russian_units diff driver ;
43871: LD_ADDR_EXP 119
43875: PUSH
43876: LD_EXP 119
43880: PUSH
43881: LD_VAR 0 9
43885: DIFF
43886: ST_TO_ADDR
// DestroyUnit ( driver ) ;
43887: LD_VAR 0 9
43891: PPUSH
43892: CALL_OW 65
// if k > 0 then
43896: LD_VAR 0 4
43900: PUSH
43901: LD_INT 0
43903: GREATER
43904: IFFALSE 43931
// begin in_out_russian_units = in_out_russian_units diff k ;
43906: LD_ADDR_EXP 119
43910: PUSH
43911: LD_EXP 119
43915: PUSH
43916: LD_VAR 0 4
43920: DIFF
43921: ST_TO_ADDR
// DestroyUnit ( k ) ;
43922: LD_VAR 0 4
43926: PPUSH
43927: CALL_OW 65
// end ; driver = 0 ;
43931: LD_ADDR_VAR 0 9
43935: PUSH
43936: LD_INT 0
43938: ST_TO_ADDR
// vehicle = 0 ;
43939: LD_ADDR_VAR 0 8
43943: PUSH
43944: LD_INT 0
43946: ST_TO_ADDR
// continue ;
43947: GO 42903
// end ; end ; if not IsOk ( vehicle ) and IsLive ( vehicle ) then
43949: LD_VAR 0 8
43953: PPUSH
43954: CALL_OW 302
43958: NOT
43959: PUSH
43960: LD_VAR 0 8
43964: PPUSH
43965: CALL_OW 300
43969: AND
43970: IFFALSE 43988
// begin ComRepairVehicle ( driver , vehicle ) ;
43972: LD_VAR 0 9
43976: PPUSH
43977: LD_VAR 0 8
43981: PPUSH
43982: CALL_OW 129
// end else
43986: GO 44259
// if IsOk ( vehicle ) and IsInUnit ( driver ) <> vehicle then
43988: LD_VAR 0 8
43992: PPUSH
43993: CALL_OW 302
43997: PUSH
43998: LD_VAR 0 9
44002: PPUSH
44003: CALL_OW 310
44007: PUSH
44008: LD_VAR 0 8
44012: NONEQUAL
44013: AND
44014: IFFALSE 44088
// begin case GetType ( IsInUnit ( driver ) ) of unit_building :
44016: LD_VAR 0 9
44020: PPUSH
44021: CALL_OW 310
44025: PPUSH
44026: CALL_OW 247
44030: PUSH
44031: LD_INT 3
44033: DOUBLE
44034: EQUAL
44035: IFTRUE 44039
44037: GO 44051
44039: POP
// ComExitBuilding ( driver ) ; unit_vehicle :
44040: LD_VAR 0 9
44044: PPUSH
44045: CALL_OW 122
44049: GO 44086
44051: LD_INT 2
44053: DOUBLE
44054: EQUAL
44055: IFTRUE 44059
44057: GO 44071
44059: POP
// ComExitVehicle ( driver ) ; else
44060: LD_VAR 0 9
44064: PPUSH
44065: CALL_OW 121
44069: GO 44086
44071: POP
// ComEnterUnit ( driver , vehicle ) ; end ;
44072: LD_VAR 0 9
44076: PPUSH
44077: LD_VAR 0 8
44081: PPUSH
44082: CALL_OW 120
// end else
44086: GO 44259
// if IsInUnit ( driver ) = vehicle and IsOk ( vehicle ) then
44088: LD_VAR 0 9
44092: PPUSH
44093: CALL_OW 310
44097: PUSH
44098: LD_VAR 0 8
44102: EQUAL
44103: PUSH
44104: LD_VAR 0 8
44108: PPUSH
44109: CALL_OW 302
44113: AND
44114: IFFALSE 44220
// begin ComAgressiveMove ( vehicle , chosen_path [ path_index ] [ 1 ] , chosen_path [ path_index ] [ 2 ] ) ;
44116: LD_VAR 0 8
44120: PPUSH
44121: LD_VAR 0 13
44125: PUSH
44126: LD_VAR 0 14
44130: ARRAY
44131: PUSH
44132: LD_INT 1
44134: ARRAY
44135: PPUSH
44136: LD_VAR 0 13
44140: PUSH
44141: LD_VAR 0 14
44145: ARRAY
44146: PUSH
44147: LD_INT 2
44149: ARRAY
44150: PPUSH
44151: CALL_OW 114
// if path_index + 1 <= chosen_path then
44155: LD_VAR 0 14
44159: PUSH
44160: LD_INT 1
44162: PLUS
44163: PUSH
44164: LD_VAR 0 13
44168: LESSEQUAL
44169: IFFALSE 44218
// AddComAgressiveMove ( vehicle , chosen_path [ path_index + 1 ] [ 1 ] , chosen_path [ path_index + 1 ] [ 2 ] ) ;
44171: LD_VAR 0 8
44175: PPUSH
44176: LD_VAR 0 13
44180: PUSH
44181: LD_VAR 0 14
44185: PUSH
44186: LD_INT 1
44188: PLUS
44189: ARRAY
44190: PUSH
44191: LD_INT 1
44193: ARRAY
44194: PPUSH
44195: LD_VAR 0 13
44199: PUSH
44200: LD_VAR 0 14
44204: PUSH
44205: LD_INT 1
44207: PLUS
44208: ARRAY
44209: PUSH
44210: LD_INT 2
44212: ARRAY
44213: PPUSH
44214: CALL_OW 174
// end else
44218: GO 44259
// ComMoveXY ( driver , chosen_path [ path_index ] [ 1 ] , chosen_path [ path_index ] [ 2 ] ) ;
44220: LD_VAR 0 9
44224: PPUSH
44225: LD_VAR 0 13
44229: PUSH
44230: LD_VAR 0 14
44234: ARRAY
44235: PUSH
44236: LD_INT 1
44238: ARRAY
44239: PPUSH
44240: LD_VAR 0 13
44244: PUSH
44245: LD_VAR 0 14
44249: ARRAY
44250: PUSH
44251: LD_INT 2
44253: ARRAY
44254: PPUSH
44255: CALL_OW 111
// until false ;
44259: LD_INT 0
44261: IFFALSE 42903
// end ;
44263: PPOPN 14
44265: END
// function CreateRussianVehicle ( cargo_bay_boolean ) ; begin
44266: LD_INT 0
44268: PPUSH
// uc_side = russians_alt ;
44269: LD_ADDR_OWVAR 20
44273: PUSH
44274: LD_EXP 6
44278: ST_TO_ADDR
// uc_nation = nation_russian ;
44279: LD_ADDR_OWVAR 21
44283: PUSH
44284: LD_INT 3
44286: ST_TO_ADDR
// vc_engine = engine_siberite ;
44287: LD_ADDR_OWVAR 39
44291: PUSH
44292: LD_INT 3
44294: ST_TO_ADDR
// vc_control = control_manual ;
44295: LD_ADDR_OWVAR 38
44299: PUSH
44300: LD_INT 1
44302: ST_TO_ADDR
// vc_chassis = ru_medium_wheeled ;
44303: LD_ADDR_OWVAR 37
44307: PUSH
44308: LD_INT 21
44310: ST_TO_ADDR
// if cargo_bay_boolean then
44311: LD_VAR 0 1
44315: IFFALSE 44327
// vc_weapon = ru_cargo_bay else
44317: LD_ADDR_OWVAR 40
44321: PUSH
44322: LD_INT 51
44324: ST_TO_ADDR
44325: GO 44393
// if Rand ( 1 , 3 ) = 1 then
44327: LD_INT 1
44329: PPUSH
44330: LD_INT 3
44332: PPUSH
44333: CALL_OW 12
44337: PUSH
44338: LD_INT 1
44340: EQUAL
44341: IFFALSE 44385
// begin if Rand ( 1 , 1 + difficulty ) = 1 then
44343: LD_INT 1
44345: PPUSH
44346: LD_INT 1
44348: PUSH
44349: LD_OWVAR 67
44353: PLUS
44354: PPUSH
44355: CALL_OW 12
44359: PUSH
44360: LD_INT 1
44362: EQUAL
44363: IFFALSE 44375
// vc_weapon = ru_heavy_machine_gun else
44365: LD_ADDR_OWVAR 40
44369: PUSH
44370: LD_INT 42
44372: ST_TO_ADDR
44373: GO 44383
// vc_weapon = ru_gatling_gun ;
44375: LD_ADDR_OWVAR 40
44379: PUSH
44380: LD_INT 43
44382: ST_TO_ADDR
// end else
44383: GO 44393
// vc_weapon = ru_gun ;
44385: LD_ADDR_OWVAR 40
44389: PUSH
44390: LD_INT 44
44392: ST_TO_ADDR
// result = CreateVehicle ;
44393: LD_ADDR_VAR 0 2
44397: PUSH
44398: CALL_OW 45
44402: ST_TO_ADDR
// end ;
44403: LD_VAR 0 2
44407: RET
// every 0 0$1 + 0 0$0.6 do var temp_unit ; var cargo_bay_has_been_captured , old_Heike ;
44408: GO 44410
44410: DISABLE
44411: LD_INT 0
44413: PPUSH
44414: PPUSH
44415: PPUSH
// begin cargo_bay_has_been_captured = false ;
44416: LD_ADDR_VAR 0 2
44420: PUSH
44421: LD_INT 0
44423: ST_TO_ADDR
// repeat wait ( 0 0$0.5 ) ;
44424: LD_INT 18
44426: PPUSH
44427: CALL_OW 67
// if not cargo_bay_has_been_captured then
44431: LD_VAR 0 2
44435: NOT
44436: IFFALSE 44722
// begin if IsDead ( the_cargo_bay_captured ) then
44438: LD_EXP 98
44442: PPUSH
44443: CALL_OW 301
44447: IFFALSE 44457
// the_cargo_bay_captured = 0 ;
44449: LD_ADDR_EXP 98
44453: PUSH
44454: LD_INT 0
44456: ST_TO_ADDR
// if the_cargo_bay_captured = 0 then
44457: LD_EXP 98
44461: PUSH
44462: LD_INT 0
44464: EQUAL
44465: IFFALSE 44469
// continue ;
44467: GO 44424
// if not IsOk ( the_cargo_bay_captured ) then
44469: LD_EXP 98
44473: PPUSH
44474: CALL_OW 302
44478: NOT
44479: IFFALSE 44483
// continue ;
44481: GO 44424
// cargo_bay_has_been_captured = true ;
44483: LD_ADDR_VAR 0 2
44487: PUSH
44488: LD_INT 1
44490: ST_TO_ADDR
// DialogueOn ;
44491: CALL_OW 6
// Say ( Dwayne , D3-Dw-1 ) ;
44495: LD_EXP 8
44499: PPUSH
44500: LD_STRING D3-Dw-1
44502: PPUSH
44503: CALL_OW 88
// Say ( Heike , D3-H-1 ) ;
44507: LD_EXP 7
44511: PPUSH
44512: LD_STRING D3-H-1
44514: PPUSH
44515: CALL_OW 88
// if IsOk ( Kurt ) and not kurt_is_substitute then
44519: LD_EXP 10
44523: PPUSH
44524: CALL_OW 302
44528: PUSH
44529: LD_EXP 71
44533: NOT
44534: AND
44535: IFFALSE 44575
// begin Say ( Kurt , D3-Ku-1a ) ;
44537: LD_EXP 10
44541: PPUSH
44542: LD_STRING D3-Ku-1a
44544: PPUSH
44545: CALL_OW 88
// Say ( Heike , D3-H-2a ) ;
44549: LD_EXP 7
44553: PPUSH
44554: LD_STRING D3-H-2a
44556: PPUSH
44557: CALL_OW 88
// Say ( Kurt , D3-Ku-2a ) ;
44561: LD_EXP 10
44565: PPUSH
44566: LD_STRING D3-Ku-2a
44568: PPUSH
44569: CALL_OW 88
// end else
44573: GO 44643
// begin Say ( Dwayne , D3-Dw-2b ) ;
44575: LD_EXP 8
44579: PPUSH
44580: LD_STRING D3-Dw-2b
44582: PPUSH
44583: CALL_OW 88
// Say ( Heike , D3-H-2b ) ;
44587: LD_EXP 7
44591: PPUSH
44592: LD_STRING D3-H-2b
44594: PPUSH
44595: CALL_OW 88
// if oswald_is_substitute then
44599: LD_EXP 70
44603: IFFALSE 44619
// Say ( Oswald , D3-Os_sub-1b ) else
44605: LD_EXP 9
44609: PPUSH
44610: LD_STRING D3-Os_sub-1b
44612: PPUSH
44613: CALL_OW 88
44617: GO 44631
// Say ( Oswald , D3-Os-1b ) ;
44619: LD_EXP 9
44623: PPUSH
44624: LD_STRING D3-Os-1b
44626: PPUSH
44627: CALL_OW 88
// Say ( Kurt , D3-Ku_sub-1b ) ;
44631: LD_EXP 10
44635: PPUSH
44636: LD_STRING D3-Ku_sub-1b
44638: PPUSH
44639: CALL_OW 88
// end ; Say ( Heike , D3-H-3 ) ;
44643: LD_EXP 7
44647: PPUSH
44648: LD_STRING D3-H-3
44650: PPUSH
44651: CALL_OW 88
// Say ( Heike , D3-H-4 ) ;
44655: LD_EXP 7
44659: PPUSH
44660: LD_STRING D3-H-4
44662: PPUSH
44663: CALL_OW 88
// DialogueOff ;
44667: CALL_OW 7
// wait ( 0 0$0.2 ) ;
44671: LD_INT 7
44673: PPUSH
44674: CALL_OW 67
// ChangeMissionObjectives ( MAddSabotage ) ;
44678: LD_STRING MAddSabotage
44680: PPUSH
44681: CALL_OW 337
// if difficulty < 3 then
44685: LD_OWVAR 67
44689: PUSH
44690: LD_INT 3
44692: LESS
44693: IFFALSE 44703
// start_display_guards_distracted_hint = true ;
44695: LD_ADDR_EXP 125
44699: PUSH
44700: LD_INT 1
44702: ST_TO_ADDR
// if num_sabotaged_cargo_bays >= 3 then
44703: LD_EXP 121
44707: PUSH
44708: LD_INT 3
44710: GREATEREQUAL
44711: IFFALSE 44720
// ChangeMissionObjectives ( MOutSabotage ) ;
44713: LD_STRING MOutSabotage
44715: PPUSH
44716: CALL_OW 337
// end else
44720: GO 45091
// begin temp_unit = IsInUnit ( Heike ) ;
44722: LD_ADDR_VAR 0 1
44726: PUSH
44727: LD_EXP 7
44731: PPUSH
44732: CALL_OW 310
44736: ST_TO_ADDR
// if temp_unit > 0 and GetType ( temp_unit ) = unit_vehicle and GetWeapon ( temp_unit ) = ru_cargo_bay then
44737: LD_VAR 0 1
44741: PUSH
44742: LD_INT 0
44744: GREATER
44745: PUSH
44746: LD_VAR 0 1
44750: PPUSH
44751: CALL_OW 247
44755: PUSH
44756: LD_INT 2
44758: EQUAL
44759: AND
44760: PUSH
44761: LD_VAR 0 1
44765: PPUSH
44766: CALL_OW 264
44770: PUSH
44771: LD_INT 51
44773: EQUAL
44774: AND
44775: IFFALSE 45091
// begin RemoveMineOfUnit ( Heike ) ;
44777: LD_EXP 7
44781: PPUSH
44782: CALL_OW 460
// PrepareNewCharacter ( Heike ) ;
44786: LD_STRING Heike
44788: PPUSH
44789: CALL_OW 26
// uc_side = you ;
44793: LD_ADDR_OWVAR 20
44797: PUSH
44798: LD_EXP 2
44802: ST_TO_ADDR
// uc_nation = nation_russian ;
44803: LD_ADDR_OWVAR 21
44807: PUSH
44808: LD_INT 3
44810: ST_TO_ADDR
// hc_class = class_mechanic ;
44811: LD_ADDR_OWVAR 28
44815: PUSH
44816: LD_INT 3
44818: ST_TO_ADDR
// old_Heike = Heike ;
44819: LD_ADDR_VAR 0 3
44823: PUSH
44824: LD_EXP 7
44828: ST_TO_ADDR
// Heike = CreateHuman ;
44829: LD_ADDR_EXP 7
44833: PUSH
44834: CALL_OW 44
44838: ST_TO_ADDR
// hc_importance = 0 ;
44839: LD_ADDR_OWVAR 32
44843: PUSH
44844: LD_INT 0
44846: ST_TO_ADDR
// CopySkills ( old_Heike , Heike ) ;
44847: LD_VAR 0 3
44851: PPUSH
44852: LD_EXP 7
44856: PPUSH
44857: CALL_OW 510
// RemoveUnit ( old_Heike ) ;
44861: LD_VAR 0 3
44865: PPUSH
44866: CALL_OW 64
// PlaceHumanInUnit ( Heike , temp_unit ) ;
44870: LD_EXP 7
44874: PPUSH
44875: LD_VAR 0 1
44879: PPUSH
44880: CALL_OW 52
// SetLives ( Heike , GetLives ( old_Heike ) ) ;
44884: LD_EXP 7
44888: PPUSH
44889: LD_VAR 0 3
44893: PPUSH
44894: CALL_OW 256
44898: PPUSH
44899: CALL_OW 234
// DialogueOn ;
44903: CALL_OW 6
// Say ( Dwayne , D4-Dw-1 ) ;
44907: LD_EXP 8
44911: PPUSH
44912: LD_STRING D4-Dw-1
44914: PPUSH
44915: CALL_OW 88
// Say ( Heike , D4-H-1 ) ;
44919: LD_EXP 7
44923: PPUSH
44924: LD_STRING D4-H-1
44926: PPUSH
44927: CALL_OW 88
// SayNoName ( Yakov , D4-boyfriend-1 ) ;
44931: LD_EXP 15
44935: PPUSH
44936: LD_STRING D4-boyfriend-1
44938: PPUSH
44939: CALL_OW 90
// if IsOk ( Oswald ) and not oswald_is_substitute then
44943: LD_EXP 9
44947: PPUSH
44948: CALL_OW 302
44952: PUSH
44953: LD_EXP 70
44957: NOT
44958: AND
44959: IFFALSE 44999
// begin Say ( Oswald , D4-Os-1a ) ;
44961: LD_EXP 9
44965: PPUSH
44966: LD_STRING D4-Os-1a
44968: PPUSH
44969: CALL_OW 88
// Say ( Heike , D4-H-2 ) ;
44973: LD_EXP 7
44977: PPUSH
44978: LD_STRING D4-H-2
44980: PPUSH
44981: CALL_OW 88
// Say ( Oswald , D4-Os-2a ) ;
44985: LD_EXP 9
44989: PPUSH
44990: LD_STRING D4-Os-2a
44992: PPUSH
44993: CALL_OW 88
// end else
44997: GO 45047
// begin Say ( Dwayne , D4-Dw-2b ) ;
44999: LD_EXP 8
45003: PPUSH
45004: LD_STRING D4-Dw-2b
45006: PPUSH
45007: CALL_OW 88
// Say ( Heike , D4-H-2 ) ;
45011: LD_EXP 7
45015: PPUSH
45016: LD_STRING D4-H-2
45018: PPUSH
45019: CALL_OW 88
// Say ( Dwayne , D4-Dw-3b ) ;
45023: LD_EXP 8
45027: PPUSH
45028: LD_STRING D4-Dw-3b
45030: PPUSH
45031: CALL_OW 88
// Say ( Heike , D4-H-3b ) ;
45035: LD_EXP 7
45039: PPUSH
45040: LD_STRING D4-H-3b
45042: PPUSH
45043: CALL_OW 88
// end ; Say ( Dwayne , D4-Dw-4 ) ;
45047: LD_EXP 8
45051: PPUSH
45052: LD_STRING D4-Dw-4
45054: PPUSH
45055: CALL_OW 88
// DialogueOff ;
45059: CALL_OW 7
// if heike_undercover = 0 then
45063: LD_EXP 83
45067: PUSH
45068: LD_INT 0
45070: EQUAL
45071: IFFALSE 45082
// ChangeHeikeUndercoverStatus ( 2 ) else
45073: LD_INT 2
45075: PPUSH
45076: CALL 42004 0 1
45080: GO 45089
// ChangeHeikeUndercoverStatus ( 3 ) ;
45082: LD_INT 3
45084: PPUSH
45085: CALL 42004 0 1
// exit ;
45089: GO 45095
// end ; end ; until false ;
45091: LD_INT 0
45093: IFFALSE 44424
// end ;
45095: PPOPN 3
45097: END
// every 0 0$1 + 0 0$0.5 trigger start_display_guards_distracted_hint do
45098: LD_EXP 125
45102: IFFALSE 45180
45104: GO 45106
45106: DISABLE
// begin repeat wait ( 0 0$1 ) ;
45107: LD_INT 35
45109: PPUSH
45110: CALL_OW 67
// DeleteDisplayStrings ( #Ar09-ArchiveGuardsDistractedY ) ;
45114: LD_STRING #Ar09-ArchiveGuardsDistractedY
45116: PPUSH
45117: CALL 34489 0 1
// DeleteDisplayStrings ( #Ar09-ArchiveGuardsDistractedN ) ;
45121: LD_STRING #Ar09-ArchiveGuardsDistractedN
45123: PPUSH
45124: CALL 34489 0 1
// if ArchiveGuardsDistracted then
45128: CALL 45181 0 0
45132: IFFALSE 45145
// AddOrUpdateDisplayStrings ( #Ar09-ArchiveGuardsDistractedY , [ ] ) else
45134: LD_STRING #Ar09-ArchiveGuardsDistractedY
45136: PPUSH
45137: EMPTY
45138: PPUSH
45139: CALL 34320 0 2
45143: GO 45154
// AddOrUpdateDisplayStrings ( #Ar09-ArchiveGuardsDistractedN , [ ] ) ;
45145: LD_STRING #Ar09-ArchiveGuardsDistractedN
45147: PPUSH
45148: EMPTY
45149: PPUSH
45150: CALL 34320 0 2
// until num_documents_stolen = max_num_documents_stealable ;
45154: LD_EXP 99
45158: PUSH
45159: LD_EXP 126
45163: EQUAL
45164: IFFALSE 45107
// DeleteDisplayStrings ( #Ar09-ArchiveGuardsDistractedY ) ;
45166: LD_STRING #Ar09-ArchiveGuardsDistractedY
45168: PPUSH
45169: CALL 34489 0 1
// DeleteDisplayStrings ( #Ar09-ArchiveGuardsDistractedN ) ;
45173: LD_STRING #Ar09-ArchiveGuardsDistractedN
45175: PPUSH
45176: CALL 34489 0 1
// end ;
45180: END
// function ArchiveGuardsDistracted ; begin
45181: LD_INT 0
45183: PPUSH
// result = false ;
45184: LD_ADDR_VAR 0 1
45188: PUSH
45189: LD_INT 0
45191: ST_TO_ADDR
// case difficulty of 1 :
45192: LD_OWVAR 67
45196: PUSH
45197: LD_INT 1
45199: DOUBLE
45200: EQUAL
45201: IFTRUE 45205
45203: GO 45238
45205: POP
// begin if ( code_red or code_black ) and heike_undercover = 2 then
45206: LD_EXP 76
45210: PUSH
45211: LD_EXP 77
45215: OR
45216: PUSH
45217: LD_EXP 83
45221: PUSH
45222: LD_INT 2
45224: EQUAL
45225: AND
45226: IFFALSE 45236
// result = true ;
45228: LD_ADDR_VAR 0 1
45232: PUSH
45233: LD_INT 1
45235: ST_TO_ADDR
// end ; 2 :
45236: GO 45285
45238: LD_INT 2
45240: DOUBLE
45241: EQUAL
45242: IFTRUE 45246
45244: GO 45273
45246: POP
// begin if code_black and heike_undercover = 2 then
45247: LD_EXP 77
45251: PUSH
45252: LD_EXP 83
45256: PUSH
45257: LD_INT 2
45259: EQUAL
45260: AND
45261: IFFALSE 45271
// result = true ;
45263: LD_ADDR_VAR 0 1
45267: PUSH
45268: LD_INT 1
45270: ST_TO_ADDR
// end ; 3 :
45271: GO 45285
45273: LD_INT 3
45275: DOUBLE
45276: EQUAL
45277: IFTRUE 45281
45279: GO 45284
45281: POP
// begin end ; end ;
45282: GO 45285
45284: POP
// end ;
45285: LD_VAR 0 1
45289: RET
// every 0 0$1 + 0 0$0.4 do var veh , un ;
45290: GO 45292
45292: DISABLE
45293: LD_INT 0
45295: PPUSH
45296: PPUSH
// begin repeat wait ( 0 0$0.5 ) ;
45297: LD_INT 18
45299: PPUSH
45300: CALL_OW 67
// if heike_undercover_entered_war_vehicle then
45304: LD_EXP 91
45308: IFFALSE 45312
// exit ;
45310: GO 45492
// if heike_undercover in [ 0 , 1 ] then
45312: LD_EXP 83
45316: PUSH
45317: LD_INT 0
45319: PUSH
45320: LD_INT 1
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: IN
45327: IFFALSE 45333
// continue else
45329: GO 45297
45331: GO 45345
// if heike_undercover = 4 then
45333: LD_EXP 83
45337: PUSH
45338: LD_INT 4
45340: EQUAL
45341: IFFALSE 45345
// exit ;
45343: GO 45492
// veh = IsInUnit ( Heike ) ;
45345: LD_ADDR_VAR 0 1
45349: PUSH
45350: LD_EXP 7
45354: PPUSH
45355: CALL_OW 310
45359: ST_TO_ADDR
// if veh > 0 and GetType ( veh ) = unit_vehicle and GetWeapon ( veh ) <> ru_cargo_bay then
45360: LD_VAR 0 1
45364: PUSH
45365: LD_INT 0
45367: GREATER
45368: PUSH
45369: LD_VAR 0 1
45373: PPUSH
45374: CALL_OW 247
45378: PUSH
45379: LD_INT 2
45381: EQUAL
45382: AND
45383: PUSH
45384: LD_VAR 0 1
45388: PPUSH
45389: CALL_OW 264
45393: PUSH
45394: LD_INT 51
45396: NONEQUAL
45397: AND
45398: IFFALSE 45488
// begin for un in FilterAllUnits ( [ f_side , russians ] ) do
45400: LD_ADDR_VAR 0 2
45404: PUSH
45405: LD_INT 22
45407: PUSH
45408: LD_EXP 3
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: PPUSH
45417: CALL_OW 69
45421: PUSH
45422: FOR_IN
45423: IFFALSE 45455
// if Attacks ( un ) = veh then
45425: LD_VAR 0 2
45429: PPUSH
45430: CALL_OW 320
45434: PUSH
45435: LD_VAR 0 1
45439: EQUAL
45440: IFFALSE 45453
// begin ChangeHeikeUndercoverStatus ( 4 ) ;
45442: LD_INT 4
45444: PPUSH
45445: CALL 42004 0 1
// exit ;
45449: POP
45450: POP
45451: GO 45492
// end ;
45453: GO 45422
45455: POP
45456: POP
// if GetSide ( Attacks ( veh ) ) = russians then
45457: LD_VAR 0 1
45461: PPUSH
45462: CALL_OW 320
45466: PPUSH
45467: CALL_OW 255
45471: PUSH
45472: LD_EXP 3
45476: EQUAL
45477: IFFALSE 45488
// begin ChangeHeikeUndercoverStatus ( 4 ) ;
45479: LD_INT 4
45481: PPUSH
45482: CALL 42004 0 1
// exit ;
45486: GO 45492
// end ; end ; until false ;
45488: LD_INT 0
45490: IFFALSE 45297
// end ;
45492: PPOPN 2
45494: END
// every 0 0$1 + 0 0$0.3 do var i , un , temp_list ;
45495: GO 45497
45497: DISABLE
45498: LD_INT 0
45500: PPUSH
45501: PPUSH
45502: PPUSH
// begin repeat wait ( 0 0$0.5 ) ;
45503: LD_INT 18
45505: PPUSH
45506: CALL_OW 67
// if heike_undercover = 4 then
45510: LD_EXP 83
45514: PUSH
45515: LD_INT 4
45517: EQUAL
45518: IFFALSE 45522
// exit ;
45520: GO 45663
// if heike_undercover in [ 0 , 1 ] then
45522: LD_EXP 83
45526: PUSH
45527: LD_INT 0
45529: PUSH
45530: LD_INT 1
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: IN
45537: IFFALSE 45541
// continue ;
45539: GO 45503
// un = Attacks ( Heike ) ;
45541: LD_ADDR_VAR 0 2
45545: PUSH
45546: LD_EXP 7
45550: PPUSH
45551: CALL_OW 320
45555: ST_TO_ADDR
// if un > 0 then
45556: LD_VAR 0 2
45560: PUSH
45561: LD_INT 0
45563: GREATER
45564: IFFALSE 45659
// begin temp_list = [ ] ;
45566: LD_ADDR_VAR 0 3
45570: PUSH
45571: EMPTY
45572: ST_TO_ADDR
// for i in patrols do
45573: LD_ADDR_VAR 0 1
45577: PUSH
45578: LD_EXP 78
45582: PUSH
45583: FOR_IN
45584: IFFALSE 45604
// temp_list = temp_list ^ i ;
45586: LD_ADDR_VAR 0 3
45590: PUSH
45591: LD_VAR 0 3
45595: PUSH
45596: LD_VAR 0 1
45600: ADD
45601: ST_TO_ADDR
45602: GO 45583
45604: POP
45605: POP
// temp_list = UnitFilter ( temp_list , [ f_not , [ f_inarea , ru_base_area ] ] ) ;
45606: LD_ADDR_VAR 0 3
45610: PUSH
45611: LD_VAR 0 3
45615: PPUSH
45616: LD_INT 3
45618: PUSH
45619: LD_INT 95
45621: PUSH
45622: LD_INT 2
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PPUSH
45633: CALL_OW 72
45637: ST_TO_ADDR
// if un in temp_list then
45638: LD_VAR 0 2
45642: PUSH
45643: LD_VAR 0 3
45647: IN
45648: IFFALSE 45659
// begin ChangeHeikeUndercoverStatus ( 4 ) ;
45650: LD_INT 4
45652: PPUSH
45653: CALL 42004 0 1
// exit ;
45657: GO 45663
// end ; end ; until false ;
45659: LD_INT 0
45661: IFFALSE 45503
// end ;
45663: PPOPN 3
45665: END
// every 0 0$1 + 0 0$0.5 do var val ;
45666: GO 45668
45668: DISABLE
45669: LD_INT 0
45671: PPUSH
// begin repeat wait ( 0 0$1 ) ;
45672: LD_INT 35
45674: PPUSH
45675: CALL_OW 67
// if heike_undercover = 4 then
45679: LD_EXP 83
45683: PUSH
45684: LD_INT 4
45686: EQUAL
45687: IFFALSE 45691
// exit ;
45689: GO 45828
// if heike_undercover in [ 0 , 1 ] then
45691: LD_EXP 83
45695: PUSH
45696: LD_INT 0
45698: PUSH
45699: LD_INT 1
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: IN
45706: IFFALSE 45710
// continue ;
45708: GO 45672
// wait ( 1 1$30 ) ;
45710: LD_INT 3150
45712: PPUSH
45713: CALL_OW 67
// if not entrance_guard_dialogue_started and heike_undercover in [ 2 , 3 ] then
45717: LD_EXP 120
45721: NOT
45722: PUSH
45723: LD_EXP 83
45727: PUSH
45728: LD_INT 2
45730: PUSH
45731: LD_INT 3
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: IN
45738: AND
45739: IFFALSE 45822
// begin val = a ;
45741: LD_ADDR_VAR 0 1
45745: PUSH
45746: LD_STRING a
45748: ST_TO_ADDR
// if cargo_bays_origin >= the_cargo_bay_captured then
45749: LD_EXP 102
45753: PUSH
45754: LD_EXP 98
45758: GREATEREQUAL
45759: IFFALSE 45785
// if cargo_bays_origin [ the_cargo_bay_captured ] = 3 then
45761: LD_EXP 102
45765: PUSH
45766: LD_EXP 98
45770: ARRAY
45771: PUSH
45772: LD_INT 3
45774: EQUAL
45775: IFFALSE 45785
// val = b ;
45777: LD_ADDR_VAR 0 1
45781: PUSH
45782: LD_STRING b
45784: ST_TO_ADDR
// DialogueOn ;
45785: CALL_OW 6
// SayRadio ( Yefibachev , D23- & val & -Leader-1 ) ;
45789: LD_EXP 14
45793: PPUSH
45794: LD_STRING D23-
45796: PUSH
45797: LD_VAR 0 1
45801: STR
45802: PUSH
45803: LD_STRING -Leader-1
45805: STR
45806: PPUSH
45807: CALL_OW 94
// DialogueOff ;
45811: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
45815: LD_INT 4
45817: PPUSH
45818: CALL 42004 0 1
// end ; exit ;
45822: GO 45828
// until false ;
45824: LD_INT 0
45826: IFFALSE 45672
// end ;
45828: PPOPN 1
45830: END
// every 0 0$1 + 0 0$0.1 do var stu , other_guard , temp_list , i , vehicle ;
45831: GO 45833
45833: DISABLE
45834: LD_INT 0
45836: PPUSH
45837: PPUSH
45838: PPUSH
45839: PPUSH
45840: PPUSH
// begin repeat wait ( 0 0$0.5 ) ;
45841: LD_INT 18
45843: PPUSH
45844: CALL_OW 67
// if heike_undercover = 0 then
45848: LD_EXP 83
45852: PUSH
45853: LD_INT 0
45855: EQUAL
45856: IFFALSE 45862
// continue else
45858: GO 45841
45860: GO 45885
// if heike_undercover in [ 1 , 3 , 4 ] then
45862: LD_EXP 83
45866: PUSH
45867: LD_INT 1
45869: PUSH
45870: LD_INT 3
45872: PUSH
45873: LD_INT 4
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: LIST
45880: IN
45881: IFFALSE 45885
// exit ;
45883: GO 46877
// vehicle = IsInUnit ( Heike ) ;
45885: LD_ADDR_VAR 0 5
45889: PUSH
45890: LD_EXP 7
45894: PPUSH
45895: CALL_OW 310
45899: ST_TO_ADDR
// if GetWeapon ( vehicle ) = ru_cargo_bay and GetDistUnitXY ( Heike , 75 , 64 ) <= 3 then
45900: LD_VAR 0 5
45904: PPUSH
45905: CALL_OW 264
45909: PUSH
45910: LD_INT 51
45912: EQUAL
45913: PUSH
45914: LD_EXP 7
45918: PPUSH
45919: LD_INT 75
45921: PPUSH
45922: LD_INT 64
45924: PPUSH
45925: CALL_OW 297
45929: PUSH
45930: LD_INT 3
45932: LESSEQUAL
45933: AND
45934: IFFALSE 46873
// begin entrance_guard_dialogue_started = true ;
45936: LD_ADDR_EXP 120
45940: PUSH
45941: LD_INT 1
45943: ST_TO_ADDR
// temp_list = [ ] ;
45944: LD_ADDR_VAR 0 3
45948: PUSH
45949: EMPTY
45950: ST_TO_ADDR
// for i in ai_bunkers [ 1 ] do
45951: LD_ADDR_VAR 0 4
45955: PUSH
45956: LD_EXP 49
45960: PUSH
45961: LD_INT 1
45963: ARRAY
45964: PUSH
45965: FOR_IN
45966: IFFALSE 45991
// temp_list = temp_list ^ UnitsInside ( i ) ;
45968: LD_ADDR_VAR 0 3
45972: PUSH
45973: LD_VAR 0 3
45977: PUSH
45978: LD_VAR 0 4
45982: PPUSH
45983: CALL_OW 313
45987: ADD
45988: ST_TO_ADDR
45989: GO 45965
45991: POP
45992: POP
// stu = 0 ;
45993: LD_ADDR_VAR 0 1
45997: PUSH
45998: LD_INT 0
46000: ST_TO_ADDR
// other_guard = 0 ;
46001: LD_ADDR_VAR 0 2
46005: PUSH
46006: LD_INT 0
46008: ST_TO_ADDR
// for i in temp_list do
46009: LD_ADDR_VAR 0 4
46013: PUSH
46014: LD_VAR 0 3
46018: PUSH
46019: FOR_IN
46020: IFFALSE 46090
// if stu = 0 and i = Stanimir then
46022: LD_VAR 0 1
46026: PUSH
46027: LD_INT 0
46029: EQUAL
46030: PUSH
46031: LD_VAR 0 4
46035: PUSH
46036: LD_EXP 12
46040: EQUAL
46041: AND
46042: IFFALSE 46056
// stu = i else
46044: LD_ADDR_VAR 0 1
46048: PUSH
46049: LD_VAR 0 4
46053: ST_TO_ADDR
46054: GO 46088
// if other_guard = 0 then
46056: LD_VAR 0 2
46060: PUSH
46061: LD_INT 0
46063: EQUAL
46064: IFFALSE 46078
// other_guard = i else
46066: LD_ADDR_VAR 0 2
46070: PUSH
46071: LD_VAR 0 4
46075: ST_TO_ADDR
46076: GO 46088
// stu = i ;
46078: LD_ADDR_VAR 0 1
46082: PUSH
46083: LD_VAR 0 4
46087: ST_TO_ADDR
46088: GO 46019
46090: POP
46091: POP
// CenterOnUnits ( vehicle ) ;
46092: LD_VAR 0 5
46096: PPUSH
46097: CALL_OW 85
// DialogueOn ;
46101: CALL_OW 6
// Say ( stu , D5-GuardStu-1 ) ;
46105: LD_VAR 0 1
46109: PPUSH
46110: LD_STRING D5-GuardStu-1
46112: PPUSH
46113: CALL_OW 88
// DialogueOff ;
46117: CALL_OW 7
// i = 0 ;
46121: LD_ADDR_VAR 0 4
46125: PUSH
46126: LD_INT 0
46128: ST_TO_ADDR
// repeat wait ( 0 0$0.5 ) ;
46129: LD_INT 18
46131: PPUSH
46132: CALL_OW 67
// if HasTask ( vehicle ) then
46136: LD_VAR 0 5
46140: PPUSH
46141: CALL_OW 314
46145: IFFALSE 46163
// i = i + 1 else
46147: LD_ADDR_VAR 0 4
46151: PUSH
46152: LD_VAR 0 4
46156: PUSH
46157: LD_INT 1
46159: PLUS
46160: ST_TO_ADDR
46161: GO 46165
// break ;
46163: GO 46319
// case i of 4 :
46165: LD_VAR 0 4
46169: PUSH
46170: LD_INT 4
46172: DOUBLE
46173: EQUAL
46174: IFTRUE 46178
46176: GO 46201
46178: POP
// begin DialogueOn ;
46179: CALL_OW 6
// Say ( stu , D5-a-GuardStu-1 ) ;
46183: LD_VAR 0 1
46187: PPUSH
46188: LD_STRING D5-a-GuardStu-1
46190: PPUSH
46191: CALL_OW 88
// DialogueOff ;
46195: CALL_OW 7
// end ; 8 :
46199: GO 46315
46201: LD_INT 8
46203: DOUBLE
46204: EQUAL
46205: IFTRUE 46209
46207: GO 46314
46209: POP
// begin DialogueOn ;
46210: CALL_OW 6
// if IsInArea ( Heike , ru_base_area ) then
46214: LD_EXP 7
46218: PPUSH
46219: LD_INT 2
46221: PPUSH
46222: CALL_OW 308
46226: IFFALSE 46266
// begin Say ( stu , D5-aa-GuardStu-1 ) ;
46228: LD_VAR 0 1
46232: PPUSH
46233: LD_STRING D5-aa-GuardStu-1
46235: PPUSH
46236: CALL_OW 88
// if code_black then
46240: LD_EXP 77
46244: IFFALSE 46256
// code_black_renew = true else
46246: LD_ADDR_EXP 124
46250: PUSH
46251: LD_INT 1
46253: ST_TO_ADDR
46254: GO 46264
// code_black = true ;
46256: LD_ADDR_EXP 77
46260: PUSH
46261: LD_INT 1
46263: ST_TO_ADDR
// end else
46264: GO 46299
// begin Say ( stu , D5-ab-GuardStu-1 ) ;
46266: LD_VAR 0 1
46270: PPUSH
46271: LD_STRING D5-ab-GuardStu-1
46273: PPUSH
46274: CALL_OW 88
// code_red = true ;
46278: LD_ADDR_EXP 76
46282: PUSH
46283: LD_INT 1
46285: ST_TO_ADDR
// CreateCodeRedPatrols ( difficulty - 1 ) ;
46286: LD_OWVAR 67
46290: PUSH
46291: LD_INT 1
46293: MINUS
46294: PPUSH
46295: CALL 38894 0 1
// end ; ChangeHeikeUndercoverStatus ( 4 ) ;
46299: LD_INT 4
46301: PPUSH
46302: CALL 42004 0 1
// DialogueOff ;
46306: CALL_OW 7
// exit ;
46310: GO 46877
// end ; end ;
46312: GO 46315
46314: POP
// until false ;
46315: LD_INT 0
46317: IFFALSE 46129
// heike_arrived_to_base_in_this_cargo_bay = vehicle ;
46319: LD_ADDR_EXP 105
46323: PUSH
46324: LD_VAR 0 5
46328: ST_TO_ADDR
// DialogueOn ;
46329: CALL_OW 6
// Say ( stu , D5-b-GuardStu-1 ) ;
46333: LD_VAR 0 1
46337: PPUSH
46338: LD_STRING D5-b-GuardStu-1
46340: PPUSH
46341: CALL_OW 88
// DWait ( 0 0$1 ) ;
46345: LD_INT 35
46347: PPUSH
46348: CALL_OW 68
// Say ( stu , D5-b-GuardStu-2 ) ;
46352: LD_VAR 0 1
46356: PPUSH
46357: LD_STRING D5-b-GuardStu-2
46359: PPUSH
46360: CALL_OW 88
// DWait ( 0 0$0.2 ) ;
46364: LD_INT 7
46366: PPUSH
46367: CALL_OW 68
// if Query ( QGoods ) <> cargo_bays_origin [ vehicle ] then
46371: LD_STRING QGoods
46373: PPUSH
46374: CALL_OW 97
46378: PUSH
46379: LD_EXP 102
46383: PUSH
46384: LD_VAR 0 5
46388: ARRAY
46389: NONEQUAL
46390: IFFALSE 46425
// begin Say ( stu , D5-wrong-GuardStu-1 ) ;
46392: LD_VAR 0 1
46396: PPUSH
46397: LD_STRING D5-wrong-GuardStu-1
46399: PPUSH
46400: CALL_OW 88
// DWait ( 0 0$0.2 ) ;
46404: LD_INT 7
46406: PPUSH
46407: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
46411: LD_STRING HeikeCaptive
46413: PPUSH
46414: CALL_OW 104
// DWait ( 0 0$1 ) ;
46418: LD_INT 35
46420: PPUSH
46421: CALL_OW 68
// end ; if GetLives ( vehicle ) >= 500 then
46425: LD_VAR 0 5
46429: PPUSH
46430: CALL_OW 256
46434: PUSH
46435: LD_INT 500
46437: GREATEREQUAL
46438: IFFALSE 46517
// begin case heike_parking_spot of 1 :
46440: LD_EXP 72
46444: PUSH
46445: LD_INT 1
46447: DOUBLE
46448: EQUAL
46449: IFTRUE 46453
46451: GO 46468
46453: POP
// Say ( other_guard , D5-right_a-GuardOther-1a ) ; 2 :
46454: LD_VAR 0 2
46458: PPUSH
46459: LD_STRING D5-right_a-GuardOther-1a
46461: PPUSH
46462: CALL_OW 88
46466: GO 46515
46468: LD_INT 2
46470: DOUBLE
46471: EQUAL
46472: IFTRUE 46476
46474: GO 46491
46476: POP
// Say ( other_guard , D5-right_a-GuardOther-1b ) ; 3 :
46477: LD_VAR 0 2
46481: PPUSH
46482: LD_STRING D5-right_a-GuardOther-1b
46484: PPUSH
46485: CALL_OW 88
46489: GO 46515
46491: LD_INT 3
46493: DOUBLE
46494: EQUAL
46495: IFTRUE 46499
46497: GO 46514
46499: POP
// Say ( other_guard , D5-right_a-GuardOther-1c ) ; end ;
46500: LD_VAR 0 2
46504: PPUSH
46505: LD_STRING D5-right_a-GuardOther-1c
46507: PPUSH
46508: CALL_OW 88
46512: GO 46515
46514: POP
// end else
46515: GO 46859
// begin Say ( other_guard , D5-right_b-GuardOther-1 ) ;
46517: LD_VAR 0 2
46521: PPUSH
46522: LD_STRING D5-right_b-GuardOther-1
46524: PPUSH
46525: CALL_OW 88
// DWait ( 0 0$0.2 ) ;
46529: LD_INT 7
46531: PPUSH
46532: CALL_OW 68
// case Query ( QGuardTrouble ) of 1 :
46536: LD_STRING QGuardTrouble
46538: PPUSH
46539: CALL_OW 97
46543: PUSH
46544: LD_INT 1
46546: DOUBLE
46547: EQUAL
46548: IFTRUE 46552
46550: GO 46642
46552: POP
// begin Say ( Heike , D5-right_b1-H-1 ) ;
46553: LD_EXP 7
46557: PPUSH
46558: LD_STRING D5-right_b1-H-1
46560: PPUSH
46561: CALL_OW 88
// case heike_parking_spot of 1 :
46565: LD_EXP 72
46569: PUSH
46570: LD_INT 1
46572: DOUBLE
46573: EQUAL
46574: IFTRUE 46578
46576: GO 46593
46578: POP
// Say ( other_guard , D5-right_b1-GuardOther-1a ) ; 2 :
46579: LD_VAR 0 2
46583: PPUSH
46584: LD_STRING D5-right_b1-GuardOther-1a
46586: PPUSH
46587: CALL_OW 88
46591: GO 46640
46593: LD_INT 2
46595: DOUBLE
46596: EQUAL
46597: IFTRUE 46601
46599: GO 46616
46601: POP
// Say ( other_guard , D5-right_b1-GuardOther-1b ) ; 3 :
46602: LD_VAR 0 2
46606: PPUSH
46607: LD_STRING D5-right_b1-GuardOther-1b
46609: PPUSH
46610: CALL_OW 88
46614: GO 46640
46616: LD_INT 3
46618: DOUBLE
46619: EQUAL
46620: IFTRUE 46624
46622: GO 46639
46624: POP
// Say ( other_guard , D5-right_b1-GuardOther-1c ) ; end ;
46625: LD_VAR 0 2
46629: PPUSH
46630: LD_STRING D5-right_b1-GuardOther-1c
46632: PPUSH
46633: CALL_OW 88
46637: GO 46640
46639: POP
// end ; 2 :
46640: GO 46859
46642: LD_INT 2
46644: DOUBLE
46645: EQUAL
46646: IFTRUE 46650
46648: GO 46760
46650: POP
// begin Say ( Heike , D5-right_b2-H-1 ) ;
46651: LD_EXP 7
46655: PPUSH
46656: LD_STRING D5-right_b2-H-1
46658: PPUSH
46659: CALL_OW 88
// Say ( other_guard , D5-right_b2-GuardOther-1 ) ;
46663: LD_VAR 0 2
46667: PPUSH
46668: LD_STRING D5-right_b2-GuardOther-1
46670: PPUSH
46671: CALL_OW 88
// case heike_parking_spot of 1 :
46675: LD_EXP 72
46679: PUSH
46680: LD_INT 1
46682: DOUBLE
46683: EQUAL
46684: IFTRUE 46688
46686: GO 46703
46688: POP
// Say ( other_guard , D5-right_b2-GuardOther-2a ) ; 2 :
46689: LD_VAR 0 2
46693: PPUSH
46694: LD_STRING D5-right_b2-GuardOther-2a
46696: PPUSH
46697: CALL_OW 88
46701: GO 46750
46703: LD_INT 2
46705: DOUBLE
46706: EQUAL
46707: IFTRUE 46711
46709: GO 46726
46711: POP
// Say ( other_guard , D5-right_b2-GuardOther-2b ) ; 3 :
46712: LD_VAR 0 2
46716: PPUSH
46717: LD_STRING D5-right_b2-GuardOther-2b
46719: PPUSH
46720: CALL_OW 88
46724: GO 46750
46726: LD_INT 3
46728: DOUBLE
46729: EQUAL
46730: IFTRUE 46734
46732: GO 46749
46734: POP
// Say ( other_guard , D5-right_b2-GuardOther-2c ) ; end ;
46735: LD_VAR 0 2
46739: PPUSH
46740: LD_STRING D5-right_b2-GuardOther-2c
46742: PPUSH
46743: CALL_OW 88
46747: GO 46750
46749: POP
// send_guard_from_entrance_to_office = true ;
46750: LD_ADDR_EXP 103
46754: PUSH
46755: LD_INT 1
46757: ST_TO_ADDR
// end ; 3 :
46758: GO 46859
46760: LD_INT 3
46762: DOUBLE
46763: EQUAL
46764: IFTRUE 46768
46766: GO 46858
46768: POP
// begin Say ( Heike , D5-right_b3-H-1 ) ;
46769: LD_EXP 7
46773: PPUSH
46774: LD_STRING D5-right_b3-H-1
46776: PPUSH
46777: CALL_OW 88
// case heike_parking_spot of 1 :
46781: LD_EXP 72
46785: PUSH
46786: LD_INT 1
46788: DOUBLE
46789: EQUAL
46790: IFTRUE 46794
46792: GO 46809
46794: POP
// Say ( other_guard , D5-right_b1-GuardOther-1a ) ; 2 :
46795: LD_VAR 0 2
46799: PPUSH
46800: LD_STRING D5-right_b1-GuardOther-1a
46802: PPUSH
46803: CALL_OW 88
46807: GO 46856
46809: LD_INT 2
46811: DOUBLE
46812: EQUAL
46813: IFTRUE 46817
46815: GO 46832
46817: POP
// Say ( other_guard , D5-right_b1-GuardOther-1b ) ; 3 :
46818: LD_VAR 0 2
46822: PPUSH
46823: LD_STRING D5-right_b1-GuardOther-1b
46825: PPUSH
46826: CALL_OW 88
46830: GO 46856
46832: LD_INT 3
46834: DOUBLE
46835: EQUAL
46836: IFTRUE 46840
46838: GO 46855
46840: POP
// Say ( other_guard , D5-right_b1-GuardOther-1c ) ; end ;
46841: LD_VAR 0 2
46845: PPUSH
46846: LD_STRING D5-right_b1-GuardOther-1c
46848: PPUSH
46849: CALL_OW 88
46853: GO 46856
46855: POP
// end ; end ;
46856: GO 46859
46858: POP
// end ; DialogueOff ;
46859: CALL_OW 7
// entrance_guard_dialogue_played = true ;
46863: LD_ADDR_EXP 84
46867: PUSH
46868: LD_INT 1
46870: ST_TO_ADDR
// exit ;
46871: GO 46877
// end ; until false ;
46873: LD_INT 0
46875: IFFALSE 45841
// end ;
46877: PPOPN 5
46879: END
// every 0 0$1 + 0 0$0.2 do var i ; var sol ;
46880: GO 46882
46882: DISABLE
46883: LD_INT 0
46885: PPUSH
46886: PPUSH
// begin sol = 0 ;
46887: LD_ADDR_VAR 0 2
46891: PUSH
46892: LD_INT 0
46894: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
46895: LD_INT 35
46897: PPUSH
46898: CALL_OW 67
// if not send_guard_from_entrance_to_office then
46902: LD_EXP 103
46906: NOT
46907: IFFALSE 46911
// continue ;
46909: GO 46895
// if code_red or code_black then
46911: LD_EXP 76
46915: PUSH
46916: LD_EXP 77
46920: OR
46921: IFFALSE 46933
// begin entrance_guard_to_office = 0 ;
46923: LD_ADDR_EXP 104
46927: PUSH
46928: LD_INT 0
46930: ST_TO_ADDR
// exit ;
46931: GO 47297
// end ; if entrance_guard_to_office in ai_heal_these_humans [ 1 ] or not IsOk ( leader_office ) then
46933: LD_EXP 104
46937: PUSH
46938: LD_EXP 42
46942: PUSH
46943: LD_INT 1
46945: ARRAY
46946: IN
46947: PUSH
46948: LD_EXP 93
46952: PPUSH
46953: CALL_OW 302
46957: NOT
46958: OR
46959: IFFALSE 46991
// begin if entrance_guard_to_office > 0 then
46961: LD_EXP 104
46965: PUSH
46966: LD_INT 0
46968: GREATER
46969: IFFALSE 46989
// begin sol = entrance_guard_to_office ;
46971: LD_ADDR_VAR 0 2
46975: PUSH
46976: LD_EXP 104
46980: ST_TO_ADDR
// entrance_guard_to_office = 0 ;
46981: LD_ADDR_EXP 104
46985: PUSH
46986: LD_INT 0
46988: ST_TO_ADDR
// end ; continue ;
46989: GO 46895
// end ; if sol > 0 then
46991: LD_VAR 0 2
46995: PUSH
46996: LD_INT 0
46998: GREATER
46999: IFFALSE 47019
// begin entrance_guard_to_office = sol ;
47001: LD_ADDR_EXP 104
47005: PUSH
47006: LD_VAR 0 2
47010: ST_TO_ADDR
// sol = 0 ;
47011: LD_ADDR_VAR 0 2
47015: PUSH
47016: LD_INT 0
47018: ST_TO_ADDR
// end ; if entrance_guard_to_office = 0 then
47019: LD_EXP 104
47023: PUSH
47024: LD_INT 0
47026: EQUAL
47027: IFFALSE 47098
// begin for i in ai_bunkers [ 1 ] do
47029: LD_ADDR_VAR 0 1
47033: PUSH
47034: LD_EXP 49
47038: PUSH
47039: LD_INT 1
47041: ARRAY
47042: PUSH
47043: FOR_IN
47044: IFFALSE 47084
// if UnitsInside ( i ) > 0 then
47046: LD_VAR 0 1
47050: PPUSH
47051: CALL_OW 313
47055: PUSH
47056: LD_INT 0
47058: GREATER
47059: IFFALSE 47082
// begin entrance_guard_to_office = UnitsInside ( i ) [ 1 ] ;
47061: LD_ADDR_EXP 104
47065: PUSH
47066: LD_VAR 0 1
47070: PPUSH
47071: CALL_OW 313
47075: PUSH
47076: LD_INT 1
47078: ARRAY
47079: ST_TO_ADDR
// break ;
47080: GO 47084
// end ;
47082: GO 47043
47084: POP
47085: POP
// if entrance_guard_to_office = 0 then
47086: LD_EXP 104
47090: PUSH
47091: LD_INT 0
47093: EQUAL
47094: IFFALSE 47098
// continue ;
47096: GO 46895
// end ; if IsInUnit ( entrance_guard_to_office ) <> leader_office then
47098: LD_EXP 104
47102: PPUSH
47103: CALL_OW 310
47107: PUSH
47108: LD_EXP 93
47112: NONEQUAL
47113: IFFALSE 47187
// begin case GetType ( IsInUnit ( entrance_guard_to_office ) ) of unit_building :
47115: LD_EXP 104
47119: PPUSH
47120: CALL_OW 310
47124: PPUSH
47125: CALL_OW 247
47129: PUSH
47130: LD_INT 3
47132: DOUBLE
47133: EQUAL
47134: IFTRUE 47138
47136: GO 47150
47138: POP
// ComExitBuilding ( entrance_guard_to_office ) ; unit_vehicle :
47139: LD_EXP 104
47143: PPUSH
47144: CALL_OW 122
47148: GO 47185
47150: LD_INT 2
47152: DOUBLE
47153: EQUAL
47154: IFTRUE 47158
47156: GO 47170
47158: POP
// ComExitVehicle ( entrance_guard_to_office ) ; else
47159: LD_EXP 104
47163: PPUSH
47164: CALL_OW 121
47168: GO 47185
47170: POP
// ComEnterUnit ( entrance_guard_to_office , leader_office ) ; end ;
47171: LD_EXP 104
47175: PPUSH
47176: LD_EXP 93
47180: PPUSH
47181: CALL_OW 120
// end else
47185: GO 47293
// begin for i = 1 to 5 do
47187: LD_ADDR_VAR 0 1
47191: PUSH
47192: DOUBLE
47193: LD_INT 1
47195: DEC
47196: ST_TO_ADDR
47197: LD_INT 5
47199: PUSH
47200: FOR_TO
47201: IFFALSE 47236
// begin if code_red or code_black then
47203: LD_EXP 76
47207: PUSH
47208: LD_EXP 77
47212: OR
47213: IFFALSE 47227
// begin entrance_guard_to_office = 0 ;
47215: LD_ADDR_EXP 104
47219: PUSH
47220: LD_INT 0
47222: ST_TO_ADDR
// exit ;
47223: POP
47224: POP
47225: GO 47297
// end ; wait ( 0 0$1 ) ;
47227: LD_INT 35
47229: PPUSH
47230: CALL_OW 67
// end ;
47234: GO 47200
47236: POP
47237: POP
// entrance_guard_to_office = 0 ;
47238: LD_ADDR_EXP 104
47242: PUSH
47243: LD_INT 0
47245: ST_TO_ADDR
// wait ( 0 0$5 ) ;
47246: LD_INT 175
47248: PPUSH
47249: CALL_OW 67
// if not code_red and not code_black then
47253: LD_EXP 76
47257: NOT
47258: PUSH
47259: LD_EXP 77
47263: NOT
47264: AND
47265: IFFALSE 47291
// CreateCodeRedPatrols ( [ 0 , 1 , 1 ] [ difficulty ] ) ;
47267: LD_INT 0
47269: PUSH
47270: LD_INT 1
47272: PUSH
47273: LD_INT 1
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: LIST
47280: PUSH
47281: LD_OWVAR 67
47285: ARRAY
47286: PPUSH
47287: CALL 38894 0 1
// exit ;
47291: GO 47297
// end ; until false ;
47293: LD_INT 0
47295: IFFALSE 46895
// end ;
47297: PPOPN 2
47299: END
// every 0 0$1 + 0 0$0.3 do var i , val ; var arrival_cargo_bay_parked , before_parking_seen_tick , before_parking_dialogue_num , cargo_bay ; var pats_know_about_boyfriend , times_heike_seen_after_parking , reprimand_tick ;
47300: GO 47302
47302: DISABLE
47303: LD_INT 0
47305: PPUSH
47306: PPUSH
47307: PPUSH
47308: PPUSH
47309: PPUSH
47310: PPUSH
47311: PPUSH
47312: PPUSH
47313: PPUSH
// begin arrival_cargo_bay_parked = false ;
47314: LD_ADDR_VAR 0 3
47318: PUSH
47319: LD_INT 0
47321: ST_TO_ADDR
// before_parking_seen_tick = 0 ;
47322: LD_ADDR_VAR 0 4
47326: PUSH
47327: LD_INT 0
47329: ST_TO_ADDR
// before_parking_dialogue_num = 0 ;
47330: LD_ADDR_VAR 0 5
47334: PUSH
47335: LD_INT 0
47337: ST_TO_ADDR
// cargo_bay = 0 ;
47338: LD_ADDR_VAR 0 6
47342: PUSH
47343: LD_INT 0
47345: ST_TO_ADDR
// pats_know_about_boyfriend = false ;
47346: LD_ADDR_VAR 0 7
47350: PUSH
47351: LD_INT 0
47353: ST_TO_ADDR
// times_heike_seen_after_parking = 0 ;
47354: LD_ADDR_VAR 0 8
47358: PUSH
47359: LD_INT 0
47361: ST_TO_ADDR
// reprimand_tick = 0 ;
47362: LD_ADDR_VAR 0 9
47366: PUSH
47367: LD_INT 0
47369: ST_TO_ADDR
// repeat wait ( 0 0$0.5 ) ;
47370: LD_INT 18
47372: PPUSH
47373: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] or IsDead ( bad_pat ) or IsDead ( good_pat ) or terminate_internal_patrol then
47377: LD_EXP 83
47381: PUSH
47382: LD_INT 3
47384: PUSH
47385: LD_INT 4
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: IN
47392: PUSH
47393: LD_EXP 19
47397: PPUSH
47398: CALL_OW 301
47402: OR
47403: PUSH
47404: LD_EXP 18
47408: PPUSH
47409: CALL_OW 301
47413: OR
47414: PUSH
47415: LD_EXP 82
47419: OR
47420: IFFALSE 47424
// exit ;
47422: GO 49331
// if heike_arrived_to_base_in_this_cargo_bay = 0 then
47424: LD_EXP 105
47428: PUSH
47429: LD_INT 0
47431: EQUAL
47432: IFFALSE 47436
// continue ;
47434: GO 47370
// until true ;
47436: LD_INT 1
47438: IFFALSE 47370
// cargo_bay = heike_arrived_to_base_in_this_cargo_bay ;
47440: LD_ADDR_VAR 0 6
47444: PUSH
47445: LD_EXP 105
47449: ST_TO_ADDR
// repeat if cargo_bay = 0 then
47450: LD_VAR 0 6
47454: PUSH
47455: LD_INT 0
47457: EQUAL
47458: IFFALSE 47525
// begin val = IsInUnit ( Heike ) ;
47460: LD_ADDR_VAR 0 2
47464: PUSH
47465: LD_EXP 7
47469: PPUSH
47470: CALL_OW 310
47474: ST_TO_ADDR
// if val > 0 and GetType ( val ) = unit_vehicle and GetWeapon ( val ) = ru_cargo_bay then
47475: LD_VAR 0 2
47479: PUSH
47480: LD_INT 0
47482: GREATER
47483: PUSH
47484: LD_VAR 0 2
47488: PPUSH
47489: CALL_OW 247
47493: PUSH
47494: LD_INT 2
47496: EQUAL
47497: AND
47498: PUSH
47499: LD_VAR 0 2
47503: PPUSH
47504: CALL_OW 264
47508: PUSH
47509: LD_INT 51
47511: EQUAL
47512: AND
47513: IFFALSE 47525
// cargo_bay = val ;
47515: LD_ADDR_VAR 0 6
47519: PUSH
47520: LD_VAR 0 2
47524: ST_TO_ADDR
// end ; wait ( 0 0$0.5 ) ;
47525: LD_INT 18
47527: PPUSH
47528: CALL_OW 67
// if not arrival_cargo_bay_parked then
47532: LD_VAR 0 3
47536: NOT
47537: IFFALSE 47562
// if IsInUnit ( Heike ) = 0 then
47539: LD_EXP 7
47543: PPUSH
47544: CALL_OW 310
47548: PUSH
47549: LD_INT 0
47551: EQUAL
47552: IFFALSE 47562
// arrival_cargo_bay_parked = true ;
47554: LD_ADDR_VAR 0 3
47558: PUSH
47559: LD_INT 1
47561: ST_TO_ADDR
// if heike_undercover in [ 3 , 4 ] or IsDead ( bad_pat ) or IsDead ( good_pat ) or terminate_internal_patrol then
47562: LD_EXP 83
47566: PUSH
47567: LD_INT 3
47569: PUSH
47570: LD_INT 4
47572: PUSH
47573: EMPTY
47574: LIST
47575: LIST
47576: IN
47577: PUSH
47578: LD_EXP 19
47582: PPUSH
47583: CALL_OW 301
47587: OR
47588: PUSH
47589: LD_EXP 18
47593: PPUSH
47594: CALL_OW 301
47598: OR
47599: PUSH
47600: LD_EXP 82
47604: OR
47605: IFFALSE 47609
// exit ;
47607: GO 49331
// if halt_internal_patrol = 1 or code_black then
47609: LD_EXP 81
47613: PUSH
47614: LD_INT 1
47616: EQUAL
47617: PUSH
47618: LD_EXP 77
47622: OR
47623: IFFALSE 47627
// continue ;
47625: GO 47450
// if IsInUnit ( Heike ) = 0 and cargo_bay > 0 then
47627: LD_EXP 7
47631: PPUSH
47632: CALL_OW 310
47636: PUSH
47637: LD_INT 0
47639: EQUAL
47640: PUSH
47641: LD_VAR 0 6
47645: PUSH
47646: LD_INT 0
47648: GREATER
47649: AND
47650: IFFALSE 48203
// begin if not IsInArea ( cargo_bay , cargo_bay_parking ) and GuardsCanSeeHeike then
47652: LD_VAR 0 6
47656: PPUSH
47657: LD_INT 13
47659: PPUSH
47660: CALL_OW 308
47664: NOT
47665: PUSH
47666: CALL 49334 0 0
47670: AND
47671: IFFALSE 48195
// begin dont_park_cargo_bay = cargo_bay ;
47673: LD_ADDR_EXP 107
47677: PUSH
47678: LD_VAR 0 6
47682: ST_TO_ADDR
// halt_internal_patrol = 2 ;
47683: LD_ADDR_EXP 81
47687: PUSH
47688: LD_INT 2
47690: ST_TO_ADDR
// ComTurnUnit ( good_pat , Heike ) ;
47691: LD_EXP 18
47695: PPUSH
47696: LD_EXP 7
47700: PPUSH
47701: CALL_OW 119
// ComturnUnit ( bad_pat , Heike ) ;
47705: LD_EXP 19
47709: PPUSH
47710: LD_EXP 7
47714: PPUSH
47715: CALL_OW 119
// wait ( 25 ) ;
47719: LD_INT 25
47721: PPUSH
47722: CALL_OW 67
// CenterOnUnits ( [ good_pat , bad_pat ] ) ;
47726: LD_EXP 18
47730: PUSH
47731: LD_EXP 19
47735: PUSH
47736: EMPTY
47737: LIST
47738: LIST
47739: PPUSH
47740: CALL_OW 85
// DialogueOn ;
47744: CALL_OW 6
// Say ( bad_pat , D10-PatBad-1 ) ;
47748: LD_EXP 19
47752: PPUSH
47753: LD_STRING D10-PatBad-1
47755: PPUSH
47756: CALL_OW 88
// Say ( Heike , D10-H-1 ) ;
47760: LD_EXP 7
47764: PPUSH
47765: LD_STRING D10-H-1
47767: PPUSH
47768: CALL_OW 88
// Say ( bad_pat , D10-PatBad-2 ) ;
47772: LD_EXP 19
47776: PPUSH
47777: LD_STRING D10-PatBad-2
47779: PPUSH
47780: CALL_OW 88
// if pats_know_about_boyfriend then
47784: LD_VAR 0 7
47788: IFFALSE 47802
// Say ( good_pat , D10-PatGood-1 ) ;
47790: LD_EXP 18
47794: PPUSH
47795: LD_STRING D10-PatGood-1
47797: PPUSH
47798: CALL_OW 88
// DialogueOff ;
47802: CALL_OW 7
// ComTurnUnit ( good_pat , bad_pat ) ;
47806: LD_EXP 18
47810: PPUSH
47811: LD_EXP 19
47815: PPUSH
47816: CALL_OW 119
// ComTurnUnit ( bad_pat , good_pat ) ;
47820: LD_EXP 19
47824: PPUSH
47825: LD_EXP 18
47829: PPUSH
47830: CALL_OW 119
// val = GetDistUnits ( Heike , cargo_bay ) ;
47834: LD_ADDR_VAR 0 2
47838: PUSH
47839: LD_EXP 7
47843: PPUSH
47844: LD_VAR 0 6
47848: PPUSH
47849: CALL_OW 296
47853: ST_TO_ADDR
// i = 0 ;
47854: LD_ADDR_VAR 0 1
47858: PUSH
47859: LD_INT 0
47861: ST_TO_ADDR
// repeat wait ( 0 0$0.5 ) ;
47862: LD_INT 18
47864: PPUSH
47865: CALL_OW 67
// i = i + 1 ;
47869: LD_ADDR_VAR 0 1
47873: PUSH
47874: LD_VAR 0 1
47878: PUSH
47879: LD_INT 1
47881: PLUS
47882: ST_TO_ADDR
// if halt_internal_patrol = 1 or code_black then
47883: LD_EXP 81
47887: PUSH
47888: LD_INT 1
47890: EQUAL
47891: PUSH
47892: LD_EXP 77
47896: OR
47897: IFFALSE 47901
// break ;
47899: GO 48147
// if IsInUnit ( Heike ) = cargo_bay then
47901: LD_EXP 7
47905: PPUSH
47906: CALL_OW 310
47910: PUSH
47911: LD_VAR 0 6
47915: EQUAL
47916: IFFALSE 47920
// break ;
47918: GO 48147
// if GetDistUnits ( Heike , cargo_bay ) >= val + 2 then
47920: LD_EXP 7
47924: PPUSH
47925: LD_VAR 0 6
47929: PPUSH
47930: CALL_OW 296
47934: PUSH
47935: LD_VAR 0 2
47939: PUSH
47940: LD_INT 2
47942: PLUS
47943: GREATEREQUAL
47944: IFFALSE 48013
// begin ComTurnUnit ( bad_pat , Heike ) ;
47946: LD_EXP 19
47950: PPUSH
47951: LD_EXP 7
47955: PPUSH
47956: CALL_OW 119
// wait ( 3 ) ;
47960: LD_INT 3
47962: PPUSH
47963: CALL_OW 67
// DialogueOn ;
47967: CALL_OW 6
// Say ( bad_pat , D10-PatBad-3 ) ;
47971: LD_EXP 19
47975: PPUSH
47976: LD_STRING D10-PatBad-3
47978: PPUSH
47979: CALL_OW 88
// Say ( bad_pat , D10-PatBad-4 ) ;
47983: LD_EXP 19
47987: PPUSH
47988: LD_STRING D10-PatBad-4
47990: PPUSH
47991: CALL_OW 88
// DWait ( 0 0$0.5 ) ;
47995: LD_INT 18
47997: PPUSH
47998: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
48002: LD_STRING HeikeCaptive
48004: PPUSH
48005: CALL_OW 104
// DialogueOff ;
48009: CALL_OW 7
// end ; if i = 10 then
48013: LD_VAR 0 1
48017: PUSH
48018: LD_INT 10
48020: EQUAL
48021: IFFALSE 48078
// begin ComTurnUnit ( bad_pat , Heike ) ;
48023: LD_EXP 19
48027: PPUSH
48028: LD_EXP 7
48032: PPUSH
48033: CALL_OW 119
// wait ( 3 ) ;
48037: LD_INT 3
48039: PPUSH
48040: CALL_OW 67
// DialogueOn ;
48044: CALL_OW 6
// Say ( bad_pat , D10-PatBad-5 ) ;
48048: LD_EXP 19
48052: PPUSH
48053: LD_STRING D10-PatBad-5
48055: PPUSH
48056: CALL_OW 88
// DialogueOff ;
48060: CALL_OW 7
// ComTurnUnit ( bad_pat , good_pat ) ;
48064: LD_EXP 19
48068: PPUSH
48069: LD_EXP 18
48073: PPUSH
48074: CALL_OW 119
// end ; if i = 20 then
48078: LD_VAR 0 1
48082: PUSH
48083: LD_INT 20
48085: EQUAL
48086: IFFALSE 48143
// begin ComTurnUnit ( bad_pat , Heike ) ;
48088: LD_EXP 19
48092: PPUSH
48093: LD_EXP 7
48097: PPUSH
48098: CALL_OW 119
// wait ( 3 ) ;
48102: LD_INT 3
48104: PPUSH
48105: CALL_OW 67
// DialogueOn ;
48109: CALL_OW 6
// Say ( bad_pat , D10-PatBad-6 ) ;
48113: LD_EXP 19
48117: PPUSH
48118: LD_STRING D10-PatBad-6
48120: PPUSH
48121: CALL_OW 88
// DWait ( 0 0$0.5 ) ;
48125: LD_INT 18
48127: PPUSH
48128: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
48132: LD_STRING HeikeCaptive
48134: PPUSH
48135: CALL_OW 104
// DialogueOff ;
48139: CALL_OW 7
// end ; until false ;
48143: LD_INT 0
48145: IFFALSE 47862
// if halt_internal_patrol = 2 then
48147: LD_EXP 81
48151: PUSH
48152: LD_INT 2
48154: EQUAL
48155: IFFALSE 48165
// halt_internal_patrol = 0 ;
48157: LD_ADDR_EXP 81
48161: PUSH
48162: LD_INT 0
48164: ST_TO_ADDR
// dont_park_cargo_bay = 0 ;
48165: LD_ADDR_EXP 107
48169: PUSH
48170: LD_INT 0
48172: ST_TO_ADDR
// cargo_bay = 0 ;
48173: LD_ADDR_VAR 0 6
48177: PUSH
48178: LD_INT 0
48180: ST_TO_ADDR
// reprimand_tick = tick ;
48181: LD_ADDR_VAR 0 9
48185: PUSH
48186: LD_OWVAR 1
48190: ST_TO_ADDR
// continue ;
48191: GO 47450
// end else
48193: GO 48203
// cargo_bay = 0 ;
48195: LD_ADDR_VAR 0 6
48199: PUSH
48200: LD_INT 0
48202: ST_TO_ADDR
// end ; if not arrival_cargo_bay_parked then
48203: LD_VAR 0 3
48207: NOT
48208: IFFALSE 48849
// begin if GuardsCanSeeHeike then
48210: CALL 49334 0 0
48214: IFFALSE 48847
// begin if before_parking_seen_tick = 0 then
48216: LD_VAR 0 4
48220: PUSH
48221: LD_INT 0
48223: EQUAL
48224: IFFALSE 48238
// begin before_parking_seen_tick = tick ;
48226: LD_ADDR_VAR 0 4
48230: PUSH
48231: LD_OWVAR 1
48235: ST_TO_ADDR
// continue ;
48236: GO 47450
// end ; if tick - before_parking_seen_tick >= 0 0$25 and before_parking_dialogue_num = 0 then
48238: LD_OWVAR 1
48242: PUSH
48243: LD_VAR 0 4
48247: MINUS
48248: PUSH
48249: LD_INT 875
48251: GREATEREQUAL
48252: PUSH
48253: LD_VAR 0 5
48257: PUSH
48258: LD_INT 0
48260: EQUAL
48261: AND
48262: IFFALSE 48708
// begin before_parking_dialogue_num = 1 ;
48264: LD_ADDR_VAR 0 5
48268: PUSH
48269: LD_INT 1
48271: ST_TO_ADDR
// before_parking_seen_tick = tick ;
48272: LD_ADDR_VAR 0 4
48276: PUSH
48277: LD_OWVAR 1
48281: ST_TO_ADDR
// reprimand_tick = tick ;
48282: LD_ADDR_VAR 0 9
48286: PUSH
48287: LD_OWVAR 1
48291: ST_TO_ADDR
// halt_internal_patrol = 2 ;
48292: LD_ADDR_EXP 81
48296: PUSH
48297: LD_INT 2
48299: ST_TO_ADDR
// ComTurnUnit ( good_pat , Heike ) ;
48300: LD_EXP 18
48304: PPUSH
48305: LD_EXP 7
48309: PPUSH
48310: CALL_OW 119
// ComturnUnit ( bad_pat , Heike ) ;
48314: LD_EXP 19
48318: PPUSH
48319: LD_EXP 7
48323: PPUSH
48324: CALL_OW 119
// wait ( 25 ) ;
48328: LD_INT 25
48330: PPUSH
48331: CALL_OW 67
// CenterOnUnits ( [ good_pat , bad_pat ] ) ;
48335: LD_EXP 18
48339: PUSH
48340: LD_EXP 19
48344: PUSH
48345: EMPTY
48346: LIST
48347: LIST
48348: PPUSH
48349: CALL_OW 85
// DialogueOn ;
48353: CALL_OW 6
// Say ( good_pat , D9-PatGood-1 ) ;
48357: LD_EXP 18
48361: PPUSH
48362: LD_STRING D9-PatGood-1
48364: PPUSH
48365: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
48369: LD_INT 10
48371: PPUSH
48372: CALL_OW 68
// case Query ( QPatrolHeikeInVehicle ) of 1 :
48376: LD_STRING QPatrolHeikeInVehicle
48378: PPUSH
48379: CALL_OW 97
48383: PUSH
48384: LD_INT 1
48386: DOUBLE
48387: EQUAL
48388: IFTRUE 48392
48390: GO 48526
48392: POP
// begin Say ( Heike , D9-1-H-1 ) ;
48393: LD_EXP 7
48397: PPUSH
48398: LD_STRING D9-1-H-1
48400: PPUSH
48401: CALL_OW 88
// Say ( good_pat , D9-1-PatGood-1 ) ;
48405: LD_EXP 18
48409: PPUSH
48410: LD_STRING D9-1-PatGood-1
48412: PPUSH
48413: CALL_OW 88
// Say ( Heike , D9-1-H-2 ) ;
48417: LD_EXP 7
48421: PPUSH
48422: LD_STRING D9-1-H-2
48424: PPUSH
48425: CALL_OW 88
// Say ( bad_pat , D9-1-PatBad-1 ) ;
48429: LD_EXP 19
48433: PPUSH
48434: LD_STRING D9-1-PatBad-1
48436: PPUSH
48437: CALL_OW 88
// Say ( Heike , D9-1-H-3 ) ;
48441: LD_EXP 7
48445: PPUSH
48446: LD_STRING D9-1-H-3
48448: PPUSH
48449: CALL_OW 88
// DWait ( 0 0$0.8 ) ;
48453: LD_INT 28
48455: PPUSH
48456: CALL_OW 68
// Say ( good_pat , D9-1-PatGood-2 ) ;
48460: LD_EXP 18
48464: PPUSH
48465: LD_STRING D9-1-PatGood-2
48467: PPUSH
48468: CALL_OW 88
// Say ( good_pat , D9-1-PatGood-3 ) ;
48472: LD_EXP 18
48476: PPUSH
48477: LD_STRING D9-1-PatGood-3
48479: PPUSH
48480: CALL_OW 88
// Say ( Heike , D9-1-H-4 ) ;
48484: LD_EXP 7
48488: PPUSH
48489: LD_STRING D9-1-H-4
48491: PPUSH
48492: CALL_OW 88
// Say ( good_pat , D9-1-PatGood-4 ) ;
48496: LD_EXP 18
48500: PPUSH
48501: LD_STRING D9-1-PatGood-4
48503: PPUSH
48504: CALL_OW 88
// boyfriend_identified = true ;
48508: LD_ADDR_EXP 106
48512: PUSH
48513: LD_INT 1
48515: ST_TO_ADDR
// pats_know_about_boyfriend = true ;
48516: LD_ADDR_VAR 0 7
48520: PUSH
48521: LD_INT 1
48523: ST_TO_ADDR
// end ; 2 :
48524: GO 48684
48526: LD_INT 2
48528: DOUBLE
48529: EQUAL
48530: IFTRUE 48534
48532: GO 48636
48534: POP
// begin case heike_parking_spot of 1 :
48535: LD_EXP 72
48539: PUSH
48540: LD_INT 1
48542: DOUBLE
48543: EQUAL
48544: IFTRUE 48548
48546: GO 48563
48548: POP
// Say ( Heike , D9-2-H-1a ) ; 2 :
48549: LD_EXP 7
48553: PPUSH
48554: LD_STRING D9-2-H-1a
48556: PPUSH
48557: CALL_OW 88
48561: GO 48610
48563: LD_INT 2
48565: DOUBLE
48566: EQUAL
48567: IFTRUE 48571
48569: GO 48586
48571: POP
// Say ( Heike , D9-2-H-1b ) ; 3 :
48572: LD_EXP 7
48576: PPUSH
48577: LD_STRING D9-2-H-1b
48579: PPUSH
48580: CALL_OW 88
48584: GO 48610
48586: LD_INT 3
48588: DOUBLE
48589: EQUAL
48590: IFTRUE 48594
48592: GO 48609
48594: POP
// Say ( Heike , D9-2-H-1c ) ; end ;
48595: LD_EXP 7
48599: PPUSH
48600: LD_STRING D9-2-H-1c
48602: PPUSH
48603: CALL_OW 88
48607: GO 48610
48609: POP
// Say ( good_pat , D9-2-PatGood-1 ) ;
48610: LD_EXP 18
48614: PPUSH
48615: LD_STRING D9-2-PatGood-1
48617: PPUSH
48618: CALL_OW 88
// Say ( Heike , D9-2-H-2 ) ;
48622: LD_EXP 7
48626: PPUSH
48627: LD_STRING D9-2-H-2
48629: PPUSH
48630: CALL_OW 88
// end ; 3 :
48634: GO 48684
48636: LD_INT 3
48638: DOUBLE
48639: EQUAL
48640: IFTRUE 48644
48642: GO 48683
48644: POP
// begin Say ( Heike , D9-3-H-1 ) ;
48645: LD_EXP 7
48649: PPUSH
48650: LD_STRING D9-3-H-1
48652: PPUSH
48653: CALL_OW 88
// Say ( good_pat , D9-3-PatGood-1 ) ;
48657: LD_EXP 18
48661: PPUSH
48662: LD_STRING D9-3-PatGood-1
48664: PPUSH
48665: CALL_OW 88
// Say ( Heike , D9-3-H-2 ) ;
48669: LD_EXP 7
48673: PPUSH
48674: LD_STRING D9-3-H-2
48676: PPUSH
48677: CALL_OW 88
// end ; end ;
48681: GO 48684
48683: POP
// DialogueOff ;
48684: CALL_OW 7
// if halt_internal_patrol = 2 then
48688: LD_EXP 81
48692: PUSH
48693: LD_INT 2
48695: EQUAL
48696: IFFALSE 48706
// halt_internal_patrol = 0 ;
48698: LD_ADDR_EXP 81
48702: PUSH
48703: LD_INT 0
48705: ST_TO_ADDR
// continue ;
48706: GO 47450
// end ; if tick - before_parking_seen_tick >= 1 1$0 and before_parking_dialogue_num = 1 then
48708: LD_OWVAR 1
48712: PUSH
48713: LD_VAR 0 4
48717: MINUS
48718: PUSH
48719: LD_INT 2100
48721: GREATEREQUAL
48722: PUSH
48723: LD_VAR 0 5
48727: PUSH
48728: LD_INT 1
48730: EQUAL
48731: AND
48732: IFFALSE 48847
// begin halt_internal_patrol = 2 ;
48734: LD_ADDR_EXP 81
48738: PUSH
48739: LD_INT 2
48741: ST_TO_ADDR
// ComTurnUnit ( good_pat , Heike ) ;
48742: LD_EXP 18
48746: PPUSH
48747: LD_EXP 7
48751: PPUSH
48752: CALL_OW 119
// ComturnUnit ( bad_pat , Heike ) ;
48756: LD_EXP 19
48760: PPUSH
48761: LD_EXP 7
48765: PPUSH
48766: CALL_OW 119
// wait ( 25 ) ;
48770: LD_INT 25
48772: PPUSH
48773: CALL_OW 67
// CenterOnUnits ( [ good_pat , bad_pat ] ) ;
48777: LD_EXP 18
48781: PUSH
48782: LD_EXP 19
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: PPUSH
48791: CALL_OW 85
// DialogueOn ;
48795: CALL_OW 6
// Say ( bad_pat , D9-PatBad-1 ) ;
48799: LD_EXP 19
48803: PPUSH
48804: LD_STRING D9-PatBad-1
48806: PPUSH
48807: CALL_OW 88
// DWait ( 0 0$0.5 ) ;
48811: LD_INT 18
48813: PPUSH
48814: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
48818: LD_STRING HeikeCaptive
48820: PPUSH
48821: CALL_OW 104
// DialogueOff ;
48825: CALL_OW 7
// if halt_internal_patrol = 2 then
48829: LD_EXP 81
48833: PUSH
48834: LD_INT 2
48836: EQUAL
48837: IFFALSE 48847
// halt_internal_patrol = 0 ;
48839: LD_ADDR_EXP 81
48843: PUSH
48844: LD_INT 0
48846: ST_TO_ADDR
// end ; end ; end else
48847: GO 49327
// begin if intel_party_vehicles > 0 and not intel_party_leave then
48849: LD_EXP 114
48853: PUSH
48854: LD_INT 0
48856: GREATER
48857: PUSH
48858: LD_EXP 117
48862: NOT
48863: AND
48864: IFFALSE 48876
// reprimand_tick = tick ;
48866: LD_ADDR_VAR 0 9
48870: PUSH
48871: LD_OWVAR 1
48875: ST_TO_ADDR
// if GuardsCanSeeHeike and tick - reprimand_tick >= 0 0$30 and tick - heike_last_exit_building_tick >= reenter_building_cooldown + 0 0$3 then
48876: CALL 49334 0 0
48880: PUSH
48881: LD_OWVAR 1
48885: PUSH
48886: LD_VAR 0 9
48890: MINUS
48891: PUSH
48892: LD_INT 1050
48894: GREATEREQUAL
48895: AND
48896: PUSH
48897: LD_OWVAR 1
48901: PUSH
48902: LD_EXP 108
48906: MINUS
48907: PUSH
48908: LD_EXP 109
48912: PUSH
48913: LD_INT 105
48915: PLUS
48916: GREATEREQUAL
48917: AND
48918: IFFALSE 49327
// begin if times_heike_seen_after_parking > 0 then
48920: LD_VAR 0 8
48924: PUSH
48925: LD_INT 0
48927: GREATER
48928: IFFALSE 48973
// begin halt_internal_patrol = 2 ;
48930: LD_ADDR_EXP 81
48934: PUSH
48935: LD_INT 2
48937: ST_TO_ADDR
// ComTurnUnit ( good_pat , Heike ) ;
48938: LD_EXP 18
48942: PPUSH
48943: LD_EXP 7
48947: PPUSH
48948: CALL_OW 119
// ComturnUnit ( bad_pat , Heike ) ;
48952: LD_EXP 19
48956: PPUSH
48957: LD_EXP 7
48961: PPUSH
48962: CALL_OW 119
// wait ( 25 ) ;
48966: LD_INT 25
48968: PPUSH
48969: CALL_OW 67
// end ; case times_heike_seen_after_parking of 0 :
48973: LD_VAR 0 8
48977: PUSH
48978: LD_INT 0
48980: DOUBLE
48981: EQUAL
48982: IFTRUE 48986
48984: GO 49063
48986: POP
// begin DialogueOn ;
48987: CALL_OW 6
// if Rand ( 1 , 2 ) = 1 then
48991: LD_INT 1
48993: PPUSH
48994: LD_INT 2
48996: PPUSH
48997: CALL_OW 12
49001: PUSH
49002: LD_INT 1
49004: EQUAL
49005: IFFALSE 49033
// begin Say ( bad_pat , D19-a-PatBad-1 ) ;
49007: LD_EXP 19
49011: PPUSH
49012: LD_STRING D19-a-PatBad-1
49014: PPUSH
49015: CALL_OW 88
// Say ( good_pat , D19-a-PatGood-1 ) ;
49019: LD_EXP 18
49023: PPUSH
49024: LD_STRING D19-a-PatGood-1
49026: PPUSH
49027: CALL_OW 88
// end else
49031: GO 49057
// begin Say ( bad_pat , D19-b-PatBad-1 ) ;
49033: LD_EXP 19
49037: PPUSH
49038: LD_STRING D19-b-PatBad-1
49040: PPUSH
49041: CALL_OW 88
// Say ( good_pat , D19-b-PatGood-1 ) ;
49045: LD_EXP 18
49049: PPUSH
49050: LD_STRING D19-b-PatGood-1
49052: PPUSH
49053: CALL_OW 88
// end ; DialogueOff ;
49057: CALL_OW 7
// end ; 1 :
49061: GO 49285
49063: LD_INT 1
49065: DOUBLE
49066: EQUAL
49067: IFTRUE 49071
49069: GO 49142
49071: POP
// begin CenterOnUnits ( [ good_pat , bad_pat ] ) ;
49072: LD_EXP 18
49076: PUSH
49077: LD_EXP 19
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: PPUSH
49086: CALL_OW 85
// DialogueOn ;
49090: CALL_OW 6
// if Rand ( 1 , 2 ) = 1 then
49094: LD_INT 1
49096: PPUSH
49097: LD_INT 2
49099: PPUSH
49100: CALL_OW 12
49104: PUSH
49105: LD_INT 1
49107: EQUAL
49108: IFFALSE 49124
// Say ( bad_pat , D19-c-PatBad-1 ) else
49110: LD_EXP 19
49114: PPUSH
49115: LD_STRING D19-c-PatBad-1
49117: PPUSH
49118: CALL_OW 88
49122: GO 49136
// Say ( bad_pat , D19-d-PatBad-1 ) ;
49124: LD_EXP 19
49128: PPUSH
49129: LD_STRING D19-d-PatBad-1
49131: PPUSH
49132: CALL_OW 88
// DialogueOff ;
49136: CALL_OW 7
// end ; 2 :
49140: GO 49285
49142: LD_INT 2
49144: DOUBLE
49145: EQUAL
49146: IFTRUE 49150
49148: GO 49221
49150: POP
// begin CenterOnUnits ( [ good_pat , bad_pat ] ) ;
49151: LD_EXP 18
49155: PUSH
49156: LD_EXP 19
49160: PUSH
49161: EMPTY
49162: LIST
49163: LIST
49164: PPUSH
49165: CALL_OW 85
// DialogueOn ;
49169: CALL_OW 6
// if Rand ( 1 , 2 ) = 1 then
49173: LD_INT 1
49175: PPUSH
49176: LD_INT 2
49178: PPUSH
49179: CALL_OW 12
49183: PUSH
49184: LD_INT 1
49186: EQUAL
49187: IFFALSE 49203
// Say ( bad_pat , D19-e-PatBad-1 ) else
49189: LD_EXP 19
49193: PPUSH
49194: LD_STRING D19-e-PatBad-1
49196: PPUSH
49197: CALL_OW 88
49201: GO 49215
// Say ( bad_pat , D19-f-PatBad-1 ) ;
49203: LD_EXP 19
49207: PPUSH
49208: LD_STRING D19-f-PatBad-1
49210: PPUSH
49211: CALL_OW 88
// DialogueOff ;
49215: CALL_OW 7
// end ; 3 :
49219: GO 49285
49221: LD_INT 3
49223: DOUBLE
49224: EQUAL
49225: IFTRUE 49229
49227: GO 49284
49229: POP
// begin CenterOnUnits ( [ good_pat , bad_pat ] ) ;
49230: LD_EXP 18
49234: PUSH
49235: LD_EXP 19
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: PPUSH
49244: CALL_OW 85
// DialogueOn ;
49248: CALL_OW 6
// Say ( bad_pat , D19-g-PatBad-1 ) ;
49252: LD_EXP 19
49256: PPUSH
49257: LD_STRING D19-g-PatBad-1
49259: PPUSH
49260: CALL_OW 88
// DWait ( 0 0$0.5 ) ;
49264: LD_INT 18
49266: PPUSH
49267: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
49271: LD_STRING HeikeCaptive
49273: PPUSH
49274: CALL_OW 104
// DialogueOff ;
49278: CALL_OW 7
// end ; end ;
49282: GO 49285
49284: POP
// times_heike_seen_after_parking = times_heike_seen_after_parking + 1 ;
49285: LD_ADDR_VAR 0 8
49289: PUSH
49290: LD_VAR 0 8
49294: PUSH
49295: LD_INT 1
49297: PLUS
49298: ST_TO_ADDR
// reprimand_tick = tick ;
49299: LD_ADDR_VAR 0 9
49303: PUSH
49304: LD_OWVAR 1
49308: ST_TO_ADDR
// if halt_internal_patrol = 2 then
49309: LD_EXP 81
49313: PUSH
49314: LD_INT 2
49316: EQUAL
49317: IFFALSE 49327
// halt_internal_patrol = 0 ;
49319: LD_ADDR_EXP 81
49323: PUSH
49324: LD_INT 0
49326: ST_TO_ADDR
// end ; end ; until false ;
49327: LD_INT 0
49329: IFFALSE 47450
// end ;
49331: PPOPN 9
49333: END
// function GuardsCanSeeHeike ; var i ; begin
49334: LD_INT 0
49336: PPUSH
49337: PPUSH
// result = false ;
49338: LD_ADDR_VAR 0 1
49342: PUSH
49343: LD_INT 0
49345: ST_TO_ADDR
// for i in [ good_pat , bad_pat ] do
49346: LD_ADDR_VAR 0 2
49350: PUSH
49351: LD_EXP 18
49355: PUSH
49356: LD_EXP 19
49360: PUSH
49361: EMPTY
49362: LIST
49363: LIST
49364: PUSH
49365: FOR_IN
49366: IFFALSE 49435
// if See ( you , i ) and GetDistUnits ( i , Heike ) <= [ 8 , 9 , 10 ] [ difficulty ] then
49368: LD_EXP 2
49372: PPUSH
49373: LD_VAR 0 2
49377: PPUSH
49378: CALL_OW 292
49382: PUSH
49383: LD_VAR 0 2
49387: PPUSH
49388: LD_EXP 7
49392: PPUSH
49393: CALL_OW 296
49397: PUSH
49398: LD_INT 8
49400: PUSH
49401: LD_INT 9
49403: PUSH
49404: LD_INT 10
49406: PUSH
49407: EMPTY
49408: LIST
49409: LIST
49410: LIST
49411: PUSH
49412: LD_OWVAR 67
49416: ARRAY
49417: LESSEQUAL
49418: AND
49419: IFFALSE 49433
// begin result = true ;
49421: LD_ADDR_VAR 0 1
49425: PUSH
49426: LD_INT 1
49428: ST_TO_ADDR
// exit ;
49429: POP
49430: POP
49431: GO 49437
// end ;
49433: GO 49365
49435: POP
49436: POP
// end ;
49437: LD_VAR 0 1
49441: RET
// every 0 0$1 + 0 0$0.6 do var i , max_dist , min_dist , temp_list , un ; var first_time ;
49442: GO 49444
49444: DISABLE
49445: LD_INT 0
49447: PPUSH
49448: PPUSH
49449: PPUSH
49450: PPUSH
49451: PPUSH
49452: PPUSH
// begin first_time = true ;
49453: LD_ADDR_VAR 0 6
49457: PUSH
49458: LD_INT 1
49460: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
49461: LD_INT 35
49463: PPUSH
49464: CALL_OW 67
// if UnitFilter ( [ Dmitri , Sergei , Yann ] , [ f_alive ] ) < 3 or heike_undercover in [ 3 , 4 ] then
49468: LD_EXP 20
49472: PUSH
49473: LD_EXP 21
49477: PUSH
49478: LD_EXP 22
49482: PUSH
49483: EMPTY
49484: LIST
49485: LIST
49486: LIST
49487: PPUSH
49488: LD_INT 51
49490: PUSH
49491: EMPTY
49492: LIST
49493: PPUSH
49494: CALL_OW 72
49498: PUSH
49499: LD_INT 3
49501: LESS
49502: PUSH
49503: LD_EXP 83
49507: PUSH
49508: LD_INT 3
49510: PUSH
49511: LD_INT 4
49513: PUSH
49514: EMPTY
49515: LIST
49516: LIST
49517: IN
49518: OR
49519: IFFALSE 49523
// exit ;
49521: GO 52557
// if UnitFilter ( [ Dmitri , Sergei , Yann ] , [ [ f_ok ] , [ f_distxy , 59 , 13 , 2 ] ] ) < 3 or code_black or heike_undercover in [ 0 , 1 ] or not Yakov_luring in [ 0 , 4 ] or not IsOk ( the_archive ) then
49523: LD_EXP 20
49527: PUSH
49528: LD_EXP 21
49532: PUSH
49533: LD_EXP 22
49537: PUSH
49538: EMPTY
49539: LIST
49540: LIST
49541: LIST
49542: PPUSH
49543: LD_INT 50
49545: PUSH
49546: EMPTY
49547: LIST
49548: PUSH
49549: LD_INT 92
49551: PUSH
49552: LD_INT 59
49554: PUSH
49555: LD_INT 13
49557: PUSH
49558: LD_INT 2
49560: PUSH
49561: EMPTY
49562: LIST
49563: LIST
49564: LIST
49565: LIST
49566: PUSH
49567: EMPTY
49568: LIST
49569: LIST
49570: PPUSH
49571: CALL_OW 72
49575: PUSH
49576: LD_INT 3
49578: LESS
49579: PUSH
49580: LD_EXP 77
49584: OR
49585: PUSH
49586: LD_EXP 83
49590: PUSH
49591: LD_INT 0
49593: PUSH
49594: LD_INT 1
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: IN
49601: OR
49602: PUSH
49603: LD_EXP 113
49607: PUSH
49608: LD_INT 0
49610: PUSH
49611: LD_INT 4
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: IN
49618: NOT
49619: OR
49620: PUSH
49621: LD_EXP 75
49625: PPUSH
49626: CALL_OW 302
49630: NOT
49631: OR
49632: IFFALSE 49636
// continue ;
49634: GO 49461
// temp_list = [ ] ;
49636: LD_ADDR_VAR 0 4
49640: PUSH
49641: EMPTY
49642: ST_TO_ADDR
// for i in patrols do
49643: LD_ADDR_VAR 0 1
49647: PUSH
49648: LD_EXP 78
49652: PUSH
49653: FOR_IN
49654: IFFALSE 49674
// temp_list = temp_list ^ i ;
49656: LD_ADDR_VAR 0 4
49660: PUSH
49661: LD_VAR 0 4
49665: PUSH
49666: LD_VAR 0 1
49670: ADD
49671: ST_TO_ADDR
49672: GO 49653
49674: POP
49675: POP
// if ( temp_list diff [ Dmitri , Sergei , Yann ] ) < temp_list then
49676: LD_VAR 0 4
49680: PUSH
49681: LD_EXP 20
49685: PUSH
49686: LD_EXP 21
49690: PUSH
49691: LD_EXP 22
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: LIST
49700: DIFF
49701: PUSH
49702: LD_VAR 0 4
49706: LESS
49707: IFFALSE 49711
// continue ;
49709: GO 49461
// if first_time then
49711: LD_VAR 0 6
49715: IFFALSE 49795
// begin if IsInUnit ( Heike ) = 0 and GetDistUnitXY ( Heike , 59 , 13 ) <= 8 then
49717: LD_EXP 7
49721: PPUSH
49722: CALL_OW 310
49726: PUSH
49727: LD_INT 0
49729: EQUAL
49730: PUSH
49731: LD_EXP 7
49735: PPUSH
49736: LD_INT 59
49738: PPUSH
49739: LD_INT 13
49741: PPUSH
49742: CALL_OW 297
49746: PUSH
49747: LD_INT 8
49749: LESSEQUAL
49750: AND
49751: IFFALSE 49793
// begin first_time = false ;
49753: LD_ADDR_VAR 0 6
49757: PUSH
49758: LD_INT 0
49760: ST_TO_ADDR
// DialogueOn ;
49761: CALL_OW 6
// Say ( Dmitri , D11-Dmitri-1 ) ;
49765: LD_EXP 20
49769: PPUSH
49770: LD_STRING D11-Dmitri-1
49772: PPUSH
49773: CALL_OW 88
// Say ( Sergei , D11-Sergei-1 ) ;
49777: LD_EXP 21
49781: PPUSH
49782: LD_STRING D11-Sergei-1
49784: PPUSH
49785: CALL_OW 88
// DialogueOff ;
49789: CALL_OW 7
// end ; end else
49793: GO 52553
// begin if IsInUnit ( Heike ) = 0 and GetDistUnitXY ( Heike , 59 , 13 ) <= 3 then
49795: LD_EXP 7
49799: PPUSH
49800: CALL_OW 310
49804: PUSH
49805: LD_INT 0
49807: EQUAL
49808: PUSH
49809: LD_EXP 7
49813: PPUSH
49814: LD_INT 59
49816: PPUSH
49817: LD_INT 13
49819: PPUSH
49820: CALL_OW 297
49824: PUSH
49825: LD_INT 3
49827: LESSEQUAL
49828: AND
49829: IFFALSE 52553
// begin F_InGameOn ;
49831: CALL 68232 0 0
// ComTurnXY ( Heike , 59 , 13 ) ;
49835: LD_EXP 7
49839: PPUSH
49840: LD_INT 59
49842: PPUSH
49843: LD_INT 13
49845: PPUSH
49846: CALL_OW 118
// for i in [ Dmitri , Sergei , Yann ] do
49850: LD_ADDR_VAR 0 1
49854: PUSH
49855: LD_EXP 20
49859: PUSH
49860: LD_EXP 21
49864: PUSH
49865: LD_EXP 22
49869: PUSH
49870: EMPTY
49871: LIST
49872: LIST
49873: LIST
49874: PUSH
49875: FOR_IN
49876: IFFALSE 49894
// ComTurnUnit ( i , Heike ) ;
49878: LD_VAR 0 1
49882: PPUSH
49883: LD_EXP 7
49887: PPUSH
49888: CALL_OW 119
49892: GO 49875
49894: POP
49895: POP
// wait ( 0 0$0.5 ) ;
49896: LD_INT 18
49898: PPUSH
49899: CALL_OW 67
// CenterOnXY ( 59 , 13 ) ;
49903: LD_INT 59
49905: PPUSH
49906: LD_INT 13
49908: PPUSH
49909: CALL_OW 84
// DialogueOn ;
49913: CALL_OW 6
// Say ( Dmitri , D11-Dmitri-2 ) ;
49917: LD_EXP 20
49921: PPUSH
49922: LD_STRING D11-Dmitri-2
49924: PPUSH
49925: CALL_OW 88
// Say ( Heike , D11-H-1 ) ;
49929: LD_EXP 7
49933: PPUSH
49934: LD_STRING D11-H-1
49936: PPUSH
49937: CALL_OW 88
// Say ( Dmitri , D11-Dmitri-3 ) ;
49941: LD_EXP 20
49945: PPUSH
49946: LD_STRING D11-Dmitri-3
49948: PPUSH
49949: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
49953: LD_INT 10
49955: PPUSH
49956: CALL_OW 68
// case Query ( QShootingGalleryName ) of 1 :
49960: LD_STRING QShootingGalleryName
49962: PPUSH
49963: CALL_OW 97
49967: PUSH
49968: LD_INT 1
49970: DOUBLE
49971: EQUAL
49972: IFTRUE 49976
49974: GO 50152
49976: POP
// begin Say ( Heike , D11-1-H-1 ) ;
49977: LD_EXP 7
49981: PPUSH
49982: LD_STRING D11-1-H-1
49984: PPUSH
49985: CALL_OW 88
// Say ( Yann , D11-1-SolOtherShooting-1 ) ;
49989: LD_EXP 22
49993: PPUSH
49994: LD_STRING D11-1-SolOtherShooting-1
49996: PPUSH
49997: CALL_OW 88
// Say ( Dmitri , D11-1-Dmitri-1 ) ;
50001: LD_EXP 20
50005: PPUSH
50006: LD_STRING D11-1-Dmitri-1
50008: PPUSH
50009: CALL_OW 88
// Say ( Yann , D11-1-SolOtherShooting-2 ) ;
50013: LD_EXP 22
50017: PPUSH
50018: LD_STRING D11-1-SolOtherShooting-2
50020: PPUSH
50021: CALL_OW 88
// Say ( Sergei , D11-1-Sergei-1 ) ;
50025: LD_EXP 21
50029: PPUSH
50030: LD_STRING D11-1-Sergei-1
50032: PPUSH
50033: CALL_OW 88
// Say ( Dmitri , D11-1-Dmitri-2 ) ;
50037: LD_EXP 20
50041: PPUSH
50042: LD_STRING D11-1-Dmitri-2
50044: PPUSH
50045: CALL_OW 88
// Say ( Yann , D11-1-SolOtherShooting-3 ) ;
50049: LD_EXP 22
50053: PPUSH
50054: LD_STRING D11-1-SolOtherShooting-3
50056: PPUSH
50057: CALL_OW 88
// Say ( Heike , D11-1-H-2 ) ;
50061: LD_EXP 7
50065: PPUSH
50066: LD_STRING D11-1-H-2
50068: PPUSH
50069: CALL_OW 88
// Say ( Dmitri , D11-1-Dmitri-3 ) ;
50073: LD_EXP 20
50077: PPUSH
50078: LD_STRING D11-1-Dmitri-3
50080: PPUSH
50081: CALL_OW 88
// boyfriend_identified = true ;
50085: LD_ADDR_EXP 106
50089: PUSH
50090: LD_INT 1
50092: ST_TO_ADDR
// DialogueOff ;
50093: CALL_OW 7
// F_InGameOff ;
50097: CALL 68468 0 0
// for i in [ Yann , Dmitri , Sergei ] do
50101: LD_ADDR_VAR 0 1
50105: PUSH
50106: LD_EXP 22
50110: PUSH
50111: LD_EXP 20
50115: PUSH
50116: LD_EXP 21
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: LIST
50125: PUSH
50126: FOR_IN
50127: IFFALSE 50146
// ComTurnXY ( i , 59 , 13 ) ;
50129: LD_VAR 0 1
50133: PPUSH
50134: LD_INT 59
50136: PPUSH
50137: LD_INT 13
50139: PPUSH
50140: CALL_OW 118
50144: GO 50126
50146: POP
50147: POP
// exit ;
50148: GO 52557
// end ; 2 :
50150: GO 50700
50152: LD_INT 2
50154: DOUBLE
50155: EQUAL
50156: IFTRUE 50160
50158: GO 50223
50160: POP
// begin Say ( Heike , D11-2-H-1 ) ;
50161: LD_EXP 7
50165: PPUSH
50166: LD_STRING D11-2-H-1
50168: PPUSH
50169: CALL_OW 88
// Say ( Sergei , D11-2-Sergei-1 ) ;
50173: LD_EXP 21
50177: PPUSH
50178: LD_STRING D11-2-Sergei-1
50180: PPUSH
50181: CALL_OW 88
// Say ( Dmitri , D11-2-Dmitri-1 ) ;
50185: LD_EXP 20
50189: PPUSH
50190: LD_STRING D11-2-Dmitri-1
50192: PPUSH
50193: CALL_OW 88
// Say ( Heike , D11-2-H-2 ) ;
50197: LD_EXP 7
50201: PPUSH
50202: LD_STRING D11-2-H-2
50204: PPUSH
50205: CALL_OW 88
// Say ( Dmitri , D11-2-Dmitri-2 ) ;
50209: LD_EXP 20
50213: PPUSH
50214: LD_STRING D11-2-Dmitri-2
50216: PPUSH
50217: CALL_OW 88
// end ; 3 :
50221: GO 50700
50223: LD_INT 3
50225: DOUBLE
50226: EQUAL
50227: IFTRUE 50231
50229: GO 50699
50231: POP
// begin Say ( Heike , D11-3-H-1 ) ;
50232: LD_EXP 7
50236: PPUSH
50237: LD_STRING D11-3-H-1
50239: PPUSH
50240: CALL_OW 88
// Say ( Dmitri , D11-3-Dmitri-1 ) ;
50244: LD_EXP 20
50248: PPUSH
50249: LD_STRING D11-3-Dmitri-1
50251: PPUSH
50252: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
50256: LD_INT 10
50258: PPUSH
50259: CALL_OW 68
// if Query ( QShootingGalleryCompetition ) = 2 then
50263: LD_STRING QShootingGalleryCompetition
50265: PPUSH
50266: CALL_OW 97
50270: PUSH
50271: LD_INT 2
50273: EQUAL
50274: IFFALSE 50310
// begin Say ( Heike , D11-32-H1 ) ;
50276: LD_EXP 7
50280: PPUSH
50281: LD_STRING D11-32-H1
50283: PPUSH
50284: CALL_OW 88
// Say ( Sergei , D11-32-Sergei-1 ) ;
50288: LD_EXP 21
50292: PPUSH
50293: LD_STRING D11-32-Sergei-1
50295: PPUSH
50296: CALL_OW 88
// DialogueOff ;
50300: CALL_OW 7
// F_InGameOff ;
50304: CALL 68468 0 0
// exit ;
50308: GO 52557
// end ; Say ( Heike , D11-31-H-1 ) ;
50310: LD_EXP 7
50314: PPUSH
50315: LD_STRING D11-31-H-1
50317: PPUSH
50318: CALL_OW 88
// Say ( Yann , D11-31-SolOtherShooting-1 ) ;
50322: LD_EXP 22
50326: PPUSH
50327: LD_STRING D11-31-SolOtherShooting-1
50329: PPUSH
50330: CALL_OW 88
// Say ( Dmitri , D11-31-Dmitri-1 ) ;
50334: LD_EXP 20
50338: PPUSH
50339: LD_STRING D11-31-Dmitri-1
50341: PPUSH
50342: CALL_OW 88
// CenterOnXY ( 63 , 11 ) ;
50346: LD_INT 63
50348: PPUSH
50349: LD_INT 11
50351: PPUSH
50352: CALL_OW 84
// DialogueOff ;
50356: CALL_OW 7
// ExclusiveOn ;
50360: CALL_OW 4
// ComAttackPlace ( Dmitri , 65 , 14 ) ;
50364: LD_EXP 20
50368: PPUSH
50369: LD_INT 65
50371: PPUSH
50372: LD_INT 14
50374: PPUSH
50375: CALL_OW 116
// repeat wait ( 0 0$0.2 ) ;
50379: LD_INT 7
50381: PPUSH
50382: CALL_OW 67
// until GetResourceAmountXY ( 65 , 14 ) = 0 ;
50386: LD_INT 65
50388: PPUSH
50389: LD_INT 14
50391: PPUSH
50392: CALL_OW 284
50396: PUSH
50397: LD_INT 0
50399: EQUAL
50400: IFFALSE 50379
// ComAttackPlace ( Dmitri , 67 , 14 ) ;
50402: LD_EXP 20
50406: PPUSH
50407: LD_INT 67
50409: PPUSH
50410: LD_INT 14
50412: PPUSH
50413: CALL_OW 116
// repeat wait ( 0 0$0.2 ) ;
50417: LD_INT 7
50419: PPUSH
50420: CALL_OW 67
// until GetResourceAmountXY ( 67 , 14 ) = 0 ;
50424: LD_INT 67
50426: PPUSH
50427: LD_INT 14
50429: PPUSH
50430: CALL_OW 284
50434: PUSH
50435: LD_INT 0
50437: EQUAL
50438: IFFALSE 50417
// wait ( 0 0$0.5 ) ;
50440: LD_INT 18
50442: PPUSH
50443: CALL_OW 67
// ComTurnUnit ( Dmitri , Heike ) ;
50447: LD_EXP 20
50451: PPUSH
50452: LD_EXP 7
50456: PPUSH
50457: CALL_OW 119
// wait ( 0 0$0.5 ) ;
50461: LD_INT 18
50463: PPUSH
50464: CALL_OW 67
// ComAttackPlace ( Heike , 61 , 7 ) ;
50468: LD_EXP 7
50472: PPUSH
50473: LD_INT 61
50475: PPUSH
50476: LD_INT 7
50478: PPUSH
50479: CALL_OW 116
// repeat wait ( 1 ) ;
50483: LD_INT 1
50485: PPUSH
50486: CALL_OW 67
// until Attacks ( Heike ) = - 1 ;
50490: LD_EXP 7
50494: PPUSH
50495: CALL_OW 320
50499: PUSH
50500: LD_INT 1
50502: NEG
50503: EQUAL
50504: IFFALSE 50483
// wait ( 40 ) ;
50506: LD_INT 40
50508: PPUSH
50509: CALL_OW 67
// ChangeResourceAmountXY ( 61 , 7 , 0 ) ;
50513: LD_INT 61
50515: PPUSH
50516: LD_INT 7
50518: PPUSH
50519: LD_INT 0
50521: PPUSH
50522: CALL_OW 285
// MineExplosion ( 61 , 7 , 0 ) ;
50526: LD_INT 61
50528: PPUSH
50529: LD_INT 7
50531: PPUSH
50532: LD_INT 0
50534: PPUSH
50535: CALL_OW 453
// wait ( 0 0$0.5 ) ;
50539: LD_INT 18
50541: PPUSH
50542: CALL_OW 67
// ComAttackPlace ( Heike , 62 , 6 ) ;
50546: LD_EXP 7
50550: PPUSH
50551: LD_INT 62
50553: PPUSH
50554: LD_INT 6
50556: PPUSH
50557: CALL_OW 116
// repeat wait ( 1 ) ;
50561: LD_INT 1
50563: PPUSH
50564: CALL_OW 67
// until Attacks ( Heike ) = - 1 ;
50568: LD_EXP 7
50572: PPUSH
50573: CALL_OW 320
50577: PUSH
50578: LD_INT 1
50580: NEG
50581: EQUAL
50582: IFFALSE 50561
// wait ( 40 ) ;
50584: LD_INT 40
50586: PPUSH
50587: CALL_OW 67
// ChangeResourceAmountXY ( 62 , 6 , 0 ) ;
50591: LD_INT 62
50593: PPUSH
50594: LD_INT 6
50596: PPUSH
50597: LD_INT 0
50599: PPUSH
50600: CALL_OW 285
// MineExplosion ( 62 , 6 , 0 ) ;
50604: LD_INT 62
50606: PPUSH
50607: LD_INT 6
50609: PPUSH
50610: LD_INT 0
50612: PPUSH
50613: CALL_OW 453
// wait ( 0 0$0.5 ) ;
50617: LD_INT 18
50619: PPUSH
50620: CALL_OW 67
// ComTurnUnit ( Heike , Dmitri ) ;
50624: LD_EXP 7
50628: PPUSH
50629: LD_EXP 20
50633: PPUSH
50634: CALL_OW 119
// wait ( 0 0$1.5 ) ;
50638: LD_INT 52
50640: PPUSH
50641: CALL_OW 67
// DialogueOn ;
50645: CALL_OW 6
// Say ( Sergei , D11-31-Sergei-1 ) ;
50649: LD_EXP 21
50653: PPUSH
50654: LD_STRING D11-31-Sergei-1
50656: PPUSH
50657: CALL_OW 88
// Say ( Dmitri , D11-31-Dmitri-2 ) ;
50661: LD_EXP 20
50665: PPUSH
50666: LD_STRING D11-31-Dmitri-2
50668: PPUSH
50669: CALL_OW 88
// Say ( Heike , D11-31-H-2 ) ;
50673: LD_EXP 7
50677: PPUSH
50678: LD_STRING D11-31-H-2
50680: PPUSH
50681: CALL_OW 88
// Say ( Dmitri , D11-31-Dmitri-3 ) ;
50685: LD_EXP 20
50689: PPUSH
50690: LD_STRING D11-31-Dmitri-3
50692: PPUSH
50693: CALL_OW 88
// end ; end ;
50697: GO 50700
50699: POP
// Say ( Dmitri , D11-2-Dmitri-3 ) ;
50700: LD_EXP 20
50704: PPUSH
50705: LD_STRING D11-2-Dmitri-3
50707: PPUSH
50708: CALL_OW 88
// temp_list = [ ] ;
50712: LD_ADDR_VAR 0 4
50716: PUSH
50717: EMPTY
50718: ST_TO_ADDR
// for i in ai_labs [ 1 ] do
50719: LD_ADDR_VAR 0 1
50723: PUSH
50724: LD_EXP 33
50728: PUSH
50729: LD_INT 1
50731: ARRAY
50732: PUSH
50733: FOR_IN
50734: IFFALSE 50765
// temp_list = temp_list ^ GetDistUnitXY ( i , 59 , 13 ) ;
50736: LD_ADDR_VAR 0 4
50740: PUSH
50741: LD_VAR 0 4
50745: PUSH
50746: LD_VAR 0 1
50750: PPUSH
50751: LD_INT 59
50753: PPUSH
50754: LD_INT 13
50756: PPUSH
50757: CALL_OW 297
50761: ADD
50762: ST_TO_ADDR
50763: GO 50733
50765: POP
50766: POP
// temp_list = SortListByListAsc ( ai_labs [ 1 ] , temp_list ) ;
50767: LD_ADDR_VAR 0 4
50771: PUSH
50772: LD_EXP 33
50776: PUSH
50777: LD_INT 1
50779: ARRAY
50780: PPUSH
50781: LD_VAR 0 4
50785: PPUSH
50786: CALL_OW 76
50790: ST_TO_ADDR
// max_dist = GetDistUnitXY ( temp_list [ temp_list + 0 ] , 59 , 13 ) ;
50791: LD_ADDR_VAR 0 2
50795: PUSH
50796: LD_VAR 0 4
50800: PUSH
50801: LD_VAR 0 4
50805: PUSH
50806: LD_INT 0
50808: PLUS
50809: ARRAY
50810: PPUSH
50811: LD_INT 59
50813: PPUSH
50814: LD_INT 13
50816: PPUSH
50817: CALL_OW 297
50821: ST_TO_ADDR
// min_dist = GetDistUnitXY ( temp_list [ 1 ] , 59 , 13 ) ;
50822: LD_ADDR_VAR 0 3
50826: PUSH
50827: LD_VAR 0 4
50831: PUSH
50832: LD_INT 1
50834: ARRAY
50835: PPUSH
50836: LD_INT 59
50838: PPUSH
50839: LD_INT 13
50841: PPUSH
50842: CALL_OW 297
50846: ST_TO_ADDR
// temp_list = [ ] ;
50847: LD_ADDR_VAR 0 4
50851: PUSH
50852: EMPTY
50853: ST_TO_ADDR
// i = GetDistUnitXY ( the_archive , 59 , 13 ) ;
50854: LD_ADDR_VAR 0 1
50858: PUSH
50859: LD_EXP 75
50863: PPUSH
50864: LD_INT 59
50866: PPUSH
50867: LD_INT 13
50869: PPUSH
50870: CALL_OW 297
50874: ST_TO_ADDR
// if i < max_dist then
50875: LD_VAR 0 1
50879: PUSH
50880: LD_VAR 0 2
50884: LESS
50885: IFFALSE 50901
// temp_list = temp_list ^ 1 ;
50887: LD_ADDR_VAR 0 4
50891: PUSH
50892: LD_VAR 0 4
50896: PUSH
50897: LD_INT 1
50899: ADD
50900: ST_TO_ADDR
// if i > min_dist then
50901: LD_VAR 0 1
50905: PUSH
50906: LD_VAR 0 3
50910: GREATER
50911: IFFALSE 50927
// temp_list = temp_list ^ 2 ;
50913: LD_ADDR_VAR 0 4
50917: PUSH
50918: LD_VAR 0 4
50922: PUSH
50923: LD_INT 2
50925: ADD
50926: ST_TO_ADDR
// if temp_list [ Rand ( 1 , temp_list ) ] = 1 then
50927: LD_VAR 0 4
50931: PUSH
50932: LD_INT 1
50934: PPUSH
50935: LD_VAR 0 4
50939: PPUSH
50940: CALL_OW 12
50944: ARRAY
50945: PUSH
50946: LD_INT 1
50948: EQUAL
50949: IFFALSE 50965
// Say ( Sergei , D11-2-Sergei-2a ) else
50951: LD_EXP 21
50955: PPUSH
50956: LD_STRING D11-2-Sergei-2a
50958: PPUSH
50959: CALL_OW 88
50963: GO 50977
// Say ( Sergei , D11-2-Sergei-2b ) ;
50965: LD_EXP 21
50969: PPUSH
50970: LD_STRING D11-2-Sergei-2b
50972: PPUSH
50973: CALL_OW 88
// Say ( Dmitri , D11-2-Dmitri-4 ) ;
50977: LD_EXP 20
50981: PPUSH
50982: LD_STRING D11-2-Dmitri-4
50984: PPUSH
50985: CALL_OW 88
// DWait ( 0 0$0.3 ) ;
50989: LD_INT 10
50991: PPUSH
50992: CALL_OW 68
// if Query ( QShootingGalleryOpportunity ) = 2 then
50996: LD_STRING QShootingGalleryOpportunity
50998: PPUSH
50999: CALL_OW 97
51003: PUSH
51004: LD_INT 2
51006: EQUAL
51007: IFFALSE 51187
// begin Say ( Heike , D11-22-H-1 ) ;
51009: LD_EXP 7
51013: PPUSH
51014: LD_STRING D11-22-H-1
51016: PPUSH
51017: CALL_OW 88
// Say ( Sergei , D11-22-Sergei-1 ) ;
51021: LD_EXP 21
51025: PPUSH
51026: LD_STRING D11-22-Sergei-1
51028: PPUSH
51029: CALL_OW 88
// Say ( Dmitri , D11-22-Dmitri-1 ) ;
51033: LD_EXP 20
51037: PPUSH
51038: LD_STRING D11-22-Dmitri-1
51040: PPUSH
51041: CALL_OW 88
// Say ( Yann , D11-22-SolOtherShooting-1 ) ;
51045: LD_EXP 22
51049: PPUSH
51050: LD_STRING D11-22-SolOtherShooting-1
51052: PPUSH
51053: CALL_OW 88
// DialogueOff ;
51057: CALL_OW 7
// ExclusiveOn ;
51061: CALL_OW 4
// for i in [ Yann , Dmitri , Sergei ] do
51065: LD_ADDR_VAR 0 1
51069: PUSH
51070: LD_EXP 22
51074: PUSH
51075: LD_EXP 20
51079: PUSH
51080: LD_EXP 21
51084: PUSH
51085: EMPTY
51086: LIST
51087: LIST
51088: LIST
51089: PUSH
51090: FOR_IN
51091: IFFALSE 51110
// ComTurnXY ( i , 59 , 13 ) ;
51093: LD_VAR 0 1
51097: PPUSH
51098: LD_INT 59
51100: PPUSH
51101: LD_INT 13
51103: PPUSH
51104: CALL_OW 118
51108: GO 51090
51110: POP
51111: POP
// i = 0 ;
51112: LD_ADDR_VAR 0 1
51116: PUSH
51117: LD_INT 0
51119: ST_TO_ADDR
// repeat ComMoveXY ( Heike , 56 , 15 ) ;
51120: LD_EXP 7
51124: PPUSH
51125: LD_INT 56
51127: PPUSH
51128: LD_INT 15
51130: PPUSH
51131: CALL_OW 111
// wait ( 0 0$0.5 ) ;
51135: LD_INT 18
51137: PPUSH
51138: CALL_OW 67
// i = i + 1 ;
51142: LD_ADDR_VAR 0 1
51146: PUSH
51147: LD_VAR 0 1
51151: PUSH
51152: LD_INT 1
51154: PLUS
51155: ST_TO_ADDR
// until not IsInArea ( Heike , weapon_test_area ) or i >= 10 ;
51156: LD_EXP 7
51160: PPUSH
51161: LD_INT 18
51163: PPUSH
51164: CALL_OW 308
51168: NOT
51169: PUSH
51170: LD_VAR 0 1
51174: PUSH
51175: LD_INT 10
51177: GREATEREQUAL
51178: OR
51179: IFFALSE 51120
// F_InGameOff ;
51181: CALL 68468 0 0
// exit ;
51185: GO 52557
// end ; Say ( Heike , D11-21-H-1 ) ;
51187: LD_EXP 7
51191: PPUSH
51192: LD_STRING D11-21-H-1
51194: PPUSH
51195: CALL_OW 88
// Say ( Dmitri , D11-21-Dmitri-1 ) ;
51199: LD_EXP 20
51203: PPUSH
51204: LD_STRING D11-21-Dmitri-1
51206: PPUSH
51207: CALL_OW 88
// Say ( Heike , D11-21-H-2 ) ;
51211: LD_EXP 7
51215: PPUSH
51216: LD_STRING D11-21-H-2
51218: PPUSH
51219: CALL_OW 88
// async ;
51223: ASYNC
// Say ( Sergei , D11-21-Sergei-1 ) ;
51224: LD_EXP 21
51228: PPUSH
51229: LD_STRING D11-21-Sergei-1
51231: PPUSH
51232: CALL_OW 88
// sync ;
51236: SYNC
// SayNoFace ( Yann , D11-21-SolOtherShooting-1 ) ;
51237: LD_EXP 22
51241: PPUSH
51242: LD_STRING D11-21-SolOtherShooting-1
51244: PPUSH
51245: CALL_OW 89
// Say ( Dmitri , D11-21-Dmitri-2 ) ;
51249: LD_EXP 20
51253: PPUSH
51254: LD_STRING D11-21-Dmitri-2
51256: PPUSH
51257: CALL_OW 88
// DialogueOff ;
51261: CALL_OW 7
// ExclusiveOn ;
51265: CALL_OW 4
// repeat CenterOnUnits ( Heike ) ;
51269: LD_EXP 7
51273: PPUSH
51274: CALL_OW 85
// ComEnterUnit ( Dmitri , the_archive ) ;
51278: LD_EXP 20
51282: PPUSH
51283: LD_EXP 75
51287: PPUSH
51288: CALL_OW 120
// i = AI_InvertDirection ( GetDir ( Dmitri ) ) ;
51292: LD_ADDR_VAR 0 1
51296: PUSH
51297: LD_EXP 20
51301: PPUSH
51302: CALL_OW 254
51306: PPUSH
51307: CALL 34263 0 1
51311: ST_TO_ADDR
// ComMoveXY ( Heike , ShiftX ( GetX ( Dmitri ) , i , 1 ) , ShiftY ( GetY ( Dmitri ) , i , 1 ) ) ;
51312: LD_EXP 7
51316: PPUSH
51317: LD_EXP 20
51321: PPUSH
51322: CALL_OW 250
51326: PPUSH
51327: LD_VAR 0 1
51331: PPUSH
51332: LD_INT 1
51334: PPUSH
51335: CALL_OW 272
51339: PPUSH
51340: LD_EXP 20
51344: PPUSH
51345: CALL_OW 251
51349: PPUSH
51350: LD_VAR 0 1
51354: PPUSH
51355: LD_INT 1
51357: PPUSH
51358: CALL_OW 273
51362: PPUSH
51363: CALL_OW 111
// if GetDistUnits ( Dmitri , the_archive ) <= 6 then
51367: LD_EXP 20
51371: PPUSH
51372: LD_EXP 75
51376: PPUSH
51377: CALL_OW 296
51381: PUSH
51382: LD_INT 6
51384: LESSEQUAL
51385: IFFALSE 51477
// begin temp_list = UnitsInside ( the_archive ) ;
51387: LD_ADDR_VAR 0 4
51391: PUSH
51392: LD_EXP 75
51396: PPUSH
51397: CALL_OW 313
51401: ST_TO_ADDR
// if temp_list = 6 then
51402: LD_VAR 0 4
51406: PUSH
51407: LD_INT 6
51409: EQUAL
51410: IFFALSE 51477
// begin un = 0 ;
51412: LD_ADDR_VAR 0 5
51416: PUSH
51417: LD_INT 0
51419: ST_TO_ADDR
// for i in temp_list do
51420: LD_ADDR_VAR 0 1
51424: PUSH
51425: LD_VAR 0 4
51429: PUSH
51430: FOR_IN
51431: IFFALSE 51459
// if i <> Barovnin then
51433: LD_VAR 0 1
51437: PUSH
51438: LD_EXP 13
51442: NONEQUAL
51443: IFFALSE 51457
// begin un = i ;
51445: LD_ADDR_VAR 0 5
51449: PUSH
51450: LD_VAR 0 1
51454: ST_TO_ADDR
// break ;
51455: GO 51459
// end ;
51457: GO 51430
51459: POP
51460: POP
// ComExitBuilding ( un ) ;
51461: LD_VAR 0 5
51465: PPUSH
51466: CALL_OW 122
// wait ( 3 ) ;
51470: LD_INT 3
51472: PPUSH
51473: CALL_OW 67
// end ; end ; wait ( 0 0$1 ) ;
51477: LD_INT 35
51479: PPUSH
51480: CALL_OW 67
// until IsInUnit ( Dmitri ) = the_archive ;
51484: LD_EXP 20
51488: PPUSH
51489: CALL_OW 310
51493: PUSH
51494: LD_EXP 75
51498: EQUAL
51499: IFFALSE 51269
// for i in [ Yann , Sergei ] do
51501: LD_ADDR_VAR 0 1
51505: PUSH
51506: LD_EXP 22
51510: PUSH
51511: LD_EXP 21
51515: PUSH
51516: EMPTY
51517: LIST
51518: LIST
51519: PUSH
51520: FOR_IN
51521: IFFALSE 51540
// ComTurnXY ( i , 59 , 13 ) ;
51523: LD_VAR 0 1
51527: PPUSH
51528: LD_INT 59
51530: PPUSH
51531: LD_INT 13
51533: PPUSH
51534: CALL_OW 118
51538: GO 51520
51540: POP
51541: POP
// player_units_in_russian_buildings = player_units_in_russian_buildings ^ [ [ Heike , the_archive ] ] ;
51542: LD_ADDR_EXP 88
51546: PUSH
51547: LD_EXP 88
51551: PUSH
51552: LD_EXP 7
51556: PUSH
51557: LD_EXP 75
51561: PUSH
51562: EMPTY
51563: LIST
51564: LIST
51565: PUSH
51566: EMPTY
51567: LIST
51568: ADD
51569: ST_TO_ADDR
// RemoveUnit ( Heike ) ;
51570: LD_EXP 7
51574: PPUSH
51575: CALL_OW 64
// PlaceSeeing ( GetX ( the_archive ) , GetY ( the_archive ) , you , - 7 ) ;
51579: LD_EXP 75
51583: PPUSH
51584: CALL_OW 250
51588: PPUSH
51589: LD_EXP 75
51593: PPUSH
51594: CALL_OW 251
51598: PPUSH
51599: LD_EXP 2
51603: PPUSH
51604: LD_INT 7
51606: NEG
51607: PPUSH
51608: CALL_OW 330
// wait ( 3 ) ;
51612: LD_INT 3
51614: PPUSH
51615: CALL_OW 67
// DialogueOn ;
51619: CALL_OW 6
// Say ( Dmitri , D11-21-Dmitri-3 ) ;
51623: LD_EXP 20
51627: PPUSH
51628: LD_STRING D11-21-Dmitri-3
51630: PPUSH
51631: CALL_OW 88
// Say ( Heike , D11-21-H-3 ) ;
51635: LD_EXP 7
51639: PPUSH
51640: LD_STRING D11-21-H-3
51642: PPUSH
51643: CALL_OW 88
// Say ( Dmitri , D11-21-Dmitri-4 ) ;
51647: LD_EXP 20
51651: PPUSH
51652: LD_STRING D11-21-Dmitri-4
51654: PPUSH
51655: CALL_OW 88
// Say ( Heike , D11-21-H-4 ) ;
51659: LD_EXP 7
51663: PPUSH
51664: LD_STRING D11-21-H-4
51666: PPUSH
51667: CALL_OW 88
// Say ( Dmitri , D11-21-Dmitri-5 ) ;
51671: LD_EXP 20
51675: PPUSH
51676: LD_STRING D11-21-Dmitri-5
51678: PPUSH
51679: CALL_OW 88
// Say ( Heike , D11-21-H-5 ) ;
51683: LD_EXP 7
51687: PPUSH
51688: LD_STRING D11-21-H-5
51690: PPUSH
51691: CALL_OW 88
// Say ( Dmitri , D11-21-Dmitri-6 ) ;
51695: LD_EXP 20
51699: PPUSH
51700: LD_STRING D11-21-Dmitri-6
51702: PPUSH
51703: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
51707: LD_INT 10
51709: PPUSH
51710: CALL_OW 68
// if Query ( QShootingGalleryKill ) = 1 then
51714: LD_STRING QShootingGalleryKill
51716: PPUSH
51717: CALL_OW 97
51721: PUSH
51722: LD_INT 1
51724: EQUAL
51725: IFFALSE 52090
// begin RemoveHumanFromVariables ( 1 , Dmitri , true ) ;
51727: LD_INT 1
51729: PPUSH
51730: LD_EXP 20
51734: PPUSH
51735: LD_INT 1
51737: PPUSH
51738: CALL 10822 0 3
// DestroyUnit ( Dmitri ) ;
51742: LD_EXP 20
51746: PPUSH
51747: CALL_OW 65
// SayEffect ( D11-211-Effect-1 ) ;
51751: LD_STRING D11-211-Effect-1
51753: PPUSH
51754: CALL_OW 96
// dwait ( 0 0$1 ) ;
51758: LD_INT 35
51760: PPUSH
51761: CALL_OW 68
// temp_list = UnitsInside ( the_archive ) ;
51765: LD_ADDR_VAR 0 4
51769: PUSH
51770: LD_EXP 75
51774: PPUSH
51775: CALL_OW 313
51779: ST_TO_ADDR
// if Barovnin in temp_list then
51780: LD_EXP 13
51784: PUSH
51785: LD_VAR 0 4
51789: IN
51790: IFFALSE 51806
// Say ( Barovnin , D11-211-Doc-1 ) else
51792: LD_EXP 13
51796: PPUSH
51797: LD_STRING D11-211-Doc-1
51799: PPUSH
51800: CALL_OW 88
51804: GO 51869
// if temp_list > 0 then
51806: LD_VAR 0 4
51810: PUSH
51811: LD_INT 0
51813: GREATER
51814: IFFALSE 51869
// if GetSex ( temp_list [ 1 ] ) = sex_male then
51816: LD_VAR 0 4
51820: PUSH
51821: LD_INT 1
51823: ARRAY
51824: PPUSH
51825: CALL_OW 258
51829: PUSH
51830: LD_INT 1
51832: EQUAL
51833: IFFALSE 51853
// Say ( temp_list [ 1 ] , D11-211-SciM-1 ) else
51835: LD_VAR 0 4
51839: PUSH
51840: LD_INT 1
51842: ARRAY
51843: PPUSH
51844: LD_STRING D11-211-SciM-1
51846: PPUSH
51847: CALL_OW 88
51851: GO 51869
// Say ( temp_list [ 1 ] , D11-211-SciF-1 ) ;
51853: LD_VAR 0 4
51857: PUSH
51858: LD_INT 1
51860: ARRAY
51861: PPUSH
51862: LD_STRING D11-211-SciF-1
51864: PPUSH
51865: CALL_OW 88
// archive_found = true ;
51869: LD_ADDR_EXP 100
51873: PUSH
51874: LD_INT 1
51876: ST_TO_ADDR
// DialogueOff ;
51877: CALL_OW 7
// F_InGameOff ;
51881: CALL 68468 0 0
// if temp_list > 0 then
51885: LD_VAR 0 4
51889: PUSH
51890: LD_INT 0
51892: GREATER
51893: IFFALSE 52088
// begin wait ( 0 0$5 ) ;
51895: LD_INT 175
51897: PPUSH
51898: CALL_OW 67
// DialogueOn ;
51902: CALL_OW 6
// if Barovnin in temp_list then
51906: LD_EXP 13
51910: PUSH
51911: LD_VAR 0 4
51915: IN
51916: IFFALSE 51955
// begin Say ( Barovnin , D11-211-Doc-2 ) ;
51918: LD_EXP 13
51922: PPUSH
51923: LD_STRING D11-211-Doc-2
51925: PPUSH
51926: CALL_OW 88
// temp_list = Replace ( temp_list , 1 , Barovnin ) ;
51930: LD_ADDR_VAR 0 4
51934: PUSH
51935: LD_VAR 0 4
51939: PPUSH
51940: LD_INT 1
51942: PPUSH
51943: LD_EXP 13
51947: PPUSH
51948: CALL_OW 1
51952: ST_TO_ADDR
// end else
51953: GO 52008
// if GetSex ( temp_list [ 1 ] ) = sex_male then
51955: LD_VAR 0 4
51959: PUSH
51960: LD_INT 1
51962: ARRAY
51963: PPUSH
51964: CALL_OW 258
51968: PUSH
51969: LD_INT 1
51971: EQUAL
51972: IFFALSE 51992
// Say ( temp_list [ 1 ] , D11-211-SciM-2 ) else
51974: LD_VAR 0 4
51978: PUSH
51979: LD_INT 1
51981: ARRAY
51982: PPUSH
51983: LD_STRING D11-211-SciM-2
51985: PPUSH
51986: CALL_OW 88
51990: GO 52008
// Say ( temp_list [ 1 ] , D11-211-SciF-2 ) ;
51992: LD_VAR 0 4
51996: PUSH
51997: LD_INT 1
51999: ARRAY
52000: PPUSH
52001: LD_STRING D11-211-SciF-2
52003: PPUSH
52004: CALL_OW 88
// DialogueOff ;
52008: CALL_OW 7
// repeat wait ( 0 0$2 ) ;
52012: LD_INT 70
52014: PPUSH
52015: CALL_OW 67
// until not code_black ;
52019: LD_EXP 77
52023: NOT
52024: IFFALSE 52012
// if IsDead ( temp_list [ 1 ] ) then
52026: LD_VAR 0 4
52030: PUSH
52031: LD_INT 1
52033: ARRAY
52034: PPUSH
52035: CALL_OW 301
52039: IFFALSE 52043
// exit ;
52041: GO 52557
// if heike_undercover <> 4 then
52043: LD_EXP 83
52047: PUSH
52048: LD_INT 4
52050: NONEQUAL
52051: IFFALSE 52080
// begin DialogueOn ;
52053: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-2b ) ;
52057: LD_EXP 14
52061: PPUSH
52062: LD_STRING D7-Leader-2b
52064: PPUSH
52065: CALL_OW 94
// DialogueOff ;
52069: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
52073: LD_INT 4
52075: PPUSH
52076: CALL 42004 0 1
// end ; code_black = true ;
52080: LD_ADDR_EXP 77
52084: PUSH
52085: LD_INT 1
52087: ST_TO_ADDR
// end ; exit ;
52088: GO 52557
// end ; Say ( Heike , D11-212-H-1 ) ;
52090: LD_EXP 7
52094: PPUSH
52095: LD_STRING D11-212-H-1
52097: PPUSH
52098: CALL_OW 88
// Say ( Dmitri , D11-212-Dmitri-1 ) ;
52102: LD_EXP 20
52106: PPUSH
52107: LD_STRING D11-212-Dmitri-1
52109: PPUSH
52110: CALL_OW 88
// archive_found = true ;
52114: LD_ADDR_EXP 100
52118: PUSH
52119: LD_INT 1
52121: ST_TO_ADDR
// except_Dmitri = true ;
52122: LD_ADDR_EXP 110
52126: PUSH
52127: LD_INT 1
52129: ST_TO_ADDR
// DialogueOff ;
52130: CALL_OW 7
// F_InGameOff ;
52134: CALL 68468 0 0
// repeat wait ( 0 0$1 ) ;
52138: LD_INT 35
52140: PPUSH
52141: CALL_OW 67
// if IsDead ( Dmitri ) then
52145: LD_EXP 20
52149: PPUSH
52150: CALL_OW 301
52154: IFFALSE 52158
// exit ;
52156: GO 52557
// un = IsInUnit ( Dmitri ) ;
52158: LD_ADDR_VAR 0 5
52162: PUSH
52163: LD_EXP 20
52167: PPUSH
52168: CALL_OW 310
52172: ST_TO_ADDR
// if un = leader_office then
52173: LD_VAR 0 5
52177: PUSH
52178: LD_EXP 93
52182: EQUAL
52183: IFFALSE 52189
// break else
52185: GO 52471
52187: GO 52252
// if un > 0 then
52189: LD_VAR 0 5
52193: PUSH
52194: LD_INT 0
52196: GREATER
52197: IFFALSE 52252
// begin case GetType ( un ) of unit_vehicle :
52199: LD_VAR 0 5
52203: PPUSH
52204: CALL_OW 247
52208: PUSH
52209: LD_INT 2
52211: DOUBLE
52212: EQUAL
52213: IFTRUE 52217
52215: GO 52229
52217: POP
// ComExitVehicle ( Dmitri ) ; unit_building :
52218: LD_EXP 20
52222: PPUSH
52223: CALL_OW 121
52227: GO 52250
52229: LD_INT 3
52231: DOUBLE
52232: EQUAL
52233: IFTRUE 52237
52235: GO 52249
52237: POP
// ComExitBuilding ( Dmitri ) ; end ;
52238: LD_EXP 20
52242: PPUSH
52243: CALL_OW 122
52247: GO 52250
52249: POP
// continue ;
52250: GO 52138
// end ; if IsOk ( leader_office ) then
52252: LD_EXP 93
52256: PPUSH
52257: CALL_OW 302
52261: IFFALSE 52279
// ComEnterUnit ( Dmitri , leader_office ) else
52263: LD_EXP 20
52267: PPUSH
52268: LD_EXP 93
52272: PPUSH
52273: CALL_OW 120
52277: GO 52357
// begin if GetDistUnitXY ( Dmitri , ai_human_pullback_hex [ 1 ] [ 1 ] , ai_human_pullback_hex [ 1 ] [ 2 ] ) <= 3 then
52279: LD_EXP 20
52283: PPUSH
52284: LD_EXP 40
52288: PUSH
52289: LD_INT 1
52291: ARRAY
52292: PUSH
52293: LD_INT 1
52295: ARRAY
52296: PPUSH
52297: LD_EXP 40
52301: PUSH
52302: LD_INT 1
52304: ARRAY
52305: PUSH
52306: LD_INT 2
52308: ARRAY
52309: PPUSH
52310: CALL_OW 297
52314: PUSH
52315: LD_INT 3
52317: LESSEQUAL
52318: IFFALSE 52322
// break ;
52320: GO 52471
// ComMoveXY ( Dmitri , ai_human_pullback_hex [ 1 ] [ 1 ] , ai_human_pullback_hex [ 1 ] [ 2 ] ) ;
52322: LD_EXP 20
52326: PPUSH
52327: LD_EXP 40
52331: PUSH
52332: LD_INT 1
52334: ARRAY
52335: PUSH
52336: LD_INT 1
52338: ARRAY
52339: PPUSH
52340: LD_EXP 40
52344: PUSH
52345: LD_INT 1
52347: ARRAY
52348: PUSH
52349: LD_INT 2
52351: ARRAY
52352: PPUSH
52353: CALL_OW 111
// end ; if GetDistUnits ( Dmitri , leader_office ) <= 4 then
52357: LD_EXP 20
52361: PPUSH
52362: LD_EXP 93
52366: PPUSH
52367: CALL_OW 296
52371: PUSH
52372: LD_INT 4
52374: LESSEQUAL
52375: IFFALSE 52467
// begin temp_list = UnitsInside ( leader_office ) ;
52377: LD_ADDR_VAR 0 4
52381: PUSH
52382: LD_EXP 93
52386: PPUSH
52387: CALL_OW 313
52391: ST_TO_ADDR
// if temp_list = 6 then
52392: LD_VAR 0 4
52396: PUSH
52397: LD_INT 6
52399: EQUAL
52400: IFFALSE 52467
// begin un = 0 ;
52402: LD_ADDR_VAR 0 5
52406: PUSH
52407: LD_INT 0
52409: ST_TO_ADDR
// for i in temp_list do
52410: LD_ADDR_VAR 0 1
52414: PUSH
52415: LD_VAR 0 4
52419: PUSH
52420: FOR_IN
52421: IFFALSE 52449
// if i <> Yefibachev then
52423: LD_VAR 0 1
52427: PUSH
52428: LD_EXP 14
52432: NONEQUAL
52433: IFFALSE 52447
// begin un = i ;
52435: LD_ADDR_VAR 0 5
52439: PUSH
52440: LD_VAR 0 1
52444: ST_TO_ADDR
// break ;
52445: GO 52449
// end ;
52447: GO 52420
52449: POP
52450: POP
// ComExitBuilding ( un ) ;
52451: LD_VAR 0 5
52455: PPUSH
52456: CALL_OW 122
// wait ( 3 ) ;
52460: LD_INT 3
52462: PPUSH
52463: CALL_OW 67
// end ; end ; until false ;
52467: LD_INT 0
52469: IFFALSE 52138
// repeat wait ( 0 0$2 ) ;
52471: LD_INT 70
52473: PPUSH
52474: CALL_OW 67
// until not code_black ;
52478: LD_EXP 77
52482: NOT
52483: IFFALSE 52471
// if IsDead ( Dmitri ) then
52485: LD_EXP 20
52489: PPUSH
52490: CALL_OW 301
52494: IFFALSE 52498
// exit ;
52496: GO 52557
// if heike_undercover <> 4 then
52498: LD_EXP 83
52502: PUSH
52503: LD_INT 4
52505: NONEQUAL
52506: IFFALSE 52535
// begin DialogueOn ;
52508: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-2b ) ;
52512: LD_EXP 14
52516: PPUSH
52517: LD_STRING D7-Leader-2b
52519: PPUSH
52520: CALL_OW 94
// DialogueOff ;
52524: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
52528: LD_INT 4
52530: PPUSH
52531: CALL 42004 0 1
// end ; code_black = true ;
52535: LD_ADDR_EXP 77
52539: PUSH
52540: LD_INT 1
52542: ST_TO_ADDR
// except_Dmitri = false ;
52543: LD_ADDR_EXP 110
52547: PUSH
52548: LD_INT 0
52550: ST_TO_ADDR
// exit ;
52551: GO 52557
// end ; end ; until false ;
52553: LD_INT 0
52555: IFFALSE 49461
// end ;
52557: PPOPN 6
52559: END
// every 0 0$1.1 do var count ;
52560: GO 52562
52562: DISABLE
52563: LD_INT 0
52565: PPUSH
// begin count = 0 ;
52566: LD_ADDR_VAR 0 1
52570: PUSH
52571: LD_INT 0
52573: ST_TO_ADDR
// repeat wait ( 0 0$0.5 ) ;
52574: LD_INT 18
52576: PPUSH
52577: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] then
52581: LD_EXP 83
52585: PUSH
52586: LD_INT 3
52588: PUSH
52589: LD_INT 4
52591: PUSH
52592: EMPTY
52593: LIST
52594: LIST
52595: IN
52596: IFFALSE 52600
// exit ;
52598: GO 52758
// if IsInArea ( Heike , weapon_test_area ) then
52600: LD_EXP 7
52604: PPUSH
52605: LD_INT 18
52607: PPUSH
52608: CALL_OW 308
52612: IFFALSE 52754
// begin DialogueOn ;
52614: CALL_OW 6
// case count of 0 :
52618: LD_VAR 0 1
52622: PUSH
52623: LD_INT 0
52625: DOUBLE
52626: EQUAL
52627: IFTRUE 52631
52629: GO 52660
52631: POP
// begin Say ( Dmitri , D24-Dmitri-1 ) ;
52632: LD_EXP 20
52636: PPUSH
52637: LD_STRING D24-Dmitri-1
52639: PPUSH
52640: CALL_OW 88
// count = count + 1 ;
52644: LD_ADDR_VAR 0 1
52648: PUSH
52649: LD_VAR 0 1
52653: PUSH
52654: LD_INT 1
52656: PLUS
52657: ST_TO_ADDR
// end ; 1 :
52658: GO 52713
52660: LD_INT 1
52662: DOUBLE
52663: EQUAL
52664: IFTRUE 52668
52666: GO 52712
52668: POP
// begin Say ( Dmitri , D24-Dmitri-2 ) ;
52669: LD_EXP 20
52673: PPUSH
52674: LD_STRING D24-Dmitri-2
52676: PPUSH
52677: CALL_OW 88
// count = count + 1 ;
52681: LD_ADDR_VAR 0 1
52685: PUSH
52686: LD_VAR 0 1
52690: PUSH
52691: LD_INT 1
52693: PLUS
52694: ST_TO_ADDR
// ChangeHeikeUndercoverStatus ( 4 ) ;
52695: LD_INT 4
52697: PPUSH
52698: CALL 42004 0 1
// code_black = true ;
52702: LD_ADDR_EXP 77
52706: PUSH
52707: LD_INT 1
52709: ST_TO_ADDR
// end ; end ;
52710: GO 52713
52712: POP
// DialogueOff ;
52713: CALL_OW 7
// case count of 1 :
52717: LD_VAR 0 1
52721: PUSH
52722: LD_INT 1
52724: DOUBLE
52725: EQUAL
52726: IFTRUE 52730
52728: GO 52740
52730: POP
// wait ( 0 0$2 ) ; 2 :
52731: LD_INT 70
52733: PPUSH
52734: CALL_OW 67
52738: GO 52754
52740: LD_INT 2
52742: DOUBLE
52743: EQUAL
52744: IFTRUE 52748
52746: GO 52753
52748: POP
// exit ; end ;
52749: GO 52758
52751: GO 52754
52753: POP
// end ; until false ;
52754: LD_INT 0
52756: IFFALSE 52574
// end ;
52758: PPOPN 1
52760: END
// every 0 0$1 + 0 0$0.9 do var i , val , temp_list , k , temp_list_2 , all_soldiers ; var timer , f_sol , other_sols , heike_times_wander_away , heike_times_enter_vehicle , heike_wander_away_cooldown ; var heike_enter_vehicle_cooldown , attack_tolerance ;
52761: GO 52763
52763: DISABLE
52764: LD_INT 0
52766: PPUSH
52767: PPUSH
52768: PPUSH
52769: PPUSH
52770: PPUSH
52771: PPUSH
52772: PPUSH
52773: PPUSH
52774: PPUSH
52775: PPUSH
52776: PPUSH
52777: PPUSH
52778: PPUSH
52779: PPUSH
// begin timer = 0 0$22 ;
52780: LD_ADDR_VAR 0 7
52784: PUSH
52785: LD_INT 770
52787: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
52788: LD_INT 35
52790: PPUSH
52791: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] or IsDead ( Yefibachev ) or IsDead ( Natalya ) or ( ai_soldiers [ 1 ] diff [ Stanimir , Yefibachev , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_sol ] ) <= 4 then
52795: LD_EXP 83
52799: PUSH
52800: LD_INT 3
52802: PUSH
52803: LD_INT 4
52805: PUSH
52806: EMPTY
52807: LIST
52808: LIST
52809: IN
52810: PUSH
52811: LD_EXP 14
52815: PPUSH
52816: CALL_OW 301
52820: OR
52821: PUSH
52822: LD_EXP 16
52826: PPUSH
52827: CALL_OW 301
52831: OR
52832: PUSH
52833: LD_EXP 26
52837: PUSH
52838: LD_INT 1
52840: ARRAY
52841: PUSH
52842: LD_EXP 12
52846: PUSH
52847: LD_EXP 14
52851: PUSH
52852: LD_EXP 18
52856: PUSH
52857: LD_EXP 19
52861: PUSH
52862: LD_EXP 20
52866: PUSH
52867: LD_EXP 21
52871: PUSH
52872: LD_EXP 22
52876: PUSH
52877: LD_EXP 24
52881: PUSH
52882: EMPTY
52883: LIST
52884: LIST
52885: LIST
52886: LIST
52887: LIST
52888: LIST
52889: LIST
52890: LIST
52891: DIFF
52892: PUSH
52893: LD_INT 4
52895: LESSEQUAL
52896: OR
52897: IFFALSE 52901
// exit ;
52899: GO 55514
// if HeikeInWorkshop and heike_undercover = 2 and not code_red and not code_black and Yakov_luring in [ 0 , 4 ] and IsInUnit ( Yefibachev ) = leader_office then
52901: CALL 55517 0 0
52905: PUSH
52906: LD_EXP 83
52910: PUSH
52911: LD_INT 2
52913: EQUAL
52914: AND
52915: PUSH
52916: LD_EXP 76
52920: NOT
52921: AND
52922: PUSH
52923: LD_EXP 77
52927: NOT
52928: AND
52929: PUSH
52930: LD_EXP 113
52934: PUSH
52935: LD_INT 0
52937: PUSH
52938: LD_INT 4
52940: PUSH
52941: EMPTY
52942: LIST
52943: LIST
52944: IN
52945: AND
52946: PUSH
52947: LD_EXP 14
52951: PPUSH
52952: CALL_OW 310
52956: PUSH
52957: LD_EXP 93
52961: EQUAL
52962: AND
52963: IFFALSE 52981
// timer = timer - 0 0$1 else
52965: LD_ADDR_VAR 0 7
52969: PUSH
52970: LD_VAR 0 7
52974: PUSH
52975: LD_INT 35
52977: MINUS
52978: ST_TO_ADDR
52979: GO 52989
// timer = 0 0$15 ;
52981: LD_ADDR_VAR 0 7
52985: PUSH
52986: LD_INT 525
52988: ST_TO_ADDR
// until timer <= 0 0$0 ;
52989: LD_VAR 0 7
52993: PUSH
52994: LD_INT 0
52996: LESSEQUAL
52997: IFFALSE 52788
// val = 0 ;
52999: LD_ADDR_VAR 0 2
53003: PUSH
53004: LD_INT 0
53006: ST_TO_ADDR
// for i in ai_armouries [ 1 ] do
53007: LD_ADDR_VAR 0 1
53011: PUSH
53012: LD_EXP 48
53016: PUSH
53017: LD_INT 1
53019: ARRAY
53020: PUSH
53021: FOR_IN
53022: IFFALSE 53140
// begin temp_list = UnitsInside ( i ) ;
53024: LD_ADDR_VAR 0 3
53028: PUSH
53029: LD_VAR 0 1
53033: PPUSH
53034: CALL_OW 313
53038: ST_TO_ADDR
// for k in temp_list do
53039: LD_ADDR_VAR 0 4
53043: PUSH
53044: LD_VAR 0 3
53048: PUSH
53049: FOR_IN
53050: IFFALSE 53124
// if not k in [ Stanimir , Yefibachev , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_sol ] then
53052: LD_VAR 0 4
53056: PUSH
53057: LD_EXP 12
53061: PUSH
53062: LD_EXP 14
53066: PUSH
53067: LD_EXP 18
53071: PUSH
53072: LD_EXP 19
53076: PUSH
53077: LD_EXP 20
53081: PUSH
53082: LD_EXP 21
53086: PUSH
53087: LD_EXP 22
53091: PUSH
53092: LD_EXP 24
53096: PUSH
53097: EMPTY
53098: LIST
53099: LIST
53100: LIST
53101: LIST
53102: LIST
53103: LIST
53104: LIST
53105: LIST
53106: IN
53107: NOT
53108: IFFALSE 53122
// begin val = k ;
53110: LD_ADDR_VAR 0 2
53114: PUSH
53115: LD_VAR 0 4
53119: ST_TO_ADDR
// break ;
53120: GO 53124
// end ;
53122: GO 53049
53124: POP
53125: POP
// if val > 0 then
53126: LD_VAR 0 2
53130: PUSH
53131: LD_INT 0
53133: GREATER
53134: IFFALSE 53138
// break ;
53136: GO 53140
// end ;
53138: GO 53021
53140: POP
53141: POP
// if val = 0 then
53142: LD_VAR 0 2
53146: PUSH
53147: LD_INT 0
53149: EQUAL
53150: IFFALSE 53255
// begin for i in ai_soldiers [ 1 ] do
53152: LD_ADDR_VAR 0 1
53156: PUSH
53157: LD_EXP 26
53161: PUSH
53162: LD_INT 1
53164: ARRAY
53165: PUSH
53166: FOR_IN
53167: IFFALSE 53241
// if not i in [ Stanimir , Yefibachev , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_sol ] then
53169: LD_VAR 0 1
53173: PUSH
53174: LD_EXP 12
53178: PUSH
53179: LD_EXP 14
53183: PUSH
53184: LD_EXP 18
53188: PUSH
53189: LD_EXP 19
53193: PUSH
53194: LD_EXP 20
53198: PUSH
53199: LD_EXP 21
53203: PUSH
53204: LD_EXP 22
53208: PUSH
53209: LD_EXP 24
53213: PUSH
53214: EMPTY
53215: LIST
53216: LIST
53217: LIST
53218: LIST
53219: LIST
53220: LIST
53221: LIST
53222: LIST
53223: IN
53224: NOT
53225: IFFALSE 53239
// begin val = i ;
53227: LD_ADDR_VAR 0 2
53231: PUSH
53232: LD_VAR 0 1
53236: ST_TO_ADDR
// break ;
53237: GO 53241
// end ;
53239: GO 53166
53241: POP
53242: POP
// if val = 0 then
53243: LD_VAR 0 2
53247: PUSH
53248: LD_INT 0
53250: EQUAL
53251: IFFALSE 53255
// exit ;
53253: GO 55514
// end ; workshop_messenger = val ;
53255: LD_ADDR_EXP 115
53259: PUSH
53260: LD_VAR 0 2
53264: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53265: LD_INT 35
53267: PPUSH
53268: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] or IsDead ( Yefibachev ) or IsDead ( Natalya ) then
53272: LD_EXP 83
53276: PUSH
53277: LD_INT 3
53279: PUSH
53280: LD_INT 4
53282: PUSH
53283: EMPTY
53284: LIST
53285: LIST
53286: IN
53287: PUSH
53288: LD_EXP 14
53292: PPUSH
53293: CALL_OW 301
53297: OR
53298: PUSH
53299: LD_EXP 16
53303: PPUSH
53304: CALL_OW 301
53308: OR
53309: IFFALSE 53321
// begin workshop_messenger = 0 ;
53311: LD_ADDR_EXP 115
53315: PUSH
53316: LD_INT 0
53318: ST_TO_ADDR
// exit ;
53319: GO 55514
// end ; if not ( HeikeInWorkshop and heike_undercover = 2 and not code_red and not code_black and Yakov_luring in [ 0 , 4 ] and IsInUnit ( Yefibachev ) = leader_office ) then
53321: CALL 55517 0 0
53325: PUSH
53326: LD_EXP 83
53330: PUSH
53331: LD_INT 2
53333: EQUAL
53334: AND
53335: PUSH
53336: LD_EXP 76
53340: NOT
53341: AND
53342: PUSH
53343: LD_EXP 77
53347: NOT
53348: AND
53349: PUSH
53350: LD_EXP 113
53354: PUSH
53355: LD_INT 0
53357: PUSH
53358: LD_INT 4
53360: PUSH
53361: EMPTY
53362: LIST
53363: LIST
53364: IN
53365: AND
53366: PUSH
53367: LD_EXP 14
53371: PPUSH
53372: CALL_OW 310
53376: PUSH
53377: LD_EXP 93
53381: EQUAL
53382: AND
53383: NOT
53384: IFFALSE 53396
// begin workshop_messenger = 0 ;
53386: LD_ADDR_EXP 115
53390: PUSH
53391: LD_INT 0
53393: ST_TO_ADDR
// exit ;
53394: GO 55514
// end ; if IsDead ( workshop_messenger ) then
53396: LD_EXP 115
53400: PPUSH
53401: CALL_OW 301
53405: IFFALSE 53417
// begin workshop_messenger = 0 ;
53407: LD_ADDR_EXP 115
53411: PUSH
53412: LD_INT 0
53414: ST_TO_ADDR
// exit ;
53415: GO 55514
// end ; if workshop_messenger in ai_heal_these_humans [ 1 ] then
53417: LD_EXP 115
53421: PUSH
53422: LD_EXP 42
53426: PUSH
53427: LD_INT 1
53429: ARRAY
53430: IN
53431: IFFALSE 53435
// continue ;
53433: GO 53265
// k = IsInUnit ( workshop_messenger ) ;
53435: LD_ADDR_VAR 0 4
53439: PUSH
53440: LD_EXP 115
53444: PPUSH
53445: CALL_OW 310
53449: ST_TO_ADDR
// if k in ai_facts [ 1 ] then
53450: LD_VAR 0 4
53454: PUSH
53455: LD_EXP 47
53459: PUSH
53460: LD_INT 1
53462: ARRAY
53463: IN
53464: IFFALSE 53468
// break ;
53466: GO 53685
// case GetType ( k ) of unit_vehicle :
53468: LD_VAR 0 4
53472: PPUSH
53473: CALL_OW 247
53477: PUSH
53478: LD_INT 2
53480: DOUBLE
53481: EQUAL
53482: IFTRUE 53486
53484: GO 53498
53486: POP
// ComExitVehicle ( workshop_messenger ) ; unit_building :
53487: LD_EXP 115
53491: PPUSH
53492: CALL_OW 121
53496: GO 53681
53498: LD_INT 3
53500: DOUBLE
53501: EQUAL
53502: IFTRUE 53506
53504: GO 53518
53506: POP
// ComExitBuilding ( workshop_messenger ) ; else
53507: LD_EXP 115
53511: PPUSH
53512: CALL_OW 122
53516: GO 53681
53518: POP
// if ai_facts [ 1 ] > 0 then
53519: LD_EXP 47
53523: PUSH
53524: LD_INT 1
53526: ARRAY
53527: PUSH
53528: LD_INT 0
53530: GREATER
53531: IFFALSE 53681
// begin if GetDistUnits ( workshop_messenger , ai_facts [ 1 ] [ 1 ] ) <= 5 then
53533: LD_EXP 115
53537: PPUSH
53538: LD_EXP 47
53542: PUSH
53543: LD_INT 1
53545: ARRAY
53546: PUSH
53547: LD_INT 1
53549: ARRAY
53550: PPUSH
53551: CALL_OW 296
53555: PUSH
53556: LD_INT 5
53558: LESSEQUAL
53559: IFFALSE 53659
// begin temp_list = UnitsInside ( ai_facts [ 1 ] [ 1 ] ) ;
53561: LD_ADDR_VAR 0 3
53565: PUSH
53566: LD_EXP 47
53570: PUSH
53571: LD_INT 1
53573: ARRAY
53574: PUSH
53575: LD_INT 1
53577: ARRAY
53578: PPUSH
53579: CALL_OW 313
53583: ST_TO_ADDR
// if temp_list = 6 then
53584: LD_VAR 0 3
53588: PUSH
53589: LD_INT 6
53591: EQUAL
53592: IFFALSE 53659
// begin k = 0 ;
53594: LD_ADDR_VAR 0 4
53598: PUSH
53599: LD_INT 0
53601: ST_TO_ADDR
// for i in temp_list do
53602: LD_ADDR_VAR 0 1
53606: PUSH
53607: LD_VAR 0 3
53611: PUSH
53612: FOR_IN
53613: IFFALSE 53641
// if i <> Natalya then
53615: LD_VAR 0 1
53619: PUSH
53620: LD_EXP 16
53624: NONEQUAL
53625: IFFALSE 53639
// begin k = i ;
53627: LD_ADDR_VAR 0 4
53631: PUSH
53632: LD_VAR 0 1
53636: ST_TO_ADDR
// break ;
53637: GO 53641
// end ;
53639: GO 53612
53641: POP
53642: POP
// ComExitBuilding ( k ) ;
53643: LD_VAR 0 4
53647: PPUSH
53648: CALL_OW 122
// wait ( 3 ) ;
53652: LD_INT 3
53654: PPUSH
53655: CALL_OW 67
// end ; end ; ComEnterUnit ( workshop_messenger , ai_facts [ 1 ] [ 1 ] ) ;
53659: LD_EXP 115
53663: PPUSH
53664: LD_EXP 47
53668: PUSH
53669: LD_INT 1
53671: ARRAY
53672: PUSH
53673: LD_INT 1
53675: ARRAY
53676: PPUSH
53677: CALL_OW 120
// end ; end ; until false ;
53681: LD_INT 0
53683: IFFALSE 53265
// CenterOnUnits ( ai_facts [ 1 ] [ 1 ] ) ;
53685: LD_EXP 47
53689: PUSH
53690: LD_INT 1
53692: ARRAY
53693: PUSH
53694: LD_INT 1
53696: ARRAY
53697: PPUSH
53698: CALL_OW 85
// DialogueOn ;
53702: CALL_OW 6
// if GetSex ( workshop_messenger ) = sex_male then
53706: LD_EXP 115
53710: PPUSH
53711: CALL_OW 258
53715: PUSH
53716: LD_INT 1
53718: EQUAL
53719: IFFALSE 53735
// Say ( workshop_messenger , D14-SolM1-1 ) else
53721: LD_EXP 115
53725: PPUSH
53726: LD_STRING D14-SolM1-1
53728: PPUSH
53729: CALL_OW 88
53733: GO 53747
// Say ( workshop_messenger , D14-SolF1-1 ) ;
53735: LD_EXP 115
53739: PPUSH
53740: LD_STRING D14-SolF1-1
53742: PPUSH
53743: CALL_OW 88
// Say ( Natalya , D14-Natalya-1 ) ;
53747: LD_EXP 16
53751: PPUSH
53752: LD_STRING D14-Natalya-1
53754: PPUSH
53755: CALL_OW 88
// if GetSex ( workshop_messenger ) = sex_male then
53759: LD_EXP 115
53763: PPUSH
53764: CALL_OW 258
53768: PUSH
53769: LD_INT 1
53771: EQUAL
53772: IFFALSE 53788
// Say ( workshop_messenger , D14-SolM1-2 ) else
53774: LD_EXP 115
53778: PPUSH
53779: LD_STRING D14-SolM1-2
53781: PPUSH
53782: CALL_OW 88
53786: GO 53800
// Say ( workshop_messenger , D14-SolF1-2 ) ;
53788: LD_EXP 115
53792: PPUSH
53793: LD_STRING D14-SolF1-2
53795: PPUSH
53796: CALL_OW 88
// Say ( Natalya , D14-Natalya-2 ) ;
53800: LD_EXP 16
53804: PPUSH
53805: LD_STRING D14-Natalya-2
53807: PPUSH
53808: CALL_OW 88
// DialogueOff ;
53812: CALL_OW 7
// for i = 1 to 3 do
53816: LD_ADDR_VAR 0 1
53820: PUSH
53821: DOUBLE
53822: LD_INT 1
53824: DEC
53825: ST_TO_ADDR
53826: LD_INT 3
53828: PUSH
53829: FOR_TO
53830: IFFALSE 53938
// begin val = CreateRussianVehicle ( false ) ;
53832: LD_ADDR_VAR 0 2
53836: PUSH
53837: LD_INT 0
53839: PPUSH
53840: CALL 44266 0 1
53844: ST_TO_ADDR
// SetLives ( val , Rand ( 700 , 900 ) ) ;
53845: LD_VAR 0 2
53849: PPUSH
53850: LD_INT 700
53852: PPUSH
53853: LD_INT 900
53855: PPUSH
53856: CALL_OW 12
53860: PPUSH
53861: CALL_OW 234
// SetDir ( val , Rand ( 0 , 5 ) ) ;
53865: LD_VAR 0 2
53869: PPUSH
53870: LD_INT 0
53872: PPUSH
53873: LD_INT 5
53875: PPUSH
53876: CALL_OW 12
53880: PPUSH
53881: CALL_OW 233
// PlaceUnitXYR ( val , 59 , 43 , 5 , false ) ;
53885: LD_VAR 0 2
53889: PPUSH
53890: LD_INT 59
53892: PPUSH
53893: LD_INT 43
53895: PPUSH
53896: LD_INT 5
53898: PPUSH
53899: LD_INT 0
53901: PPUSH
53902: CALL_OW 50
// DoNotAttack ( you , val ) ;
53906: LD_EXP 2
53910: PPUSH
53911: LD_VAR 0 2
53915: PPUSH
53916: CALL_OW 471
// intel_party_vehicles = intel_party_vehicles ^ val ;
53920: LD_ADDR_EXP 114
53924: PUSH
53925: LD_EXP 114
53929: PUSH
53930: LD_VAR 0 2
53934: ADD
53935: ST_TO_ADDR
// end ;
53936: GO 53829
53938: POP
53939: POP
// f_sol = CreateUnitsWithClass ( 1 , class_soldier , sex_female ,  , russians_alt ) [ 1 ] ;
53940: LD_ADDR_VAR 0 8
53944: PUSH
53945: LD_INT 1
53947: PPUSH
53948: LD_INT 1
53950: PPUSH
53951: LD_INT 2
53953: PPUSH
53954: LD_STRING 
53956: PPUSH
53957: LD_EXP 6
53961: PPUSH
53962: CALL 7857 0 5
53966: PUSH
53967: LD_INT 1
53969: ARRAY
53970: ST_TO_ADDR
// other_sols = CreateUnitsWithClass ( 2 , class_soldier , sex_male ,  , russians_alt ) ;
53971: LD_ADDR_VAR 0 9
53975: PUSH
53976: LD_INT 2
53978: PPUSH
53979: LD_INT 1
53981: PPUSH
53982: LD_INT 1
53984: PPUSH
53985: LD_STRING 
53987: PPUSH
53988: LD_EXP 6
53992: PPUSH
53993: CALL 7857 0 5
53997: ST_TO_ADDR
// for i in f_sol ^ other_sols do
53998: LD_ADDR_VAR 0 1
54002: PUSH
54003: LD_VAR 0 8
54007: PUSH
54008: LD_VAR 0 9
54012: ADD
54013: PUSH
54014: FOR_IN
54015: IFFALSE 54054
// begin PlaceUnitXYR ( i , 59 , 43 , 4 , false ) ;
54017: LD_VAR 0 1
54021: PPUSH
54022: LD_INT 59
54024: PPUSH
54025: LD_INT 43
54027: PPUSH
54028: LD_INT 4
54030: PPUSH
54031: LD_INT 0
54033: PPUSH
54034: CALL_OW 50
// DoNotAttack ( you , i ) ;
54038: LD_EXP 2
54042: PPUSH
54043: LD_VAR 0 1
54047: PPUSH
54048: CALL_OW 471
// end ;
54052: GO 54014
54054: POP
54055: POP
// RemoveUnit ( Yefibachev ) ;
54056: LD_EXP 14
54060: PPUSH
54061: CALL_OW 64
// PlaceUnitXYR ( Yefibachev , 59 , 43 , 4 , false ) ;
54065: LD_EXP 14
54069: PPUSH
54070: LD_INT 59
54072: PPUSH
54073: LD_INT 43
54075: PPUSH
54076: LD_INT 4
54078: PPUSH
54079: LD_INT 0
54081: PPUSH
54082: CALL_OW 50
// except_Yefibachev = true ;
54086: LD_ADDR_EXP 118
54090: PUSH
54091: LD_INT 1
54093: ST_TO_ADDR
// ComTurnUnit ( Yefibachev , f_sol ) ;
54094: LD_EXP 14
54098: PPUSH
54099: LD_VAR 0 8
54103: PPUSH
54104: CALL_OW 119
// ComTurnUnit ( f_sol , Yefibachev ) ;
54108: LD_VAR 0 8
54112: PPUSH
54113: LD_EXP 14
54117: PPUSH
54118: CALL_OW 119
// F_InGameOn ;
54122: CALL 68232 0 0
// ExclusiveOff ;
54126: CALL_OW 5
// GetPlayerUnitsOutOfBuilding ( ai_facts [ 1 ] [ 1 ] ) ;
54130: LD_EXP 47
54134: PUSH
54135: LD_INT 1
54137: ARRAY
54138: PUSH
54139: LD_INT 1
54141: ARRAY
54142: PPUSH
54143: CALL 59233 0 1
// ComExitBuilding ( workshop_messenger ) ;
54147: LD_EXP 115
54151: PPUSH
54152: CALL_OW 122
// wait ( 5 ) ;
54156: LD_INT 5
54158: PPUSH
54159: CALL_OW 67
// ExclusiveOn ;
54163: CALL_OW 4
// repeat ComMoveXY ( [ Heike , workshop_messenger ] , 59 , 43 ) ;
54167: LD_EXP 7
54171: PUSH
54172: LD_EXP 115
54176: PUSH
54177: EMPTY
54178: LIST
54179: LIST
54180: PPUSH
54181: LD_INT 59
54183: PPUSH
54184: LD_INT 43
54186: PPUSH
54187: CALL_OW 111
// CenterOnUnits ( [ Heike , workshop_messenger ] ) ;
54191: LD_EXP 7
54195: PUSH
54196: LD_EXP 115
54200: PUSH
54201: EMPTY
54202: LIST
54203: LIST
54204: PPUSH
54205: CALL_OW 85
// wait ( 0 0$1 ) ;
54209: LD_INT 35
54211: PPUSH
54212: CALL_OW 67
// until GetDistUnitXY ( Heike , 59 , 43 ) <= 5 ;
54216: LD_EXP 7
54220: PPUSH
54221: LD_INT 59
54223: PPUSH
54224: LD_INT 43
54226: PPUSH
54227: CALL_OW 297
54231: PUSH
54232: LD_INT 5
54234: LESSEQUAL
54235: IFFALSE 54167
// workshop_messenger = 0 ;
54237: LD_ADDR_EXP 115
54241: PUSH
54242: LD_INT 0
54244: ST_TO_ADDR
// CenterOnXY ( 59 , 43 ) ;
54245: LD_INT 59
54247: PPUSH
54248: LD_INT 43
54250: PPUSH
54251: CALL_OW 84
// DialogueOn ;
54255: CALL_OW 6
// Say ( f_sol , D14-SolF2-1 ) ;
54259: LD_VAR 0 8
54263: PPUSH
54264: LD_STRING D14-SolF2-1
54266: PPUSH
54267: CALL_OW 88
// DialogueOff ;
54271: CALL_OW 7
// ComFree ( [ f_sol , Yefibachev ] ) ;
54275: LD_VAR 0 8
54279: PUSH
54280: LD_EXP 14
54284: PUSH
54285: EMPTY
54286: LIST
54287: LIST
54288: PPUSH
54289: CALL_OW 139
// except_Yefibachev = false ;
54293: LD_ADDR_EXP 118
54297: PUSH
54298: LD_INT 0
54300: ST_TO_ADDR
// F_InGameOff ;
54301: CALL 68468 0 0
// RaiseSailEvent ( f_sol ) ;
54305: LD_VAR 0 8
54309: PPUSH
54310: CALL_OW 427
// heike_times_wander_away = 0 ;
54314: LD_ADDR_VAR 0 10
54318: PUSH
54319: LD_INT 0
54321: ST_TO_ADDR
// heike_wander_away_cooldown = 0 0$0 ;
54322: LD_ADDR_VAR 0 12
54326: PUSH
54327: LD_INT 0
54329: ST_TO_ADDR
// heike_times_enter_vehicle = 0 ;
54330: LD_ADDR_VAR 0 11
54334: PUSH
54335: LD_INT 0
54337: ST_TO_ADDR
// heike_enter_vehicle_cooldown = 0 0$0 ;
54338: LD_ADDR_VAR 0 13
54342: PUSH
54343: LD_INT 0
54345: ST_TO_ADDR
// attack_tolerance = 0 ;
54346: LD_ADDR_VAR 0 14
54350: PUSH
54351: LD_INT 0
54353: ST_TO_ADDR
// repeat wait ( 0 0$0.5 ) ;
54354: LD_INT 18
54356: PPUSH
54357: CALL_OW 67
// if code_red or code_black then
54361: LD_EXP 76
54365: PUSH
54366: LD_EXP 77
54370: OR
54371: IFFALSE 54383
// begin intel_party_leave = true ;
54373: LD_ADDR_EXP 117
54377: PUSH
54378: LD_INT 1
54380: ST_TO_ADDR
// break ;
54381: GO 55002
// end ; val = false ;
54383: LD_ADDR_VAR 0 2
54387: PUSH
54388: LD_INT 0
54390: ST_TO_ADDR
// for i = 1 to recent_not_went_inside_units do
54391: LD_ADDR_VAR 0 1
54395: PUSH
54396: DOUBLE
54397: LD_INT 1
54399: DEC
54400: ST_TO_ADDR
54401: LD_EXP 89
54405: PUSH
54406: FOR_TO
54407: IFFALSE 54493
// if recent_not_went_inside_units [ i ] [ 1 ] = Heike then
54409: LD_EXP 89
54413: PUSH
54414: LD_VAR 0 1
54418: ARRAY
54419: PUSH
54420: LD_INT 1
54422: ARRAY
54423: PUSH
54424: LD_EXP 7
54428: EQUAL
54429: IFFALSE 54491
// begin val = true ;
54431: LD_ADDR_VAR 0 2
54435: PUSH
54436: LD_INT 1
54438: ST_TO_ADDR
// if recent_not_went_inside_units [ i ] [ 2 ] <= 0 0$4 then
54439: LD_EXP 89
54443: PUSH
54444: LD_VAR 0 1
54448: ARRAY
54449: PUSH
54450: LD_INT 2
54452: ARRAY
54453: PUSH
54454: LD_INT 140
54456: LESSEQUAL
54457: IFFALSE 54491
// recent_not_went_inside_units = Replace ( recent_not_went_inside_units , i , [ Heike , 0 0$6 ] ) ;
54459: LD_ADDR_EXP 89
54463: PUSH
54464: LD_EXP 89
54468: PPUSH
54469: LD_VAR 0 1
54473: PPUSH
54474: LD_EXP 7
54478: PUSH
54479: LD_INT 210
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: PPUSH
54486: CALL_OW 1
54490: ST_TO_ADDR
// end ;
54491: GO 54406
54493: POP
54494: POP
// if not val then
54495: LD_VAR 0 2
54499: NOT
54500: IFFALSE 54528
// recent_not_went_inside_units = recent_not_went_inside_units ^ [ [ Heike , 0 0$6 ] ] ;
54502: LD_ADDR_EXP 89
54506: PUSH
54507: LD_EXP 89
54511: PUSH
54512: LD_EXP 7
54516: PUSH
54517: LD_INT 210
54519: PUSH
54520: EMPTY
54521: LIST
54522: LIST
54523: PUSH
54524: EMPTY
54525: LIST
54526: ADD
54527: ST_TO_ADDR
// if IsInUnit ( Heike ) in intel_party_vehicles then
54528: LD_EXP 7
54532: PPUSH
54533: CALL_OW 310
54537: PUSH
54538: LD_EXP 114
54542: IN
54543: IFFALSE 54685
// begin if heike_enter_vehicle_cooldown > 0 0$0 then
54545: LD_VAR 0 13
54549: PUSH
54550: LD_INT 0
54552: GREATER
54553: IFFALSE 54571
// begin heike_enter_vehicle_cooldown = heike_enter_vehicle_cooldown - 0 0$1 ;
54555: LD_ADDR_VAR 0 13
54559: PUSH
54560: LD_VAR 0 13
54564: PUSH
54565: LD_INT 35
54567: MINUS
54568: ST_TO_ADDR
// continue ;
54569: GO 54354
// end ; case heike_times_enter_vehicle of 0 :
54571: LD_VAR 0 11
54575: PUSH
54576: LD_INT 0
54578: DOUBLE
54579: EQUAL
54580: IFTRUE 54584
54582: GO 54611
54584: POP
// begin DialogueOn ;
54585: CALL_OW 6
// Say ( other_sols [ 1 ] , D14-SolM2-4 ) ;
54589: LD_VAR 0 9
54593: PUSH
54594: LD_INT 1
54596: ARRAY
54597: PPUSH
54598: LD_STRING D14-SolM2-4
54600: PPUSH
54601: CALL_OW 88
// DialogueOff ;
54605: CALL_OW 7
// end ; 1 :
54609: GO 54661
54611: LD_INT 1
54613: DOUBLE
54614: EQUAL
54615: IFTRUE 54619
54617: GO 54660
54619: POP
// begin DialogueOn ;
54620: CALL_OW 6
// Say ( other_sols [ 1 ] , D14-SolM2-5 ) ;
54624: LD_VAR 0 9
54628: PUSH
54629: LD_INT 1
54631: ARRAY
54632: PPUSH
54633: LD_STRING D14-SolM2-5
54635: PPUSH
54636: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
54640: LD_INT 18
54642: PPUSH
54643: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
54647: LD_STRING HeikeCaptive
54649: PPUSH
54650: CALL_OW 104
// DialogueOff ;
54654: CALL_OW 7
// end ; end ;
54658: GO 54661
54660: POP
// heike_enter_vehicle_cooldown = 0 0$5 ;
54661: LD_ADDR_VAR 0 13
54665: PUSH
54666: LD_INT 175
54668: ST_TO_ADDR
// heike_times_enter_vehicle = heike_times_enter_vehicle + 1 ;
54669: LD_ADDR_VAR 0 11
54673: PUSH
54674: LD_VAR 0 11
54678: PUSH
54679: LD_INT 1
54681: PLUS
54682: ST_TO_ADDR
// continue ;
54683: GO 54354
// end ; if GetDistUnitXY ( Heike , 59 , 43 ) > 7 then
54685: LD_EXP 7
54689: PPUSH
54690: LD_INT 59
54692: PPUSH
54693: LD_INT 43
54695: PPUSH
54696: CALL_OW 297
54700: PUSH
54701: LD_INT 7
54703: GREATER
54704: IFFALSE 54862
// begin if heike_wander_away_cooldown > 0 0$0 then
54706: LD_VAR 0 12
54710: PUSH
54711: LD_INT 0
54713: GREATER
54714: IFFALSE 54732
// begin heike_wander_away_cooldown = heike_wander_away_cooldown - 0 0$1 ;
54716: LD_ADDR_VAR 0 12
54720: PUSH
54721: LD_VAR 0 12
54725: PUSH
54726: LD_INT 35
54728: MINUS
54729: ST_TO_ADDR
// continue ;
54730: GO 54354
// end ; case heike_times_wander_away of 0 :
54732: LD_VAR 0 10
54736: PUSH
54737: LD_INT 0
54739: DOUBLE
54740: EQUAL
54741: IFTRUE 54745
54743: GO 54788
54745: POP
// begin DialogueOn ;
54746: CALL_OW 6
// Say ( other_sols [ 1 ] , D14-SolM2-1 ) ;
54750: LD_VAR 0 9
54754: PUSH
54755: LD_INT 1
54757: ARRAY
54758: PPUSH
54759: LD_STRING D14-SolM2-1
54761: PPUSH
54762: CALL_OW 88
// Say ( other_sols [ 1 ] , D14-SolM2-2 ) ;
54766: LD_VAR 0 9
54770: PUSH
54771: LD_INT 1
54773: ARRAY
54774: PPUSH
54775: LD_STRING D14-SolM2-2
54777: PPUSH
54778: CALL_OW 88
// DialogueOff ;
54782: CALL_OW 7
// end ; 1 :
54786: GO 54838
54788: LD_INT 1
54790: DOUBLE
54791: EQUAL
54792: IFTRUE 54796
54794: GO 54837
54796: POP
// begin DialogueOn ;
54797: CALL_OW 6
// Say ( other_sols [ 1 ] , D14-SolM2-3 ) ;
54801: LD_VAR 0 9
54805: PUSH
54806: LD_INT 1
54808: ARRAY
54809: PPUSH
54810: LD_STRING D14-SolM2-3
54812: PPUSH
54813: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
54817: LD_INT 18
54819: PPUSH
54820: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
54824: LD_STRING HeikeCaptive
54826: PPUSH
54827: CALL_OW 104
// DialogueOff ;
54831: CALL_OW 7
// end ; end ;
54835: GO 54838
54837: POP
// heike_wander_away_cooldown = 0 0$5 ;
54838: LD_ADDR_VAR 0 12
54842: PUSH
54843: LD_INT 175
54845: ST_TO_ADDR
// heike_times_wander_away = heike_times_wander_away + 1 ;
54846: LD_ADDR_VAR 0 10
54850: PUSH
54851: LD_VAR 0 10
54855: PUSH
54856: LD_INT 1
54858: PLUS
54859: ST_TO_ADDR
// continue ;
54860: GO 54354
// end ; if Attacks ( Heike ) in intel_party_vehicles ^ other_sols ^ f_sol then
54862: LD_EXP 7
54866: PPUSH
54867: CALL_OW 320
54871: PUSH
54872: LD_EXP 114
54876: PUSH
54877: LD_VAR 0 9
54881: ADD
54882: PUSH
54883: LD_VAR 0 8
54887: ADD
54888: IN
54889: IFFALSE 54988
// begin attack_tolerance = attack_tolerance + 1 ;
54891: LD_ADDR_VAR 0 14
54895: PUSH
54896: LD_VAR 0 14
54900: PUSH
54901: LD_INT 1
54903: PLUS
54904: ST_TO_ADDR
// if attack_tolerance >= 4 then
54905: LD_VAR 0 14
54909: PUSH
54910: LD_INT 4
54912: GREATEREQUAL
54913: IFFALSE 54986
// begin if heike_undercover <> 4 then
54915: LD_EXP 83
54919: PUSH
54920: LD_INT 4
54922: NONEQUAL
54923: IFFALSE 54952
// begin DialogueOn ;
54925: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-2b ) ;
54929: LD_EXP 14
54933: PPUSH
54934: LD_STRING D7-Leader-2b
54936: PPUSH
54937: CALL_OW 94
// DialogueOff ;
54941: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
54945: LD_INT 4
54947: PPUSH
54948: CALL 42004 0 1
// end ; intel_party_leave = true ;
54952: LD_ADDR_EXP 117
54956: PUSH
54957: LD_INT 1
54959: ST_TO_ADDR
// if code_black then
54960: LD_EXP 77
54964: IFFALSE 54976
// code_black_renew = true else
54966: LD_ADDR_EXP 124
54970: PUSH
54971: LD_INT 1
54973: ST_TO_ADDR
54974: GO 54984
// code_black = true ;
54976: LD_ADDR_EXP 77
54980: PUSH
54981: LD_INT 1
54983: ST_TO_ADDR
// break ;
54984: GO 55002
// end ; end else
54986: GO 54996
// attack_tolerance = 0 ;
54988: LD_ADDR_VAR 0 14
54992: PUSH
54993: LD_INT 0
54995: ST_TO_ADDR
// until intel_party_leave ;
54996: LD_EXP 117
55000: IFFALSE 54354
// repeat wait ( 0 0$0.5 ) ;
55002: LD_INT 18
55004: PPUSH
55005: CALL_OW 67
// for i in other_sols ^ f_sol do
55009: LD_ADDR_VAR 0 1
55013: PUSH
55014: LD_VAR 0 9
55018: PUSH
55019: LD_VAR 0 8
55023: ADD
55024: PUSH
55025: FOR_IN
55026: IFFALSE 55171
// begin val = IsInUnit ( i ) ;
55028: LD_ADDR_VAR 0 2
55032: PUSH
55033: LD_VAR 0 1
55037: PPUSH
55038: CALL_OW 310
55042: ST_TO_ADDR
// k = val ;
55043: LD_ADDR_VAR 0 4
55047: PUSH
55048: LD_VAR 0 2
55052: ST_TO_ADDR
// if val = 0 then
55053: LD_VAR 0 2
55057: PUSH
55058: LD_INT 0
55060: EQUAL
55061: IFFALSE 55073
// val = i ;
55063: LD_ADDR_VAR 0 2
55067: PUSH
55068: LD_VAR 0 1
55072: ST_TO_ADDR
// if IsInArea ( val , in_out_area_west ) then
55073: LD_VAR 0 2
55077: PPUSH
55078: LD_INT 10
55080: PPUSH
55081: CALL_OW 308
55085: IFFALSE 55169
// begin if k > 0 then
55087: LD_VAR 0 4
55091: PUSH
55092: LD_INT 0
55094: GREATER
55095: IFFALSE 55122
// begin intel_party_vehicles = intel_party_vehicles diff k ;
55097: LD_ADDR_EXP 114
55101: PUSH
55102: LD_EXP 114
55106: PUSH
55107: LD_VAR 0 4
55111: DIFF
55112: ST_TO_ADDR
// DestroyUnit ( k ) ;
55113: LD_VAR 0 4
55117: PPUSH
55118: CALL_OW 65
// end ; if i = f_sol then
55122: LD_VAR 0 1
55126: PUSH
55127: LD_VAR 0 8
55131: EQUAL
55132: IFFALSE 55144
// f_sol = 0 else
55134: LD_ADDR_VAR 0 8
55138: PUSH
55139: LD_INT 0
55141: ST_TO_ADDR
55142: GO 55160
// other_sols = other_sols diff i ;
55144: LD_ADDR_VAR 0 9
55148: PUSH
55149: LD_VAR 0 9
55153: PUSH
55154: LD_VAR 0 1
55158: DIFF
55159: ST_TO_ADDR
// DestroyUnit ( i ) ;
55160: LD_VAR 0 1
55164: PPUSH
55165: CALL_OW 65
// end ; end ;
55169: GO 55025
55171: POP
55172: POP
// intel_party_vehicles = UnitFilter ( intel_party_vehicles , [ f_ok ] ) ;
55173: LD_ADDR_EXP 114
55177: PUSH
55178: LD_EXP 114
55182: PPUSH
55183: LD_INT 50
55185: PUSH
55186: EMPTY
55187: LIST
55188: PPUSH
55189: CALL_OW 72
55193: ST_TO_ADDR
// if other_sols = 0 and f_sol = 0 then
55194: LD_VAR 0 9
55198: PUSH
55199: LD_INT 0
55201: EQUAL
55202: PUSH
55203: LD_VAR 0 8
55207: PUSH
55208: LD_INT 0
55210: EQUAL
55211: AND
55212: IFFALSE 55216
// exit ;
55214: GO 55514
// all_soldiers = other_sols ^ f_sol ;
55216: LD_ADDR_VAR 0 6
55220: PUSH
55221: LD_VAR 0 9
55225: PUSH
55226: LD_VAR 0 8
55230: ADD
55231: ST_TO_ADDR
// temp_list = UnitFilter ( intel_party_vehicles , [ f_empty ] ) ;
55232: LD_ADDR_VAR 0 3
55236: PUSH
55237: LD_EXP 114
55241: PPUSH
55242: LD_INT 58
55244: PUSH
55245: EMPTY
55246: LIST
55247: PPUSH
55248: CALL_OW 72
55252: ST_TO_ADDR
// if temp_list > 0 then
55253: LD_VAR 0 3
55257: PUSH
55258: LD_INT 0
55260: GREATER
55261: IFFALSE 55446
// begin temp_list_2 = [ ] ;
55263: LD_ADDR_VAR 0 5
55267: PUSH
55268: EMPTY
55269: ST_TO_ADDR
// for i in all_soldiers do
55270: LD_ADDR_VAR 0 1
55274: PUSH
55275: LD_VAR 0 6
55279: PUSH
55280: FOR_IN
55281: IFFALSE 55316
// if IsInUnit ( i ) = 0 then
55283: LD_VAR 0 1
55287: PPUSH
55288: CALL_OW 310
55292: PUSH
55293: LD_INT 0
55295: EQUAL
55296: IFFALSE 55314
// temp_list_2 = temp_list_2 ^ i ;
55298: LD_ADDR_VAR 0 5
55302: PUSH
55303: LD_VAR 0 5
55307: PUSH
55308: LD_VAR 0 1
55312: ADD
55313: ST_TO_ADDR
55314: GO 55280
55316: POP
55317: POP
// while temp_list_2 > 0 do
55318: LD_VAR 0 5
55322: PUSH
55323: LD_INT 0
55325: GREATER
55326: IFFALSE 55446
// begin if temp_list = 0 then
55328: LD_VAR 0 3
55332: PUSH
55333: LD_INT 0
55335: EQUAL
55336: IFFALSE 55340
// break ;
55338: GO 55446
// val = AllNearestUnitToUnit ( temp_list_2 , temp_list [ 1 ] ) ;
55340: LD_ADDR_VAR 0 2
55344: PUSH
55345: LD_VAR 0 5
55349: PPUSH
55350: LD_VAR 0 3
55354: PUSH
55355: LD_INT 1
55357: ARRAY
55358: PPUSH
55359: CALL_OW 75
55363: ST_TO_ADDR
// if val = 0 then
55364: LD_VAR 0 2
55368: PUSH
55369: LD_INT 0
55371: EQUAL
55372: IFFALSE 55376
// break ;
55374: GO 55446
// ComEnterUnit ( val , temp_list [ 1 ] ) ;
55376: LD_VAR 0 2
55380: PPUSH
55381: LD_VAR 0 3
55385: PUSH
55386: LD_INT 1
55388: ARRAY
55389: PPUSH
55390: CALL_OW 120
// temp_list_2 = temp_list_2 diff val ;
55394: LD_ADDR_VAR 0 5
55398: PUSH
55399: LD_VAR 0 5
55403: PUSH
55404: LD_VAR 0 2
55408: DIFF
55409: ST_TO_ADDR
// all_soldiers = all_soldiers diff val ;
55410: LD_ADDR_VAR 0 6
55414: PUSH
55415: LD_VAR 0 6
55419: PUSH
55420: LD_VAR 0 2
55424: DIFF
55425: ST_TO_ADDR
// temp_list = Delete ( temp_list , 1 ) ;
55426: LD_ADDR_VAR 0 3
55430: PUSH
55431: LD_VAR 0 3
55435: PPUSH
55436: LD_INT 1
55438: PPUSH
55439: CALL_OW 3
55443: ST_TO_ADDR
// end ;
55444: GO 55318
// end ; for i in all_soldiers do
55446: LD_ADDR_VAR 0 1
55450: PUSH
55451: LD_VAR 0 6
55455: PUSH
55456: FOR_IN
55457: IFFALSE 55508
// if GetDistUnitArea ( i , in_out_area_west ) <= 3 then
55459: LD_VAR 0 1
55463: PPUSH
55464: LD_INT 10
55466: PPUSH
55467: CALL_OW 299
55471: PUSH
55472: LD_INT 3
55474: LESSEQUAL
55475: IFFALSE 55491
// ComMoveToArea ( i , in_out_area_west ) else
55477: LD_VAR 0 1
55481: PPUSH
55482: LD_INT 10
55484: PPUSH
55485: CALL_OW 113
55489: GO 55506
// ComAgressiveMove ( i , 34 , 64 ) ;
55491: LD_VAR 0 1
55495: PPUSH
55496: LD_INT 34
55498: PPUSH
55499: LD_INT 64
55501: PPUSH
55502: CALL_OW 114
55506: GO 55456
55508: POP
55509: POP
// until false ;
55510: LD_INT 0
55512: IFFALSE 55002
// end ;
55514: PPOPN 14
55516: END
// function HeikeInWorkshop ; var i ; begin
55517: LD_INT 0
55519: PPUSH
55520: PPUSH
// result = false ;
55521: LD_ADDR_VAR 0 1
55525: PUSH
55526: LD_INT 0
55528: ST_TO_ADDR
// for i in player_units_in_russian_buildings do
55529: LD_ADDR_VAR 0 2
55533: PUSH
55534: LD_EXP 88
55538: PUSH
55539: FOR_IN
55540: IFFALSE 55592
// if i [ 1 ] = Heike and i [ 2 ] in ai_facts [ 1 ] then
55542: LD_VAR 0 2
55546: PUSH
55547: LD_INT 1
55549: ARRAY
55550: PUSH
55551: LD_EXP 7
55555: EQUAL
55556: PUSH
55557: LD_VAR 0 2
55561: PUSH
55562: LD_INT 2
55564: ARRAY
55565: PUSH
55566: LD_EXP 47
55570: PUSH
55571: LD_INT 1
55573: ARRAY
55574: IN
55575: AND
55576: IFFALSE 55590
// begin result = true ;
55578: LD_ADDR_VAR 0 1
55582: PUSH
55583: LD_INT 1
55585: ST_TO_ADDR
// exit ;
55586: POP
55587: POP
55588: GO 55594
// end ;
55590: GO 55539
55592: POP
55593: POP
// end ;
55594: LD_VAR 0 1
55598: RET
// on SailEvent ( sol ) do var val , i , temp_list , un ; var been_in_archive , not_full_repair_dialogue_played ;
55599: LD_INT 0
55601: PPUSH
55602: PPUSH
55603: PPUSH
55604: PPUSH
55605: PPUSH
55606: PPUSH
// begin been_in_archive = false ;
55607: LD_ADDR_VAR 0 6
55611: PUSH
55612: LD_INT 0
55614: ST_TO_ADDR
// not_full_repair_dialogue_played = false ;
55615: LD_ADDR_VAR 0 7
55619: PUSH
55620: LD_INT 0
55622: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55623: LD_INT 35
55625: PPUSH
55626: CALL_OW 67
// if code_red or code_black then
55630: LD_EXP 76
55634: PUSH
55635: LD_EXP 77
55639: OR
55640: IFFALSE 55644
// exit ;
55642: GO 56152
// if not IsOk ( the_archive ) then
55644: LD_EXP 75
55648: PPUSH
55649: CALL_OW 302
55653: NOT
55654: IFFALSE 55658
// continue ;
55656: GO 55623
// if not been_in_archive then
55658: LD_VAR 0 6
55662: NOT
55663: IFFALSE 55924
// begin i = GetDir ( the_archive ) ;
55665: LD_ADDR_VAR 0 3
55669: PUSH
55670: LD_EXP 75
55674: PPUSH
55675: CALL_OW 254
55679: ST_TO_ADDR
// temp_list = [ ShiftX ( GetX ( the_archive ) , i , 3 ) , ShiftY ( GetY ( the_archive ) , i , 3 ) ] ;
55680: LD_ADDR_VAR 0 4
55684: PUSH
55685: LD_EXP 75
55689: PPUSH
55690: CALL_OW 250
55694: PPUSH
55695: LD_VAR 0 3
55699: PPUSH
55700: LD_INT 3
55702: PPUSH
55703: CALL_OW 272
55707: PUSH
55708: LD_EXP 75
55712: PPUSH
55713: CALL_OW 251
55717: PPUSH
55718: LD_VAR 0 3
55722: PPUSH
55723: LD_INT 3
55725: PPUSH
55726: CALL_OW 273
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: ST_TO_ADDR
// if GetDistUnitXY ( sol , temp_list [ 1 ] , temp_list [ 2 ] ) <= 1 then
55735: LD_VAR 0 1
55739: PPUSH
55740: LD_VAR 0 4
55744: PUSH
55745: LD_INT 1
55747: ARRAY
55748: PPUSH
55749: LD_VAR 0 4
55753: PUSH
55754: LD_INT 2
55756: ARRAY
55757: PPUSH
55758: CALL_OW 297
55762: PUSH
55763: LD_INT 1
55765: LESSEQUAL
55766: IFFALSE 55839
// begin RemoveUnit ( sol ) ;
55768: LD_VAR 0 1
55772: PPUSH
55773: CALL_OW 64
// been_in_archive = true ;
55777: LD_ADDR_VAR 0 6
55781: PUSH
55782: LD_INT 1
55784: ST_TO_ADDR
// wait ( 0 0$4 ) ;
55785: LD_INT 140
55787: PPUSH
55788: CALL_OW 67
// while not PlaceUnitXYR ( sol , temp_list [ 1 ] , temp_list [ 2 ] , 1 , false ) do
55792: LD_VAR 0 1
55796: PPUSH
55797: LD_VAR 0 4
55801: PUSH
55802: LD_INT 1
55804: ARRAY
55805: PPUSH
55806: LD_VAR 0 4
55810: PUSH
55811: LD_INT 2
55813: ARRAY
55814: PPUSH
55815: LD_INT 1
55817: PPUSH
55818: LD_INT 0
55820: PPUSH
55821: CALL_OW 50
55825: NOT
55826: IFFALSE 55837
// wait ( 0 0$0.5 ) ;
55828: LD_INT 18
55830: PPUSH
55831: CALL_OW 67
55835: GO 55792
// end else
55837: GO 55922
// case GetType ( IsInUnit ( sol ) ) of unit_vehicle :
55839: LD_VAR 0 1
55843: PPUSH
55844: CALL_OW 310
55848: PPUSH
55849: CALL_OW 247
55853: PUSH
55854: LD_INT 2
55856: DOUBLE
55857: EQUAL
55858: IFTRUE 55862
55860: GO 55874
55862: POP
// ComExitVehicle ( sol ) ; unit_building :
55863: LD_VAR 0 1
55867: PPUSH
55868: CALL_OW 121
55872: GO 55922
55874: LD_INT 3
55876: DOUBLE
55877: EQUAL
55878: IFTRUE 55882
55880: GO 55894
55882: POP
// ComExitBuilding ( sol ) ; else
55883: LD_VAR 0 1
55887: PPUSH
55888: CALL_OW 122
55892: GO 55922
55894: POP
// ComMoveXY ( sol , temp_list [ 1 ] , temp_list [ 2 ] ) ; end ;
55895: LD_VAR 0 1
55899: PPUSH
55900: LD_VAR 0 4
55904: PUSH
55905: LD_INT 1
55907: ARRAY
55908: PPUSH
55909: LD_VAR 0 4
55913: PUSH
55914: LD_INT 2
55916: ARRAY
55917: PPUSH
55918: CALL_OW 111
// end else
55922: GO 56148
// begin if GetDistUnitXY ( sol , 59 , 43 ) <= 5 then
55924: LD_VAR 0 1
55928: PPUSH
55929: LD_INT 59
55931: PPUSH
55932: LD_INT 43
55934: PPUSH
55935: CALL_OW 297
55939: PUSH
55940: LD_INT 5
55942: LESSEQUAL
55943: IFFALSE 56077
// begin val = true ;
55945: LD_ADDR_VAR 0 2
55949: PUSH
55950: LD_INT 1
55952: ST_TO_ADDR
// for i in intel_party_vehicles do
55953: LD_ADDR_VAR 0 3
55957: PUSH
55958: LD_EXP 114
55962: PUSH
55963: FOR_IN
55964: IFFALSE 55993
// if GetLives ( i ) < 1000 then
55966: LD_VAR 0 3
55970: PPUSH
55971: CALL_OW 256
55975: PUSH
55976: LD_INT 1000
55978: LESS
55979: IFFALSE 55991
// begin val = false ;
55981: LD_ADDR_VAR 0 2
55985: PUSH
55986: LD_INT 0
55988: ST_TO_ADDR
// break ;
55989: GO 55993
// end ;
55991: GO 55963
55993: POP
55994: POP
// if not val then
55995: LD_VAR 0 2
55999: NOT
56000: IFFALSE 56039
// begin if not not_full_repair_dialogue_played then
56002: LD_VAR 0 7
56006: NOT
56007: IFFALSE 56037
// begin DialogueOn ;
56009: CALL_OW 6
// Say ( sol , D14-SolF2-2 ) ;
56013: LD_VAR 0 1
56017: PPUSH
56018: LD_STRING D14-SolF2-2
56020: PPUSH
56021: CALL_OW 88
// DialogueOff ;
56025: CALL_OW 7
// not_full_repair_dialogue_played = true ;
56029: LD_ADDR_VAR 0 7
56033: PUSH
56034: LD_INT 1
56036: ST_TO_ADDR
// end ; continue ;
56037: GO 55623
// end ; if not_full_repair_dialogue_played then
56039: LD_VAR 0 7
56043: IFFALSE 56065
// begin DialogueOn ;
56045: CALL_OW 6
// Say ( sol , D14-SolF2-3 ) ;
56049: LD_VAR 0 1
56053: PPUSH
56054: LD_STRING D14-SolF2-3
56056: PPUSH
56057: CALL_OW 88
// DialogueOff ;
56061: CALL_OW 7
// end ; intel_party_leave = true ;
56065: LD_ADDR_EXP 117
56069: PUSH
56070: LD_INT 1
56072: ST_TO_ADDR
// exit ;
56073: GO 56152
// end else
56075: GO 56148
// case GetType ( IsInUnit ( sol ) ) of unit_vehicle :
56077: LD_VAR 0 1
56081: PPUSH
56082: CALL_OW 310
56086: PPUSH
56087: CALL_OW 247
56091: PUSH
56092: LD_INT 2
56094: DOUBLE
56095: EQUAL
56096: IFTRUE 56100
56098: GO 56112
56100: POP
// ComExitVehicle ( sol ) ; unit_building :
56101: LD_VAR 0 1
56105: PPUSH
56106: CALL_OW 121
56110: GO 56148
56112: LD_INT 3
56114: DOUBLE
56115: EQUAL
56116: IFTRUE 56120
56118: GO 56132
56120: POP
// ComExitBuilding ( sol ) ; else
56121: LD_VAR 0 1
56125: PPUSH
56126: CALL_OW 122
56130: GO 56148
56132: POP
// ComMoveXY ( sol , 59 , 43 ) ; end ;
56133: LD_VAR 0 1
56137: PPUSH
56138: LD_INT 59
56140: PPUSH
56141: LD_INT 43
56143: PPUSH
56144: CALL_OW 111
// end ; until false ;
56148: LD_INT 0
56150: IFFALSE 55623
// end ;
56152: PPOPN 7
56154: END
// every 0 0$1 + 0 0$0.3 do var i , temp_list , val , temp_list_2 , def_buildings , speaker ; var initial_cooldown , heike_in_base , dialogue_level , dialogue_cooldown ;
56155: GO 56157
56157: DISABLE
56158: LD_INT 0
56160: PPUSH
56161: PPUSH
56162: PPUSH
56163: PPUSH
56164: PPUSH
56165: PPUSH
56166: PPUSH
56167: PPUSH
56168: PPUSH
56169: PPUSH
// begin initial_cooldown = 0 0$5 ;
56170: LD_ADDR_VAR 0 7
56174: PUSH
56175: LD_INT 175
56177: ST_TO_ADDR
// heike_in_base = false ;
56178: LD_ADDR_VAR 0 8
56182: PUSH
56183: LD_INT 0
56185: ST_TO_ADDR
// dialogue_level = 0 ;
56186: LD_ADDR_VAR 0 9
56190: PUSH
56191: LD_INT 0
56193: ST_TO_ADDR
// dialogue_cooldown = 0 0$0 ;
56194: LD_ADDR_VAR 0 10
56198: PUSH
56199: LD_INT 0
56201: ST_TO_ADDR
// repeat heike_in_base = IsInArea ( Heike , ru_base_area ) ;
56202: LD_ADDR_VAR 0 8
56206: PUSH
56207: LD_EXP 7
56211: PPUSH
56212: LD_INT 2
56214: PPUSH
56215: CALL_OW 308
56219: ST_TO_ADDR
// if heike_in_base then
56220: LD_VAR 0 8
56224: IFFALSE 56234
// dialogue_level = 0 ;
56226: LD_ADDR_VAR 0 9
56230: PUSH
56231: LD_INT 0
56233: ST_TO_ADDR
// wait ( 0 0$0.5 ) ;
56234: LD_INT 18
56236: PPUSH
56237: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] then
56241: LD_EXP 83
56245: PUSH
56246: LD_INT 3
56248: PUSH
56249: LD_INT 4
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: IN
56256: IFFALSE 56260
// exit ;
56258: GO 57193
// if heike_undercover in [ 0 , 1 ] or not entrance_guard_dialogue_played then
56260: LD_EXP 83
56264: PUSH
56265: LD_INT 0
56267: PUSH
56268: LD_INT 1
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: IN
56275: PUSH
56276: LD_EXP 84
56280: NOT
56281: OR
56282: IFFALSE 56286
// continue ;
56284: GO 56202
// if initial_cooldown > 0 0$0 then
56286: LD_VAR 0 7
56290: PUSH
56291: LD_INT 0
56293: GREATER
56294: IFFALSE 56312
// begin initial_cooldown = initial_cooldown - 0 0$0.5 ;
56296: LD_ADDR_VAR 0 7
56300: PUSH
56301: LD_VAR 0 7
56305: PUSH
56306: LD_INT 18
56308: MINUS
56309: ST_TO_ADDR
// continue ;
56310: GO 56202
// end ; if dialogue_cooldown > 0 0$0 then
56312: LD_VAR 0 10
56316: PUSH
56317: LD_INT 0
56319: GREATER
56320: IFFALSE 56338
// begin dialogue_cooldown = dialogue_cooldown - 0 0$0.5 ;
56322: LD_ADDR_VAR 0 10
56326: PUSH
56327: LD_VAR 0 10
56331: PUSH
56332: LD_INT 18
56334: MINUS
56335: ST_TO_ADDR
// continue ;
56336: GO 56202
// end ; if not ( IsInArea ( Heike , just_outside_rus_base ) or ( dialogue_level > 0 and not IsInArea ( Heike , ru_base_area ) ) ) then
56338: LD_EXP 7
56342: PPUSH
56343: LD_INT 15
56345: PPUSH
56346: CALL_OW 308
56350: PUSH
56351: LD_VAR 0 9
56355: PUSH
56356: LD_INT 0
56358: GREATER
56359: PUSH
56360: LD_EXP 7
56364: PPUSH
56365: LD_INT 2
56367: PPUSH
56368: CALL_OW 308
56372: NOT
56373: AND
56374: OR
56375: NOT
56376: IFFALSE 56380
// continue ;
56378: GO 56202
// speaker = 0 ;
56380: LD_ADDR_VAR 0 6
56384: PUSH
56385: LD_INT 0
56387: ST_TO_ADDR
// def_buildings = ai_armouries [ 1 ] ^ ai_bunkers [ 1 ] ;
56388: LD_ADDR_VAR 0 5
56392: PUSH
56393: LD_EXP 48
56397: PUSH
56398: LD_INT 1
56400: ARRAY
56401: PUSH
56402: LD_EXP 49
56406: PUSH
56407: LD_INT 1
56409: ARRAY
56410: ADD
56411: ST_TO_ADDR
// if def_buildings > 0 then
56412: LD_VAR 0 5
56416: PUSH
56417: LD_INT 0
56419: GREATER
56420: IFFALSE 56799
// begin temp_list = [ ] ;
56422: LD_ADDR_VAR 0 2
56426: PUSH
56427: EMPTY
56428: ST_TO_ADDR
// for i in def_buildings do
56429: LD_ADDR_VAR 0 1
56433: PUSH
56434: LD_VAR 0 5
56438: PUSH
56439: FOR_IN
56440: IFFALSE 56470
// temp_list = temp_list ^ GetDistUnits ( i , Heike ) ;
56442: LD_ADDR_VAR 0 2
56446: PUSH
56447: LD_VAR 0 2
56451: PUSH
56452: LD_VAR 0 1
56456: PPUSH
56457: LD_EXP 7
56461: PPUSH
56462: CALL_OW 296
56466: ADD
56467: ST_TO_ADDR
56468: GO 56439
56470: POP
56471: POP
// val = WorstFromListByList ( def_buildings , temp_list ) ;
56472: LD_ADDR_VAR 0 3
56476: PUSH
56477: LD_VAR 0 5
56481: PPUSH
56482: LD_VAR 0 2
56486: PPUSH
56487: CALL_OW 78
56491: ST_TO_ADDR
// if val in ai_bunkers [ 1 ] then
56492: LD_VAR 0 3
56496: PUSH
56497: LD_EXP 49
56501: PUSH
56502: LD_INT 1
56504: ARRAY
56505: IN
56506: IFFALSE 56524
// temp_list = ai_bunkers [ 1 ] else
56508: LD_ADDR_VAR 0 2
56512: PUSH
56513: LD_EXP 49
56517: PUSH
56518: LD_INT 1
56520: ARRAY
56521: ST_TO_ADDR
56522: GO 56537
// temp_list = [ val ] ;
56524: LD_ADDR_VAR 0 2
56528: PUSH
56529: LD_VAR 0 3
56533: PUSH
56534: EMPTY
56535: LIST
56536: ST_TO_ADDR
// temp_list_2 = [ ] ;
56537: LD_ADDR_VAR 0 4
56541: PUSH
56542: EMPTY
56543: ST_TO_ADDR
// for i in temp_list do
56544: LD_ADDR_VAR 0 1
56548: PUSH
56549: LD_VAR 0 2
56553: PUSH
56554: FOR_IN
56555: IFFALSE 56580
// temp_list_2 = temp_list_2 ^ UnitsInside ( i ) ;
56557: LD_ADDR_VAR 0 4
56561: PUSH
56562: LD_VAR 0 4
56566: PUSH
56567: LD_VAR 0 1
56571: PPUSH
56572: CALL_OW 313
56576: ADD
56577: ST_TO_ADDR
56578: GO 56554
56580: POP
56581: POP
// temp_list_2 = temp_list_2 diff [ Stanimir , Yefibachev , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_sol ] ;
56582: LD_ADDR_VAR 0 4
56586: PUSH
56587: LD_VAR 0 4
56591: PUSH
56592: LD_EXP 12
56596: PUSH
56597: LD_EXP 14
56601: PUSH
56602: LD_EXP 18
56606: PUSH
56607: LD_EXP 19
56611: PUSH
56612: LD_EXP 20
56616: PUSH
56617: LD_EXP 21
56621: PUSH
56622: LD_EXP 22
56626: PUSH
56627: LD_EXP 24
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: LIST
56636: LIST
56637: LIST
56638: LIST
56639: LIST
56640: LIST
56641: DIFF
56642: ST_TO_ADDR
// if temp_list_2 > 0 then
56643: LD_VAR 0 4
56647: PUSH
56648: LD_INT 0
56650: GREATER
56651: IFFALSE 56669
// speaker = temp_list_2 [ 1 ] else
56653: LD_ADDR_VAR 0 6
56657: PUSH
56658: LD_VAR 0 4
56662: PUSH
56663: LD_INT 1
56665: ARRAY
56666: ST_TO_ADDR
56667: GO 56799
// begin temp_list_2 = [ ] ;
56669: LD_ADDR_VAR 0 4
56673: PUSH
56674: EMPTY
56675: ST_TO_ADDR
// for i in def_buildings do
56676: LD_ADDR_VAR 0 1
56680: PUSH
56681: LD_VAR 0 5
56685: PUSH
56686: FOR_IN
56687: IFFALSE 56712
// temp_list_2 = temp_list_2 ^ UnitsInside ( i ) ;
56689: LD_ADDR_VAR 0 4
56693: PUSH
56694: LD_VAR 0 4
56698: PUSH
56699: LD_VAR 0 1
56703: PPUSH
56704: CALL_OW 313
56708: ADD
56709: ST_TO_ADDR
56710: GO 56686
56712: POP
56713: POP
// temp_list_2 = temp_list_2 diff [ Stanimir , Yefibachev , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_sol ] ;
56714: LD_ADDR_VAR 0 4
56718: PUSH
56719: LD_VAR 0 4
56723: PUSH
56724: LD_EXP 12
56728: PUSH
56729: LD_EXP 14
56733: PUSH
56734: LD_EXP 18
56738: PUSH
56739: LD_EXP 19
56743: PUSH
56744: LD_EXP 20
56748: PUSH
56749: LD_EXP 21
56753: PUSH
56754: LD_EXP 22
56758: PUSH
56759: LD_EXP 24
56763: PUSH
56764: EMPTY
56765: LIST
56766: LIST
56767: LIST
56768: LIST
56769: LIST
56770: LIST
56771: LIST
56772: LIST
56773: DIFF
56774: ST_TO_ADDR
// if temp_list_2 > 0 then
56775: LD_VAR 0 4
56779: PUSH
56780: LD_INT 0
56782: GREATER
56783: IFFALSE 56799
// speaker = temp_list_2 [ 1 ] ;
56785: LD_ADDR_VAR 0 6
56789: PUSH
56790: LD_VAR 0 4
56794: PUSH
56795: LD_INT 1
56797: ARRAY
56798: ST_TO_ADDR
// end ; end ; if speaker = 0 then
56799: LD_VAR 0 6
56803: PUSH
56804: LD_INT 0
56806: EQUAL
56807: IFFALSE 56898
// begin temp_list_2 = ai_soldiers [ 1 ] diff [ Stanimir , Yefibachev , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_sol ] ;
56809: LD_ADDR_VAR 0 4
56813: PUSH
56814: LD_EXP 26
56818: PUSH
56819: LD_INT 1
56821: ARRAY
56822: PUSH
56823: LD_EXP 12
56827: PUSH
56828: LD_EXP 14
56832: PUSH
56833: LD_EXP 18
56837: PUSH
56838: LD_EXP 19
56842: PUSH
56843: LD_EXP 20
56847: PUSH
56848: LD_EXP 21
56852: PUSH
56853: LD_EXP 22
56857: PUSH
56858: LD_EXP 24
56862: PUSH
56863: EMPTY
56864: LIST
56865: LIST
56866: LIST
56867: LIST
56868: LIST
56869: LIST
56870: LIST
56871: LIST
56872: DIFF
56873: ST_TO_ADDR
// if temp_list_2 > 0 then
56874: LD_VAR 0 4
56878: PUSH
56879: LD_INT 0
56881: GREATER
56882: IFFALSE 56898
// speaker = temp_list_2 [ 1 ] ;
56884: LD_ADDR_VAR 0 6
56888: PUSH
56889: LD_VAR 0 4
56893: PUSH
56894: LD_INT 1
56896: ARRAY
56897: ST_TO_ADDR
// end ; DialogueOn ;
56898: CALL_OW 6
// case dialogue_level of 0 :
56902: LD_VAR 0 9
56906: PUSH
56907: LD_INT 0
56909: DOUBLE
56910: EQUAL
56911: IFTRUE 56915
56913: GO 57024
56915: POP
// begin if heike_in_base then
56916: LD_VAR 0 8
56920: IFFALSE 56973
// begin if GetSex ( speaker ) = sex_male then
56922: LD_VAR 0 6
56926: PPUSH
56927: CALL_OW 258
56931: PUSH
56932: LD_INT 1
56934: EQUAL
56935: IFFALSE 56951
// Say ( speaker , D21-SolM-1 ) else
56937: LD_VAR 0 6
56941: PPUSH
56942: LD_STRING D21-SolM-1
56944: PPUSH
56945: CALL_OW 88
56949: GO 56963
// Say ( speaker , D21-SolF-1 ) ;
56951: LD_VAR 0 6
56955: PPUSH
56956: LD_STRING D21-SolF-1
56958: PPUSH
56959: CALL_OW 88
// dialogue_cooldown = 0 0$4 ;
56963: LD_ADDR_VAR 0 10
56967: PUSH
56968: LD_INT 140
56970: ST_TO_ADDR
// end else
56971: GO 57022
// begin if GetSex ( speaker ) = sex_male then
56973: LD_VAR 0 6
56977: PPUSH
56978: CALL_OW 258
56982: PUSH
56983: LD_INT 1
56985: EQUAL
56986: IFFALSE 57002
// Say ( speaker , D21-SolM-4 ) else
56988: LD_VAR 0 6
56992: PPUSH
56993: LD_STRING D21-SolM-4
56995: PPUSH
56996: CALL_OW 88
57000: GO 57014
// Say ( speaker , D21-SolF-4 ) ;
57002: LD_VAR 0 6
57006: PPUSH
57007: LD_STRING D21-SolF-4
57009: PPUSH
57010: CALL_OW 88
// dialogue_cooldown = 0 0$5 ;
57014: LD_ADDR_VAR 0 10
57018: PUSH
57019: LD_INT 175
57021: ST_TO_ADDR
// end ; end ; 1 :
57022: GO 57171
57024: LD_INT 1
57026: DOUBLE
57027: EQUAL
57028: IFTRUE 57032
57030: GO 57084
57032: POP
// begin if GetSex ( speaker ) = sex_male then
57033: LD_VAR 0 6
57037: PPUSH
57038: CALL_OW 258
57042: PUSH
57043: LD_INT 1
57045: EQUAL
57046: IFFALSE 57062
// Say ( speaker , D21-SolM-2 ) else
57048: LD_VAR 0 6
57052: PPUSH
57053: LD_STRING D21-SolM-2
57055: PPUSH
57056: CALL_OW 88
57060: GO 57074
// Say ( speaker , D21-SolF-2 ) ;
57062: LD_VAR 0 6
57066: PPUSH
57067: LD_STRING D21-SolF-2
57069: PPUSH
57070: CALL_OW 88
// dialogue_cooldown = 0 0$4 ;
57074: LD_ADDR_VAR 0 10
57078: PUSH
57079: LD_INT 140
57081: ST_TO_ADDR
// end ; 2 :
57082: GO 57171
57084: LD_INT 2
57086: DOUBLE
57087: EQUAL
57088: IFTRUE 57092
57090: GO 57170
57092: POP
// begin if GetSex ( speaker ) = sex_male then
57093: LD_VAR 0 6
57097: PPUSH
57098: CALL_OW 258
57102: PUSH
57103: LD_INT 1
57105: EQUAL
57106: IFFALSE 57122
// Say ( speaker , D21-SolM-3 ) else
57108: LD_VAR 0 6
57112: PPUSH
57113: LD_STRING D21-SolM-3
57115: PPUSH
57116: CALL_OW 88
57120: GO 57134
// Say ( speaker , D21-SolF-3 ) ;
57122: LD_VAR 0 6
57126: PPUSH
57127: LD_STRING D21-SolF-3
57129: PPUSH
57130: CALL_OW 88
// code_red = true ;
57134: LD_ADDR_EXP 76
57138: PUSH
57139: LD_INT 1
57141: ST_TO_ADDR
// CreateCodeRedPatrols ( difficulty - 1 ) ;
57142: LD_OWVAR 67
57146: PUSH
57147: LD_INT 1
57149: MINUS
57150: PPUSH
57151: CALL 38894 0 1
// ChangeHeikeUndercoverStatus ( 4 ) ;
57155: LD_INT 4
57157: PPUSH
57158: CALL 42004 0 1
// DialogueOff ;
57162: CALL_OW 7
// exit ;
57166: GO 57193
// end ; end ;
57168: GO 57171
57170: POP
// DialogueOff ;
57171: CALL_OW 7
// dialogue_level = dialogue_level + 1 ;
57175: LD_ADDR_VAR 0 9
57179: PUSH
57180: LD_VAR 0 9
57184: PUSH
57185: LD_INT 1
57187: PLUS
57188: ST_TO_ADDR
// until false ;
57189: LD_INT 0
57191: IFFALSE 56202
// end ;
57193: PPOPN 10
57195: END
// every 0 0$1 + 0 0$0.4 do var b , temp_list , hex_list , forbidden_units , i ;
57196: GO 57198
57198: DISABLE
57199: LD_INT 0
57201: PPUSH
57202: PPUSH
57203: PPUSH
57204: PPUSH
57205: PPUSH
// begin repeat wait ( 0 0$0.5 ) ;
57206: LD_INT 18
57208: PPUSH
57209: CALL_OW 67
// forbidden_units = [ ] ;
57213: LD_ADDR_VAR 0 4
57217: PUSH
57218: EMPTY
57219: ST_TO_ADDR
// i = 1 ;
57220: LD_ADDR_VAR 0 5
57224: PUSH
57225: LD_INT 1
57227: ST_TO_ADDR
// while i <= recent_not_went_inside_units do
57228: LD_VAR 0 5
57232: PUSH
57233: LD_EXP 89
57237: LESSEQUAL
57238: IFFALSE 57380
// begin temp_list = Replace ( recent_not_went_inside_units [ i ] , 2 , recent_not_went_inside_units [ i ] [ 2 ] - 0 0$0.5 ) ;
57240: LD_ADDR_VAR 0 2
57244: PUSH
57245: LD_EXP 89
57249: PUSH
57250: LD_VAR 0 5
57254: ARRAY
57255: PPUSH
57256: LD_INT 2
57258: PPUSH
57259: LD_EXP 89
57263: PUSH
57264: LD_VAR 0 5
57268: ARRAY
57269: PUSH
57270: LD_INT 2
57272: ARRAY
57273: PUSH
57274: LD_INT 18
57276: MINUS
57277: PPUSH
57278: CALL_OW 1
57282: ST_TO_ADDR
// if temp_list [ 2 ] <= 0 0$0 then
57283: LD_VAR 0 2
57287: PUSH
57288: LD_INT 2
57290: ARRAY
57291: PUSH
57292: LD_INT 0
57294: LESSEQUAL
57295: IFFALSE 57319
// begin recent_not_went_inside_units = Delete ( recent_not_went_inside_units , i ) ;
57297: LD_ADDR_EXP 89
57301: PUSH
57302: LD_EXP 89
57306: PPUSH
57307: LD_VAR 0 5
57311: PPUSH
57312: CALL_OW 3
57316: ST_TO_ADDR
// end else
57317: GO 57378
// begin recent_not_went_inside_units = Replace ( recent_not_went_inside_units , i , temp_list ) ;
57319: LD_ADDR_EXP 89
57323: PUSH
57324: LD_EXP 89
57328: PPUSH
57329: LD_VAR 0 5
57333: PPUSH
57334: LD_VAR 0 2
57338: PPUSH
57339: CALL_OW 1
57343: ST_TO_ADDR
// forbidden_units = forbidden_units ^ temp_list [ 1 ] ;
57344: LD_ADDR_VAR 0 4
57348: PUSH
57349: LD_VAR 0 4
57353: PUSH
57354: LD_VAR 0 2
57358: PUSH
57359: LD_INT 1
57361: ARRAY
57362: ADD
57363: ST_TO_ADDR
// i = i + 1 ;
57364: LD_ADDR_VAR 0 5
57368: PUSH
57369: LD_VAR 0 5
57373: PUSH
57374: LD_INT 1
57376: PLUS
57377: ST_TO_ADDR
// end ; end ;
57378: GO 57228
// for b in UnitFilter ( ai_depot [ 1 ] ^ depot_north ^ ai_labs [ 1 ] ^ ai_facts [ 1 ] ^ ai_armouries [ 1 ] , [ f_ok ] ) do
57380: LD_ADDR_VAR 0 1
57384: PUSH
57385: LD_EXP 32
57389: PUSH
57390: LD_INT 1
57392: ARRAY
57393: PUSH
57394: LD_EXP 86
57398: ADD
57399: PUSH
57400: LD_EXP 33
57404: PUSH
57405: LD_INT 1
57407: ARRAY
57408: ADD
57409: PUSH
57410: LD_EXP 47
57414: PUSH
57415: LD_INT 1
57417: ARRAY
57418: ADD
57419: PUSH
57420: LD_EXP 48
57424: PUSH
57425: LD_INT 1
57427: ARRAY
57428: ADD
57429: PPUSH
57430: LD_INT 50
57432: PUSH
57433: EMPTY
57434: LIST
57435: PPUSH
57436: CALL_OW 72
57440: PUSH
57441: FOR_IN
57442: IFFALSE 57863
// begin hex_list = GetBuildingEntranceHexes ( b ) ;
57444: LD_ADDR_VAR 0 3
57448: PUSH
57449: LD_VAR 0 1
57453: PPUSH
57454: CALL 57872 0 1
57458: ST_TO_ADDR
// temp_list = [ ] ;
57459: LD_ADDR_VAR 0 2
57463: PUSH
57464: EMPTY
57465: ST_TO_ADDR
// for i in hex_list do
57466: LD_ADDR_VAR 0 5
57470: PUSH
57471: LD_VAR 0 3
57475: PUSH
57476: FOR_IN
57477: IFFALSE 57515
// temp_list = temp_list ^ HexInfo ( i [ 1 ] , i [ 2 ] ) ;
57479: LD_ADDR_VAR 0 2
57483: PUSH
57484: LD_VAR 0 2
57488: PUSH
57489: LD_VAR 0 5
57493: PUSH
57494: LD_INT 1
57496: ARRAY
57497: PPUSH
57498: LD_VAR 0 5
57502: PUSH
57503: LD_INT 2
57505: ARRAY
57506: PPUSH
57507: CALL_OW 428
57511: ADD
57512: ST_TO_ADDR
57513: GO 57476
57515: POP
57516: POP
// temp_list = UnitFilter ( temp_list , [ [ f_type , unit_human ] , [ f_side , you ] , [ f_not , [ f_hastask ] ] , [ f_ok ] ] ) diff Gonzo ;
57517: LD_ADDR_VAR 0 2
57521: PUSH
57522: LD_VAR 0 2
57526: PPUSH
57527: LD_INT 21
57529: PUSH
57530: LD_INT 1
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: PUSH
57537: LD_INT 22
57539: PUSH
57540: LD_EXP 2
57544: PUSH
57545: EMPTY
57546: LIST
57547: LIST
57548: PUSH
57549: LD_INT 3
57551: PUSH
57552: LD_INT 60
57554: PUSH
57555: EMPTY
57556: LIST
57557: PUSH
57558: EMPTY
57559: LIST
57560: LIST
57561: PUSH
57562: LD_INT 50
57564: PUSH
57565: EMPTY
57566: LIST
57567: PUSH
57568: EMPTY
57569: LIST
57570: LIST
57571: LIST
57572: LIST
57573: PPUSH
57574: CALL_OW 72
57578: PUSH
57579: LD_EXP 11
57583: DIFF
57584: ST_TO_ADDR
// if b in ai_armouries [ 1 ] then
57585: LD_VAR 0 1
57589: PUSH
57590: LD_EXP 48
57594: PUSH
57595: LD_INT 1
57597: ARRAY
57598: IN
57599: IFFALSE 57660
// begin if heike_undercover = 2 and Heike in temp_list and not Heike in forbidden_units then
57601: LD_EXP 83
57605: PUSH
57606: LD_INT 2
57608: EQUAL
57609: PUSH
57610: LD_EXP 7
57614: PUSH
57615: LD_VAR 0 2
57619: IN
57620: AND
57621: PUSH
57622: LD_EXP 7
57626: PUSH
57627: LD_VAR 0 4
57631: IN
57632: NOT
57633: AND
57634: IFFALSE 57651
// temp_list = [ Heike ] else
57636: LD_ADDR_VAR 0 2
57640: PUSH
57641: LD_EXP 7
57645: PUSH
57646: EMPTY
57647: LIST
57648: ST_TO_ADDR
57649: GO 57658
// temp_list = [ ] ;
57651: LD_ADDR_VAR 0 2
57655: PUSH
57656: EMPTY
57657: ST_TO_ADDR
// end else
57658: GO 57676
// temp_list = temp_list diff forbidden_units ;
57660: LD_ADDR_VAR 0 2
57664: PUSH
57665: LD_VAR 0 2
57669: PUSH
57670: LD_VAR 0 4
57674: DIFF
57675: ST_TO_ADDR
// if temp_list > 0 then
57676: LD_VAR 0 2
57680: PUSH
57681: LD_INT 0
57683: GREATER
57684: IFFALSE 57861
// begin if Query ( QEnterBuilding ) = 1 then
57686: LD_STRING QEnterBuilding
57688: PPUSH
57689: CALL_OW 97
57693: PUSH
57694: LD_INT 1
57696: EQUAL
57697: IFFALSE 57816
// begin for i in temp_list do
57699: LD_ADDR_VAR 0 5
57703: PUSH
57704: LD_VAR 0 2
57708: PUSH
57709: FOR_IN
57710: IFFALSE 57779
// begin player_units_in_russian_buildings = player_units_in_russian_buildings ^ [ [ i , b ] ] ;
57712: LD_ADDR_EXP 88
57716: PUSH
57717: LD_EXP 88
57721: PUSH
57722: LD_VAR 0 5
57726: PUSH
57727: LD_VAR 0 1
57731: PUSH
57732: EMPTY
57733: LIST
57734: LIST
57735: PUSH
57736: EMPTY
57737: LIST
57738: ADD
57739: ST_TO_ADDR
// RemoveUnit ( i ) ;
57740: LD_VAR 0 5
57744: PPUSH
57745: CALL_OW 64
// recent_player_units_enter_russian_buildings = recent_player_units_enter_russian_buildings ^ [ [ i , b ] ] ;
57749: LD_ADDR_EXP 92
57753: PUSH
57754: LD_EXP 92
57758: PUSH
57759: LD_VAR 0 5
57763: PUSH
57764: LD_VAR 0 1
57768: PUSH
57769: EMPTY
57770: LIST
57771: LIST
57772: PUSH
57773: EMPTY
57774: LIST
57775: ADD
57776: ST_TO_ADDR
// end ;
57777: GO 57709
57779: POP
57780: POP
// PlaceSeeing ( GetX ( b ) , GetY ( b ) , you , - 7 ) ;
57781: LD_VAR 0 1
57785: PPUSH
57786: CALL_OW 250
57790: PPUSH
57791: LD_VAR 0 1
57795: PPUSH
57796: CALL_OW 251
57800: PPUSH
57801: LD_EXP 2
57805: PPUSH
57806: LD_INT 7
57808: NEG
57809: PPUSH
57810: CALL_OW 330
// end else
57814: GO 57861
// begin for i in temp_list do
57816: LD_ADDR_VAR 0 5
57820: PUSH
57821: LD_VAR 0 2
57825: PUSH
57826: FOR_IN
57827: IFFALSE 57859
// recent_not_went_inside_units = recent_not_went_inside_units ^ [ [ i , reenter_building_cooldown ] ] ;
57829: LD_ADDR_EXP 89
57833: PUSH
57834: LD_EXP 89
57838: PUSH
57839: LD_VAR 0 5
57843: PUSH
57844: LD_EXP 109
57848: PUSH
57849: EMPTY
57850: LIST
57851: LIST
57852: PUSH
57853: EMPTY
57854: LIST
57855: ADD
57856: ST_TO_ADDR
57857: GO 57826
57859: POP
57860: POP
// end ; end ; end ;
57861: GO 57441
57863: POP
57864: POP
// until false ;
57865: LD_INT 0
57867: IFFALSE 57206
// end ;
57869: PPOPN 5
57871: END
// function GetBuildingEntranceHexes ( building ) ; var shape , d , new_shape , b , direction , x , y , temp_list ; begin
57872: LD_INT 0
57874: PPUSH
57875: PPUSH
57876: PPUSH
57877: PPUSH
57878: PPUSH
57879: PPUSH
57880: PPUSH
57881: PPUSH
57882: PPUSH
// case GetBType ( building ) of b_armoury , b_barracks , b_fort :
57883: LD_VAR 0 1
57887: PPUSH
57888: CALL_OW 266
57892: PUSH
57893: LD_INT 4
57895: DOUBLE
57896: EQUAL
57897: IFTRUE 57913
57899: LD_INT 5
57901: DOUBLE
57902: EQUAL
57903: IFTRUE 57913
57905: LD_INT 35
57907: DOUBLE
57908: EQUAL
57909: IFTRUE 57913
57911: GO 57997
57913: POP
// shape = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] ] ; b_depot , b_warehouse :
57914: LD_ADDR_VAR 0 3
57918: PUSH
57919: LD_INT 1
57921: NEG
57922: PUSH
57923: LD_INT 3
57925: NEG
57926: PUSH
57927: EMPTY
57928: LIST
57929: LIST
57930: PUSH
57931: LD_INT 0
57933: PUSH
57934: LD_INT 3
57936: NEG
57937: PUSH
57938: EMPTY
57939: LIST
57940: LIST
57941: PUSH
57942: LD_INT 1
57944: PUSH
57945: LD_INT 2
57947: NEG
57948: PUSH
57949: EMPTY
57950: LIST
57951: LIST
57952: PUSH
57953: LD_INT 1
57955: NEG
57956: PUSH
57957: LD_INT 4
57959: NEG
57960: PUSH
57961: EMPTY
57962: LIST
57963: LIST
57964: PUSH
57965: LD_INT 0
57967: PUSH
57968: LD_INT 4
57970: NEG
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: PUSH
57976: LD_INT 1
57978: PUSH
57979: LD_INT 3
57981: NEG
57982: PUSH
57983: EMPTY
57984: LIST
57985: LIST
57986: PUSH
57987: EMPTY
57988: LIST
57989: LIST
57990: LIST
57991: LIST
57992: LIST
57993: LIST
57994: ST_TO_ADDR
57995: GO 58310
57997: LD_INT 0
57999: DOUBLE
58000: EQUAL
58001: IFTRUE 58011
58003: LD_INT 1
58005: DOUBLE
58006: EQUAL
58007: IFTRUE 58011
58009: GO 58095
58011: POP
// shape = [ [ - 1 , - 4 ] , [ 0 , - 3 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 4 ] , [ 1 , - 4 ] ] ; b_lab , b_lab_half , b_lab_full :
58012: LD_ADDR_VAR 0 3
58016: PUSH
58017: LD_INT 1
58019: NEG
58020: PUSH
58021: LD_INT 4
58023: NEG
58024: PUSH
58025: EMPTY
58026: LIST
58027: LIST
58028: PUSH
58029: LD_INT 0
58031: PUSH
58032: LD_INT 3
58034: NEG
58035: PUSH
58036: EMPTY
58037: LIST
58038: LIST
58039: PUSH
58040: LD_INT 1
58042: PUSH
58043: LD_INT 3
58045: NEG
58046: PUSH
58047: EMPTY
58048: LIST
58049: LIST
58050: PUSH
58051: LD_INT 1
58053: NEG
58054: PUSH
58055: LD_INT 5
58057: NEG
58058: PUSH
58059: EMPTY
58060: LIST
58061: LIST
58062: PUSH
58063: LD_INT 0
58065: PUSH
58066: LD_INT 4
58068: NEG
58069: PUSH
58070: EMPTY
58071: LIST
58072: LIST
58073: PUSH
58074: LD_INT 1
58076: PUSH
58077: LD_INT 4
58079: NEG
58080: PUSH
58081: EMPTY
58082: LIST
58083: LIST
58084: PUSH
58085: EMPTY
58086: LIST
58087: LIST
58088: LIST
58089: LIST
58090: LIST
58091: LIST
58092: ST_TO_ADDR
58093: GO 58310
58095: LD_INT 6
58097: DOUBLE
58098: EQUAL
58099: IFTRUE 58115
58101: LD_INT 7
58103: DOUBLE
58104: EQUAL
58105: IFTRUE 58115
58107: LD_INT 8
58109: DOUBLE
58110: EQUAL
58111: IFTRUE 58115
58113: GO 58211
58115: POP
// shape = [ [ - 1 , - 3 ] , [ 0 , - 2 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] ] ; b_workshop , b_factory :
58116: LD_ADDR_VAR 0 3
58120: PUSH
58121: LD_INT 1
58123: NEG
58124: PUSH
58125: LD_INT 3
58127: NEG
58128: PUSH
58129: EMPTY
58130: LIST
58131: LIST
58132: PUSH
58133: LD_INT 0
58135: PUSH
58136: LD_INT 2
58138: NEG
58139: PUSH
58140: EMPTY
58141: LIST
58142: LIST
58143: PUSH
58144: LD_INT 1
58146: PUSH
58147: LD_INT 2
58149: NEG
58150: PUSH
58151: EMPTY
58152: LIST
58153: LIST
58154: PUSH
58155: LD_INT 1
58157: NEG
58158: PUSH
58159: LD_INT 4
58161: NEG
58162: PUSH
58163: EMPTY
58164: LIST
58165: LIST
58166: PUSH
58167: LD_INT 0
58169: PUSH
58170: LD_INT 3
58172: NEG
58173: PUSH
58174: EMPTY
58175: LIST
58176: LIST
58177: PUSH
58178: LD_INT 0
58180: PUSH
58181: LD_INT 4
58183: NEG
58184: PUSH
58185: EMPTY
58186: LIST
58187: LIST
58188: PUSH
58189: LD_INT 1
58191: PUSH
58192: LD_INT 3
58194: NEG
58195: PUSH
58196: EMPTY
58197: LIST
58198: LIST
58199: PUSH
58200: EMPTY
58201: LIST
58202: LIST
58203: LIST
58204: LIST
58205: LIST
58206: LIST
58207: LIST
58208: ST_TO_ADDR
58209: GO 58310
58211: LD_INT 2
58213: DOUBLE
58214: EQUAL
58215: IFTRUE 58225
58217: LD_INT 3
58219: DOUBLE
58220: EQUAL
58221: IFTRUE 58225
58223: GO 58309
58225: POP
// shape = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] ] ; end ;
58226: LD_ADDR_VAR 0 3
58230: PUSH
58231: LD_INT 1
58233: NEG
58234: PUSH
58235: LD_INT 3
58237: NEG
58238: PUSH
58239: EMPTY
58240: LIST
58241: LIST
58242: PUSH
58243: LD_INT 0
58245: PUSH
58246: LD_INT 3
58248: NEG
58249: PUSH
58250: EMPTY
58251: LIST
58252: LIST
58253: PUSH
58254: LD_INT 1
58256: PUSH
58257: LD_INT 2
58259: NEG
58260: PUSH
58261: EMPTY
58262: LIST
58263: LIST
58264: PUSH
58265: LD_INT 1
58267: NEG
58268: PUSH
58269: LD_INT 4
58271: NEG
58272: PUSH
58273: EMPTY
58274: LIST
58275: LIST
58276: PUSH
58277: LD_INT 0
58279: PUSH
58280: LD_INT 4
58282: NEG
58283: PUSH
58284: EMPTY
58285: LIST
58286: LIST
58287: PUSH
58288: LD_INT 1
58290: PUSH
58291: LD_INT 3
58293: NEG
58294: PUSH
58295: EMPTY
58296: LIST
58297: LIST
58298: PUSH
58299: EMPTY
58300: LIST
58301: LIST
58302: LIST
58303: LIST
58304: LIST
58305: LIST
58306: ST_TO_ADDR
58307: GO 58310
58309: POP
// direction = GetDir ( building ) ;
58310: LD_ADDR_VAR 0 7
58314: PUSH
58315: LD_VAR 0 1
58319: PPUSH
58320: CALL_OW 254
58324: ST_TO_ADDR
// if direction in [ 0 , 5 ] then
58325: LD_VAR 0 7
58329: PUSH
58330: LD_INT 0
58332: PUSH
58333: LD_INT 5
58335: PUSH
58336: EMPTY
58337: LIST
58338: LIST
58339: IN
58340: IFFALSE 58438
// begin temp_list = shape ;
58342: LD_ADDR_VAR 0 10
58346: PUSH
58347: LD_VAR 0 3
58351: ST_TO_ADDR
// for d = 1 to 3 do
58352: LD_ADDR_VAR 0 4
58356: PUSH
58357: DOUBLE
58358: LD_INT 1
58360: DEC
58361: ST_TO_ADDR
58362: LD_INT 3
58364: PUSH
58365: FOR_TO
58366: IFFALSE 58426
// temp_list = Insert ( temp_list , 1 , [ shape [ d ] [ 1 ] , shape [ d ] [ 2 ] - 2 ] ) ;
58368: LD_ADDR_VAR 0 10
58372: PUSH
58373: LD_VAR 0 10
58377: PPUSH
58378: LD_INT 1
58380: PPUSH
58381: LD_VAR 0 3
58385: PUSH
58386: LD_VAR 0 4
58390: ARRAY
58391: PUSH
58392: LD_INT 1
58394: ARRAY
58395: PUSH
58396: LD_VAR 0 3
58400: PUSH
58401: LD_VAR 0 4
58405: ARRAY
58406: PUSH
58407: LD_INT 2
58409: ARRAY
58410: PUSH
58411: LD_INT 2
58413: MINUS
58414: PUSH
58415: EMPTY
58416: LIST
58417: LIST
58418: PPUSH
58419: CALL_OW 2
58423: ST_TO_ADDR
58424: GO 58365
58426: POP
58427: POP
// shape = temp_list ;
58428: LD_ADDR_VAR 0 3
58432: PUSH
58433: LD_VAR 0 10
58437: ST_TO_ADDR
// end ; new_shape = [ ] ;
58438: LD_ADDR_VAR 0 5
58442: PUSH
58443: EMPTY
58444: ST_TO_ADDR
// b = 0 ;
58445: LD_ADDR_VAR 0 6
58449: PUSH
58450: LD_INT 0
58452: ST_TO_ADDR
// x = GetX ( building ) ;
58453: LD_ADDR_VAR 0 8
58457: PUSH
58458: LD_VAR 0 1
58462: PPUSH
58463: CALL_OW 250
58467: ST_TO_ADDR
// y = GetY ( building ) ;
58468: LD_ADDR_VAR 0 9
58472: PUSH
58473: LD_VAR 0 1
58477: PPUSH
58478: CALL_OW 251
58482: ST_TO_ADDR
// for d in shape do
58483: LD_ADDR_VAR 0 4
58487: PUSH
58488: LD_VAR 0 3
58492: PUSH
58493: FOR_IN
58494: IFFALSE 58968
// begin b = b + 1 ;
58496: LD_ADDR_VAR 0 6
58500: PUSH
58501: LD_VAR 0 6
58505: PUSH
58506: LD_INT 1
58508: PLUS
58509: ST_TO_ADDR
// case direction of 0 :
58510: LD_VAR 0 7
58514: PUSH
58515: LD_INT 0
58517: DOUBLE
58518: EQUAL
58519: IFTRUE 58523
58521: GO 58580
58523: POP
// new_shape = Insert ( new_shape , b , [ x + d [ 1 ] , y + d [ 2 ] ] ) ; 1 :
58524: LD_ADDR_VAR 0 5
58528: PUSH
58529: LD_VAR 0 5
58533: PPUSH
58534: LD_VAR 0 6
58538: PPUSH
58539: LD_VAR 0 8
58543: PUSH
58544: LD_VAR 0 4
58548: PUSH
58549: LD_INT 1
58551: ARRAY
58552: PLUS
58553: PUSH
58554: LD_VAR 0 9
58558: PUSH
58559: LD_VAR 0 4
58563: PUSH
58564: LD_INT 2
58566: ARRAY
58567: PLUS
58568: PUSH
58569: EMPTY
58570: LIST
58571: LIST
58572: PPUSH
58573: CALL_OW 2
58577: ST_TO_ADDR
58578: GO 58966
58580: LD_INT 1
58582: DOUBLE
58583: EQUAL
58584: IFTRUE 58588
58586: GO 58655
58588: POP
// new_shape = Insert ( new_shape , b , [ x + ( d [ 1 ] - d [ 2 ] ) , y + ( d [ 1 ] ) ] ) ; 2 :
58589: LD_ADDR_VAR 0 5
58593: PUSH
58594: LD_VAR 0 5
58598: PPUSH
58599: LD_VAR 0 6
58603: PPUSH
58604: LD_VAR 0 8
58608: PUSH
58609: LD_VAR 0 4
58613: PUSH
58614: LD_INT 1
58616: ARRAY
58617: PUSH
58618: LD_VAR 0 4
58622: PUSH
58623: LD_INT 2
58625: ARRAY
58626: MINUS
58627: PLUS
58628: PUSH
58629: LD_VAR 0 9
58633: PUSH
58634: LD_VAR 0 4
58638: PUSH
58639: LD_INT 1
58641: ARRAY
58642: PLUS
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: PPUSH
58648: CALL_OW 2
58652: ST_TO_ADDR
58653: GO 58966
58655: LD_INT 2
58657: DOUBLE
58658: EQUAL
58659: IFTRUE 58663
58661: GO 58735
58663: POP
// new_shape = Insert ( new_shape , b , [ x + ( ( - 1 ) * d [ 2 ] ) , y + ( d [ 1 ] - d [ 2 ] ) ] ) ; 3 :
58664: LD_ADDR_VAR 0 5
58668: PUSH
58669: LD_VAR 0 5
58673: PPUSH
58674: LD_VAR 0 6
58678: PPUSH
58679: LD_VAR 0 8
58683: PUSH
58684: LD_INT 1
58686: NEG
58687: PUSH
58688: LD_VAR 0 4
58692: PUSH
58693: LD_INT 2
58695: ARRAY
58696: MUL
58697: PLUS
58698: PUSH
58699: LD_VAR 0 9
58703: PUSH
58704: LD_VAR 0 4
58708: PUSH
58709: LD_INT 1
58711: ARRAY
58712: PUSH
58713: LD_VAR 0 4
58717: PUSH
58718: LD_INT 2
58720: ARRAY
58721: MINUS
58722: PLUS
58723: PUSH
58724: EMPTY
58725: LIST
58726: LIST
58727: PPUSH
58728: CALL_OW 2
58732: ST_TO_ADDR
58733: GO 58966
58735: LD_INT 3
58737: DOUBLE
58738: EQUAL
58739: IFTRUE 58743
58741: GO 58810
58743: POP
// new_shape = Insert ( new_shape , b , [ x + ( ( - 1 ) * d [ 1 ] ) , y + ( ( - 1 ) * d [ 2 ] ) ] ) ; 4 :
58744: LD_ADDR_VAR 0 5
58748: PUSH
58749: LD_VAR 0 5
58753: PPUSH
58754: LD_VAR 0 6
58758: PPUSH
58759: LD_VAR 0 8
58763: PUSH
58764: LD_INT 1
58766: NEG
58767: PUSH
58768: LD_VAR 0 4
58772: PUSH
58773: LD_INT 1
58775: ARRAY
58776: MUL
58777: PLUS
58778: PUSH
58779: LD_VAR 0 9
58783: PUSH
58784: LD_INT 1
58786: NEG
58787: PUSH
58788: LD_VAR 0 4
58792: PUSH
58793: LD_INT 2
58795: ARRAY
58796: MUL
58797: PLUS
58798: PUSH
58799: EMPTY
58800: LIST
58801: LIST
58802: PPUSH
58803: CALL_OW 2
58807: ST_TO_ADDR
58808: GO 58966
58810: LD_INT 4
58812: DOUBLE
58813: EQUAL
58814: IFTRUE 58818
58816: GO 58890
58818: POP
// new_shape = Insert ( new_shape , b , [ x + ( d [ 2 ] - d [ 1 ] ) , y + ( ( - 1 ) * d [ 1 ] ) ] ) ; 5 :
58819: LD_ADDR_VAR 0 5
58823: PUSH
58824: LD_VAR 0 5
58828: PPUSH
58829: LD_VAR 0 6
58833: PPUSH
58834: LD_VAR 0 8
58838: PUSH
58839: LD_VAR 0 4
58843: PUSH
58844: LD_INT 2
58846: ARRAY
58847: PUSH
58848: LD_VAR 0 4
58852: PUSH
58853: LD_INT 1
58855: ARRAY
58856: MINUS
58857: PLUS
58858: PUSH
58859: LD_VAR 0 9
58863: PUSH
58864: LD_INT 1
58866: NEG
58867: PUSH
58868: LD_VAR 0 4
58872: PUSH
58873: LD_INT 1
58875: ARRAY
58876: MUL
58877: PLUS
58878: PUSH
58879: EMPTY
58880: LIST
58881: LIST
58882: PPUSH
58883: CALL_OW 2
58887: ST_TO_ADDR
58888: GO 58966
58890: LD_INT 5
58892: DOUBLE
58893: EQUAL
58894: IFTRUE 58898
58896: GO 58965
58898: POP
// new_shape = Insert ( new_shape , b , [ x + ( d [ 2 ] ) , y + ( d [ 2 ] - d [ 1 ] ) ] ) ; end ;
58899: LD_ADDR_VAR 0 5
58903: PUSH
58904: LD_VAR 0 5
58908: PPUSH
58909: LD_VAR 0 6
58913: PPUSH
58914: LD_VAR 0 8
58918: PUSH
58919: LD_VAR 0 4
58923: PUSH
58924: LD_INT 2
58926: ARRAY
58927: PLUS
58928: PUSH
58929: LD_VAR 0 9
58933: PUSH
58934: LD_VAR 0 4
58938: PUSH
58939: LD_INT 2
58941: ARRAY
58942: PUSH
58943: LD_VAR 0 4
58947: PUSH
58948: LD_INT 1
58950: ARRAY
58951: MINUS
58952: PLUS
58953: PUSH
58954: EMPTY
58955: LIST
58956: LIST
58957: PPUSH
58958: CALL_OW 2
58962: ST_TO_ADDR
58963: GO 58966
58965: POP
// end ;
58966: GO 58493
58968: POP
58969: POP
// result = new_shape ;
58970: LD_ADDR_VAR 0 2
58974: PUSH
58975: LD_VAR 0 5
58979: ST_TO_ADDR
// end ;
58980: LD_VAR 0 2
58984: RET
// every 0 0$1 do var i , building , val ;
58985: GO 58987
58987: DISABLE
58988: LD_INT 0
58990: PPUSH
58991: PPUSH
58992: PPUSH
// begin repeat wait ( 0 0$0.2 ) ;
58993: LD_INT 7
58995: PPUSH
58996: CALL_OW 67
// if Yakov_luring = 3 then
59000: LD_EXP 113
59004: PUSH
59005: LD_INT 3
59007: EQUAL
59008: IFFALSE 59012
// continue ;
59010: GO 58993
// building = 0 ;
59012: LD_ADDR_VAR 0 2
59016: PUSH
59017: LD_INT 0
59019: ST_TO_ADDR
// for i in player_units_in_russian_buildings do
59020: LD_ADDR_VAR 0 1
59024: PUSH
59025: LD_EXP 88
59029: PUSH
59030: FOR_IN
59031: IFFALSE 59066
// if IsSelected ( i [ 2 ] ) then
59033: LD_VAR 0 1
59037: PUSH
59038: LD_INT 2
59040: ARRAY
59041: PPUSH
59042: CALL_OW 306
59046: IFFALSE 59064
// begin building = i [ 2 ] ;
59048: LD_ADDR_VAR 0 2
59052: PUSH
59053: LD_VAR 0 1
59057: PUSH
59058: LD_INT 2
59060: ARRAY
59061: ST_TO_ADDR
// break ;
59062: GO 59066
// end ;
59064: GO 59030
59066: POP
59067: POP
// if building > 0 then
59068: LD_VAR 0 2
59072: PUSH
59073: LD_INT 0
59075: GREATER
59076: IFFALSE 59214
// begin if Query ( QExitBuilding ) = 1 then
59078: LD_STRING QExitBuilding
59080: PPUSH
59081: CALL_OW 97
59085: PUSH
59086: LD_INT 1
59088: EQUAL
59089: IFFALSE 59205
// begin if Yakov_luring = 2 and building = the_archive then
59091: LD_EXP 113
59095: PUSH
59096: LD_INT 2
59098: EQUAL
59099: PUSH
59100: LD_VAR 0 2
59104: PUSH
59105: LD_EXP 75
59109: EQUAL
59110: AND
59111: IFFALSE 59196
// begin val = false ;
59113: LD_ADDR_VAR 0 3
59117: PUSH
59118: LD_INT 0
59120: ST_TO_ADDR
// for i in player_units_in_russian_buildings do
59121: LD_ADDR_VAR 0 1
59125: PUSH
59126: LD_EXP 88
59130: PUSH
59131: FOR_IN
59132: IFFALSE 59178
// if i [ 1 ] = Heike and i [ 2 ] = building then
59134: LD_VAR 0 1
59138: PUSH
59139: LD_INT 1
59141: ARRAY
59142: PUSH
59143: LD_EXP 7
59147: EQUAL
59148: PUSH
59149: LD_VAR 0 1
59153: PUSH
59154: LD_INT 2
59156: ARRAY
59157: PUSH
59158: LD_VAR 0 2
59162: EQUAL
59163: AND
59164: IFFALSE 59176
// begin val = true ;
59166: LD_ADDR_VAR 0 3
59170: PUSH
59171: LD_INT 1
59173: ST_TO_ADDR
// break ;
59174: GO 59178
// end ;
59176: GO 59131
59178: POP
59179: POP
// if val then
59180: LD_VAR 0 3
59184: IFFALSE 59196
// begin Yakov_luring = 3 ;
59186: LD_ADDR_EXP 113
59190: PUSH
59191: LD_INT 3
59193: ST_TO_ADDR
// continue ;
59194: GO 58993
// end ; end ; GetPlayerUnitsOutOfBuilding ( building ) ;
59196: LD_VAR 0 2
59200: PPUSH
59201: CALL 59233 0 1
// end ; DeselectUnits ( building ) ;
59205: LD_VAR 0 2
59209: PPUSH
59210: CALL_OW 491
// end ; until false ;
59214: LD_INT 0
59216: IFFALSE 58993
// end ;
59218: PPOPN 3
59220: END
// on UnitGoesToRed ( un ) do begin GetPlayerUnitsOutOfBuilding ( un ) ;
59221: LD_VAR 0 1
59225: PPUSH
59226: CALL 59233 0 1
// end ;
59230: PPOPN 1
59232: END
// function GetPlayerUnitsOutOfBuilding ( building ) ; var i , hex_list , un_list , dist , val , hex ; begin
59233: LD_INT 0
59235: PPUSH
59236: PPUSH
59237: PPUSH
59238: PPUSH
59239: PPUSH
59240: PPUSH
59241: PPUSH
// un_list = [ ] ;
59242: LD_ADDR_VAR 0 5
59246: PUSH
59247: EMPTY
59248: ST_TO_ADDR
// i = 1 ;
59249: LD_ADDR_VAR 0 3
59253: PUSH
59254: LD_INT 1
59256: ST_TO_ADDR
// while i <= player_units_in_russian_buildings do
59257: LD_VAR 0 3
59261: PUSH
59262: LD_EXP 88
59266: LESSEQUAL
59267: IFFALSE 59355
// begin if building = player_units_in_russian_buildings [ i ] [ 2 ] then
59269: LD_VAR 0 1
59273: PUSH
59274: LD_EXP 88
59278: PUSH
59279: LD_VAR 0 3
59283: ARRAY
59284: PUSH
59285: LD_INT 2
59287: ARRAY
59288: EQUAL
59289: IFFALSE 59339
// begin un_list = un_list ^ player_units_in_russian_buildings [ i ] [ 1 ] ;
59291: LD_ADDR_VAR 0 5
59295: PUSH
59296: LD_VAR 0 5
59300: PUSH
59301: LD_EXP 88
59305: PUSH
59306: LD_VAR 0 3
59310: ARRAY
59311: PUSH
59312: LD_INT 1
59314: ARRAY
59315: ADD
59316: ST_TO_ADDR
// player_units_in_russian_buildings = Delete ( player_units_in_russian_buildings , i ) ;
59317: LD_ADDR_EXP 88
59321: PUSH
59322: LD_EXP 88
59326: PPUSH
59327: LD_VAR 0 3
59331: PPUSH
59332: CALL_OW 3
59336: ST_TO_ADDR
// continue ;
59337: GO 59257
// end ; i = i + 1 ;
59339: LD_ADDR_VAR 0 3
59343: PUSH
59344: LD_VAR 0 3
59348: PUSH
59349: LD_INT 1
59351: PLUS
59352: ST_TO_ADDR
// end ;
59353: GO 59257
// i = 1 ;
59355: LD_ADDR_VAR 0 3
59359: PUSH
59360: LD_INT 1
59362: ST_TO_ADDR
// while i <= recent_player_units_enter_russian_buildings do
59363: LD_VAR 0 3
59367: PUSH
59368: LD_EXP 92
59372: LESSEQUAL
59373: IFFALSE 59435
// begin if building = recent_player_units_enter_russian_buildings [ i ] [ 2 ] then
59375: LD_VAR 0 1
59379: PUSH
59380: LD_EXP 92
59384: PUSH
59385: LD_VAR 0 3
59389: ARRAY
59390: PUSH
59391: LD_INT 2
59393: ARRAY
59394: EQUAL
59395: IFFALSE 59419
// begin recent_player_units_enter_russian_buildings = Delete ( recent_player_units_enter_russian_buildings , i ) ;
59397: LD_ADDR_EXP 92
59401: PUSH
59402: LD_EXP 92
59406: PPUSH
59407: LD_VAR 0 3
59411: PPUSH
59412: CALL_OW 3
59416: ST_TO_ADDR
// continue ;
59417: GO 59363
// end ; i = i + 1 ;
59419: LD_ADDR_VAR 0 3
59423: PUSH
59424: LD_VAR 0 3
59428: PUSH
59429: LD_INT 1
59431: PLUS
59432: ST_TO_ADDR
// end ;
59433: GO 59363
// if Heike in un_list then
59435: LD_EXP 7
59439: PUSH
59440: LD_VAR 0 5
59444: IN
59445: IFFALSE 59457
// heike_last_exit_building_tick = tick ;
59447: LD_ADDR_EXP 108
59451: PUSH
59452: LD_OWVAR 1
59456: ST_TO_ADDR
// if un_list > 0 then
59457: LD_VAR 0 5
59461: PUSH
59462: LD_INT 0
59464: GREATER
59465: IFFALSE 59678
// begin hex_list = GetBuildingEntranceHexes ( building ) ;
59467: LD_ADDR_VAR 0 4
59471: PUSH
59472: LD_VAR 0 1
59476: PPUSH
59477: CALL 57872 0 1
59481: ST_TO_ADDR
// for i in un_list do
59482: LD_ADDR_VAR 0 3
59486: PUSH
59487: LD_VAR 0 5
59491: PUSH
59492: FOR_IN
59493: IFFALSE 59525
// recent_not_went_inside_units = recent_not_went_inside_units ^ [ [ i , reenter_building_cooldown ] ] ;
59495: LD_ADDR_EXP 89
59499: PUSH
59500: LD_EXP 89
59504: PUSH
59505: LD_VAR 0 3
59509: PUSH
59510: LD_EXP 109
59514: PUSH
59515: EMPTY
59516: LIST
59517: LIST
59518: PUSH
59519: EMPTY
59520: LIST
59521: ADD
59522: ST_TO_ADDR
59523: GO 59492
59525: POP
59526: POP
// dist = 1 ;
59527: LD_ADDR_VAR 0 6
59531: PUSH
59532: LD_INT 1
59534: ST_TO_ADDR
// while un_list > 0 do
59535: LD_VAR 0 5
59539: PUSH
59540: LD_INT 0
59542: GREATER
59543: IFFALSE 59678
// begin while un_list > 0 do
59545: LD_VAR 0 5
59549: PUSH
59550: LD_INT 0
59552: GREATER
59553: IFFALSE 59662
// begin val = false ;
59555: LD_ADDR_VAR 0 7
59559: PUSH
59560: LD_INT 0
59562: ST_TO_ADDR
// for hex in hex_list do
59563: LD_ADDR_VAR 0 8
59567: PUSH
59568: LD_VAR 0 4
59572: PUSH
59573: FOR_IN
59574: IFFALSE 59649
// begin val = PlaceUnitXYR ( un_list [ 1 ] , hex [ 1 ] , hex [ 2 ] , dist , false ) ;
59576: LD_ADDR_VAR 0 7
59580: PUSH
59581: LD_VAR 0 5
59585: PUSH
59586: LD_INT 1
59588: ARRAY
59589: PPUSH
59590: LD_VAR 0 8
59594: PUSH
59595: LD_INT 1
59597: ARRAY
59598: PPUSH
59599: LD_VAR 0 8
59603: PUSH
59604: LD_INT 2
59606: ARRAY
59607: PPUSH
59608: LD_VAR 0 6
59612: PPUSH
59613: LD_INT 0
59615: PPUSH
59616: CALL_OW 50
59620: ST_TO_ADDR
// if val then
59621: LD_VAR 0 7
59625: IFFALSE 59647
// begin un_list = Delete ( un_list , 1 ) ;
59627: LD_ADDR_VAR 0 5
59631: PUSH
59632: LD_VAR 0 5
59636: PPUSH
59637: LD_INT 1
59639: PPUSH
59640: CALL_OW 3
59644: ST_TO_ADDR
// break ;
59645: GO 59649
// end ; end ;
59647: GO 59573
59649: POP
59650: POP
// if not val then
59651: LD_VAR 0 7
59655: NOT
59656: IFFALSE 59660
// break ;
59658: GO 59662
// end ;
59660: GO 59545
// dist = dist + 1 ;
59662: LD_ADDR_VAR 0 6
59666: PUSH
59667: LD_VAR 0 6
59671: PUSH
59672: LD_INT 1
59674: PLUS
59675: ST_TO_ADDR
// end ;
59676: GO 59535
// end ; RemoveSeeing ( GetX ( building ) , GetY ( building ) , you ) ;
59678: LD_VAR 0 1
59682: PPUSH
59683: CALL_OW 250
59687: PPUSH
59688: LD_VAR 0 1
59692: PPUSH
59693: CALL_OW 251
59697: PPUSH
59698: LD_EXP 2
59702: PPUSH
59703: CALL_OW 331
// end ;
59707: LD_VAR 0 2
59711: RET
// every 0 0$1 + 0 0$0.5 do var i , k , temp_list , un , building ; var visited_buildings , num_times_heike_visited_lab , num_times_heike_visited_armoury ; var leader_office_choices , visited_northern_depot , visited_main_depot , visited_workshop ; var asked_for_boyfriend ;
59712: GO 59714
59714: DISABLE
59715: LD_INT 0
59717: PPUSH
59718: PPUSH
59719: PPUSH
59720: PPUSH
59721: PPUSH
59722: PPUSH
59723: PPUSH
59724: PPUSH
59725: PPUSH
59726: PPUSH
59727: PPUSH
59728: PPUSH
59729: PPUSH
// begin visited_buildings = [ ] ;
59730: LD_ADDR_VAR 0 6
59734: PUSH
59735: EMPTY
59736: ST_TO_ADDR
// num_times_heike_visited_lab = 0 ;
59737: LD_ADDR_VAR 0 7
59741: PUSH
59742: LD_INT 0
59744: ST_TO_ADDR
// num_times_heike_visited_armoury = 0 ;
59745: LD_ADDR_VAR 0 8
59749: PUSH
59750: LD_INT 0
59752: ST_TO_ADDR
// leader_office_choices = [ ] ;
59753: LD_ADDR_VAR 0 9
59757: PUSH
59758: EMPTY
59759: ST_TO_ADDR
// visited_northern_depot = false ;
59760: LD_ADDR_VAR 0 10
59764: PUSH
59765: LD_INT 0
59767: ST_TO_ADDR
// visited_main_depot = false ;
59768: LD_ADDR_VAR 0 11
59772: PUSH
59773: LD_INT 0
59775: ST_TO_ADDR
// visited_workshop = false ;
59776: LD_ADDR_VAR 0 12
59780: PUSH
59781: LD_INT 0
59783: ST_TO_ADDR
// asked_for_boyfriend = false ;
59784: LD_ADDR_VAR 0 13
59788: PUSH
59789: LD_INT 0
59791: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59792: LD_INT 35
59794: PPUSH
59795: CALL_OW 67
// if recent_player_units_enter_russian_buildings = 0 then
59799: LD_EXP 92
59803: PUSH
59804: LD_INT 0
59806: EQUAL
59807: IFFALSE 59811
// continue ;
59809: GO 59792
// wait ( 0 0$0.5 ) ;
59811: LD_INT 18
59813: PPUSH
59814: CALL_OW 67
// if recent_player_units_enter_russian_buildings = 0 then
59818: LD_EXP 92
59822: PUSH
59823: LD_INT 0
59825: EQUAL
59826: IFFALSE 59830
// continue ;
59828: GO 59792
// temp_list = [ ] ;
59830: LD_ADDR_VAR 0 3
59834: PUSH
59835: EMPTY
59836: ST_TO_ADDR
// building = recent_player_units_enter_russian_buildings [ 1 ] [ 2 ] ;
59837: LD_ADDR_VAR 0 5
59841: PUSH
59842: LD_EXP 92
59846: PUSH
59847: LD_INT 1
59849: ARRAY
59850: PUSH
59851: LD_INT 2
59853: ARRAY
59854: ST_TO_ADDR
// i = 1 ;
59855: LD_ADDR_VAR 0 1
59859: PUSH
59860: LD_INT 1
59862: ST_TO_ADDR
// while i <= recent_player_units_enter_russian_buildings do
59863: LD_VAR 0 1
59867: PUSH
59868: LD_EXP 92
59872: LESSEQUAL
59873: IFFALSE 59961
// begin if recent_player_units_enter_russian_buildings [ i ] [ 2 ] = building then
59875: LD_EXP 92
59879: PUSH
59880: LD_VAR 0 1
59884: ARRAY
59885: PUSH
59886: LD_INT 2
59888: ARRAY
59889: PUSH
59890: LD_VAR 0 5
59894: EQUAL
59895: IFFALSE 59945
// begin temp_list = temp_list ^ recent_player_units_enter_russian_buildings [ i ] [ 1 ] ;
59897: LD_ADDR_VAR 0 3
59901: PUSH
59902: LD_VAR 0 3
59906: PUSH
59907: LD_EXP 92
59911: PUSH
59912: LD_VAR 0 1
59916: ARRAY
59917: PUSH
59918: LD_INT 1
59920: ARRAY
59921: ADD
59922: ST_TO_ADDR
// recent_player_units_enter_russian_buildings = Delete ( recent_player_units_enter_russian_buildings , i ) ;
59923: LD_ADDR_EXP 92
59927: PUSH
59928: LD_EXP 92
59932: PPUSH
59933: LD_VAR 0 1
59937: PPUSH
59938: CALL_OW 3
59942: ST_TO_ADDR
// continue ;
59943: GO 59863
// end ; i = i + 1 ;
59945: LD_ADDR_VAR 0 1
59949: PUSH
59950: LD_VAR 0 1
59954: PUSH
59955: LD_INT 1
59957: PLUS
59958: ST_TO_ADDR
// end ;
59959: GO 59863
// if Heike in temp_list and heike_undercover = 2 then
59961: LD_EXP 7
59965: PUSH
59966: LD_VAR 0 3
59970: IN
59971: PUSH
59972: LD_EXP 83
59976: PUSH
59977: LD_INT 2
59979: EQUAL
59980: AND
59981: IFFALSE 59995
// un = Heike else
59983: LD_ADDR_VAR 0 4
59987: PUSH
59988: LD_EXP 7
59992: ST_TO_ADDR
59993: GO 60009
// un = temp_list [ 1 ] ;
59995: LD_ADDR_VAR 0 4
59999: PUSH
60000: LD_VAR 0 3
60004: PUSH
60005: LD_INT 1
60007: ARRAY
60008: ST_TO_ADDR
// if un = Heike and heike_undercover = 2 then
60009: LD_VAR 0 4
60013: PUSH
60014: LD_EXP 7
60018: EQUAL
60019: PUSH
60020: LD_EXP 83
60024: PUSH
60025: LD_INT 2
60027: EQUAL
60028: AND
60029: IFFALSE 63407
// begin visited_buildings = visited_buildings union building ;
60031: LD_ADDR_VAR 0 6
60035: PUSH
60036: LD_VAR 0 6
60040: PUSH
60041: LD_VAR 0 5
60045: UNION
60046: ST_TO_ADDR
// if building = the_archive and ( UnitsInside ( the_archive ) = 0 or Yakov_luring = 2 or ArchiveGuardsDistracted ) then
60047: LD_VAR 0 5
60051: PUSH
60052: LD_EXP 75
60056: EQUAL
60057: PUSH
60058: LD_EXP 75
60062: PPUSH
60063: CALL_OW 313
60067: PUSH
60068: LD_INT 0
60070: EQUAL
60071: PUSH
60072: LD_EXP 113
60076: PUSH
60077: LD_INT 2
60079: EQUAL
60080: OR
60081: PUSH
60082: CALL 45181 0 0
60086: OR
60087: AND
60088: IFFALSE 60127
// begin if not archive_found then
60090: LD_EXP 100
60094: NOT
60095: IFFALSE 60125
// begin DialogueOn ;
60097: CALL_OW 6
// Say ( Heike , D20-H-1 ) ;
60101: LD_EXP 7
60105: PPUSH
60106: LD_STRING D20-H-1
60108: PPUSH
60109: CALL_OW 88
// DialogueOff ;
60113: CALL_OW 7
// archive_found = true ;
60117: LD_ADDR_EXP 100
60121: PUSH
60122: LD_INT 1
60124: ST_TO_ADDR
// end ; continue ;
60125: GO 59792
// end ; if building in ai_labs [ 1 ] then
60127: LD_VAR 0 5
60131: PUSH
60132: LD_EXP 33
60136: PUSH
60137: LD_INT 1
60139: ARRAY
60140: IN
60141: IFFALSE 60541
// begin temp_list = UnitsInside ( building ) ;
60143: LD_ADDR_VAR 0 3
60147: PUSH
60148: LD_VAR 0 5
60152: PPUSH
60153: CALL_OW 313
60157: ST_TO_ADDR
// if temp_list = 0 then
60158: LD_VAR 0 3
60162: PUSH
60163: LD_INT 0
60165: EQUAL
60166: IFFALSE 60198
// begin recent_player_units_enter_russian_buildings = recent_player_units_enter_russian_buildings ^ [ [ un , building ] ] ;
60168: LD_ADDR_EXP 92
60172: PUSH
60173: LD_EXP 92
60177: PUSH
60178: LD_VAR 0 4
60182: PUSH
60183: LD_VAR 0 5
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: EMPTY
60193: LIST
60194: ADD
60195: ST_TO_ADDR
// continue ;
60196: GO 59792
// end ; num_times_heike_visited_lab = num_times_heike_visited_lab + 1 ;
60198: LD_ADDR_VAR 0 7
60202: PUSH
60203: LD_VAR 0 7
60207: PUSH
60208: LD_INT 1
60210: PLUS
60211: ST_TO_ADDR
// if Barovnin in temp_list then
60212: LD_EXP 13
60216: PUSH
60217: LD_VAR 0 3
60221: IN
60222: IFFALSE 60236
// k = Barovnin else
60224: LD_ADDR_VAR 0 2
60228: PUSH
60229: LD_EXP 13
60233: ST_TO_ADDR
60234: GO 60250
// k = temp_list [ 1 ] ;
60236: LD_ADDR_VAR 0 2
60240: PUSH
60241: LD_VAR 0 3
60245: PUSH
60246: LD_INT 1
60248: ARRAY
60249: ST_TO_ADDR
// DialogueOn ;
60250: CALL_OW 6
// case num_times_heike_visited_lab of 1 :
60254: LD_VAR 0 7
60258: PUSH
60259: LD_INT 1
60261: DOUBLE
60262: EQUAL
60263: IFTRUE 60267
60265: GO 60337
60267: POP
// begin if k = Barovnin then
60268: LD_VAR 0 2
60272: PUSH
60273: LD_EXP 13
60277: EQUAL
60278: IFFALSE 60294
// begin Say ( Barovnin , D17-Doc-1 ) ;
60280: LD_EXP 13
60284: PPUSH
60285: LD_STRING D17-Doc-1
60287: PPUSH
60288: CALL_OW 88
// end else
60292: GO 60335
// if GetSex ( k ) = sex_male then
60294: LD_VAR 0 2
60298: PPUSH
60299: CALL_OW 258
60303: PUSH
60304: LD_INT 1
60306: EQUAL
60307: IFFALSE 60323
// Say ( k , D17-SciM-1 ) else
60309: LD_VAR 0 2
60313: PPUSH
60314: LD_STRING D17-SciM-1
60316: PPUSH
60317: CALL_OW 88
60321: GO 60335
// Say ( k , D17-SciF-1 ) ;
60323: LD_VAR 0 2
60327: PPUSH
60328: LD_STRING D17-SciF-1
60330: PPUSH
60331: CALL_OW 88
// end ; 2 :
60335: GO 60519
60337: LD_INT 2
60339: DOUBLE
60340: EQUAL
60341: IFTRUE 60345
60343: GO 60518
60345: POP
// begin if k = Barovnin then
60346: LD_VAR 0 2
60350: PUSH
60351: LD_EXP 13
60355: EQUAL
60356: IFFALSE 60396
// begin Say ( Barovnin , D17-Doc-2 ) ;
60358: LD_EXP 13
60362: PPUSH
60363: LD_STRING D17-Doc-2
60365: PPUSH
60366: CALL_OW 88
// Say ( Heike , D17-H-1 ) ;
60370: LD_EXP 7
60374: PPUSH
60375: LD_STRING D17-H-1
60377: PPUSH
60378: CALL_OW 88
// Say ( Barovnin , D17-Doc-3 ) ;
60382: LD_EXP 13
60386: PPUSH
60387: LD_STRING D17-Doc-3
60389: PPUSH
60390: CALL_OW 88
// end else
60394: GO 60485
// if GetSex ( k ) = sex_male then
60396: LD_VAR 0 2
60400: PPUSH
60401: CALL_OW 258
60405: PUSH
60406: LD_INT 1
60408: EQUAL
60409: IFFALSE 60449
// begin Say ( k , D17-SciM-2 ) ;
60411: LD_VAR 0 2
60415: PPUSH
60416: LD_STRING D17-SciM-2
60418: PPUSH
60419: CALL_OW 88
// Say ( Heike , D17-H-1 ) ;
60423: LD_EXP 7
60427: PPUSH
60428: LD_STRING D17-H-1
60430: PPUSH
60431: CALL_OW 88
// Say ( k , D17-SciM-3 ) ;
60435: LD_VAR 0 2
60439: PPUSH
60440: LD_STRING D17-SciM-3
60442: PPUSH
60443: CALL_OW 88
// end else
60447: GO 60485
// begin Say ( k , D17-SciF-2 ) ;
60449: LD_VAR 0 2
60453: PPUSH
60454: LD_STRING D17-SciF-2
60456: PPUSH
60457: CALL_OW 88
// Say ( Heike , D17-H-1 ) ;
60461: LD_EXP 7
60465: PPUSH
60466: LD_STRING D17-H-1
60468: PPUSH
60469: CALL_OW 88
// Say ( k , D17-SciF-3 ) ;
60473: LD_VAR 0 2
60477: PPUSH
60478: LD_STRING D17-SciF-3
60480: PPUSH
60481: CALL_OW 88
// end ; ChangeHeikeUndercoverStatus ( 4 ) ;
60485: LD_INT 4
60487: PPUSH
60488: CALL 42004 0 1
// if code_black then
60492: LD_EXP 77
60496: IFFALSE 60508
// code_black_renew = true else
60498: LD_ADDR_EXP 124
60502: PUSH
60503: LD_INT 1
60505: ST_TO_ADDR
60506: GO 60516
// code_black = true ;
60508: LD_ADDR_EXP 77
60512: PUSH
60513: LD_INT 1
60515: ST_TO_ADDR
// end ; end ;
60516: GO 60519
60518: POP
// DWait ( 0 0$0.5 ) ;
60519: LD_INT 18
60521: PPUSH
60522: CALL_OW 68
// DialogueOff ;
60526: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( building ) ;
60530: LD_VAR 0 5
60534: PPUSH
60535: CALL 59233 0 1
// continue ;
60539: GO 59792
// end ; if building in ai_armouries [ 1 ] and building <> leader_office then
60541: LD_VAR 0 5
60545: PUSH
60546: LD_EXP 48
60550: PUSH
60551: LD_INT 1
60553: ARRAY
60554: IN
60555: PUSH
60556: LD_VAR 0 5
60560: PUSH
60561: LD_EXP 93
60565: NONEQUAL
60566: AND
60567: IFFALSE 60854
// begin temp_list = UnitsInside ( building ) ;
60569: LD_ADDR_VAR 0 3
60573: PUSH
60574: LD_VAR 0 5
60578: PPUSH
60579: CALL_OW 313
60583: ST_TO_ADDR
// if temp_list = 0 then
60584: LD_VAR 0 3
60588: PUSH
60589: LD_INT 0
60591: EQUAL
60592: IFFALSE 60624
// begin recent_player_units_enter_russian_buildings = recent_player_units_enter_russian_buildings ^ [ [ un , building ] ] ;
60594: LD_ADDR_EXP 92
60598: PUSH
60599: LD_EXP 92
60603: PUSH
60604: LD_VAR 0 4
60608: PUSH
60609: LD_VAR 0 5
60613: PUSH
60614: EMPTY
60615: LIST
60616: LIST
60617: PUSH
60618: EMPTY
60619: LIST
60620: ADD
60621: ST_TO_ADDR
// continue ;
60622: GO 59792
// end ; num_times_heike_visited_armoury = num_times_heike_visited_armoury + 1 ;
60624: LD_ADDR_VAR 0 8
60628: PUSH
60629: LD_VAR 0 8
60633: PUSH
60634: LD_INT 1
60636: PLUS
60637: ST_TO_ADDR
// k = temp_list [ 1 ] ;
60638: LD_ADDR_VAR 0 2
60642: PUSH
60643: LD_VAR 0 3
60647: PUSH
60648: LD_INT 1
60650: ARRAY
60651: ST_TO_ADDR
// DialogueOn ;
60652: CALL_OW 6
// case num_times_heike_visited_armoury of 1 :
60656: LD_VAR 0 8
60660: PUSH
60661: LD_INT 1
60663: DOUBLE
60664: EQUAL
60665: IFTRUE 60669
60667: GO 60713
60669: POP
// begin if GetSex ( k ) = sex_male then
60670: LD_VAR 0 2
60674: PPUSH
60675: CALL_OW 258
60679: PUSH
60680: LD_INT 1
60682: EQUAL
60683: IFFALSE 60699
// Say ( k , D16-SolM-1 ) else
60685: LD_VAR 0 2
60689: PPUSH
60690: LD_STRING D16-SolM-1
60692: PPUSH
60693: CALL_OW 88
60697: GO 60711
// Say ( k , D16-SolF-1 ) ;
60699: LD_VAR 0 2
60703: PPUSH
60704: LD_STRING D16-SolF-1
60706: PPUSH
60707: CALL_OW 88
// end ; 2 :
60711: GO 60832
60713: LD_INT 2
60715: DOUBLE
60716: EQUAL
60717: IFTRUE 60721
60719: GO 60765
60721: POP
// begin if GetSex ( k ) = sex_male then
60722: LD_VAR 0 2
60726: PPUSH
60727: CALL_OW 258
60731: PUSH
60732: LD_INT 1
60734: EQUAL
60735: IFFALSE 60751
// Say ( k , D16-SolM-2 ) else
60737: LD_VAR 0 2
60741: PPUSH
60742: LD_STRING D16-SolM-2
60744: PPUSH
60745: CALL_OW 88
60749: GO 60763
// Say ( k , D16-SolF-2 ) ;
60751: LD_VAR 0 2
60755: PPUSH
60756: LD_STRING D16-SolF-2
60758: PPUSH
60759: CALL_OW 88
// end ; 3 :
60763: GO 60832
60765: LD_INT 3
60767: DOUBLE
60768: EQUAL
60769: IFTRUE 60773
60771: GO 60831
60773: POP
// begin if GetSex ( k ) = sex_male then
60774: LD_VAR 0 2
60778: PPUSH
60779: CALL_OW 258
60783: PUSH
60784: LD_INT 1
60786: EQUAL
60787: IFFALSE 60803
// Say ( k , D16-SolM-3 ) else
60789: LD_VAR 0 2
60793: PPUSH
60794: LD_STRING D16-SolM-3
60796: PPUSH
60797: CALL_OW 88
60801: GO 60815
// Say ( k , D16-SolF-3 ) ;
60803: LD_VAR 0 2
60807: PPUSH
60808: LD_STRING D16-SolF-3
60810: PPUSH
60811: CALL_OW 88
// DWait ( 0 0$0.5 ) ;
60815: LD_INT 18
60817: PPUSH
60818: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
60822: LD_STRING HeikeCaptive
60824: PPUSH
60825: CALL_OW 104
// end ; end ;
60829: GO 60832
60831: POP
// DWait ( 0 0$0.5 ) ;
60832: LD_INT 18
60834: PPUSH
60835: CALL_OW 68
// DialogueOff ;
60839: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( building ) ;
60843: LD_VAR 0 5
60847: PPUSH
60848: CALL 59233 0 1
// continue ;
60852: GO 59792
// end ; if building = leader_office then
60854: LD_VAR 0 5
60858: PUSH
60859: LD_EXP 93
60863: EQUAL
60864: IFFALSE 61511
// begin if IsDead ( Yefibachev ) then
60866: LD_EXP 14
60870: PPUSH
60871: CALL_OW 301
60875: IFFALSE 60910
// begin DialogueOn ;
60877: CALL_OW 6
// Query ( QLeaderDead ) ;
60881: LD_STRING QLeaderDead
60883: PPUSH
60884: CALL_OW 97
// DWait ( 0 0$0.5 ) ;
60888: LD_INT 18
60890: PPUSH
60891: CALL_OW 68
// DialogueOff ;
60895: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( building ) ;
60899: LD_VAR 0 5
60903: PPUSH
60904: CALL 59233 0 1
// continue ;
60908: GO 59792
// end ; if IsInUnit ( Yefibachev ) <> leader_office then
60910: LD_EXP 14
60914: PPUSH
60915: CALL_OW 310
60919: PUSH
60920: LD_EXP 93
60924: NONEQUAL
60925: IFFALSE 60960
// begin DialogueOn ;
60927: CALL_OW 6
// Query ( QLeaderNotHereButAlive ) ;
60931: LD_STRING QLeaderNotHereButAlive
60933: PPUSH
60934: CALL_OW 97
// DWait ( 0 0$0.5 ) ;
60938: LD_INT 18
60940: PPUSH
60941: CALL_OW 68
// DialogueOff ;
60945: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( building ) ;
60949: LD_VAR 0 5
60953: PPUSH
60954: CALL 59233 0 1
// continue ;
60958: GO 59792
// end ; if code_black then
60960: LD_EXP 77
60964: IFFALSE 61004
// begin DialogueOn ;
60966: CALL_OW 6
// Say ( Yefibachev , D15-c-Leader-1 ) ;
60970: LD_EXP 14
60974: PPUSH
60975: LD_STRING D15-c-Leader-1
60977: PPUSH
60978: CALL_OW 88
// Dwait ( 0 0$0.5 ) ;
60982: LD_INT 18
60984: PPUSH
60985: CALL_OW 68
// DialogueOff ;
60989: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( building ) ;
60993: LD_VAR 0 5
60997: PPUSH
60998: CALL 59233 0 1
// continue ;
61002: GO 59792
// end ; k = true ;
61004: LD_ADDR_VAR 0 2
61008: PUSH
61009: LD_INT 1
61011: ST_TO_ADDR
// if leader_office_choices > 0 then
61012: LD_VAR 0 9
61016: PUSH
61017: LD_INT 0
61019: GREATER
61020: IFFALSE 61050
// if leader_office_choices [ leader_office_choices + 0 ] = 3 then
61022: LD_VAR 0 9
61026: PUSH
61027: LD_VAR 0 9
61031: PUSH
61032: LD_INT 0
61034: PLUS
61035: ARRAY
61036: PUSH
61037: LD_INT 3
61039: EQUAL
61040: IFFALSE 61050
// k = false ;
61042: LD_ADDR_VAR 0 2
61046: PUSH
61047: LD_INT 0
61049: ST_TO_ADDR
// DialogueOn ;
61050: CALL_OW 6
// if k then
61054: LD_VAR 0 2
61058: IFFALSE 61074
// Say ( Yefibachev , D15-a-Leader-1 ) else
61060: LD_EXP 14
61064: PPUSH
61065: LD_STRING D15-a-Leader-1
61067: PPUSH
61068: CALL_OW 88
61072: GO 61086
// Say ( Yefibachev , D15-b-Leader-1 ) ;
61074: LD_EXP 14
61078: PPUSH
61079: LD_STRING D15-b-Leader-1
61081: PPUSH
61082: CALL_OW 88
// DWait ( 0 0$0.2 ) ;
61086: LD_INT 7
61088: PPUSH
61089: CALL_OW 68
// if leader_office_choices = 0 then
61093: LD_VAR 0 9
61097: PUSH
61098: LD_INT 0
61100: EQUAL
61101: IFFALSE 61169
// begin temp_list = [ 1 , 3 ] ;
61103: LD_ADDR_VAR 0 3
61107: PUSH
61108: LD_INT 1
61110: PUSH
61111: LD_INT 3
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: ST_TO_ADDR
// if found_depot_document and not 2 in leader_office_choices then
61118: LD_EXP 95
61122: PUSH
61123: LD_INT 2
61125: PUSH
61126: LD_VAR 0 9
61130: IN
61131: NOT
61132: AND
61133: IFFALSE 61149
// temp_list = temp_list ^ 2 ;
61135: LD_ADDR_VAR 0 3
61139: PUSH
61140: LD_VAR 0 3
61144: PUSH
61145: LD_INT 2
61147: ADD
61148: ST_TO_ADDR
// i = SelectiveQuery ( QLeaderOfficeFirstEnter , temp_list ) ;
61149: LD_ADDR_VAR 0 1
61153: PUSH
61154: LD_STRING QLeaderOfficeFirstEnter
61156: PPUSH
61157: LD_VAR 0 3
61161: PPUSH
61162: CALL_OW 98
61166: ST_TO_ADDR
// end else
61167: GO 61233
// begin temp_list = [ 2 ] ;
61169: LD_ADDR_VAR 0 3
61173: PUSH
61174: LD_INT 2
61176: PUSH
61177: EMPTY
61178: LIST
61179: ST_TO_ADDR
// if found_depot_document and not 2 in leader_office_choices then
61180: LD_EXP 95
61184: PUSH
61185: LD_INT 2
61187: PUSH
61188: LD_VAR 0 9
61192: IN
61193: NOT
61194: AND
61195: IFFALSE 61211
// temp_list = temp_list ^ 1 ;
61197: LD_ADDR_VAR 0 3
61201: PUSH
61202: LD_VAR 0 3
61206: PUSH
61207: LD_INT 1
61209: ADD
61210: ST_TO_ADDR
// i = 1 + SelectiveQuery ( QLeaderOfficeNextEnter , temp_list ) ;
61211: LD_ADDR_VAR 0 1
61215: PUSH
61216: LD_INT 1
61218: PUSH
61219: LD_STRING QLeaderOfficeNextEnter
61221: PPUSH
61222: LD_VAR 0 3
61226: PPUSH
61227: CALL_OW 98
61231: PLUS
61232: ST_TO_ADDR
// end ; case i of 1 :
61233: LD_VAR 0 1
61237: PUSH
61238: LD_INT 1
61240: DOUBLE
61241: EQUAL
61242: IFTRUE 61246
61244: GO 61273
61246: POP
// begin Say ( Heike , D15-1-H-1 ) ;
61247: LD_EXP 7
61251: PPUSH
61252: LD_STRING D15-1-H-1
61254: PPUSH
61255: CALL_OW 88
// Say ( Yefibachev , D15-1-Leader-1 ) ;
61259: LD_EXP 14
61263: PPUSH
61264: LD_STRING D15-1-Leader-1
61266: PPUSH
61267: CALL_OW 88
// end ; 2 :
61271: GO 61473
61273: LD_INT 2
61275: DOUBLE
61276: EQUAL
61277: IFTRUE 61281
61279: GO 61323
61281: POP
// begin Say ( Heike , D15-2-H-1 ) ;
61282: LD_EXP 7
61286: PPUSH
61287: LD_STRING D15-2-H-1
61289: PPUSH
61290: CALL_OW 88
// DWait ( 0 0$1.5 ) ;
61294: LD_INT 52
61296: PPUSH
61297: CALL_OW 68
// Say ( Yefibachev , D15-2-Leader-1 ) ;
61301: LD_EXP 14
61305: PPUSH
61306: LD_STRING D15-2-Leader-1
61308: PPUSH
61309: CALL_OW 88
// send_sol_from_office_to_archive = true ;
61313: LD_ADDR_EXP 96
61317: PUSH
61318: LD_INT 1
61320: ST_TO_ADDR
// end ; 3 :
61321: GO 61473
61323: LD_INT 3
61325: DOUBLE
61326: EQUAL
61327: IFTRUE 61331
61329: GO 61472
61331: POP
// begin if k and not 3 in leader_office_choices then
61332: LD_VAR 0 2
61336: PUSH
61337: LD_INT 3
61339: PUSH
61340: LD_VAR 0 9
61344: IN
61345: NOT
61346: AND
61347: IFFALSE 61399
// begin Say ( Heike , D15-3a-H-1 ) ;
61349: LD_EXP 7
61353: PPUSH
61354: LD_STRING D15-3a-H-1
61356: PPUSH
61357: CALL_OW 88
// Say ( Yefibachev , D15-3a-Leader-1 ) ;
61361: LD_EXP 14
61365: PPUSH
61366: LD_STRING D15-3a-Leader-1
61368: PPUSH
61369: CALL_OW 88
// Say ( Heike , D15-3a-H-2 ) ;
61373: LD_EXP 7
61377: PPUSH
61378: LD_STRING D15-3a-H-2
61380: PPUSH
61381: CALL_OW 88
// Say ( Yefibachev , D15-3a-Leader-2 ) ;
61385: LD_EXP 14
61389: PPUSH
61390: LD_STRING D15-3a-Leader-2
61392: PPUSH
61393: CALL_OW 88
// end else
61397: GO 61470
// if not k then
61399: LD_VAR 0 2
61403: NOT
61404: IFFALSE 61446
// begin Say ( Heike , D15-3b-H-1 ) ;
61406: LD_EXP 7
61410: PPUSH
61411: LD_STRING D15-3b-H-1
61413: PPUSH
61414: CALL_OW 88
// Say ( Yefibachev , D15-3b-Leader-1 ) ;
61418: LD_EXP 14
61422: PPUSH
61423: LD_STRING D15-3b-Leader-1
61425: PPUSH
61426: CALL_OW 88
// DWait ( 0 0$0.5 ) ;
61430: LD_INT 18
61432: PPUSH
61433: CALL_OW 68
// YouLost ( HeikeCaptive ) ;
61437: LD_STRING HeikeCaptive
61439: PPUSH
61440: CALL_OW 104
// end else
61444: GO 61470
// begin Say ( Heike , D15-3c-H-1 ) ;
61446: LD_EXP 7
61450: PPUSH
61451: LD_STRING D15-3c-H-1
61453: PPUSH
61454: CALL_OW 88
// Say ( Yefibachev , D15-3c-Leader-1 ) ;
61458: LD_EXP 14
61462: PPUSH
61463: LD_STRING D15-3c-Leader-1
61465: PPUSH
61466: CALL_OW 88
// end ; end ; end ;
61470: GO 61473
61472: POP
// leader_office_choices = leader_office_choices ^ i ;
61473: LD_ADDR_VAR 0 9
61477: PUSH
61478: LD_VAR 0 9
61482: PUSH
61483: LD_VAR 0 1
61487: ADD
61488: ST_TO_ADDR
// DWait ( 0 0$0.5 ) ;
61489: LD_INT 18
61491: PPUSH
61492: CALL_OW 68
// DialogueOff ;
61496: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( building ) ;
61500: LD_VAR 0 5
61504: PPUSH
61505: CALL 59233 0 1
// continue ;
61509: GO 59792
// end ; if building = depot_north then
61511: LD_VAR 0 5
61515: PUSH
61516: LD_EXP 86
61520: EQUAL
61521: IFFALSE 61613
// begin if not visited_northern_depot then
61523: LD_VAR 0 10
61527: NOT
61528: IFFALSE 61583
// begin visited_northern_depot = true ;
61530: LD_ADDR_VAR 0 10
61534: PUSH
61535: LD_INT 1
61537: ST_TO_ADDR
// DialogueOn ;
61538: CALL_OW 6
// Query ( QDepotNorth1 ) ;
61542: LD_STRING QDepotNorth1
61544: PPUSH
61545: CALL_OW 97
// DWait ( 0 0$0.2 ) ;
61549: LD_INT 7
61551: PPUSH
61552: CALL_OW 68
// if Query ( QDepotNorth2 ) = 1 then
61556: LD_STRING QDepotNorth2
61558: PPUSH
61559: CALL_OW 97
61563: PUSH
61564: LD_INT 1
61566: EQUAL
61567: IFFALSE 61577
// found_depot_document = true ;
61569: LD_ADDR_EXP 95
61573: PUSH
61574: LD_INT 1
61576: ST_TO_ADDR
// DialogueOff ;
61577: CALL_OW 7
// end else
61581: GO 61611
// if not found_depot_document then
61583: LD_EXP 95
61587: NOT
61588: IFFALSE 61611
// if Query ( QDepotNorth3 ) = 1 then
61590: LD_STRING QDepotNorth3
61592: PPUSH
61593: CALL_OW 97
61597: PUSH
61598: LD_INT 1
61600: EQUAL
61601: IFFALSE 61611
// found_depot_document = true ;
61603: LD_ADDR_EXP 95
61607: PUSH
61608: LD_INT 1
61610: ST_TO_ADDR
// continue ;
61611: GO 59792
// end ; if building = ai_depot [ 1 ] then
61613: LD_VAR 0 5
61617: PUSH
61618: LD_EXP 32
61622: PUSH
61623: LD_INT 1
61625: ARRAY
61626: EQUAL
61627: IFFALSE 62920
// begin if not visited_main_depot and Yakov_luring in [ 0 , 4 ] and not code_black then
61629: LD_VAR 0 11
61633: NOT
61634: PUSH
61635: LD_EXP 113
61639: PUSH
61640: LD_INT 0
61642: PUSH
61643: LD_INT 4
61645: PUSH
61646: EMPTY
61647: LIST
61648: LIST
61649: IN
61650: AND
61651: PUSH
61652: LD_EXP 77
61656: NOT
61657: AND
61658: IFFALSE 62918
// begin k = true ;
61660: LD_ADDR_VAR 0 2
61664: PUSH
61665: LD_INT 1
61667: ST_TO_ADDR
// for i in [ poker_eng , poker_sol , poker_mec ] do
61668: LD_ADDR_VAR 0 1
61672: PUSH
61673: LD_EXP 23
61677: PUSH
61678: LD_EXP 24
61682: PUSH
61683: LD_EXP 25
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: LIST
61692: PUSH
61693: FOR_IN
61694: IFFALSE 61729
// if IsInUnit ( i ) <> ai_depot [ 1 ] then
61696: LD_VAR 0 1
61700: PPUSH
61701: CALL_OW 310
61705: PUSH
61706: LD_EXP 32
61710: PUSH
61711: LD_INT 1
61713: ARRAY
61714: NONEQUAL
61715: IFFALSE 61727
// begin k = false ;
61717: LD_ADDR_VAR 0 2
61721: PUSH
61722: LD_INT 0
61724: ST_TO_ADDR
// break ;
61725: GO 61729
// end ;
61727: GO 61693
61729: POP
61730: POP
// if k then
61731: LD_VAR 0 2
61735: IFFALSE 62918
// begin visited_main_depot = true ;
61737: LD_ADDR_VAR 0 11
61741: PUSH
61742: LD_INT 1
61744: ST_TO_ADDR
// DialogueOn ;
61745: CALL_OW 6
// Say ( poker_sol , D12-SolM-1 ) ;
61749: LD_EXP 24
61753: PPUSH
61754: LD_STRING D12-SolM-1
61756: PPUSH
61757: CALL_OW 88
// Say ( poker_eng , D12-EngF-1 ) ;
61761: LD_EXP 23
61765: PPUSH
61766: LD_STRING D12-EngF-1
61768: PPUSH
61769: CALL_OW 88
// Say ( poker_sol , D12-SolM-2 ) ;
61773: LD_EXP 24
61777: PPUSH
61778: LD_STRING D12-SolM-2
61780: PPUSH
61781: CALL_OW 88
// Say ( poker_mec , D12-MecM-1 ) ;
61785: LD_EXP 25
61789: PPUSH
61790: LD_STRING D12-MecM-1
61792: PPUSH
61793: CALL_OW 88
// Say ( poker_mec , D12-MecM-2 ) ;
61797: LD_EXP 25
61801: PPUSH
61802: LD_STRING D12-MecM-2
61804: PPUSH
61805: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
61809: LD_INT 10
61811: PPUSH
61812: CALL_OW 68
// if Query ( QDepotPlay ) = 2 then
61816: LD_STRING QDepotPlay
61818: PPUSH
61819: CALL_OW 97
61823: PUSH
61824: LD_INT 2
61826: EQUAL
61827: IFFALSE 61884
// begin Say ( Heike , D12-2-H-1 ) ;
61829: LD_EXP 7
61833: PPUSH
61834: LD_STRING D12-2-H-1
61836: PPUSH
61837: CALL_OW 88
// Say ( poker_eng , D12-2-EngF-1 ) ;
61841: LD_EXP 23
61845: PPUSH
61846: LD_STRING D12-2-EngF-1
61848: PPUSH
61849: CALL_OW 88
// Say ( poker_sol , D12-2-SolM-1 ) ;
61853: LD_EXP 24
61857: PPUSH
61858: LD_STRING D12-2-SolM-1
61860: PPUSH
61861: CALL_OW 88
// DialogueOff ;
61865: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( ai_depot [ 1 ] ) ;
61869: LD_EXP 32
61873: PUSH
61874: LD_INT 1
61876: ARRAY
61877: PPUSH
61878: CALL 59233 0 1
// continue ;
61882: GO 59792
// end ; Say ( poker_sol , D12-1-SolM-1 ) ;
61884: LD_EXP 24
61888: PPUSH
61889: LD_STRING D12-1-SolM-1
61891: PPUSH
61892: CALL_OW 88
// Say ( poker_eng , D12-1-EngF-1 ) ;
61896: LD_EXP 23
61900: PPUSH
61901: LD_STRING D12-1-EngF-1
61903: PPUSH
61904: CALL_OW 88
// Say ( poker_sol , D12-1-SolM-2 ) ;
61908: LD_EXP 24
61912: PPUSH
61913: LD_STRING D12-1-SolM-2
61915: PPUSH
61916: CALL_OW 88
// Say ( poker_mec , D12-1-MecM-1 ) ;
61920: LD_EXP 25
61924: PPUSH
61925: LD_STRING D12-1-MecM-1
61927: PPUSH
61928: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
61932: LD_INT 10
61934: PPUSH
61935: CALL_OW 68
// case Query ( QDepotName ) of 1 :
61939: LD_STRING QDepotName
61941: PPUSH
61942: CALL_OW 97
61946: PUSH
61947: LD_INT 1
61949: DOUBLE
61950: EQUAL
61951: IFTRUE 61955
61953: GO 62081
61955: POP
// begin Say ( Heike , D12-11-H-1 ) ;
61956: LD_EXP 7
61960: PPUSH
61961: LD_STRING D12-11-H-1
61963: PPUSH
61964: CALL_OW 88
// Say ( poker_mec , D12-11-MecM-1 ) ;
61968: LD_EXP 25
61972: PPUSH
61973: LD_STRING D12-11-MecM-1
61975: PPUSH
61976: CALL_OW 88
// Say ( poker_sol , D12-11-SolM-1 ) ;
61980: LD_EXP 24
61984: PPUSH
61985: LD_STRING D12-11-SolM-1
61987: PPUSH
61988: CALL_OW 88
// Say ( poker_eng , D12-11-EngF-1 ) ;
61992: LD_EXP 23
61996: PPUSH
61997: LD_STRING D12-11-EngF-1
61999: PPUSH
62000: CALL_OW 88
// Say ( poker_sol , D12-11-SolM-2 ) ;
62004: LD_EXP 24
62008: PPUSH
62009: LD_STRING D12-11-SolM-2
62011: PPUSH
62012: CALL_OW 88
// Say ( poker_eng , D12-11-EngF-2 ) ;
62016: LD_EXP 23
62020: PPUSH
62021: LD_STRING D12-11-EngF-2
62023: PPUSH
62024: CALL_OW 88
// Say ( Heike , D12-11-H-2 ) ;
62028: LD_EXP 7
62032: PPUSH
62033: LD_STRING D12-11-H-2
62035: PPUSH
62036: CALL_OW 88
// Say ( poker_eng , D12-11-EngF-3 ) ;
62040: LD_EXP 23
62044: PPUSH
62045: LD_STRING D12-11-EngF-3
62047: PPUSH
62048: CALL_OW 88
// boyfriend_identified = true ;
62052: LD_ADDR_EXP 106
62056: PUSH
62057: LD_INT 1
62059: ST_TO_ADDR
// dwait ( 0 0$0.5 ) ;
62060: LD_INT 18
62062: PPUSH
62063: CALL_OW 68
// Say ( Heike , D12-1g-H-1 ) ;
62067: LD_EXP 7
62071: PPUSH
62072: LD_STRING D12-1g-H-1
62074: PPUSH
62075: CALL_OW 88
// end ; 2 :
62079: GO 62298
62081: LD_INT 2
62083: DOUBLE
62084: EQUAL
62085: IFTRUE 62089
62087: GO 62219
62089: POP
// begin Say ( Heike , D12-12-H-1 ) ;
62090: LD_EXP 7
62094: PPUSH
62095: LD_STRING D12-12-H-1
62097: PPUSH
62098: CALL_OW 88
// Say ( poker_mec , D12-12-MecM-1 ) ;
62102: LD_EXP 25
62106: PPUSH
62107: LD_STRING D12-12-MecM-1
62109: PPUSH
62110: CALL_OW 88
// Say ( poker_eng , D12-12-EngF-1 ) ;
62114: LD_EXP 23
62118: PPUSH
62119: LD_STRING D12-12-EngF-1
62121: PPUSH
62122: CALL_OW 88
// Say ( Heike , D12-12-H-2 ) ;
62126: LD_EXP 7
62130: PPUSH
62131: LD_STRING D12-12-H-2
62133: PPUSH
62134: CALL_OW 88
// Say ( poker_eng , D12-12-EngF-2 ) ;
62138: LD_EXP 23
62142: PPUSH
62143: LD_STRING D12-12-EngF-2
62145: PPUSH
62146: CALL_OW 88
// Say ( poker_sol , D12-12-SolM-1 ) ;
62150: LD_EXP 24
62154: PPUSH
62155: LD_STRING D12-12-SolM-1
62157: PPUSH
62158: CALL_OW 88
// Say ( poker_eng , D12-12-EngF-3 ) ;
62162: LD_EXP 23
62166: PPUSH
62167: LD_STRING D12-12-EngF-3
62169: PPUSH
62170: CALL_OW 88
// Say ( poker_sol , D12-12-SolM-2 ) ;
62174: LD_EXP 24
62178: PPUSH
62179: LD_STRING D12-12-SolM-2
62181: PPUSH
62182: CALL_OW 88
// Say ( poker_eng , D12-12-EngF-4 ) ;
62186: LD_EXP 23
62190: PPUSH
62191: LD_STRING D12-12-EngF-4
62193: PPUSH
62194: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
62198: LD_INT 18
62200: PPUSH
62201: CALL_OW 68
// Say ( Heike , D12-1g-H-1 ) ;
62205: LD_EXP 7
62209: PPUSH
62210: LD_STRING D12-1g-H-1
62212: PPUSH
62213: CALL_OW 88
// end ; 3 :
62217: GO 62298
62219: LD_INT 3
62221: DOUBLE
62222: EQUAL
62223: IFTRUE 62227
62225: GO 62297
62227: POP
// begin dwait ( 0 0$0.5 ) ;
62228: LD_INT 18
62230: PPUSH
62231: CALL_OW 68
// Say ( Heike , D12-1g-H-1 ) ;
62235: LD_EXP 7
62239: PPUSH
62240: LD_STRING D12-1g-H-1
62242: PPUSH
62243: CALL_OW 88
// Say ( poker_mec , D12-13-MecM-1 ) ;
62247: LD_EXP 25
62251: PPUSH
62252: LD_STRING D12-13-MecM-1
62254: PPUSH
62255: CALL_OW 88
// Say ( poker_sol , D12-13-SolM-1 ) ;
62259: LD_EXP 24
62263: PPUSH
62264: LD_STRING D12-13-SolM-1
62266: PPUSH
62267: CALL_OW 88
// Say ( poker_eng , D12-13-EngF-1 ) ;
62271: LD_EXP 23
62275: PPUSH
62276: LD_STRING D12-13-EngF-1
62278: PPUSH
62279: CALL_OW 88
// Say ( poker_sol , D12-13-SolM-2 ) ;
62283: LD_EXP 24
62287: PPUSH
62288: LD_STRING D12-13-SolM-2
62290: PPUSH
62291: CALL_OW 88
// end ; end ;
62295: GO 62298
62297: POP
// Say ( poker_mec , D12-1x-MecM-1 ) ;
62298: LD_EXP 25
62302: PPUSH
62303: LD_STRING D12-1x-MecM-1
62305: PPUSH
62306: CALL_OW 88
// Say ( poker_sol , D12-1x-SolM-1 ) ;
62310: LD_EXP 24
62314: PPUSH
62315: LD_STRING D12-1x-SolM-1
62317: PPUSH
62318: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
62322: LD_INT 10
62324: PPUSH
62325: CALL_OW 68
// case Query ( QDepotArchive ) of 1 :
62329: LD_STRING QDepotArchive
62331: PPUSH
62332: CALL_OW 97
62336: PUSH
62337: LD_INT 1
62339: DOUBLE
62340: EQUAL
62341: IFTRUE 62345
62343: GO 62408
62345: POP
// begin Say ( Heike , D12-1x1-H-1 ) ;
62346: LD_EXP 7
62350: PPUSH
62351: LD_STRING D12-1x1-H-1
62353: PPUSH
62354: CALL_OW 88
// Say ( poker_sol , D12-1x1-SolM-1 ) ;
62358: LD_EXP 24
62362: PPUSH
62363: LD_STRING D12-1x1-SolM-1
62365: PPUSH
62366: CALL_OW 88
// Say ( Heike , D12-1x1-H-2 ) ;
62370: LD_EXP 7
62374: PPUSH
62375: LD_STRING D12-1x1-H-2
62377: PPUSH
62378: CALL_OW 88
// Say ( poker_sol , D12-1x1-SolM-2 ) ;
62382: LD_EXP 24
62386: PPUSH
62387: LD_STRING D12-1x1-SolM-2
62389: PPUSH
62390: CALL_OW 88
// Say ( poker_eng , D12-1x1-EngF-1 ) ;
62394: LD_EXP 23
62398: PPUSH
62399: LD_STRING D12-1x1-EngF-1
62401: PPUSH
62402: CALL_OW 88
// end ; 2 :
62406: GO 62432
62408: LD_INT 2
62410: DOUBLE
62411: EQUAL
62412: IFTRUE 62416
62414: GO 62431
62416: POP
// begin Say ( poker_eng , D12-1x2-EngF-1 ) ;
62417: LD_EXP 23
62421: PPUSH
62422: LD_STRING D12-1x2-EngF-1
62424: PPUSH
62425: CALL_OW 88
// end ; end ;
62429: GO 62432
62431: POP
// DWait ( 0 0$1 ) ;
62432: LD_INT 35
62434: PPUSH
62435: CALL_OW 68
// Say ( poker_mec , D12-1xx-MecM-1 ) ;
62439: LD_EXP 25
62443: PPUSH
62444: LD_STRING D12-1xx-MecM-1
62446: PPUSH
62447: CALL_OW 88
// Say ( poker_eng , D12-1xx-EngF-1 ) ;
62451: LD_EXP 23
62455: PPUSH
62456: LD_STRING D12-1xx-EngF-1
62458: PPUSH
62459: CALL_OW 88
// Say ( poker_mec , D12-1xx-MecM-2 ) ;
62463: LD_EXP 25
62467: PPUSH
62468: LD_STRING D12-1xx-MecM-2
62470: PPUSH
62471: CALL_OW 88
// Say ( poker_mec , D12-1xx-MecM-3 ) ;
62475: LD_EXP 25
62479: PPUSH
62480: LD_STRING D12-1xx-MecM-3
62482: PPUSH
62483: CALL_OW 88
// Say ( poker_sol , D12-1xx-SolM-1 ) ;
62487: LD_EXP 24
62491: PPUSH
62492: LD_STRING D12-1xx-SolM-1
62494: PPUSH
62495: CALL_OW 88
// Say ( poker_mec , D12-1xx-MecM-4 ) ;
62499: LD_EXP 25
62503: PPUSH
62504: LD_STRING D12-1xx-MecM-4
62506: PPUSH
62507: CALL_OW 88
// Say ( poker_mec , D12-1xx-MecM-5 ) ;
62511: LD_EXP 25
62515: PPUSH
62516: LD_STRING D12-1xx-MecM-5
62518: PPUSH
62519: CALL_OW 88
// Say ( poker_mec , D12-1xx-MecM-6 ) ;
62523: LD_EXP 25
62527: PPUSH
62528: LD_STRING D12-1xx-MecM-6
62530: PPUSH
62531: CALL_OW 88
// async ;
62535: ASYNC
// Say ( poker_eng , D12-1xx-EngF-2 ) ;
62536: LD_EXP 23
62540: PPUSH
62541: LD_STRING D12-1xx-EngF-2
62543: PPUSH
62544: CALL_OW 88
// sync ;
62548: SYNC
// Say ( poker_sol , D12-1xx-SolM-2 ) ;
62549: LD_EXP 24
62553: PPUSH
62554: LD_STRING D12-1xx-SolM-2
62556: PPUSH
62557: CALL_OW 88
// Say ( poker_eng , D12-1xx-EngF-3 ) ;
62561: LD_EXP 23
62565: PPUSH
62566: LD_STRING D12-1xx-EngF-3
62568: PPUSH
62569: CALL_OW 88
// Say ( poker_mec , D12-1xx-MecM-7 ) ;
62573: LD_EXP 25
62577: PPUSH
62578: LD_STRING D12-1xx-MecM-7
62580: PPUSH
62581: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
62585: LD_INT 10
62587: PPUSH
62588: CALL_OW 68
// case Query ( QDepotScientistsAndArchive ) of 1 :
62592: LD_STRING QDepotScientistsAndArchive
62594: PPUSH
62595: CALL_OW 97
62599: PUSH
62600: LD_INT 1
62602: DOUBLE
62603: EQUAL
62604: IFTRUE 62608
62606: GO 62635
62608: POP
// begin Say ( Heike , D12-1xx1-H-1 ) ;
62609: LD_EXP 7
62613: PPUSH
62614: LD_STRING D12-1xx1-H-1
62616: PPUSH
62617: CALL_OW 88
// Say ( poker_mec , D12-1xx1-MecM-1 ) ;
62621: LD_EXP 25
62625: PPUSH
62626: LD_STRING D12-1xx1-MecM-1
62628: PPUSH
62629: CALL_OW 88
// end ; 2 :
62633: GO 62659
62635: LD_INT 2
62637: DOUBLE
62638: EQUAL
62639: IFTRUE 62643
62641: GO 62658
62643: POP
// begin Say ( poker_sol , D12-1xx2-SolM-1 ) ;
62644: LD_EXP 24
62648: PPUSH
62649: LD_STRING D12-1xx2-SolM-1
62651: PPUSH
62652: CALL_OW 88
// end ; end ;
62656: GO 62659
62658: POP
// Say ( poker_sol , D12-1xxx-SolM-1 ) ;
62659: LD_EXP 24
62663: PPUSH
62664: LD_STRING D12-1xxx-SolM-1
62666: PPUSH
62667: CALL_OW 88
// Say ( poker_eng , D12-1xxx-EngF-1 ) ;
62671: LD_EXP 23
62675: PPUSH
62676: LD_STRING D12-1xxx-EngF-1
62678: PPUSH
62679: CALL_OW 88
// Say ( poker_sol , D12-1xxx-SolM-2 ) ;
62683: LD_EXP 24
62687: PPUSH
62688: LD_STRING D12-1xxx-SolM-2
62690: PPUSH
62691: CALL_OW 88
// Say ( poker_eng , D12-1xxx-EngF-2 ) ;
62695: LD_EXP 23
62699: PPUSH
62700: LD_STRING D12-1xxx-EngF-2
62702: PPUSH
62703: CALL_OW 88
// Say ( poker_sol , D12-1xxx-SolM-3 ) ;
62707: LD_EXP 24
62711: PPUSH
62712: LD_STRING D12-1xxx-SolM-3
62714: PPUSH
62715: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
62719: LD_INT 10
62721: PPUSH
62722: CALL_OW 68
// case Query ( QDepotLeader ) of 1 :
62726: LD_STRING QDepotLeader
62728: PPUSH
62729: CALL_OW 97
62733: PUSH
62734: LD_INT 1
62736: DOUBLE
62737: EQUAL
62738: IFTRUE 62742
62740: GO 62853
62742: POP
// begin Say ( Heike , D12-1xxx1-H-1 ) ;
62743: LD_EXP 7
62747: PPUSH
62748: LD_STRING D12-1xxx1-H-1
62750: PPUSH
62751: CALL_OW 88
// Say ( poker_sol , D12-1xxx1-SolM-1 ) ;
62755: LD_EXP 24
62759: PPUSH
62760: LD_STRING D12-1xxx1-SolM-1
62762: PPUSH
62763: CALL_OW 88
// Say ( poker_eng , D12-1xxx1-EngF-1 ) ;
62767: LD_EXP 23
62771: PPUSH
62772: LD_STRING D12-1xxx1-EngF-1
62774: PPUSH
62775: CALL_OW 88
// Say ( poker_sol , D12-1xxx1-SolM-2 ) ;
62779: LD_EXP 24
62783: PPUSH
62784: LD_STRING D12-1xxx1-SolM-2
62786: PPUSH
62787: CALL_OW 88
// Say ( poker_eng , D12-1xxx1-EngF-2 ) ;
62791: LD_EXP 23
62795: PPUSH
62796: LD_STRING D12-1xxx1-EngF-2
62798: PPUSH
62799: CALL_OW 88
// Say ( Heike , D12-1xxx1-H-2_v2 ) ;
62803: LD_EXP 7
62807: PPUSH
62808: LD_STRING D12-1xxx1-H-2_v2
62810: PPUSH
62811: CALL_OW 88
// Say ( poker_sol , D12-1xxx1-SolM-3 ) ;
62815: LD_EXP 24
62819: PPUSH
62820: LD_STRING D12-1xxx1-SolM-3
62822: PPUSH
62823: CALL_OW 88
// Say ( Heike , D12-1xxx1-H-3 ) ;
62827: LD_EXP 7
62831: PPUSH
62832: LD_STRING D12-1xxx1-H-3
62834: PPUSH
62835: CALL_OW 88
// Say ( poker_eng , D12-1xxx1-EngF-3 ) ;
62839: LD_EXP 23
62843: PPUSH
62844: LD_STRING D12-1xxx1-EngF-3
62846: PPUSH
62847: CALL_OW 88
// end ; 2 :
62851: GO 62889
62853: LD_INT 2
62855: DOUBLE
62856: EQUAL
62857: IFTRUE 62861
62859: GO 62888
62861: POP
// begin Say ( Heike , D12-1xxx2-H-1 ) ;
62862: LD_EXP 7
62866: PPUSH
62867: LD_STRING D12-1xxx2-H-1
62869: PPUSH
62870: CALL_OW 88
// Say ( poker_mec , D12-1xxx2-MecM-1 ) ;
62874: LD_EXP 25
62878: PPUSH
62879: LD_STRING D12-1xxx2-MecM-1
62881: PPUSH
62882: CALL_OW 88
// end ; end ;
62886: GO 62889
62888: POP
// Say ( poker_sol , D12-1xxx2-SolM-1 ) ;
62889: LD_EXP 24
62893: PPUSH
62894: LD_STRING D12-1xxx2-SolM-1
62896: PPUSH
62897: CALL_OW 88
// DialogueOff ;
62901: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( ai_depot [ 1 ] ) ;
62905: LD_EXP 32
62909: PUSH
62910: LD_INT 1
62912: ARRAY
62913: PPUSH
62914: CALL 59233 0 1
// end ; end ; continue ;
62918: GO 59792
// end ; if building in ai_facts [ 1 ] then
62920: LD_VAR 0 5
62924: PUSH
62925: LD_EXP 47
62929: PUSH
62930: LD_INT 1
62932: ARRAY
62933: IN
62934: IFFALSE 63405
// begin if code_black then
62936: LD_EXP 77
62940: IFFALSE 62972
// begin recent_player_units_enter_russian_buildings = recent_player_units_enter_russian_buildings ^ [ [ un , building ] ] ;
62942: LD_ADDR_EXP 92
62946: PUSH
62947: LD_EXP 92
62951: PUSH
62952: LD_VAR 0 4
62956: PUSH
62957: LD_VAR 0 5
62961: PUSH
62962: EMPTY
62963: LIST
62964: LIST
62965: PUSH
62966: EMPTY
62967: LIST
62968: ADD
62969: ST_TO_ADDR
// continue ;
62970: GO 59792
// end ; if boyfriend_identified and not asked_for_boyfriend then
62972: LD_EXP 106
62976: PUSH
62977: LD_VAR 0 13
62981: NOT
62982: AND
62983: IFFALSE 63299
// begin if Query ( QWorkshopBoyfriend1 ) = 1 then
62985: LD_STRING QWorkshopBoyfriend1
62987: PPUSH
62988: CALL_OW 97
62992: PUSH
62993: LD_INT 1
62995: EQUAL
62996: IFFALSE 63299
// begin DialogueOn ;
62998: CALL_OW 6
// Say ( Heike , D13-1-H-1 ) ;
63002: LD_EXP 7
63006: PPUSH
63007: LD_STRING D13-1-H-1
63009: PPUSH
63010: CALL_OW 88
// if IsInUnit ( Yakov ) in ai_facts [ 1 ] and not Yakov in ai_mechanics_attack [ 1 ] then
63014: LD_EXP 15
63018: PPUSH
63019: CALL_OW 310
63023: PUSH
63024: LD_EXP 47
63028: PUSH
63029: LD_INT 1
63031: ARRAY
63032: IN
63033: PUSH
63034: LD_EXP 15
63038: PUSH
63039: LD_EXP 29
63043: PUSH
63044: LD_INT 1
63046: ARRAY
63047: IN
63048: NOT
63049: AND
63050: IFFALSE 63283
// begin asked_for_boyfriend = true ;
63052: LD_ADDR_VAR 0 13
63056: PUSH
63057: LD_INT 1
63059: ST_TO_ADDR
// Say ( Yakov , D13-1-boyfriend-1 ) ;
63060: LD_EXP 15
63064: PPUSH
63065: LD_STRING D13-1-boyfriend-1
63067: PPUSH
63068: CALL_OW 88
// temp_list = [ 1 , 2 ] ;
63072: LD_ADDR_VAR 0 3
63076: PUSH
63077: LD_INT 1
63079: PUSH
63080: LD_INT 2
63082: PUSH
63083: EMPTY
63084: LIST
63085: LIST
63086: ST_TO_ADDR
// if IsDead ( Yefibachev ) then
63087: LD_EXP 14
63091: PPUSH
63092: CALL_OW 301
63096: IFFALSE 63112
// temp_list = temp_list diff 1 ;
63098: LD_ADDR_VAR 0 3
63102: PUSH
63103: LD_VAR 0 3
63107: PUSH
63108: LD_INT 1
63110: DIFF
63111: ST_TO_ADDR
// dwait ( 0 0$0.3 ) ;
63112: LD_INT 10
63114: PPUSH
63115: CALL_OW 68
// case SelectiveQuery ( QWorkshopBoyfriend2 , temp_list ) of 1 :
63119: LD_STRING QWorkshopBoyfriend2
63121: PPUSH
63122: LD_VAR 0 3
63126: PPUSH
63127: CALL_OW 98
63131: PUSH
63132: LD_INT 1
63134: DOUBLE
63135: EQUAL
63136: IFTRUE 63140
63138: GO 63205
63140: POP
// begin Say ( Heike , D13-11-H-1 ) ;
63141: LD_EXP 7
63145: PPUSH
63146: LD_STRING D13-11-H-1
63148: PPUSH
63149: CALL_OW 88
// Say ( Yakov , D13-11-boyfriend-1 ) ;
63153: LD_EXP 15
63157: PPUSH
63158: LD_STRING D13-11-boyfriend-1
63160: PPUSH
63161: CALL_OW 88
// Say ( Heike , D13-11-H-2 ) ;
63165: LD_EXP 7
63169: PPUSH
63170: LD_STRING D13-11-H-2
63172: PPUSH
63173: CALL_OW 88
// Say ( Yakov , D13-11-boyfriend-2 ) ;
63177: LD_EXP 15
63181: PPUSH
63182: LD_STRING D13-11-boyfriend-2
63184: PPUSH
63185: CALL_OW 88
// DialogueOff ;
63189: CALL_OW 7
// Yakov_to_archive = true ;
63193: LD_ADDR_EXP 112
63197: PUSH
63198: LD_INT 1
63200: ST_TO_ADDR
// continue ;
63201: GO 59792
// end ; 2 :
63203: GO 63281
63205: LD_INT 2
63207: DOUBLE
63208: EQUAL
63209: IFTRUE 63213
63211: GO 63280
63213: POP
// begin Say ( Heike , D13-12-H-1 ) ;
63214: LD_EXP 7
63218: PPUSH
63219: LD_STRING D13-12-H-1
63221: PPUSH
63222: CALL_OW 88
// Say ( Yakov , D13-12-boyfriend-1 ) ;
63226: LD_EXP 15
63230: PPUSH
63231: LD_STRING D13-12-boyfriend-1
63233: PPUSH
63234: CALL_OW 88
// Say ( Heike , D13-12-H-2 ) ;
63238: LD_EXP 7
63242: PPUSH
63243: LD_STRING D13-12-H-2
63245: PPUSH
63246: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
63250: LD_INT 10
63252: PPUSH
63253: CALL_OW 68
// Query ( QBoyfriendLurePlan ) ;
63257: LD_STRING QBoyfriendLurePlan
63259: PPUSH
63260: CALL_OW 97
// DialogueOff ;
63264: CALL_OW 7
// Yakov_luring = 1 ;
63268: LD_ADDR_EXP 113
63272: PUSH
63273: LD_INT 1
63275: ST_TO_ADDR
// continue ;
63276: GO 59792
// end ; end ;
63278: GO 63281
63280: POP
// end else
63281: GO 63299
// begin Say ( Natalya , D13-1-Natalya-1 ) ;
63283: LD_EXP 16
63287: PPUSH
63288: LD_STRING D13-1-Natalya-1
63290: PPUSH
63291: CALL_OW 88
// DialogueOff ;
63295: CALL_OW 7
// end ; end ; end ; if not visited_workshop and IsInUnit ( Natalya ) in ai_facts [ 1 ] then
63299: LD_VAR 0 12
63303: NOT
63304: PUSH
63305: LD_EXP 16
63309: PPUSH
63310: CALL_OW 310
63314: PUSH
63315: LD_EXP 47
63319: PUSH
63320: LD_INT 1
63322: ARRAY
63323: IN
63324: AND
63325: IFFALSE 63403
// begin visited_workshop = true ;
63327: LD_ADDR_VAR 0 12
63331: PUSH
63332: LD_INT 1
63334: ST_TO_ADDR
// DialogueOn ;
63335: CALL_OW 6
// Say ( Natalya , D13-2-Natalya-1 ) ;
63339: LD_EXP 16
63343: PPUSH
63344: LD_STRING D13-2-Natalya-1
63346: PPUSH
63347: CALL_OW 88
// Say ( Heike , D13-2-H-1 ) ;
63351: LD_EXP 7
63355: PPUSH
63356: LD_STRING D13-2-H-1
63358: PPUSH
63359: CALL_OW 88
// Say ( Natalya , D13-2-Natalya-2 ) ;
63363: LD_EXP 16
63367: PPUSH
63368: LD_STRING D13-2-Natalya-2
63370: PPUSH
63371: CALL_OW 88
// Say ( Heike , D13-2-H-2 ) ;
63375: LD_EXP 7
63379: PPUSH
63380: LD_STRING D13-2-H-2
63382: PPUSH
63383: CALL_OW 88
// Say ( Natalya , D13-2-Natalya-3 ) ;
63387: LD_EXP 16
63391: PPUSH
63392: LD_STRING D13-2-Natalya-3
63394: PPUSH
63395: CALL_OW 88
// DialogueOff ;
63399: CALL_OW 7
// end ; continue ;
63403: GO 59792
// end ; end else
63405: GO 63810
// begin if not building in visited_buildings then
63407: LD_VAR 0 5
63411: PUSH
63412: LD_VAR 0 6
63416: IN
63417: NOT
63418: IFFALSE 63810
// begin visited_buildings = visited_buildings ^ building ;
63420: LD_ADDR_VAR 0 6
63424: PUSH
63425: LD_VAR 0 6
63429: PUSH
63430: LD_VAR 0 5
63434: ADD
63435: ST_TO_ADDR
// DialogueOn ;
63436: CALL_OW 6
// if building = the_archive then
63440: LD_VAR 0 5
63444: PUSH
63445: LD_EXP 75
63449: EQUAL
63450: IFFALSE 63608
// begin case un of Heike :
63452: LD_VAR 0 4
63456: PUSH
63457: LD_EXP 7
63461: DOUBLE
63462: EQUAL
63463: IFTRUE 63467
63465: GO 63482
63467: POP
// Say ( Heike , D20-H-1 ) ; Dwayne :
63468: LD_EXP 7
63472: PPUSH
63473: LD_STRING D20-H-1
63475: PPUSH
63476: CALL_OW 88
63480: GO 63598
63482: LD_EXP 8
63486: DOUBLE
63487: EQUAL
63488: IFTRUE 63492
63490: GO 63507
63492: POP
// Say ( Dwayne , D20-Dw-1 ) ; Oswald :
63493: LD_EXP 8
63497: PPUSH
63498: LD_STRING D20-Dw-1
63500: PPUSH
63501: CALL_OW 88
63505: GO 63598
63507: LD_EXP 9
63511: DOUBLE
63512: EQUAL
63513: IFTRUE 63517
63515: GO 63552
63517: POP
// begin if oswald_is_substitute then
63518: LD_EXP 70
63522: IFFALSE 63538
// Say ( Oswald , D20-Os_sub-1 ) else
63524: LD_EXP 9
63528: PPUSH
63529: LD_STRING D20-Os_sub-1
63531: PPUSH
63532: CALL_OW 88
63536: GO 63550
// Say ( Oswald , D20-Os-1 ) ;
63538: LD_EXP 9
63542: PPUSH
63543: LD_STRING D20-Os-1
63545: PPUSH
63546: CALL_OW 88
// end ; Kurt :
63550: GO 63598
63552: LD_EXP 10
63556: DOUBLE
63557: EQUAL
63558: IFTRUE 63562
63560: GO 63597
63562: POP
// begin if kurt_is_substitute then
63563: LD_EXP 71
63567: IFFALSE 63583
// Say ( Kurt , D20-Ku_sub-1 ) else
63569: LD_EXP 10
63573: PPUSH
63574: LD_STRING D20-Ku_sub-1
63576: PPUSH
63577: CALL_OW 88
63581: GO 63595
// Say ( Kurt , D20-Ku-1 ) ;
63583: LD_EXP 10
63587: PPUSH
63588: LD_STRING D20-Ku-1
63590: PPUSH
63591: CALL_OW 88
// end ; end ;
63595: GO 63598
63597: POP
// archive_found = true ;
63598: LD_ADDR_EXP 100
63602: PUSH
63603: LD_INT 1
63605: ST_TO_ADDR
// end else
63606: GO 63806
// begin k = Rand ( 1 , 3 ) ;
63608: LD_ADDR_VAR 0 2
63612: PUSH
63613: LD_INT 1
63615: PPUSH
63616: LD_INT 3
63618: PPUSH
63619: CALL_OW 12
63623: ST_TO_ADDR
// case un of Heike :
63624: LD_VAR 0 4
63628: PUSH
63629: LD_EXP 7
63633: DOUBLE
63634: EQUAL
63635: IFTRUE 63639
63637: GO 63660
63639: POP
// Say ( Heike , D18-H- & k ) ; Dwayne :
63640: LD_EXP 7
63644: PPUSH
63645: LD_STRING D18-H-
63647: PUSH
63648: LD_VAR 0 2
63652: STR
63653: PPUSH
63654: CALL_OW 88
63658: GO 63806
63660: LD_EXP 8
63664: DOUBLE
63665: EQUAL
63666: IFTRUE 63670
63668: GO 63691
63670: POP
// Say ( Dwayne , D18-Dw- & k ) ; Oswald :
63671: LD_EXP 8
63675: PPUSH
63676: LD_STRING D18-Dw-
63678: PUSH
63679: LD_VAR 0 2
63683: STR
63684: PPUSH
63685: CALL_OW 88
63689: GO 63806
63691: LD_EXP 9
63695: DOUBLE
63696: EQUAL
63697: IFTRUE 63701
63699: GO 63748
63701: POP
// begin if oswald_is_substitute then
63702: LD_EXP 70
63706: IFFALSE 63728
// Say ( Oswald , D18-Os_sub- & k ) else
63708: LD_EXP 9
63712: PPUSH
63713: LD_STRING D18-Os_sub-
63715: PUSH
63716: LD_VAR 0 2
63720: STR
63721: PPUSH
63722: CALL_OW 88
63726: GO 63746
// Say ( Oswald , D18-Os- & k ) ;
63728: LD_EXP 9
63732: PPUSH
63733: LD_STRING D18-Os-
63735: PUSH
63736: LD_VAR 0 2
63740: STR
63741: PPUSH
63742: CALL_OW 88
// end ; Kurt :
63746: GO 63806
63748: LD_EXP 10
63752: DOUBLE
63753: EQUAL
63754: IFTRUE 63758
63756: GO 63805
63758: POP
// begin if kurt_is_substitute then
63759: LD_EXP 71
63763: IFFALSE 63785
// Say ( Kurt , D18-Ku_sub- & k ) else
63765: LD_EXP 10
63769: PPUSH
63770: LD_STRING D18-Ku_sub-
63772: PUSH
63773: LD_VAR 0 2
63777: STR
63778: PPUSH
63779: CALL_OW 88
63783: GO 63803
// Say ( Kurt , D18-Ku- & k ) ;
63785: LD_EXP 10
63789: PPUSH
63790: LD_STRING D18-Ku-
63792: PUSH
63793: LD_VAR 0 2
63797: STR
63798: PPUSH
63799: CALL_OW 88
// end ; end ;
63803: GO 63806
63805: POP
// end ; DialogueOff ;
63806: CALL_OW 7
// end ; end ; until false ;
63810: LD_INT 0
63812: IFFALSE 59792
// end ;
63814: PPOPN 13
63816: END
// every 0 0$1 + 0 0$0.1 do var i , un , temp_list ; var sol , init_cooldown ;
63817: GO 63819
63819: DISABLE
63820: LD_INT 0
63822: PPUSH
63823: PPUSH
63824: PPUSH
63825: PPUSH
63826: PPUSH
// begin sol = 0 ;
63827: LD_ADDR_VAR 0 4
63831: PUSH
63832: LD_INT 0
63834: ST_TO_ADDR
// init_cooldown = 0 0$5 ;
63835: LD_ADDR_VAR 0 5
63839: PUSH
63840: LD_INT 175
63842: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
63843: LD_INT 35
63845: PPUSH
63846: CALL_OW 67
// if not send_sol_from_office_to_archive then
63850: LD_EXP 96
63854: NOT
63855: IFFALSE 63859
// continue ;
63857: GO 63843
// if init_cooldown > 0 0$0 then
63859: LD_VAR 0 5
63863: PUSH
63864: LD_INT 0
63866: GREATER
63867: IFFALSE 63885
// begin init_cooldown = init_cooldown - 0 0$1 ;
63869: LD_ADDR_VAR 0 5
63873: PUSH
63874: LD_VAR 0 5
63878: PUSH
63879: LD_INT 35
63881: MINUS
63882: ST_TO_ADDR
// continue ;
63883: GO 63843
// end ; if code_black or sol_office_to_archive in ai_heal_these_humans [ 1 ] or not IsOk ( the_archive ) then
63885: LD_EXP 77
63889: PUSH
63890: LD_EXP 97
63894: PUSH
63895: LD_EXP 42
63899: PUSH
63900: LD_INT 1
63902: ARRAY
63903: IN
63904: OR
63905: PUSH
63906: LD_EXP 75
63910: PPUSH
63911: CALL_OW 302
63915: NOT
63916: OR
63917: IFFALSE 63949
// begin if sol_office_to_archive > 0 then
63919: LD_EXP 97
63923: PUSH
63924: LD_INT 0
63926: GREATER
63927: IFFALSE 63947
// begin sol = sol_office_to_archive ;
63929: LD_ADDR_VAR 0 4
63933: PUSH
63934: LD_EXP 97
63938: ST_TO_ADDR
// sol_office_to_archive = 0 ;
63939: LD_ADDR_EXP 97
63943: PUSH
63944: LD_INT 0
63946: ST_TO_ADDR
// end ; continue ;
63947: GO 63843
// end ; if sol > 0 then
63949: LD_VAR 0 4
63953: PUSH
63954: LD_INT 0
63956: GREATER
63957: IFFALSE 63977
// begin sol_office_to_archive = sol ;
63959: LD_ADDR_EXP 97
63963: PUSH
63964: LD_VAR 0 4
63968: ST_TO_ADDR
// sol = 0 ;
63969: LD_ADDR_VAR 0 4
63973: PUSH
63974: LD_INT 0
63976: ST_TO_ADDR
// end ; if IsDead ( sol_office_to_archive ) then
63977: LD_EXP 97
63981: PPUSH
63982: CALL_OW 301
63986: IFFALSE 63996
// sol_office_to_archive = 0 ;
63988: LD_ADDR_EXP 97
63992: PUSH
63993: LD_INT 0
63995: ST_TO_ADDR
// if sol_office_to_archive = 0 then
63996: LD_EXP 97
64000: PUSH
64001: LD_INT 0
64003: EQUAL
64004: IFFALSE 64160
// begin if not IsOk ( leader_office ) then
64006: LD_EXP 93
64010: PPUSH
64011: CALL_OW 302
64015: NOT
64016: IFFALSE 64020
// continue ;
64018: GO 63843
// for i in UnitsInside ( leader_office ) do
64020: LD_ADDR_VAR 0 1
64024: PUSH
64025: LD_EXP 93
64029: PPUSH
64030: CALL_OW 313
64034: PUSH
64035: FOR_IN
64036: IFFALSE 64146
// if not i in [ Stanimir , Barovnin , Yefibachev , Yakov , Natalya , Mikhail , good_pat , bad_pat , Dmitri , Sergei , Yann , poker_eng , poker_sol , poker_mec ] then
64038: LD_VAR 0 1
64042: PUSH
64043: LD_EXP 12
64047: PUSH
64048: LD_EXP 13
64052: PUSH
64053: LD_EXP 14
64057: PUSH
64058: LD_EXP 15
64062: PUSH
64063: LD_EXP 16
64067: PUSH
64068: LD_EXP 17
64072: PUSH
64073: LD_EXP 18
64077: PUSH
64078: LD_EXP 19
64082: PUSH
64083: LD_EXP 20
64087: PUSH
64088: LD_EXP 21
64092: PUSH
64093: LD_EXP 22
64097: PUSH
64098: LD_EXP 23
64102: PUSH
64103: LD_EXP 24
64107: PUSH
64108: LD_EXP 25
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: LIST
64117: LIST
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: IN
64129: NOT
64130: IFFALSE 64144
// begin sol_office_to_archive = i ;
64132: LD_ADDR_EXP 97
64136: PUSH
64137: LD_VAR 0 1
64141: ST_TO_ADDR
// break ;
64142: GO 64146
// end ;
64144: GO 64035
64146: POP
64147: POP
// if sol_office_to_archive = 0 then
64148: LD_EXP 97
64152: PUSH
64153: LD_INT 0
64155: EQUAL
64156: IFFALSE 64160
// continue ;
64158: GO 63843
// end ; if IsInUnit ( sol_office_to_archive ) <> the_archive then
64160: LD_EXP 97
64164: PPUSH
64165: CALL_OW 310
64169: PUSH
64170: LD_EXP 75
64174: NONEQUAL
64175: IFFALSE 64359
// begin case GetType ( IsInUnit ( sol_office_to_archive ) ) of unit_building :
64177: LD_EXP 97
64181: PPUSH
64182: CALL_OW 310
64186: PPUSH
64187: CALL_OW 247
64191: PUSH
64192: LD_INT 3
64194: DOUBLE
64195: EQUAL
64196: IFTRUE 64200
64198: GO 64212
64200: POP
// ComExitBuilding ( sol_office_to_archive ) ; unit_vehicle :
64201: LD_EXP 97
64205: PPUSH
64206: CALL_OW 122
64210: GO 64357
64212: LD_INT 2
64214: DOUBLE
64215: EQUAL
64216: IFTRUE 64220
64218: GO 64232
64220: POP
// ComExitVehicle ( sol_office_to_archive ) ; else
64221: LD_EXP 97
64225: PPUSH
64226: CALL_OW 121
64230: GO 64357
64232: POP
// begin if GetDistUnits ( sol_office_to_archive , the_archive ) <= 6 then
64233: LD_EXP 97
64237: PPUSH
64238: LD_EXP 75
64242: PPUSH
64243: CALL_OW 296
64247: PUSH
64248: LD_INT 6
64250: LESSEQUAL
64251: IFFALSE 64343
// begin temp_list = UnitsInside ( the_archive ) ;
64253: LD_ADDR_VAR 0 3
64257: PUSH
64258: LD_EXP 75
64262: PPUSH
64263: CALL_OW 313
64267: ST_TO_ADDR
// if temp_list = 6 then
64268: LD_VAR 0 3
64272: PUSH
64273: LD_INT 6
64275: EQUAL
64276: IFFALSE 64343
// begin un = 0 ;
64278: LD_ADDR_VAR 0 2
64282: PUSH
64283: LD_INT 0
64285: ST_TO_ADDR
// for i in temp_list do
64286: LD_ADDR_VAR 0 1
64290: PUSH
64291: LD_VAR 0 3
64295: PUSH
64296: FOR_IN
64297: IFFALSE 64325
// if i <> Barovnin then
64299: LD_VAR 0 1
64303: PUSH
64304: LD_EXP 13
64308: NONEQUAL
64309: IFFALSE 64323
// begin un = i ;
64311: LD_ADDR_VAR 0 2
64315: PUSH
64316: LD_VAR 0 1
64320: ST_TO_ADDR
// break ;
64321: GO 64325
// end ;
64323: GO 64296
64325: POP
64326: POP
// ComExitBuilding ( un ) ;
64327: LD_VAR 0 2
64331: PPUSH
64332: CALL_OW 122
// wait ( 3 ) ;
64336: LD_INT 3
64338: PPUSH
64339: CALL_OW 67
// end ; end ; ComEnterUnit ( sol_office_to_archive , the_archive ) ;
64343: LD_EXP 97
64347: PPUSH
64348: LD_EXP 75
64352: PPUSH
64353: CALL_OW 120
// end ; end ; end else
64357: GO 64420
// begin for i = 1 to 5 do
64359: LD_ADDR_VAR 0 1
64363: PUSH
64364: DOUBLE
64365: LD_INT 1
64367: DEC
64368: ST_TO_ADDR
64369: LD_INT 5
64371: PUSH
64372: FOR_TO
64373: IFFALSE 64408
// begin if code_red or code_black then
64375: LD_EXP 76
64379: PUSH
64380: LD_EXP 77
64384: OR
64385: IFFALSE 64399
// begin sol_office_to_archive = 0 ;
64387: LD_ADDR_EXP 97
64391: PUSH
64392: LD_INT 0
64394: ST_TO_ADDR
// exit ;
64395: POP
64396: POP
64397: GO 64424
// end ; wait ( 0 0$1 ) ;
64399: LD_INT 35
64401: PPUSH
64402: CALL_OW 67
// end ;
64406: GO 64372
64408: POP
64409: POP
// sol_office_to_archive = 0 ;
64410: LD_ADDR_EXP 97
64414: PUSH
64415: LD_INT 0
64417: ST_TO_ADDR
// exit ;
64418: GO 64424
// end ; until false ;
64420: LD_INT 0
64422: IFFALSE 63843
// end ;
64424: PPOPN 5
64426: END
// every 0 0$1 + 0 0$0.9 do var un , temp_list , i ; var been_in_archive ;
64427: GO 64429
64429: DISABLE
64430: LD_INT 0
64432: PPUSH
64433: PPUSH
64434: PPUSH
64435: PPUSH
// begin been_in_archive = false ;
64436: LD_ADDR_VAR 0 4
64440: PUSH
64441: LD_INT 0
64443: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
64444: LD_INT 35
64446: PPUSH
64447: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] or IsDead ( Yakov ) or IsDead ( Yefibachev ) then
64451: LD_EXP 83
64455: PUSH
64456: LD_INT 3
64458: PUSH
64459: LD_INT 4
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: IN
64466: PUSH
64467: LD_EXP 15
64471: PPUSH
64472: CALL_OW 301
64476: OR
64477: PUSH
64478: LD_EXP 14
64482: PPUSH
64483: CALL_OW 301
64487: OR
64488: IFFALSE 64492
// exit ;
64490: GO 65159
// until Yakov_to_archive ;
64492: LD_EXP 112
64496: IFFALSE 64444
// repeat wait ( 0 0$1 ) ;
64498: LD_INT 35
64500: PPUSH
64501: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] or IsDead ( Yakov ) or IsDead ( Yefibachev ) then
64505: LD_EXP 83
64509: PUSH
64510: LD_INT 3
64512: PUSH
64513: LD_INT 4
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: IN
64520: PUSH
64521: LD_EXP 15
64525: PPUSH
64526: CALL_OW 301
64530: OR
64531: PUSH
64532: LD_EXP 14
64536: PPUSH
64537: CALL_OW 301
64541: OR
64542: IFFALSE 64546
// exit ;
64544: GO 65159
// if code_black or Yakov in ai_mechanics_attack [ 1 ] or Yakov in ai_heal_these_humans [ 1 ] then
64546: LD_EXP 77
64550: PUSH
64551: LD_EXP 15
64555: PUSH
64556: LD_EXP 29
64560: PUSH
64561: LD_INT 1
64563: ARRAY
64564: IN
64565: OR
64566: PUSH
64567: LD_EXP 15
64571: PUSH
64572: LD_EXP 42
64576: PUSH
64577: LD_INT 1
64579: ARRAY
64580: IN
64581: OR
64582: IFFALSE 64594
// begin except_Yakov = false ;
64584: LD_ADDR_EXP 111
64588: PUSH
64589: LD_INT 0
64591: ST_TO_ADDR
// continue ;
64592: GO 64498
// end ; except_Yakov = true ;
64594: LD_ADDR_EXP 111
64598: PUSH
64599: LD_INT 1
64601: ST_TO_ADDR
// if not been_in_archive then
64602: LD_VAR 0 4
64606: NOT
64607: IFFALSE 64852
// begin if not IsOk ( the_archive ) then
64609: LD_EXP 75
64613: PPUSH
64614: CALL_OW 302
64618: NOT
64619: IFFALSE 64631
// begin except_Yakov = false ;
64621: LD_ADDR_EXP 111
64625: PUSH
64626: LD_INT 0
64628: ST_TO_ADDR
// continue ;
64629: GO 64498
// end ; un = IsInUnit ( Yakov ) ;
64631: LD_ADDR_VAR 0 1
64635: PUSH
64636: LD_EXP 15
64640: PPUSH
64641: CALL_OW 310
64645: ST_TO_ADDR
// if un <> the_archive then
64646: LD_VAR 0 1
64650: PUSH
64651: LD_EXP 75
64655: NONEQUAL
64656: IFFALSE 64835
// begin case GetType ( un ) of unit_vehicle :
64658: LD_VAR 0 1
64662: PPUSH
64663: CALL_OW 247
64667: PUSH
64668: LD_INT 2
64670: DOUBLE
64671: EQUAL
64672: IFTRUE 64676
64674: GO 64688
64676: POP
// ComExitVehicle ( Yakov ) ; unit_building :
64677: LD_EXP 15
64681: PPUSH
64682: CALL_OW 121
64686: GO 64833
64688: LD_INT 3
64690: DOUBLE
64691: EQUAL
64692: IFTRUE 64696
64694: GO 64708
64696: POP
// ComExitBuilding ( Yakov ) ; else
64697: LD_EXP 15
64701: PPUSH
64702: CALL_OW 122
64706: GO 64833
64708: POP
// begin if GetDistUnits ( Yakov , the_archive ) <= 6 then
64709: LD_EXP 15
64713: PPUSH
64714: LD_EXP 75
64718: PPUSH
64719: CALL_OW 296
64723: PUSH
64724: LD_INT 6
64726: LESSEQUAL
64727: IFFALSE 64819
// begin temp_list = UnitsInside ( the_archive ) ;
64729: LD_ADDR_VAR 0 2
64733: PUSH
64734: LD_EXP 75
64738: PPUSH
64739: CALL_OW 313
64743: ST_TO_ADDR
// if temp_list = 6 then
64744: LD_VAR 0 2
64748: PUSH
64749: LD_INT 6
64751: EQUAL
64752: IFFALSE 64819
// begin un = 0 ;
64754: LD_ADDR_VAR 0 1
64758: PUSH
64759: LD_INT 0
64761: ST_TO_ADDR
// for i in temp_list do
64762: LD_ADDR_VAR 0 3
64766: PUSH
64767: LD_VAR 0 2
64771: PUSH
64772: FOR_IN
64773: IFFALSE 64801
// if i <> Barovnin then
64775: LD_VAR 0 3
64779: PUSH
64780: LD_EXP 13
64784: NONEQUAL
64785: IFFALSE 64799
// begin un = i ;
64787: LD_ADDR_VAR 0 1
64791: PUSH
64792: LD_VAR 0 3
64796: ST_TO_ADDR
// break ;
64797: GO 64801
// end ;
64799: GO 64772
64801: POP
64802: POP
// ComExitBuilding ( un ) ;
64803: LD_VAR 0 1
64807: PPUSH
64808: CALL_OW 122
// wait ( 3 ) ;
64812: LD_INT 3
64814: PPUSH
64815: CALL_OW 67
// end ; end ; ComEnterUnit ( Yakov , the_archive ) ;
64819: LD_EXP 15
64823: PPUSH
64824: LD_EXP 75
64828: PPUSH
64829: CALL_OW 120
// end ; end ; end else
64833: GO 64850
// begin been_in_archive = true ;
64835: LD_ADDR_VAR 0 4
64839: PUSH
64840: LD_INT 1
64842: ST_TO_ADDR
// wait ( 0 0$4 ) ;
64843: LD_INT 140
64845: PPUSH
64846: CALL_OW 67
// end ; end else
64850: GO 65155
// begin if not IsOk ( leader_office ) then
64852: LD_EXP 93
64856: PPUSH
64857: CALL_OW 302
64861: NOT
64862: IFFALSE 64874
// begin except_Yakov = false ;
64864: LD_ADDR_EXP 111
64868: PUSH
64869: LD_INT 0
64871: ST_TO_ADDR
// continue ;
64872: GO 64498
// end ; un = IsInUnit ( Yakov ) ;
64874: LD_ADDR_VAR 0 1
64878: PUSH
64879: LD_EXP 15
64883: PPUSH
64884: CALL_OW 310
64888: ST_TO_ADDR
// if un <> leader_office then
64889: LD_VAR 0 1
64893: PUSH
64894: LD_EXP 93
64898: NONEQUAL
64899: IFFALSE 65078
// begin case GetType ( un ) of unit_vehicle :
64901: LD_VAR 0 1
64905: PPUSH
64906: CALL_OW 247
64910: PUSH
64911: LD_INT 2
64913: DOUBLE
64914: EQUAL
64915: IFTRUE 64919
64917: GO 64931
64919: POP
// ComExitVehicle ( Yakov ) ; unit_building :
64920: LD_EXP 15
64924: PPUSH
64925: CALL_OW 121
64929: GO 65076
64931: LD_INT 3
64933: DOUBLE
64934: EQUAL
64935: IFTRUE 64939
64937: GO 64951
64939: POP
// ComExitBuilding ( Yakov ) ; else
64940: LD_EXP 15
64944: PPUSH
64945: CALL_OW 122
64949: GO 65076
64951: POP
// begin if GetDistUnits ( Yakov , leader_office ) <= 5 then
64952: LD_EXP 15
64956: PPUSH
64957: LD_EXP 93
64961: PPUSH
64962: CALL_OW 296
64966: PUSH
64967: LD_INT 5
64969: LESSEQUAL
64970: IFFALSE 65062
// begin temp_list = UnitsInside ( leader_office ) ;
64972: LD_ADDR_VAR 0 2
64976: PUSH
64977: LD_EXP 93
64981: PPUSH
64982: CALL_OW 313
64986: ST_TO_ADDR
// if temp_list = 6 then
64987: LD_VAR 0 2
64991: PUSH
64992: LD_INT 6
64994: EQUAL
64995: IFFALSE 65062
// begin un = 0 ;
64997: LD_ADDR_VAR 0 1
65001: PUSH
65002: LD_INT 0
65004: ST_TO_ADDR
// for i in temp_list do
65005: LD_ADDR_VAR 0 3
65009: PUSH
65010: LD_VAR 0 2
65014: PUSH
65015: FOR_IN
65016: IFFALSE 65044
// if i <> Yefibachev then
65018: LD_VAR 0 3
65022: PUSH
65023: LD_EXP 14
65027: NONEQUAL
65028: IFFALSE 65042
// begin un = i ;
65030: LD_ADDR_VAR 0 1
65034: PUSH
65035: LD_VAR 0 3
65039: ST_TO_ADDR
// break ;
65040: GO 65044
// end ;
65042: GO 65015
65044: POP
65045: POP
// ComExitBuilding ( un ) ;
65046: LD_VAR 0 1
65050: PPUSH
65051: CALL_OW 122
// wait ( 3 ) ;
65055: LD_INT 3
65057: PPUSH
65058: CALL_OW 67
// end ; end ; ComEnterUnit ( Yakov , leader_office ) ;
65062: LD_EXP 15
65066: PPUSH
65067: LD_EXP 93
65071: PPUSH
65072: CALL_OW 120
// end ; end ; end else
65076: GO 65155
// begin wait ( 0 0$4 ) ;
65078: LD_INT 140
65080: PPUSH
65081: CALL_OW 67
// while code_black do
65085: LD_EXP 77
65089: IFFALSE 65100
// wait ( 0 0$2 ) ;
65091: LD_INT 70
65093: PPUSH
65094: CALL_OW 67
65098: GO 65085
// if heike_undercover <> 4 then
65100: LD_EXP 83
65104: PUSH
65105: LD_INT 4
65107: NONEQUAL
65108: IFFALSE 65137
// begin DialogueOn ;
65110: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-2b ) ;
65114: LD_EXP 14
65118: PPUSH
65119: LD_STRING D7-Leader-2b
65121: PPUSH
65122: CALL_OW 94
// DialogueOff ;
65126: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
65130: LD_INT 4
65132: PPUSH
65133: CALL 42004 0 1
// end ; code_black = true ;
65137: LD_ADDR_EXP 77
65141: PUSH
65142: LD_INT 1
65144: ST_TO_ADDR
// except_Yakov = false ;
65145: LD_ADDR_EXP 111
65149: PUSH
65150: LD_INT 0
65152: ST_TO_ADDR
// exit ;
65153: GO 65159
// end ; end ; until false ;
65155: LD_INT 0
65157: IFFALSE 64498
// end ;
65159: PPOPN 4
65161: END
// every 0 0$1 + 0 0$0.6 do var i , k , un , temp_list , temp_list_2 , time ;
65162: GO 65164
65164: DISABLE
65165: LD_INT 0
65167: PPUSH
65168: PPUSH
65169: PPUSH
65170: PPUSH
65171: PPUSH
65172: PPUSH
// begin repeat wait ( 0 0$1 ) ;
65173: LD_INT 35
65175: PPUSH
65176: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] or IsDead ( Yakov ) then
65180: LD_EXP 83
65184: PUSH
65185: LD_INT 3
65187: PUSH
65188: LD_INT 4
65190: PUSH
65191: EMPTY
65192: LIST
65193: LIST
65194: IN
65195: PUSH
65196: LD_EXP 15
65200: PPUSH
65201: CALL_OW 301
65205: OR
65206: IFFALSE 65210
// exit ;
65208: GO 67191
// until Yakov_luring = 1 ;
65210: LD_EXP 113
65214: PUSH
65215: LD_INT 1
65217: EQUAL
65218: IFFALSE 65173
// for i in player_units_in_russian_buildings do
65220: LD_ADDR_VAR 0 1
65224: PUSH
65225: LD_EXP 88
65229: PUSH
65230: FOR_IN
65231: IFFALSE 65266
// if i [ 1 ] = Heike then
65233: LD_VAR 0 1
65237: PUSH
65238: LD_INT 1
65240: ARRAY
65241: PUSH
65242: LD_EXP 7
65246: EQUAL
65247: IFFALSE 65264
// begin GetPlayerUnitsOutOfBuilding ( i [ 2 ] ) ;
65249: LD_VAR 0 1
65253: PUSH
65254: LD_INT 2
65256: ARRAY
65257: PPUSH
65258: CALL 59233 0 1
// break ;
65262: GO 65266
// end ;
65264: GO 65230
65266: POP
65267: POP
// ComExitBuilding ( Yakov ) ;
65268: LD_EXP 15
65272: PPUSH
65273: CALL_OW 122
// except_Yakov = true ;
65277: LD_ADDR_EXP 111
65281: PUSH
65282: LD_INT 1
65284: ST_TO_ADDR
// SetAreaMapShow ( dark_corner_extended , 1 ) ;
65285: LD_INT 19
65287: PPUSH
65288: LD_INT 1
65290: PPUSH
65291: CALL_OW 424
// SetAreaMapShow ( dark_corner , 2 ) ;
65295: LD_INT 14
65297: PPUSH
65298: LD_INT 2
65300: PPUSH
65301: CALL_OW 424
// i = 0 ;
65305: LD_ADDR_VAR 0 1
65309: PUSH
65310: LD_INT 0
65312: ST_TO_ADDR
// k = false ;
65313: LD_ADDR_VAR 0 2
65317: PUSH
65318: LD_INT 0
65320: ST_TO_ADDR
// repeat if IsPlaced ( Heike ) then
65321: LD_EXP 7
65325: PPUSH
65326: CALL_OW 305
65330: IFFALSE 65407
// begin un = AI_InvertDirection ( GetDir ( Heike ) ) ;
65332: LD_ADDR_VAR 0 3
65336: PUSH
65337: LD_EXP 7
65341: PPUSH
65342: CALL_OW 254
65346: PPUSH
65347: CALL 34263 0 1
65351: ST_TO_ADDR
// ComMoveXY ( Yakov , ShiftX ( GetX ( Heike ) , un , 1 ) , ShiftY ( GetY ( Heike ) , un , 1 ) ) ;
65352: LD_EXP 15
65356: PPUSH
65357: LD_EXP 7
65361: PPUSH
65362: CALL_OW 250
65366: PPUSH
65367: LD_VAR 0 3
65371: PPUSH
65372: LD_INT 1
65374: PPUSH
65375: CALL_OW 272
65379: PPUSH
65380: LD_EXP 7
65384: PPUSH
65385: CALL_OW 251
65389: PPUSH
65390: LD_VAR 0 3
65394: PPUSH
65395: LD_INT 1
65397: PPUSH
65398: CALL_OW 273
65402: PPUSH
65403: CALL_OW 111
// end ; wait ( 0 0$1 ) ;
65407: LD_INT 35
65409: PPUSH
65410: CALL_OW 67
// if not code_black then
65414: LD_EXP 77
65418: NOT
65419: IFFALSE 65508
// if ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_dist , Yakov , 10 ] ] ) diff Heike ) > 0 then
65421: LD_INT 22
65423: PUSH
65424: LD_EXP 2
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: PUSH
65433: LD_INT 21
65435: PUSH
65436: LD_INT 1
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 91
65445: PUSH
65446: LD_EXP 15
65450: PUSH
65451: LD_INT 10
65453: PUSH
65454: EMPTY
65455: LIST
65456: LIST
65457: LIST
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: LIST
65463: PPUSH
65464: CALL_OW 69
65468: PUSH
65469: LD_EXP 7
65473: DIFF
65474: PUSH
65475: LD_INT 0
65477: GREATER
65478: IFFALSE 65508
// begin DialogueOn ;
65480: CALL_OW 6
// Say ( Yakov , D13-12c-boyfriend-1 ) ;
65484: LD_EXP 15
65488: PPUSH
65489: LD_STRING D13-12c-boyfriend-1
65491: PPUSH
65492: CALL_OW 88
// DialogueOff ;
65496: CALL_OW 7
// code_black = true ;
65500: LD_ADDR_EXP 77
65504: PUSH
65505: LD_INT 1
65507: ST_TO_ADDR
// end ; if code_black then
65508: LD_EXP 77
65512: IFFALSE 65552
// begin Yakov_luring = 4 ;
65514: LD_ADDR_EXP 113
65518: PUSH
65519: LD_INT 4
65521: ST_TO_ADDR
// except_Yakov = false ;
65522: LD_ADDR_EXP 111
65526: PUSH
65527: LD_INT 0
65529: ST_TO_ADDR
// SetAreaMapShow ( dark_corner , 0 ) ;
65530: LD_INT 14
65532: PPUSH
65533: LD_INT 0
65535: PPUSH
65536: CALL_OW 424
// SetAreaMapShow ( dark_corner_extended , 0 ) ;
65540: LD_INT 19
65542: PPUSH
65543: LD_INT 0
65545: PPUSH
65546: CALL_OW 424
// exit ;
65550: GO 67191
// end ; if IsInArea ( Yakov , just_outside_rus_base ) or IsInArea ( Yakov , just_outside_rus_base_yakov ) then
65552: LD_EXP 15
65556: PPUSH
65557: LD_INT 15
65559: PPUSH
65560: CALL_OW 308
65564: PUSH
65565: LD_EXP 15
65569: PPUSH
65570: LD_INT 16
65572: PPUSH
65573: CALL_OW 308
65577: OR
65578: IFFALSE 65582
// break ;
65580: GO 65650
// if IsInArea ( Heike , dark_corner ) and GetDistUnits ( Heike , Yakov ) <= 3 then
65582: LD_EXP 7
65586: PPUSH
65587: LD_INT 14
65589: PPUSH
65590: CALL_OW 308
65594: PUSH
65595: LD_EXP 7
65599: PPUSH
65600: LD_EXP 15
65604: PPUSH
65605: CALL_OW 296
65609: PUSH
65610: LD_INT 3
65612: LESSEQUAL
65613: AND
65614: IFFALSE 65626
// begin k = true ;
65616: LD_ADDR_VAR 0 2
65620: PUSH
65621: LD_INT 1
65623: ST_TO_ADDR
// break ;
65624: GO 65650
// end ; i = i + 1 ;
65626: LD_ADDR_VAR 0 1
65630: PUSH
65631: LD_VAR 0 1
65635: PUSH
65636: LD_INT 1
65638: PLUS
65639: ST_TO_ADDR
// until i = 60 ;
65640: LD_VAR 0 1
65644: PUSH
65645: LD_INT 60
65647: EQUAL
65648: IFFALSE 65321
// SetAreaMapShow ( dark_corner , 0 ) ;
65650: LD_INT 14
65652: PPUSH
65653: LD_INT 0
65655: PPUSH
65656: CALL_OW 424
// SetAreaMapShow ( dark_corner_extended , 0 ) ;
65660: LD_INT 19
65662: PPUSH
65663: LD_INT 0
65665: PPUSH
65666: CALL_OW 424
// if not k then
65670: LD_VAR 0 2
65674: NOT
65675: IFFALSE 65762
// begin if IsOk ( Yakov ) then
65677: LD_EXP 15
65681: PPUSH
65682: CALL_OW 302
65686: IFFALSE 65744
// begin DialogueOn ;
65688: CALL_OW 6
// Say ( Yakov , D13-12a-boyfriend-1 ) ;
65692: LD_EXP 15
65696: PPUSH
65697: LD_STRING D13-12a-boyfriend-1
65699: PPUSH
65700: CALL_OW 88
// Say ( Heike , D13-12a-H-1 ) ;
65704: LD_EXP 7
65708: PPUSH
65709: LD_STRING D13-12a-H-1
65711: PPUSH
65712: CALL_OW 88
// Say ( Yakov , D13-12a-boyfriend-2 ) ;
65716: LD_EXP 15
65720: PPUSH
65721: LD_STRING D13-12a-boyfriend-2
65723: PPUSH
65724: CALL_OW 88
// Say ( Yakov , D13-12a-boyfriend-3 ) ;
65728: LD_EXP 15
65732: PPUSH
65733: LD_STRING D13-12a-boyfriend-3
65735: PPUSH
65736: CALL_OW 88
// DialogueOff ;
65740: CALL_OW 7
// end ; except_Yakov = false ;
65744: LD_ADDR_EXP 111
65748: PUSH
65749: LD_INT 0
65751: ST_TO_ADDR
// Yakov_luring = 4 ;
65752: LD_ADDR_EXP 113
65756: PUSH
65757: LD_INT 4
65759: ST_TO_ADDR
// exit ;
65760: GO 67191
// end ; F_InGameOn ;
65762: CALL 68232 0 0
// CenterOnUnits ( [ Yakov , Heike ] ) ;
65766: LD_EXP 15
65770: PUSH
65771: LD_EXP 7
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PPUSH
65780: CALL_OW 85
// ComTurnUnit ( Heike , Yakov ) ;
65784: LD_EXP 7
65788: PPUSH
65789: LD_EXP 15
65793: PPUSH
65794: CALL_OW 119
// ComTurnUnit ( Yakov , Heike ) ;
65798: LD_EXP 15
65802: PPUSH
65803: LD_EXP 7
65807: PPUSH
65808: CALL_OW 119
// wait ( 0 0$0.5 ) ;
65812: LD_INT 18
65814: PPUSH
65815: CALL_OW 67
// DialogueOn ;
65819: CALL_OW 6
// Say ( Yakov , D13-12b-boyfriend-1 ) ;
65823: LD_EXP 15
65827: PPUSH
65828: LD_STRING D13-12b-boyfriend-1
65830: PPUSH
65831: CALL_OW 88
// Say ( Heike , D13-12b-H-1 ) ;
65835: LD_EXP 7
65839: PPUSH
65840: LD_STRING D13-12b-H-1
65842: PPUSH
65843: CALL_OW 88
// Say ( Yakov , D13-12b-boyfriend-2 ) ;
65847: LD_EXP 15
65851: PPUSH
65852: LD_STRING D13-12b-boyfriend-2
65854: PPUSH
65855: CALL_OW 88
// Say ( Heike , D13-12b-H-2 ) ;
65859: LD_EXP 7
65863: PPUSH
65864: LD_STRING D13-12b-H-2
65866: PPUSH
65867: CALL_OW 88
// Say ( Yakov , D13-12b-boyfriend-3 ) ;
65871: LD_EXP 15
65875: PPUSH
65876: LD_STRING D13-12b-boyfriend-3
65878: PPUSH
65879: CALL_OW 88
// Say ( Heike , D13-12b-H-3 ) ;
65883: LD_EXP 7
65887: PPUSH
65888: LD_STRING D13-12b-H-3
65890: PPUSH
65891: CALL_OW 88
// Say ( Yakov , D13-12b-boyfriend-4 ) ;
65895: LD_EXP 15
65899: PPUSH
65900: LD_STRING D13-12b-boyfriend-4
65902: PPUSH
65903: CALL_OW 88
// temp_list = [ ] ;
65907: LD_ADDR_VAR 0 4
65911: PUSH
65912: EMPTY
65913: ST_TO_ADDR
// temp_list_2 = [ ] ;
65914: LD_ADDR_VAR 0 5
65918: PUSH
65919: EMPTY
65920: ST_TO_ADDR
// for i in ai_buildings_locations [ 1 ] do
65921: LD_ADDR_VAR 0 1
65925: PUSH
65926: LD_EXP 36
65930: PUSH
65931: LD_INT 1
65933: ARRAY
65934: PUSH
65935: FOR_IN
65936: IFFALSE 66004
// if i [ 4 ] in [ b_lab , b_lab_half , b_lab_full ] then
65938: LD_VAR 0 1
65942: PUSH
65943: LD_INT 4
65945: ARRAY
65946: PUSH
65947: LD_INT 6
65949: PUSH
65950: LD_INT 7
65952: PUSH
65953: LD_INT 8
65955: PUSH
65956: EMPTY
65957: LIST
65958: LIST
65959: LIST
65960: IN
65961: IFFALSE 66002
// begin temp_list = temp_list ^ [ i ] ;
65963: LD_ADDR_VAR 0 4
65967: PUSH
65968: LD_VAR 0 4
65972: PUSH
65973: LD_VAR 0 1
65977: PUSH
65978: EMPTY
65979: LIST
65980: ADD
65981: ST_TO_ADDR
// temp_list_2 = temp_list_2 ^ i [ 2 ] ;
65982: LD_ADDR_VAR 0 5
65986: PUSH
65987: LD_VAR 0 5
65991: PUSH
65992: LD_VAR 0 1
65996: PUSH
65997: LD_INT 2
65999: ARRAY
66000: ADD
66001: ST_TO_ADDR
// end ;
66002: GO 65935
66004: POP
66005: POP
// temp_list = SortListByListAsc ( temp_list , temp_list_2 ) ;
66006: LD_ADDR_VAR 0 4
66010: PUSH
66011: LD_VAR 0 4
66015: PPUSH
66016: LD_VAR 0 5
66020: PPUSH
66021: CALL_OW 76
66025: ST_TO_ADDR
// k = 0 ;
66026: LD_ADDR_VAR 0 2
66030: PUSH
66031: LD_INT 0
66033: ST_TO_ADDR
// temp_list_2 = [ GetX ( the_archive ) , GetY ( the_archive ) ] ;
66034: LD_ADDR_VAR 0 5
66038: PUSH
66039: LD_EXP 75
66043: PPUSH
66044: CALL_OW 250
66048: PUSH
66049: LD_EXP 75
66053: PPUSH
66054: CALL_OW 251
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: ST_TO_ADDR
// for i in temp_list do
66063: LD_ADDR_VAR 0 1
66067: PUSH
66068: LD_VAR 0 4
66072: PUSH
66073: FOR_IN
66074: IFFALSE 66134
// begin k = k + 1 ;
66076: LD_ADDR_VAR 0 2
66080: PUSH
66081: LD_VAR 0 2
66085: PUSH
66086: LD_INT 1
66088: PLUS
66089: ST_TO_ADDR
// if i [ 1 ] = temp_list_2 [ 1 ] and i [ 2 ] = temp_list_2 [ 2 ] then
66090: LD_VAR 0 1
66094: PUSH
66095: LD_INT 1
66097: ARRAY
66098: PUSH
66099: LD_VAR 0 5
66103: PUSH
66104: LD_INT 1
66106: ARRAY
66107: EQUAL
66108: PUSH
66109: LD_VAR 0 1
66113: PUSH
66114: LD_INT 2
66116: ARRAY
66117: PUSH
66118: LD_VAR 0 5
66122: PUSH
66123: LD_INT 2
66125: ARRAY
66126: EQUAL
66127: AND
66128: IFFALSE 66132
// break ;
66130: GO 66134
// end ;
66132: GO 66073
66134: POP
66135: POP
// case k of 1 :
66136: LD_VAR 0 2
66140: PUSH
66141: LD_INT 1
66143: DOUBLE
66144: EQUAL
66145: IFTRUE 66149
66147: GO 66164
66149: POP
// Say ( Yakov , D13-12ba-boyfriend-1 ) ; 2 :
66150: LD_EXP 15
66154: PPUSH
66155: LD_STRING D13-12ba-boyfriend-1
66157: PPUSH
66158: CALL_OW 88
66162: GO 66234
66164: LD_INT 2
66166: DOUBLE
66167: EQUAL
66168: IFTRUE 66172
66170: GO 66187
66172: POP
// Say ( Yakov , D13-12bb-boyfriend-1 ) ; 3 :
66173: LD_EXP 15
66177: PPUSH
66178: LD_STRING D13-12bb-boyfriend-1
66180: PPUSH
66181: CALL_OW 88
66185: GO 66234
66187: LD_INT 3
66189: DOUBLE
66190: EQUAL
66191: IFTRUE 66195
66193: GO 66210
66195: POP
// Say ( Yakov , D13-12bc-boyfriend-1 ) ; 4 :
66196: LD_EXP 15
66200: PPUSH
66201: LD_STRING D13-12bc-boyfriend-1
66203: PPUSH
66204: CALL_OW 88
66208: GO 66234
66210: LD_INT 4
66212: DOUBLE
66213: EQUAL
66214: IFTRUE 66218
66216: GO 66233
66218: POP
// Say ( Yakov , D13-12bd-boyfriend-1 ) ; end ;
66219: LD_EXP 15
66223: PPUSH
66224: LD_STRING D13-12bd-boyfriend-1
66226: PPUSH
66227: CALL_OW 88
66231: GO 66234
66233: POP
// dwait ( 0 0$0.3 ) ;
66234: LD_INT 10
66236: PPUSH
66237: CALL_OW 68
// case Query ( QBoyfriendShoot ) of 1 :
66241: LD_STRING QBoyfriendShoot
66243: PPUSH
66244: CALL_OW 97
66248: PUSH
66249: LD_INT 1
66251: DOUBLE
66252: EQUAL
66253: IFTRUE 66257
66255: GO 66319
66257: POP
// begin DialogueOff ;
66258: CALL_OW 7
// ExclusiveOn ;
66262: CALL_OW 4
// ComAttackUnit ( Heike , Yakov ) ;
66266: LD_EXP 7
66270: PPUSH
66271: LD_EXP 15
66275: PPUSH
66276: CALL_OW 115
// wait ( 40 ) ;
66280: LD_INT 40
66282: PPUSH
66283: CALL_OW 67
// KillUnit ( Yakov ) ;
66287: LD_EXP 15
66291: PPUSH
66292: CALL_OW 66
// wait ( 0 0$2 ) ;
66296: LD_INT 70
66298: PPUSH
66299: CALL_OW 67
// F_InGameOff ;
66303: CALL 68468 0 0
// Yakov_luring = 4 ;
66307: LD_ADDR_EXP 113
66311: PUSH
66312: LD_INT 4
66314: ST_TO_ADDR
// exit ;
66315: GO 67191
// end ; 2 :
66317: GO 67191
66319: LD_INT 2
66321: DOUBLE
66322: EQUAL
66323: IFTRUE 66327
66325: GO 66803
66327: POP
// begin Say ( Heike , D13-12b2-H-1 ) ;
66328: LD_EXP 7
66332: PPUSH
66333: LD_STRING D13-12b2-H-1
66335: PPUSH
66336: CALL_OW 88
// DialogueOff ;
66340: CALL_OW 7
// F_InGameOff ;
66344: CALL 68468 0 0
// Yakov_luring = 2 ;
66348: LD_ADDR_EXP 113
66352: PUSH
66353: LD_INT 2
66355: ST_TO_ADDR
// time = [ 1 1$30 , 0 0$20 , 0 0$10 ] [ difficulty ] + Rand ( 0 0$0 , 0 0$10 ) ;
66356: LD_ADDR_VAR 0 6
66360: PUSH
66361: LD_INT 3150
66363: PUSH
66364: LD_INT 700
66366: PUSH
66367: LD_INT 350
66369: PUSH
66370: EMPTY
66371: LIST
66372: LIST
66373: LIST
66374: PUSH
66375: LD_OWVAR 67
66379: ARRAY
66380: PUSH
66381: LD_INT 0
66383: PPUSH
66384: LD_INT 350
66386: PPUSH
66387: CALL_OW 12
66391: PLUS
66392: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
66393: LD_INT 35
66395: PPUSH
66396: CALL_OW 67
// if IsPlaced ( Heike ) then
66400: LD_EXP 7
66404: PPUSH
66405: CALL_OW 305
66409: IFFALSE 66488
// begin un = AI_InvertDirection ( GetDir ( Heike ) ) ;
66411: LD_ADDR_VAR 0 3
66415: PUSH
66416: LD_EXP 7
66420: PPUSH
66421: CALL_OW 254
66425: PPUSH
66426: CALL 34263 0 1
66430: ST_TO_ADDR
// ComMoveXY ( Yakov , ShiftX ( GetX ( Heike ) , un , 1 ) , ShiftY ( GetY ( Heike ) , un , 1 ) ) ;
66431: LD_EXP 15
66435: PPUSH
66436: LD_EXP 7
66440: PPUSH
66441: CALL_OW 250
66445: PPUSH
66446: LD_VAR 0 3
66450: PPUSH
66451: LD_INT 1
66453: PPUSH
66454: CALL_OW 272
66458: PPUSH
66459: LD_EXP 7
66463: PPUSH
66464: CALL_OW 251
66468: PPUSH
66469: LD_VAR 0 3
66473: PPUSH
66474: LD_INT 1
66476: PPUSH
66477: CALL_OW 273
66481: PPUSH
66482: CALL_OW 111
// end else
66486: GO 66665
// begin un = false ;
66488: LD_ADDR_VAR 0 3
66492: PUSH
66493: LD_INT 0
66495: ST_TO_ADDR
// for i in player_units_in_russian_buildings do
66496: LD_ADDR_VAR 0 1
66500: PUSH
66501: LD_EXP 88
66505: PUSH
66506: FOR_IN
66507: IFFALSE 66553
// if i [ 1 ] = Heike then
66509: LD_VAR 0 1
66513: PUSH
66514: LD_INT 1
66516: ARRAY
66517: PUSH
66518: LD_EXP 7
66522: EQUAL
66523: IFFALSE 66551
// begin if i [ 2 ] = the_archive then
66525: LD_VAR 0 1
66529: PUSH
66530: LD_INT 2
66532: ARRAY
66533: PUSH
66534: LD_EXP 75
66538: EQUAL
66539: IFFALSE 66549
// un = true ;
66541: LD_ADDR_VAR 0 3
66545: PUSH
66546: LD_INT 1
66548: ST_TO_ADDR
// break ;
66549: GO 66553
// end ;
66551: GO 66506
66553: POP
66554: POP
// if un then
66555: LD_VAR 0 3
66559: IFFALSE 66665
// begin temp_list = UnitsInside ( the_archive ) ;
66561: LD_ADDR_VAR 0 4
66565: PUSH
66566: LD_EXP 75
66570: PPUSH
66571: CALL_OW 313
66575: ST_TO_ADDR
// if temp_list = 6 then
66576: LD_VAR 0 4
66580: PUSH
66581: LD_INT 6
66583: EQUAL
66584: IFFALSE 66651
// begin un = 0 ;
66586: LD_ADDR_VAR 0 3
66590: PUSH
66591: LD_INT 0
66593: ST_TO_ADDR
// for i in temp_list do
66594: LD_ADDR_VAR 0 1
66598: PUSH
66599: LD_VAR 0 4
66603: PUSH
66604: FOR_IN
66605: IFFALSE 66633
// if i <> Barovnin then
66607: LD_VAR 0 1
66611: PUSH
66612: LD_EXP 13
66616: NONEQUAL
66617: IFFALSE 66631
// begin un = i ;
66619: LD_ADDR_VAR 0 3
66623: PUSH
66624: LD_VAR 0 1
66628: ST_TO_ADDR
// break ;
66629: GO 66633
// end ;
66631: GO 66604
66633: POP
66634: POP
// ComExitBuilding ( un ) ;
66635: LD_VAR 0 3
66639: PPUSH
66640: CALL_OW 122
// wait ( 3 ) ;
66644: LD_INT 3
66646: PPUSH
66647: CALL_OW 67
// end ; ComEnterUnit ( Yakov , the_archive ) ;
66651: LD_EXP 15
66655: PPUSH
66656: LD_EXP 75
66660: PPUSH
66661: CALL_OW 120
// end ; end ; if IsInUnit ( Yakov ) = the_archive and time > 0 0$0 and not code_black then
66665: LD_EXP 15
66669: PPUSH
66670: CALL_OW 310
66674: PUSH
66675: LD_EXP 75
66679: EQUAL
66680: PUSH
66681: LD_VAR 0 6
66685: PUSH
66686: LD_INT 0
66688: GREATER
66689: AND
66690: PUSH
66691: LD_EXP 77
66695: NOT
66696: AND
66697: IFFALSE 66713
// time = time - 0 0$1 ;
66699: LD_ADDR_VAR 0 6
66703: PUSH
66704: LD_VAR 0 6
66708: PUSH
66709: LD_INT 35
66711: MINUS
66712: ST_TO_ADDR
// if time <= 0 0$0 then
66713: LD_VAR 0 6
66717: PUSH
66718: LD_INT 0
66720: LESSEQUAL
66721: IFFALSE 66776
// begin DialogueOn ;
66723: CALL_OW 6
// Say ( Yakov , D13-12b2-boyfriend-1 ) ;
66727: LD_EXP 15
66731: PPUSH
66732: LD_STRING D13-12b2-boyfriend-1
66734: PPUSH
66735: CALL_OW 88
// DialogueOff ;
66739: CALL_OW 7
// except_Yakov = false ;
66743: LD_ADDR_EXP 111
66747: PUSH
66748: LD_INT 0
66750: ST_TO_ADDR
// ChangeHeikeUndercoverStatus ( 4 ) ;
66751: LD_INT 4
66753: PPUSH
66754: CALL 42004 0 1
// Yakov_luring = 4 ;
66758: LD_ADDR_EXP 113
66762: PUSH
66763: LD_INT 4
66765: ST_TO_ADDR
// code_black = true ;
66766: LD_ADDR_EXP 77
66770: PUSH
66771: LD_INT 1
66773: ST_TO_ADDR
// exit ;
66774: GO 67191
// end ; if IsDead ( Yakov ) then
66776: LD_EXP 15
66780: PPUSH
66781: CALL_OW 301
66785: IFFALSE 66797
// begin Yakov_luring = 4 ;
66787: LD_ADDR_EXP 113
66791: PUSH
66792: LD_INT 4
66794: ST_TO_ADDR
// exit ;
66795: GO 67191
// end ; until false ;
66797: LD_INT 0
66799: IFFALSE 66393
// end ; 3 :
66801: GO 67191
66803: LD_INT 3
66805: DOUBLE
66806: EQUAL
66807: IFTRUE 66811
66809: GO 67190
66811: POP
// begin Say ( Heike , D13-12b3-H-1 ) ;
66812: LD_EXP 7
66816: PPUSH
66817: LD_STRING D13-12b3-H-1
66819: PPUSH
66820: CALL_OW 88
// DialogueOff ;
66824: CALL_OW 7
// F_InGameOff ;
66828: CALL 68468 0 0
// repeat if IsDead ( Yakov ) then
66832: LD_EXP 15
66836: PPUSH
66837: CALL_OW 301
66841: IFFALSE 66853
// begin Yakov_luring = 4 ;
66843: LD_ADDR_EXP 113
66847: PUSH
66848: LD_INT 4
66850: ST_TO_ADDR
// exit ;
66851: GO 67191
// end ; if IsOk ( leader_office ) then
66853: LD_EXP 93
66857: PPUSH
66858: CALL_OW 302
66862: IFFALSE 66899
// begin if IsInUnit ( Yakov ) = leader_office then
66864: LD_EXP 15
66868: PPUSH
66869: CALL_OW 310
66873: PUSH
66874: LD_EXP 93
66878: EQUAL
66879: IFFALSE 66883
// break ;
66881: GO 67098
// ComEnterUnit ( Yakov , leader_office ) end else
66883: LD_EXP 15
66887: PPUSH
66888: LD_EXP 93
66892: PPUSH
66893: CALL_OW 120
66897: GO 66977
// begin if GetDistUnitXY ( Yakov , ai_human_pullback_hex [ 1 ] [ 1 ] , ai_human_pullback_hex [ 1 ] [ 2 ] ) <= 3 then
66899: LD_EXP 15
66903: PPUSH
66904: LD_EXP 40
66908: PUSH
66909: LD_INT 1
66911: ARRAY
66912: PUSH
66913: LD_INT 1
66915: ARRAY
66916: PPUSH
66917: LD_EXP 40
66921: PUSH
66922: LD_INT 1
66924: ARRAY
66925: PUSH
66926: LD_INT 2
66928: ARRAY
66929: PPUSH
66930: CALL_OW 297
66934: PUSH
66935: LD_INT 3
66937: LESSEQUAL
66938: IFFALSE 66942
// break ;
66940: GO 67098
// ComMoveXY ( Yakov , ai_human_pullback_hex [ 1 ] [ 1 ] , ai_human_pullback_hex [ 1 ] [ 2 ] ) ;
66942: LD_EXP 15
66946: PPUSH
66947: LD_EXP 40
66951: PUSH
66952: LD_INT 1
66954: ARRAY
66955: PUSH
66956: LD_INT 1
66958: ARRAY
66959: PPUSH
66960: LD_EXP 40
66964: PUSH
66965: LD_INT 1
66967: ARRAY
66968: PUSH
66969: LD_INT 2
66971: ARRAY
66972: PPUSH
66973: CALL_OW 111
// end ; wait ( 0 0$1 ) ;
66977: LD_INT 35
66979: PPUSH
66980: CALL_OW 67
// if GetDistUnits ( Yakov , leader_office ) <= 4 then
66984: LD_EXP 15
66988: PPUSH
66989: LD_EXP 93
66993: PPUSH
66994: CALL_OW 296
66998: PUSH
66999: LD_INT 4
67001: LESSEQUAL
67002: IFFALSE 67094
// begin temp_list = UnitsInside ( leader_office ) ;
67004: LD_ADDR_VAR 0 4
67008: PUSH
67009: LD_EXP 93
67013: PPUSH
67014: CALL_OW 313
67018: ST_TO_ADDR
// if temp_list = 6 then
67019: LD_VAR 0 4
67023: PUSH
67024: LD_INT 6
67026: EQUAL
67027: IFFALSE 67094
// begin un = 0 ;
67029: LD_ADDR_VAR 0 3
67033: PUSH
67034: LD_INT 0
67036: ST_TO_ADDR
// for i in temp_list do
67037: LD_ADDR_VAR 0 1
67041: PUSH
67042: LD_VAR 0 4
67046: PUSH
67047: FOR_IN
67048: IFFALSE 67076
// if i <> Yefibachev then
67050: LD_VAR 0 1
67054: PUSH
67055: LD_EXP 14
67059: NONEQUAL
67060: IFFALSE 67074
// begin un = i ;
67062: LD_ADDR_VAR 0 3
67066: PUSH
67067: LD_VAR 0 1
67071: ST_TO_ADDR
// break ;
67072: GO 67076
// end ;
67074: GO 67047
67076: POP
67077: POP
// ComExitBuilding ( un ) ;
67078: LD_VAR 0 3
67082: PPUSH
67083: CALL_OW 122
// wait ( 3 ) ;
67087: LD_INT 3
67089: PPUSH
67090: CALL_OW 67
// end ; end ; until false ;
67094: LD_INT 0
67096: IFFALSE 66832
// repeat wait ( 0 0$2 ) ;
67098: LD_INT 70
67100: PPUSH
67101: CALL_OW 67
// until not code_black ;
67105: LD_EXP 77
67109: NOT
67110: IFFALSE 67098
// if IsDead ( Yakov ) then
67112: LD_EXP 15
67116: PPUSH
67117: CALL_OW 301
67121: IFFALSE 67125
// exit ;
67123: GO 67191
// if heike_undercover <> 4 then
67125: LD_EXP 83
67129: PUSH
67130: LD_INT 4
67132: NONEQUAL
67133: IFFALSE 67162
// begin DialogueOn ;
67135: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-2b ) ;
67139: LD_EXP 14
67143: PPUSH
67144: LD_STRING D7-Leader-2b
67146: PPUSH
67147: CALL_OW 94
// DialogueOff ;
67151: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
67155: LD_INT 4
67157: PPUSH
67158: CALL 42004 0 1
// end ; code_black = true ;
67162: LD_ADDR_EXP 77
67166: PUSH
67167: LD_INT 1
67169: ST_TO_ADDR
// except_Yakov = false ;
67170: LD_ADDR_EXP 111
67174: PUSH
67175: LD_INT 0
67177: ST_TO_ADDR
// Yakov_luring = 4 ;
67178: LD_ADDR_EXP 113
67182: PUSH
67183: LD_INT 4
67185: ST_TO_ADDR
// exit ;
67186: GO 67191
// end ; end ;
67188: GO 67191
67190: POP
// end ;
67191: PPOPN 6
67193: END
// every 0 0$1 + 0 0$0.1 do var temp_list ;
67194: GO 67196
67196: DISABLE
67197: LD_INT 0
67199: PPUSH
// begin repeat wait ( 0 0$0.5 ) ;
67200: LD_INT 18
67202: PPUSH
67203: CALL_OW 67
// if heike_undercover in [ 3 , 4 ] or IsDead ( Yakov ) or Yakov_luring = 4 then
67207: LD_EXP 83
67211: PUSH
67212: LD_INT 3
67214: PUSH
67215: LD_INT 4
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: IN
67222: PUSH
67223: LD_EXP 15
67227: PPUSH
67228: CALL_OW 301
67232: OR
67233: PUSH
67234: LD_EXP 113
67238: PUSH
67239: LD_INT 4
67241: EQUAL
67242: OR
67243: IFFALSE 67247
// exit ;
67245: GO 67755
// until Yakov_luring = 3 ;
67247: LD_EXP 113
67251: PUSH
67252: LD_INT 3
67254: EQUAL
67255: IFFALSE 67200
// Yakov_luring = 4 ;
67257: LD_ADDR_EXP 113
67261: PUSH
67262: LD_INT 4
67264: ST_TO_ADDR
// DialogueOn ;
67265: CALL_OW 6
// if Query ( QBoyfriendArchive ) = 1 then
67269: LD_STRING QBoyfriendArchive
67271: PPUSH
67272: CALL_OW 97
67276: PUSH
67277: LD_INT 1
67279: EQUAL
67280: IFFALSE 67642
// begin RemoveHumanFromVariables ( 1 , Yakov , true ) ;
67282: LD_INT 1
67284: PPUSH
67285: LD_EXP 15
67289: PPUSH
67290: LD_INT 1
67292: PPUSH
67293: CALL 10822 0 3
// DestroyUnit ( Yakov ) ;
67297: LD_EXP 15
67301: PPUSH
67302: CALL_OW 65
// SayEffect ( D13-12b21-Effect-1 ) ;
67306: LD_STRING D13-12b21-Effect-1
67308: PPUSH
67309: CALL_OW 96
// dwait ( 0 0$1 ) ;
67313: LD_INT 35
67315: PPUSH
67316: CALL_OW 68
// temp_list = UnitsInside ( the_archive ) ;
67320: LD_ADDR_VAR 0 1
67324: PUSH
67325: LD_EXP 75
67329: PPUSH
67330: CALL_OW 313
67334: ST_TO_ADDR
// if Barovnin in temp_list then
67335: LD_EXP 13
67339: PUSH
67340: LD_VAR 0 1
67344: IN
67345: IFFALSE 67361
// Say ( Barovnin , D11-211-Doc-1 ) else
67347: LD_EXP 13
67351: PPUSH
67352: LD_STRING D11-211-Doc-1
67354: PPUSH
67355: CALL_OW 88
67359: GO 67424
// if temp_list > 0 then
67361: LD_VAR 0 1
67365: PUSH
67366: LD_INT 0
67368: GREATER
67369: IFFALSE 67424
// if GetSex ( temp_list [ 1 ] ) = sex_male then
67371: LD_VAR 0 1
67375: PUSH
67376: LD_INT 1
67378: ARRAY
67379: PPUSH
67380: CALL_OW 258
67384: PUSH
67385: LD_INT 1
67387: EQUAL
67388: IFFALSE 67408
// Say ( temp_list [ 1 ] , D11-211-SciM-1 ) else
67390: LD_VAR 0 1
67394: PUSH
67395: LD_INT 1
67397: ARRAY
67398: PPUSH
67399: LD_STRING D11-211-SciM-1
67401: PPUSH
67402: CALL_OW 88
67406: GO 67424
// Say ( temp_list [ 1 ] , D11-211-SciF-1 ) ;
67408: LD_VAR 0 1
67412: PUSH
67413: LD_INT 1
67415: ARRAY
67416: PPUSH
67417: LD_STRING D11-211-SciF-1
67419: PPUSH
67420: CALL_OW 88
// DialogueOff ;
67424: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( the_archive ) ;
67428: LD_EXP 75
67432: PPUSH
67433: CALL 59233 0 1
// if temp_list > 0 then
67437: LD_VAR 0 1
67441: PUSH
67442: LD_INT 0
67444: GREATER
67445: IFFALSE 67640
// begin wait ( 0 0$5 ) ;
67447: LD_INT 175
67449: PPUSH
67450: CALL_OW 67
// DialogueOn ;
67454: CALL_OW 6
// if Barovnin in temp_list then
67458: LD_EXP 13
67462: PUSH
67463: LD_VAR 0 1
67467: IN
67468: IFFALSE 67507
// begin Say ( Barovnin , D11-211-Doc-2 ) ;
67470: LD_EXP 13
67474: PPUSH
67475: LD_STRING D11-211-Doc-2
67477: PPUSH
67478: CALL_OW 88
// temp_list = Replace ( temp_list , 1 , Barovnin ) ;
67482: LD_ADDR_VAR 0 1
67486: PUSH
67487: LD_VAR 0 1
67491: PPUSH
67492: LD_INT 1
67494: PPUSH
67495: LD_EXP 13
67499: PPUSH
67500: CALL_OW 1
67504: ST_TO_ADDR
// end else
67505: GO 67560
// if GetSex ( temp_list [ 1 ] ) = sex_male then
67507: LD_VAR 0 1
67511: PUSH
67512: LD_INT 1
67514: ARRAY
67515: PPUSH
67516: CALL_OW 258
67520: PUSH
67521: LD_INT 1
67523: EQUAL
67524: IFFALSE 67544
// Say ( temp_list [ 1 ] , D11-211-SciM-2 ) else
67526: LD_VAR 0 1
67530: PUSH
67531: LD_INT 1
67533: ARRAY
67534: PPUSH
67535: LD_STRING D11-211-SciM-2
67537: PPUSH
67538: CALL_OW 88
67542: GO 67560
// Say ( temp_list [ 1 ] , D11-211-SciF-2 ) ;
67544: LD_VAR 0 1
67548: PUSH
67549: LD_INT 1
67551: ARRAY
67552: PPUSH
67553: LD_STRING D11-211-SciF-2
67555: PPUSH
67556: CALL_OW 88
// DialogueOff ;
67560: CALL_OW 7
// repeat wait ( 0 0$2 ) ;
67564: LD_INT 70
67566: PPUSH
67567: CALL_OW 67
// until not code_black ;
67571: LD_EXP 77
67575: NOT
67576: IFFALSE 67564
// if IsDead ( temp_list [ 1 ] ) then
67578: LD_VAR 0 1
67582: PUSH
67583: LD_INT 1
67585: ARRAY
67586: PPUSH
67587: CALL_OW 301
67591: IFFALSE 67595
// exit ;
67593: GO 67755
// if heike_undercover <> 4 then
67595: LD_EXP 83
67599: PUSH
67600: LD_INT 4
67602: NONEQUAL
67603: IFFALSE 67632
// begin DialogueOn ;
67605: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-2b ) ;
67609: LD_EXP 14
67613: PPUSH
67614: LD_STRING D7-Leader-2b
67616: PPUSH
67617: CALL_OW 94
// DialogueOff ;
67621: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
67625: LD_INT 4
67627: PPUSH
67628: CALL 42004 0 1
// end ; code_black = true ;
67632: LD_ADDR_EXP 77
67636: PUSH
67637: LD_INT 1
67639: ST_TO_ADDR
// end ; exit ;
67640: GO 67755
// end ; Say ( Heike , D13-12b22-H-1 ) ;
67642: LD_EXP 7
67646: PPUSH
67647: LD_STRING D13-12b22-H-1
67649: PPUSH
67650: CALL_OW 88
// DialogueOff ;
67654: CALL_OW 7
// GetPlayerUnitsOutOfBuilding ( the_archive ) ;
67658: LD_EXP 75
67662: PPUSH
67663: CALL 59233 0 1
// wait ( 0 0$20 ) ;
67667: LD_INT 700
67669: PPUSH
67670: CALL_OW 67
// while code_black do
67674: LD_EXP 77
67678: IFFALSE 67689
// wait ( 0 0$2 ) ;
67680: LD_INT 70
67682: PPUSH
67683: CALL_OW 67
67687: GO 67674
// if IsLive ( Yakov ) then
67689: LD_EXP 15
67693: PPUSH
67694: CALL_OW 300
67698: IFFALSE 67753
// begin if heike_undercover <> 4 then
67700: LD_EXP 83
67704: PUSH
67705: LD_INT 4
67707: NONEQUAL
67708: IFFALSE 67737
// begin DialogueOn ;
67710: CALL_OW 6
// SayRadio ( Yefibachev , D7-Leader-2b ) ;
67714: LD_EXP 14
67718: PPUSH
67719: LD_STRING D7-Leader-2b
67721: PPUSH
67722: CALL_OW 94
// DialogueOff ;
67726: CALL_OW 7
// ChangeHeikeUndercoverStatus ( 4 ) ;
67730: LD_INT 4
67732: PPUSH
67733: CALL 42004 0 1
// end ; code_black = true ;
67737: LD_ADDR_EXP 77
67741: PUSH
67742: LD_INT 1
67744: ST_TO_ADDR
// except_Yakov = false ;
67745: LD_ADDR_EXP 111
67749: PUSH
67750: LD_INT 0
67752: ST_TO_ADDR
// end ; exit ;
67753: GO 67755
// end ;
67755: PPOPN 1
67757: END
// every 0 0$1 + 0 0$0.8 do var i , val ;
67758: GO 67760
67760: DISABLE
67761: LD_INT 0
67763: PPUSH
67764: PPUSH
// begin repeat wait ( 0 0$0.8 ) ;
67765: LD_INT 28
67767: PPUSH
67768: CALL_OW 67
// if not archive_found then
67772: LD_EXP 100
67776: NOT
67777: IFFALSE 67781
// continue ;
67779: GO 67765
// val = false ;
67781: LD_ADDR_VAR 0 2
67785: PUSH
67786: LD_INT 0
67788: ST_TO_ADDR
// for i in player_units_in_russian_buildings do
67789: LD_ADDR_VAR 0 1
67793: PUSH
67794: LD_EXP 88
67798: PUSH
67799: FOR_IN
67800: IFFALSE 67830
// if i [ 2 ] = the_archive then
67802: LD_VAR 0 1
67806: PUSH
67807: LD_INT 2
67809: ARRAY
67810: PUSH
67811: LD_EXP 75
67815: EQUAL
67816: IFFALSE 67828
// begin val = true ;
67818: LD_ADDR_VAR 0 2
67822: PUSH
67823: LD_INT 1
67825: ST_TO_ADDR
// break ;
67826: GO 67830
// end ;
67828: GO 67799
67830: POP
67831: POP
// if not val then
67832: LD_VAR 0 2
67836: NOT
67837: IFFALSE 67841
// continue ;
67839: GO 67765
// num_documents_stolen = num_documents_stolen + 1 ;
67841: LD_ADDR_EXP 99
67845: PUSH
67846: LD_EXP 99
67850: PUSH
67851: LD_INT 1
67853: PLUS
67854: ST_TO_ADDR
// AddOrUpdateDisplayStrings ( #Ar09-DocumentsStolen , [ num_documents_stolen ] ) ;
67855: LD_STRING #Ar09-DocumentsStolen
67857: PPUSH
67858: LD_EXP 99
67862: PUSH
67863: EMPTY
67864: LIST
67865: PPUSH
67866: CALL 34320 0 2
// if num_documents_stolen = 20 then
67870: LD_EXP 99
67874: PUSH
67875: LD_INT 20
67877: EQUAL
67878: IFFALSE 67902
// begin wait ( 0 0$0.2 ) ;
67880: LD_INT 7
67882: PPUSH
67883: CALL_OW 67
// ChangeMissionObjectives ( M2 ) ;
67887: LD_STRING M2
67889: PPUSH
67890: CALL_OW 337
// mission_can_end = true ;
67894: LD_ADDR_EXP 101
67898: PUSH
67899: LD_INT 1
67901: ST_TO_ADDR
// end ; if num_documents_stolen = 35 then
67902: LD_EXP 99
67906: PUSH
67907: LD_INT 35
67909: EQUAL
67910: IFFALSE 67919
// begin ChangeMissionObjectives ( MOutStealSurplus ) ;
67912: LD_STRING MOutStealSurplus
67914: PPUSH
67915: CALL_OW 337
// end ; until num_documents_stolen = max_num_documents_stealable ;
67919: LD_EXP 99
67923: PUSH
67924: LD_EXP 126
67928: EQUAL
67929: IFFALSE 67765
// end ;
67931: PPOPN 2
67933: END
// every 0 0$1 + 0 0$0.9 do var i , temp_unit , temp_list ;
67934: GO 67936
67936: DISABLE
67937: LD_INT 0
67939: PPUSH
67940: PPUSH
67941: PPUSH
// begin repeat wait ( 0 0$1 ) ;
67942: LD_INT 35
67944: PPUSH
67945: CALL_OW 67
// temp_list = FilterAllUnits ( [ f_side , you ] ) ;
67949: LD_ADDR_VAR 0 3
67953: PUSH
67954: LD_INT 22
67956: PUSH
67957: LD_EXP 2
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PPUSH
67966: CALL_OW 69
67970: ST_TO_ADDR
// if heike_undercover in [ 2 , 3 ] then
67971: LD_EXP 83
67975: PUSH
67976: LD_INT 2
67978: PUSH
67979: LD_INT 3
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: IN
67986: IFFALSE 68004
// temp_list = temp_list diff Heike ;
67988: LD_ADDR_VAR 0 3
67992: PUSH
67993: LD_VAR 0 3
67997: PUSH
67998: LD_EXP 7
68002: DIFF
68003: ST_TO_ADDR
// for i in temp_list do
68004: LD_ADDR_VAR 0 1
68008: PUSH
68009: LD_VAR 0 3
68013: PUSH
68014: FOR_IN
68015: IFFALSE 68087
// begin temp_unit = IsInUnit ( i ) ;
68017: LD_ADDR_VAR 0 2
68021: PUSH
68022: LD_VAR 0 1
68026: PPUSH
68027: CALL_OW 310
68031: ST_TO_ADDR
// if temp_unit > 0 then
68032: LD_VAR 0 2
68036: PUSH
68037: LD_INT 0
68039: GREATER
68040: IFFALSE 68085
// if GetType ( temp_unit ) = unit_vehicle then
68042: LD_VAR 0 2
68046: PPUSH
68047: CALL_OW 247
68051: PUSH
68052: LD_INT 2
68054: EQUAL
68055: IFFALSE 68085
// begin NormalAttack ( russians , temp_unit ) ;
68057: LD_EXP 3
68061: PPUSH
68062: LD_VAR 0 2
68066: PPUSH
68067: CALL_OW 472
// NormalAttack ( russians_alt , temp_unit ) ;
68071: LD_EXP 6
68075: PPUSH
68076: LD_VAR 0 2
68080: PPUSH
68081: CALL_OW 472
// end ; end ;
68085: GO 68014
68087: POP
68088: POP
// until false ;
68089: LD_INT 0
68091: IFFALSE 67942
// end ;
68093: PPOPN 3
68095: END
// every 0 0$1 + 0 0$0.2 do var temp_unit ;
68096: GO 68098
68098: DISABLE
68099: LD_INT 0
68101: PPUSH
// begin repeat wait ( 0 0$1 ) ;
68102: LD_INT 35
68104: PPUSH
68105: CALL_OW 67
// if heike_undercover in [ 0 , 1 ] then
68109: LD_EXP 83
68113: PUSH
68114: LD_INT 0
68116: PUSH
68117: LD_INT 1
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: IN
68124: IFFALSE 68130
// continue else
68126: GO 68102
68128: GO 68142
// if heike_undercover = 4 then
68130: LD_EXP 83
68134: PUSH
68135: LD_INT 4
68137: EQUAL
68138: IFFALSE 68142
// exit ;
68140: GO 68229
// temp_unit = IsInUnit ( Heike ) ;
68142: LD_ADDR_VAR 0 1
68146: PUSH
68147: LD_EXP 7
68151: PPUSH
68152: CALL_OW 310
68156: ST_TO_ADDR
// if temp_unit > 0 then
68157: LD_VAR 0 1
68161: PUSH
68162: LD_INT 0
68164: GREATER
68165: IFFALSE 68225
// if GetType ( temp_unit ) = unit_vehicle and GetWeapon ( temp_unit ) = ru_cargo_bay then
68167: LD_VAR 0 1
68171: PPUSH
68172: CALL_OW 247
68176: PUSH
68177: LD_INT 2
68179: EQUAL
68180: PUSH
68181: LD_VAR 0 1
68185: PPUSH
68186: CALL_OW 264
68190: PUSH
68191: LD_INT 51
68193: EQUAL
68194: AND
68195: IFFALSE 68225
// begin DoNotAttack ( russians , temp_unit ) ;
68197: LD_EXP 3
68201: PPUSH
68202: LD_VAR 0 1
68206: PPUSH
68207: CALL_OW 471
// DoNotAttack ( russians_alt , temp_unit ) ;
68211: LD_EXP 6
68215: PPUSH
68216: LD_VAR 0 1
68220: PPUSH
68221: CALL_OW 471
// end ; until false ;
68225: LD_INT 0
68227: IFFALSE 68102
// end ;
68229: PPOPN 1
68231: END
// function F_InGameOn ; var i , temp_list ; begin
68232: LD_INT 0
68234: PPUSH
68235: PPUSH
68236: PPUSH
// temp_list = FilterAllUnits ( [ f_side , you ] ) ;
68237: LD_ADDR_VAR 0 3
68241: PUSH
68242: LD_INT 22
68244: PUSH
68245: LD_EXP 2
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PPUSH
68254: CALL_OW 69
68258: ST_TO_ADDR
// if heike_undercover in [ 2 , 3 ] then
68259: LD_EXP 83
68263: PUSH
68264: LD_INT 2
68266: PUSH
68267: LD_INT 3
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: IN
68274: IFFALSE 68292
// temp_list = temp_list diff Heike ;
68276: LD_ADDR_VAR 0 3
68280: PUSH
68281: LD_VAR 0 3
68285: PUSH
68286: LD_EXP 7
68290: DIFF
68291: ST_TO_ADDR
// for i in temp_list do
68292: LD_ADDR_VAR 0 2
68296: PUSH
68297: LD_VAR 0 3
68301: PUSH
68302: FOR_IN
68303: IFFALSE 68344
// begin ComStand ( i ) ;
68305: LD_VAR 0 2
68309: PPUSH
68310: CALL_OW 165
// DoNotAttack ( russians , i ) ;
68314: LD_EXP 3
68318: PPUSH
68319: LD_VAR 0 2
68323: PPUSH
68324: CALL_OW 471
// DoNotAttack ( russians_alt , i ) ;
68328: LD_EXP 6
68332: PPUSH
68333: LD_VAR 0 2
68337: PPUSH
68338: CALL_OW 471
// end ;
68342: GO 68302
68344: POP
68345: POP
// temp_list = UnitFilter ( in_out_russian_units , [ f_not , [ f_inarea , ru_base_area ] ] ) ;
68346: LD_ADDR_VAR 0 3
68350: PUSH
68351: LD_EXP 119
68355: PPUSH
68356: LD_INT 3
68358: PUSH
68359: LD_INT 95
68361: PUSH
68362: LD_INT 2
68364: PUSH
68365: EMPTY
68366: LIST
68367: LIST
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: PPUSH
68373: CALL_OW 72
68377: ST_TO_ADDR
// for i in patrols do
68378: LD_ADDR_VAR 0 2
68382: PUSH
68383: LD_EXP 78
68387: PUSH
68388: FOR_IN
68389: IFFALSE 68431
// temp_list = temp_list ^ UnitFilter ( i , [ f_not , [ f_inarea , ru_base_area ] ] ) ;
68391: LD_ADDR_VAR 0 3
68395: PUSH
68396: LD_VAR 0 3
68400: PUSH
68401: LD_VAR 0 2
68405: PPUSH
68406: LD_INT 3
68408: PUSH
68409: LD_INT 95
68411: PUSH
68412: LD_INT 2
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PPUSH
68423: CALL_OW 72
68427: ADD
68428: ST_TO_ADDR
68429: GO 68388
68431: POP
68432: POP
// for i in temp_list do
68433: LD_ADDR_VAR 0 2
68437: PUSH
68438: LD_VAR 0 3
68442: PUSH
68443: FOR_IN
68444: IFFALSE 68457
// ComStand ( i ) ;
68446: LD_VAR 0 2
68450: PPUSH
68451: CALL_OW 165
68455: GO 68443
68457: POP
68458: POP
// InGameOn ;
68459: CALL_OW 8
// end ;
68463: LD_VAR 0 1
68467: RET
// function F_InGameOff ; var i , temp_list ; begin
68468: LD_INT 0
68470: PPUSH
68471: PPUSH
68472: PPUSH
// temp_list = FilterAllUnits ( [ f_side , you ] ) ;
68473: LD_ADDR_VAR 0 3
68477: PUSH
68478: LD_INT 22
68480: PUSH
68481: LD_EXP 2
68485: PUSH
68486: EMPTY
68487: LIST
68488: LIST
68489: PPUSH
68490: CALL_OW 69
68494: ST_TO_ADDR
// if heike_undercover in [ 2 , 3 ] then
68495: LD_EXP 83
68499: PUSH
68500: LD_INT 2
68502: PUSH
68503: LD_INT 3
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: IN
68510: IFFALSE 68528
// temp_list = temp_list diff Heike ;
68512: LD_ADDR_VAR 0 3
68516: PUSH
68517: LD_VAR 0 3
68521: PUSH
68522: LD_EXP 7
68526: DIFF
68527: ST_TO_ADDR
// for i in temp_list do
68528: LD_ADDR_VAR 0 2
68532: PUSH
68533: LD_VAR 0 3
68537: PUSH
68538: FOR_IN
68539: IFFALSE 68580
// begin ComFree ( i ) ;
68541: LD_VAR 0 2
68545: PPUSH
68546: CALL_OW 139
// NormalAttack ( russians , i ) ;
68550: LD_EXP 3
68554: PPUSH
68555: LD_VAR 0 2
68559: PPUSH
68560: CALL_OW 472
// NormalAttack ( russians_alt , i ) ;
68564: LD_EXP 6
68568: PPUSH
68569: LD_VAR 0 2
68573: PPUSH
68574: CALL_OW 472
// end ;
68578: GO 68538
68580: POP
68581: POP
// temp_list = UnitFilter ( in_out_russian_units , [ f_not , [ f_inarea , ru_base_area ] ] ) ;
68582: LD_ADDR_VAR 0 3
68586: PUSH
68587: LD_EXP 119
68591: PPUSH
68592: LD_INT 3
68594: PUSH
68595: LD_INT 95
68597: PUSH
68598: LD_INT 2
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PPUSH
68609: CALL_OW 72
68613: ST_TO_ADDR
// for i in patrols do
68614: LD_ADDR_VAR 0 2
68618: PUSH
68619: LD_EXP 78
68623: PUSH
68624: FOR_IN
68625: IFFALSE 68667
// temp_list = temp_list ^ UnitFilter ( i , [ f_not , [ f_inarea , ru_base_area ] ] ) ;
68627: LD_ADDR_VAR 0 3
68631: PUSH
68632: LD_VAR 0 3
68636: PUSH
68637: LD_VAR 0 2
68641: PPUSH
68642: LD_INT 3
68644: PUSH
68645: LD_INT 95
68647: PUSH
68648: LD_INT 2
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PPUSH
68659: CALL_OW 72
68663: ADD
68664: ST_TO_ADDR
68665: GO 68624
68667: POP
68668: POP
// for i in temp_list do
68669: LD_ADDR_VAR 0 2
68673: PUSH
68674: LD_VAR 0 3
68678: PUSH
68679: FOR_IN
68680: IFFALSE 68693
// ComFree ( i ) ;
68682: LD_VAR 0 2
68686: PPUSH
68687: CALL_OW 139
68691: GO 68679
68693: POP
68694: POP
// InGameOff ;
68695: CALL_OW 9
// end ; end_of_file
68699: LD_VAR 0 1
68703: RET
// every 0 0$1 + 0 0$0.2 trigger mission_can_end do var list_all , list_in_area , i ;
68704: LD_EXP 101
68708: IFFALSE 68961
68710: GO 68712
68712: DISABLE
68713: LD_INT 0
68715: PPUSH
68716: PPUSH
68717: PPUSH
// begin SetAreaMapShow ( mission_end_area , 1 ) ;
68718: LD_INT 12
68720: PPUSH
68721: LD_INT 1
68723: PPUSH
68724: CALL_OW 424
// repeat wait ( 0 0$1 ) ;
68728: LD_INT 35
68730: PPUSH
68731: CALL_OW 67
// list_in_area = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_type , unit_human ] , [ f_inarea , mission_end_area ] ] ) ;
68735: LD_ADDR_VAR 0 2
68739: PUSH
68740: LD_INT 22
68742: PUSH
68743: LD_EXP 2
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: LD_INT 50
68754: PUSH
68755: EMPTY
68756: LIST
68757: PUSH
68758: LD_INT 21
68760: PUSH
68761: LD_INT 1
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 95
68770: PUSH
68771: LD_INT 12
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: LIST
68782: LIST
68783: PPUSH
68784: CALL_OW 69
68788: ST_TO_ADDR
// if list_in_area = 0 then
68789: LD_VAR 0 2
68793: PUSH
68794: LD_INT 0
68796: EQUAL
68797: IFFALSE 68801
// continue ;
68799: GO 68728
// if Heike in list_in_area then
68801: LD_EXP 7
68805: PUSH
68806: LD_VAR 0 2
68810: IN
68811: IFFALSE 68957
// begin list_all = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_type , unit_human ] ] ) ;
68813: LD_ADDR_VAR 0 1
68817: PUSH
68818: LD_INT 22
68820: PUSH
68821: LD_EXP 2
68825: PUSH
68826: EMPTY
68827: LIST
68828: LIST
68829: PUSH
68830: LD_INT 50
68832: PUSH
68833: EMPTY
68834: LIST
68835: PUSH
68836: LD_INT 21
68838: PUSH
68839: LD_INT 1
68841: PUSH
68842: EMPTY
68843: LIST
68844: LIST
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: LIST
68850: PPUSH
68851: CALL_OW 69
68855: ST_TO_ADDR
// if list_in_area < list_all then
68856: LD_VAR 0 2
68860: PUSH
68861: LD_VAR 0 1
68865: LESS
68866: IFFALSE 68890
// if Query ( QLeaveBehind ) = 2 then
68868: LD_STRING QLeaveBehind
68870: PPUSH
68871: CALL_OW 97
68875: PUSH
68876: LD_INT 2
68878: EQUAL
68879: IFFALSE 68890
// begin wait ( 0 0$6 ) ;
68881: LD_INT 210
68883: PPUSH
68884: CALL_OW 67
// continue ;
68888: GO 68728
// end ; EndMission ( list_in_area , FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_type , unit_vehicle ] , [ f_occupied ] , [ f_inarea , mission_end_area ] ] ) ) ;
68890: LD_VAR 0 2
68894: PPUSH
68895: LD_INT 22
68897: PUSH
68898: LD_EXP 2
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: PUSH
68907: LD_INT 50
68909: PUSH
68910: EMPTY
68911: LIST
68912: PUSH
68913: LD_INT 21
68915: PUSH
68916: LD_INT 2
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 59
68925: PUSH
68926: EMPTY
68927: LIST
68928: PUSH
68929: LD_INT 95
68931: PUSH
68932: LD_INT 12
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: PPUSH
68946: CALL_OW 69
68950: PPUSH
68951: CALL 68964 0 2
// exit ;
68955: GO 68961
// end ; until false ;
68957: LD_INT 0
68959: IFFALSE 68728
// end ;
68961: PPOPN 3
68963: END
// function EndMission ( people_list , vehicles_list ) ; var val , old_Heike , temp_list ; begin
68964: LD_INT 0
68966: PPUSH
68967: PPUSH
68968: PPUSH
68969: PPUSH
// EnableExclamations ;
68970: CALL_OW 473
// if entrance_guard_dialogue_played then
68974: LD_EXP 84
68978: IFFALSE 68990
// val = 1 else
68980: LD_ADDR_VAR 0 4
68984: PUSH
68985: LD_INT 1
68987: ST_TO_ADDR
68988: GO 68999
// val = - 1 ;
68990: LD_ADDR_VAR 0 4
68994: PUSH
68995: LD_INT 1
68997: NEG
68998: ST_TO_ADDR
// AddMedal ( Strategy , val ) ;
68999: LD_STRING Strategy
69001: PPUSH
69002: LD_VAR 0 4
69006: PPUSH
69007: CALL_OW 101
// if num_sabotaged_cargo_bays >= 3 then
69011: LD_EXP 121
69015: PUSH
69016: LD_INT 3
69018: GREATEREQUAL
69019: IFFALSE 69031
// val = 1 else
69021: LD_ADDR_VAR 0 4
69025: PUSH
69026: LD_INT 1
69028: ST_TO_ADDR
69029: GO 69061
// if num_sabotaged_cargo_bays > 0 then
69031: LD_EXP 121
69035: PUSH
69036: LD_INT 0
69038: GREATER
69039: IFFALSE 69052
// val = - 1 else
69041: LD_ADDR_VAR 0 4
69045: PUSH
69046: LD_INT 1
69048: NEG
69049: ST_TO_ADDR
69050: GO 69061
// val = - 2 ;
69052: LD_ADDR_VAR 0 4
69056: PUSH
69057: LD_INT 2
69059: NEG
69060: ST_TO_ADDR
// AddMedal ( SupplySabotage , val ) ;
69061: LD_STRING SupplySabotage
69063: PPUSH
69064: LD_VAR 0 4
69068: PPUSH
69069: CALL_OW 101
// if num_documents_stolen >= 35 then
69073: LD_EXP 99
69077: PUSH
69078: LD_INT 35
69080: GREATEREQUAL
69081: IFFALSE 69093
// val = 1 else
69083: LD_ADDR_VAR 0 4
69087: PUSH
69088: LD_INT 1
69090: ST_TO_ADDR
69091: GO 69102
// val = - 1 ;
69093: LD_ADDR_VAR 0 4
69097: PUSH
69098: LD_INT 1
69100: NEG
69101: ST_TO_ADDR
// AddMedal ( Intel , val ) ;
69102: LD_STRING Intel
69104: PPUSH
69105: LD_VAR 0 4
69109: PPUSH
69110: CALL_OW 101
// SaveVariable ( val = 1 , Extra_documents_stolen_09 ) ;
69114: LD_VAR 0 4
69118: PUSH
69119: LD_INT 1
69121: EQUAL
69122: PPUSH
69123: LD_STRING Extra_documents_stolen_09
69125: PPUSH
69126: CALL_OW 39
// GiveMedals ( Medals ) ;
69130: LD_STRING Medals
69132: PPUSH
69133: CALL_OW 102
// temp_list = [ ] ;
69137: LD_ADDR_VAR 0 6
69141: PUSH
69142: EMPTY
69143: ST_TO_ADDR
// for val in vehicles_list do
69144: LD_ADDR_VAR 0 4
69148: PUSH
69149: LD_VAR 0 2
69153: PUSH
69154: FOR_IN
69155: IFFALSE 69256
// temp_list = Insert ( temp_list , 1 , [ GetChassis ( val ) , GetControl ( val ) , GetEngine ( val ) , GetWeapon ( val ) , GetNation ( val ) , GetFuel ( val ) , GetLives ( val ) ] ) ;
69157: LD_ADDR_VAR 0 6
69161: PUSH
69162: LD_VAR 0 6
69166: PPUSH
69167: LD_INT 1
69169: PPUSH
69170: LD_VAR 0 4
69174: PPUSH
69175: CALL_OW 265
69179: PUSH
69180: LD_VAR 0 4
69184: PPUSH
69185: CALL_OW 263
69189: PUSH
69190: LD_VAR 0 4
69194: PPUSH
69195: CALL_OW 262
69199: PUSH
69200: LD_VAR 0 4
69204: PPUSH
69205: CALL_OW 264
69209: PUSH
69210: LD_VAR 0 4
69214: PPUSH
69215: CALL_OW 248
69219: PUSH
69220: LD_VAR 0 4
69224: PPUSH
69225: CALL_OW 261
69229: PUSH
69230: LD_VAR 0 4
69234: PPUSH
69235: CALL_OW 256
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: LIST
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: PPUSH
69249: CALL_OW 2
69253: ST_TO_ADDR
69254: GO 69154
69256: POP
69257: POP
// SaveVariable ( temp_list , Vehicles_09 ) ;
69258: LD_VAR 0 6
69262: PPUSH
69263: LD_STRING Vehicles_09
69265: PPUSH
69266: CALL_OW 39
// RewardPeople ( people_list ) ;
69270: LD_VAR 0 1
69274: PPUSH
69275: CALL_OW 43
// val = GetLives ( Heike ) ;
69279: LD_ADDR_VAR 0 4
69283: PUSH
69284: LD_EXP 7
69288: PPUSH
69289: CALL_OW 256
69293: ST_TO_ADDR
// if val > 500 then
69294: LD_VAR 0 4
69298: PUSH
69299: LD_INT 500
69301: GREATER
69302: IFFALSE 69312
// val = 1000 ;
69304: LD_ADDR_VAR 0 4
69308: PUSH
69309: LD_INT 1000
69311: ST_TO_ADDR
// SaveVariable ( val , Heike_HP_09 ) ;
69312: LD_VAR 0 4
69316: PPUSH
69317: LD_STRING Heike_HP_09
69319: PPUSH
69320: CALL_OW 39
// old_Heike = Heike ;
69324: LD_ADDR_VAR 0 5
69328: PUSH
69329: LD_EXP 7
69333: ST_TO_ADDR
// Heike = NewCharacter ( Heike ) ;
69334: LD_ADDR_EXP 7
69338: PUSH
69339: LD_STRING Heike
69341: PPUSH
69342: CALL_OW 25
69346: ST_TO_ADDR
// CopySkills ( old_Heike , Heike ) ;
69347: LD_VAR 0 5
69351: PPUSH
69352: LD_EXP 7
69356: PPUSH
69357: CALL_OW 510
// SaveCharacters ( Heike , Heike_09 ) ;
69361: LD_EXP 7
69365: PPUSH
69366: LD_STRING Heike_09
69368: PPUSH
69369: CALL_OW 38
// if Dwayne in people_list then
69373: LD_EXP 8
69377: PUSH
69378: LD_VAR 0 1
69382: IN
69383: IFFALSE 69442
// begin SaveCharacters ( Dwayne , Dwayne_09 ) ;
69385: LD_EXP 8
69389: PPUSH
69390: LD_STRING Dwayne_09
69392: PPUSH
69393: CALL_OW 38
// val = GetLives ( Dwayne ) ;
69397: LD_ADDR_VAR 0 4
69401: PUSH
69402: LD_EXP 8
69406: PPUSH
69407: CALL_OW 256
69411: ST_TO_ADDR
// if val > 500 then
69412: LD_VAR 0 4
69416: PUSH
69417: LD_INT 500
69419: GREATER
69420: IFFALSE 69430
// val = 1000 ;
69422: LD_ADDR_VAR 0 4
69426: PUSH
69427: LD_INT 1000
69429: ST_TO_ADDR
// SaveVariable ( val , Dwayne_HP_09 ) ;
69430: LD_VAR 0 4
69434: PPUSH
69435: LD_STRING Dwayne_HP_09
69437: PPUSH
69438: CALL_OW 39
// end ; if Oswald in people_list then
69442: LD_EXP 9
69446: PUSH
69447: LD_VAR 0 1
69451: IN
69452: IFFALSE 69523
// begin SaveCharacters ( Oswald , Oswald_09 ) ;
69454: LD_EXP 9
69458: PPUSH
69459: LD_STRING Oswald_09
69461: PPUSH
69462: CALL_OW 38
// val = GetLives ( Oswald ) ;
69466: LD_ADDR_VAR 0 4
69470: PUSH
69471: LD_EXP 9
69475: PPUSH
69476: CALL_OW 256
69480: ST_TO_ADDR
// if val > 500 then
69481: LD_VAR 0 4
69485: PUSH
69486: LD_INT 500
69488: GREATER
69489: IFFALSE 69499
// val = 1000 ;
69491: LD_ADDR_VAR 0 4
69495: PUSH
69496: LD_INT 1000
69498: ST_TO_ADDR
// SaveVariable ( val , Oswald_HP_09 ) ;
69499: LD_VAR 0 4
69503: PPUSH
69504: LD_STRING Oswald_HP_09
69506: PPUSH
69507: CALL_OW 39
// SaveVariable ( oswald_is_substitute , Oswald_is_substitute_09 ) ;
69511: LD_EXP 70
69515: PPUSH
69516: LD_STRING Oswald_is_substitute_09
69518: PPUSH
69519: CALL_OW 39
// end ; if Kurt in people_list then
69523: LD_EXP 10
69527: PUSH
69528: LD_VAR 0 1
69532: IN
69533: IFFALSE 69604
// begin SaveCharacters ( Kurt , Kurt_09 ) ;
69535: LD_EXP 10
69539: PPUSH
69540: LD_STRING Kurt_09
69542: PPUSH
69543: CALL_OW 38
// val = GetLives ( Kurt ) ;
69547: LD_ADDR_VAR 0 4
69551: PUSH
69552: LD_EXP 10
69556: PPUSH
69557: CALL_OW 256
69561: ST_TO_ADDR
// if val > 500 then
69562: LD_VAR 0 4
69566: PUSH
69567: LD_INT 500
69569: GREATER
69570: IFFALSE 69580
// val = 1000 ;
69572: LD_ADDR_VAR 0 4
69576: PUSH
69577: LD_INT 1000
69579: ST_TO_ADDR
// SaveVariable ( val , Kurt_HP_09 ) ;
69580: LD_VAR 0 4
69584: PPUSH
69585: LD_STRING Kurt_HP_09
69587: PPUSH
69588: CALL_OW 39
// SaveVariable ( kurt_is_substitute , Kurt_is_substitute_09 ) ;
69592: LD_EXP 71
69596: PPUSH
69597: LD_STRING Kurt_is_substitute_09
69599: PPUSH
69600: CALL_OW 39
// end ; if Gonzo in people_list then
69604: LD_EXP 11
69608: PUSH
69609: LD_VAR 0 1
69613: IN
69614: IFFALSE 69673
// begin SaveCharacters ( Gonzo , Gonzo_09 ) ;
69616: LD_EXP 11
69620: PPUSH
69621: LD_STRING Gonzo_09
69623: PPUSH
69624: CALL_OW 38
// val = GetLives ( Gonzo ) ;
69628: LD_ADDR_VAR 0 4
69632: PUSH
69633: LD_EXP 11
69637: PPUSH
69638: CALL_OW 256
69642: ST_TO_ADDR
// if val > 500 then
69643: LD_VAR 0 4
69647: PUSH
69648: LD_INT 500
69650: GREATER
69651: IFFALSE 69661
// val = 1000 ;
69653: LD_ADDR_VAR 0 4
69657: PUSH
69658: LD_INT 1000
69660: ST_TO_ADDR
// SaveVariable ( val , Gonzo_HP_09 ) ;
69661: LD_VAR 0 4
69665: PPUSH
69666: LD_STRING Gonzo_HP_09
69668: PPUSH
69669: CALL_OW 39
// end ; YouWin ;
69673: CALL_OW 103
// end ;
69677: LD_VAR 0 3
69681: RET

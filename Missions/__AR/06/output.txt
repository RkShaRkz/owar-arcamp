// export testing ; export you , russians , nature , you_alt , russians_alt ; export Heike , Sonya , Oswald , Ralph , Kowalski , Willard , Evelyn , Gordon , Suze , Abdul , MarkB , Olaf , Messenger , Omar ; export Swansson ; export ai_soldiers , ai_engineers , ai_mechanics_defend , ai_scientists , ai_commander , ai_depot , ai_lab ; export ai_power_plants , ai_buildings_locations , ai_vehicles_defend , ai_vehicles_attack , ai_human_pullback_hex ; export ai_building_under_construction , ai_heal_these_humans , ai_all_buildings , ai_building_constructor ; export ai_upcoming_building_data , ai_fact , ai_armoury , ai_bunkers , ai_oil_mine , ai_fact_extensions ; export ai_near_base_dist , ai_going_to_attack_this_base , ai_refuel_vehicles_list , ai_turrets ; export ai_attack_delay , ai_bases , ai_cargo_bay , ai_captured_buildings ; export survivors_found , survivors_time , wave_warning_times , wave_num , remote_built_and_tested , cargo_bay_captured , russians_got_away ; starting begin RandomizeAll ;
   0: CALL_OW 11
// ResetFog ;
   4: CALL_OW 335
// testing = false ;
   8: LD_ADDR_EXP 1
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// ai_bases = [ 1 , 2 , 3 ] ;
  16: LD_ADDR_EXP 49
  20: PUSH
  21: LD_INT 1
  23: PUSH
  24: LD_INT 2
  26: PUSH
  27: LD_INT 3
  29: PUSH
  30: EMPTY
  31: LIST
  32: LIST
  33: LIST
  34: ST_TO_ADDR
// ai_soldiers = [ [ ] , [ ] , [ ] ] ;
  35: LD_ADDR_EXP 22
  39: PUSH
  40: EMPTY
  41: PUSH
  42: EMPTY
  43: PUSH
  44: EMPTY
  45: PUSH
  46: EMPTY
  47: LIST
  48: LIST
  49: LIST
  50: ST_TO_ADDR
// ai_engineers = [ [ ] , [ ] , [ ] ] ;
  51: LD_ADDR_EXP 23
  55: PUSH
  56: EMPTY
  57: PUSH
  58: EMPTY
  59: PUSH
  60: EMPTY
  61: PUSH
  62: EMPTY
  63: LIST
  64: LIST
  65: LIST
  66: ST_TO_ADDR
// ai_mechanics_defend = [ [ ] , [ ] , [ ] ] ;
  67: LD_ADDR_EXP 24
  71: PUSH
  72: EMPTY
  73: PUSH
  74: EMPTY
  75: PUSH
  76: EMPTY
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: LIST
  82: ST_TO_ADDR
// ai_scientists = [ [ ] , [ ] , [ ] ] ;
  83: LD_ADDR_EXP 25
  87: PUSH
  88: EMPTY
  89: PUSH
  90: EMPTY
  91: PUSH
  92: EMPTY
  93: PUSH
  94: EMPTY
  95: LIST
  96: LIST
  97: LIST
  98: ST_TO_ADDR
// ai_depot = [ 0 , 0 , 0 ] ;
  99: LD_ADDR_EXP 27
 103: PUSH
 104: LD_INT 0
 106: PUSH
 107: LD_INT 0
 109: PUSH
 110: LD_INT 0
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: ST_TO_ADDR
// ai_lab = [ 0 , 0 , 0 ] ;
 118: LD_ADDR_EXP 28
 122: PUSH
 123: LD_INT 0
 125: PUSH
 126: LD_INT 0
 128: PUSH
 129: LD_INT 0
 131: PUSH
 132: EMPTY
 133: LIST
 134: LIST
 135: LIST
 136: ST_TO_ADDR
// ai_fact = [ 0 , 0 , 0 ] ;
 137: LD_ADDR_EXP 39
 141: PUSH
 142: LD_INT 0
 144: PUSH
 145: LD_INT 0
 147: PUSH
 148: LD_INT 0
 150: PUSH
 151: EMPTY
 152: LIST
 153: LIST
 154: LIST
 155: ST_TO_ADDR
// ai_armoury = [ 0 , 0 , 0 ] ;
 156: LD_ADDR_EXP 40
 160: PUSH
 161: LD_INT 0
 163: PUSH
 164: LD_INT 0
 166: PUSH
 167: LD_INT 0
 169: PUSH
 170: EMPTY
 171: LIST
 172: LIST
 173: LIST
 174: ST_TO_ADDR
// ai_bunkers = [ [ ] , [ ] , [ ] ] ;
 175: LD_ADDR_EXP 41
 179: PUSH
 180: EMPTY
 181: PUSH
 182: EMPTY
 183: PUSH
 184: EMPTY
 185: PUSH
 186: EMPTY
 187: LIST
 188: LIST
 189: LIST
 190: ST_TO_ADDR
// ai_turrets = [ [ ] , [ ] , [ ] ] ;
 191: LD_ADDR_EXP 47
 195: PUSH
 196: EMPTY
 197: PUSH
 198: EMPTY
 199: PUSH
 200: EMPTY
 201: PUSH
 202: EMPTY
 203: LIST
 204: LIST
 205: LIST
 206: ST_TO_ADDR
// ai_oil_mine = [ 0 , 0 , 0 ] ;
 207: LD_ADDR_EXP 42
 211: PUSH
 212: LD_INT 0
 214: PUSH
 215: LD_INT 0
 217: PUSH
 218: LD_INT 0
 220: PUSH
 221: EMPTY
 222: LIST
 223: LIST
 224: LIST
 225: ST_TO_ADDR
// ai_fact_extensions = [ [ ] , [ ] , [ ] ] ;
 226: LD_ADDR_EXP 43
 230: PUSH
 231: EMPTY
 232: PUSH
 233: EMPTY
 234: PUSH
 235: EMPTY
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: ST_TO_ADDR
// ai_power_plants = [ [ ] , [ ] , [ ] ] ;
 242: LD_ADDR_EXP 29
 246: PUSH
 247: EMPTY
 248: PUSH
 249: EMPTY
 250: PUSH
 251: EMPTY
 252: PUSH
 253: EMPTY
 254: LIST
 255: LIST
 256: LIST
 257: ST_TO_ADDR
// ai_buildings_locations = [ [ ] , [ ] , [ ] ] ;
 258: LD_ADDR_EXP 30
 262: PUSH
 263: EMPTY
 264: PUSH
 265: EMPTY
 266: PUSH
 267: EMPTY
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: LIST
 273: ST_TO_ADDR
// ai_captured_buildings = [ [ ] , [ ] , [ ] ] ;
 274: LD_ADDR_EXP 51
 278: PUSH
 279: EMPTY
 280: PUSH
 281: EMPTY
 282: PUSH
 283: EMPTY
 284: PUSH
 285: EMPTY
 286: LIST
 287: LIST
 288: LIST
 289: ST_TO_ADDR
// ai_vehicles_defend = [ [ ] , [ ] , [ ] ] ;
 290: LD_ADDR_EXP 31
 294: PUSH
 295: EMPTY
 296: PUSH
 297: EMPTY
 298: PUSH
 299: EMPTY
 300: PUSH
 301: EMPTY
 302: LIST
 303: LIST
 304: LIST
 305: ST_TO_ADDR
// ai_vehicles_attack = [ [ ] , [ ] , [ ] ] ;
 306: LD_ADDR_EXP 32
 310: PUSH
 311: EMPTY
 312: PUSH
 313: EMPTY
 314: PUSH
 315: EMPTY
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: LIST
 321: ST_TO_ADDR
// ai_refuel_vehicles_list = [ [ ] , [ ] , [ ] ] ;
 322: LD_ADDR_EXP 46
 326: PUSH
 327: EMPTY
 328: PUSH
 329: EMPTY
 330: PUSH
 331: EMPTY
 332: PUSH
 333: EMPTY
 334: LIST
 335: LIST
 336: LIST
 337: ST_TO_ADDR
// ai_human_pullback_hex = [ [ 22 , 7 ] , [ 108 , 118 ] , [ 116 , 51 ] ] ;
 338: LD_ADDR_EXP 33
 342: PUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 7
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 108
 355: PUSH
 356: LD_INT 118
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: LD_INT 116
 365: PUSH
 366: LD_INT 51
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: ST_TO_ADDR
// ai_building_under_construction = [ 0 , 0 , 0 ] ;
 378: LD_ADDR_EXP 34
 382: PUSH
 383: LD_INT 0
 385: PUSH
 386: LD_INT 0
 388: PUSH
 389: LD_INT 0
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: ST_TO_ADDR
// ai_heal_these_humans = [ [ ] , [ ] , [ ] ] ;
 397: LD_ADDR_EXP 35
 401: PUSH
 402: EMPTY
 403: PUSH
 404: EMPTY
 405: PUSH
 406: EMPTY
 407: PUSH
 408: EMPTY
 409: LIST
 410: LIST
 411: LIST
 412: ST_TO_ADDR
// ai_all_buildings = [ [ ] , [ ] , [ ] ] ;
 413: LD_ADDR_EXP 36
 417: PUSH
 418: EMPTY
 419: PUSH
 420: EMPTY
 421: PUSH
 422: EMPTY
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: ST_TO_ADDR
// ai_building_constructor = [ 0 , 0 , 0 ] ;
 429: LD_ADDR_EXP 37
 433: PUSH
 434: LD_INT 0
 436: PUSH
 437: LD_INT 0
 439: PUSH
 440: LD_INT 0
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// ai_upcoming_building_data = [ [ ] , [ ] , [ ] ] ;
 448: LD_ADDR_EXP 38
 452: PUSH
 453: EMPTY
 454: PUSH
 455: EMPTY
 456: PUSH
 457: EMPTY
 458: PUSH
 459: EMPTY
 460: LIST
 461: LIST
 462: LIST
 463: ST_TO_ADDR
// ai_near_base_dist = 35 ;
 464: LD_ADDR_EXP 44
 468: PUSH
 469: LD_INT 35
 471: ST_TO_ADDR
// ai_going_to_attack_this_base = [ 0 , 0 , 0 ] ;
 472: LD_ADDR_EXP 45
 476: PUSH
 477: LD_INT 0
 479: PUSH
 480: LD_INT 0
 482: PUSH
 483: LD_INT 0
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: ST_TO_ADDR
// ai_attack_delay = [ 0 0$0 , 0 0$0 , 0 0$0 ] ;
 491: LD_ADDR_EXP 48
 495: PUSH
 496: LD_INT 0
 498: PUSH
 499: LD_INT 0
 501: PUSH
 502: LD_INT 0
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: ST_TO_ADDR
// ai_cargo_bay = [ 0 , 0 , 0 ] ;
 510: LD_ADDR_EXP 50
 514: PUSH
 515: LD_INT 0
 517: PUSH
 518: LD_INT 0
 520: PUSH
 521: LD_INT 0
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: ST_TO_ADDR
// InitCrateModule ;
 529: CALL 28372 0 0
// survivors_found = 0 ;
 533: LD_ADDR_EXP 52
 537: PUSH
 538: LD_INT 0
 540: ST_TO_ADDR
// survivors_time = [ 4 4$30 , 4 4$0 , 3 3$30 ] [ difficulty ] ;
 541: LD_ADDR_EXP 53
 545: PUSH
 546: LD_INT 9450
 548: PUSH
 549: LD_INT 8400
 551: PUSH
 552: LD_INT 7350
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PUSH
 560: LD_OWVAR 67
 564: ARRAY
 565: ST_TO_ADDR
// wave_warning_times = [ 5 5$0 , 4 4$0 , 3 3$0 , 4 4$0 ] ;
 566: LD_ADDR_EXP 54
 570: PUSH
 571: LD_INT 10500
 573: PUSH
 574: LD_INT 8400
 576: PUSH
 577: LD_INT 6300
 579: PUSH
 580: LD_INT 8400
 582: PUSH
 583: EMPTY
 584: LIST
 585: LIST
 586: LIST
 587: LIST
 588: ST_TO_ADDR
// wave_num = 0 ;
 589: LD_ADDR_EXP 55
 593: PUSH
 594: LD_INT 0
 596: ST_TO_ADDR
// remote_built_and_tested = 0 ;
 597: LD_ADDR_EXP 56
 601: PUSH
 602: LD_INT 0
 604: ST_TO_ADDR
// cargo_bay_captured = false ;
 605: LD_ADDR_EXP 57
 609: PUSH
 610: LD_INT 0
 612: ST_TO_ADDR
// russians_got_away = false ;
 613: LD_ADDR_EXP 58
 617: PUSH
 618: LD_INT 0
 620: ST_TO_ADDR
// disable ( 1 ) ;
 621: LD_INT 1
 623: DISABLE_MARKED
// disable ( 2 ) ;
 624: LD_INT 2
 626: DISABLE_MARKED
// disable ( 3 ) ;
 627: LD_INT 3
 629: DISABLE_MARKED
// PrepareSides ;
 630: CALL 655 0 0
// PrepareNature ;
 634: CALL 823 0 0
// PrepareArabians ;
 638: CALL 1235 0 0
// ScanBuildings ;
 642: CALL 3548 0 0
// PrepareComputerSides ;
 646: CALL 5324 0 0
// Action ;
 650: CALL 6599 0 0
// end ;
 654: END
// function PrepareSides ; begin
 655: LD_INT 0
 657: PPUSH
// nature = 0 ;
 658: LD_ADDR_EXP 4
 662: PUSH
 663: LD_INT 0
 665: ST_TO_ADDR
// you = 2 ;
 666: LD_ADDR_EXP 2
 670: PUSH
 671: LD_INT 2
 673: ST_TO_ADDR
// russians = 3 ;
 674: LD_ADDR_EXP 3
 678: PUSH
 679: LD_INT 3
 681: ST_TO_ADDR
// you_alt = 5 ;
 682: LD_ADDR_EXP 5
 686: PUSH
 687: LD_INT 5
 689: ST_TO_ADDR
// russians_alt = 6 ;
 690: LD_ADDR_EXP 6
 694: PUSH
 695: LD_INT 6
 697: ST_TO_ADDR
// SetAttitude ( you , russians , att_enemy , true ) ;
 698: LD_EXP 2
 702: PPUSH
 703: LD_EXP 3
 707: PPUSH
 708: LD_INT 2
 710: PPUSH
 711: LD_INT 1
 713: PPUSH
 714: CALL_OW 80
// SetAttitude ( you , you_alt , att_friend , true ) ;
 718: LD_EXP 2
 722: PPUSH
 723: LD_EXP 5
 727: PPUSH
 728: LD_INT 1
 730: PPUSH
 731: LD_INT 1
 733: PPUSH
 734: CALL_OW 80
// SetAttitude ( you , russians_alt , att_enemy , true ) ;
 738: LD_EXP 2
 742: PPUSH
 743: LD_EXP 6
 747: PPUSH
 748: LD_INT 2
 750: PPUSH
 751: LD_INT 1
 753: PPUSH
 754: CALL_OW 80
// SetAttitude ( russians , you_alt , att_enemy , true ) ;
 758: LD_EXP 3
 762: PPUSH
 763: LD_EXP 5
 767: PPUSH
 768: LD_INT 2
 770: PPUSH
 771: LD_INT 1
 773: PPUSH
 774: CALL_OW 80
// SetAttitude ( russians , russians_alt , att_friend , true ) ;
 778: LD_EXP 3
 782: PPUSH
 783: LD_EXP 6
 787: PPUSH
 788: LD_INT 1
 790: PPUSH
 791: LD_INT 1
 793: PPUSH
 794: CALL_OW 80
// SetAttitude ( you_alt , russians_alt , att_enemy , true ) ;
 798: LD_EXP 5
 802: PPUSH
 803: LD_EXP 6
 807: PPUSH
 808: LD_INT 2
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: CALL_OW 80
// end ;
 818: LD_VAR 0 1
 822: RET
// function PrepareNature ; var i , spots , num , temp_value , count , temp_unit ; begin
 823: LD_INT 0
 825: PPUSH
 826: PPUSH
 827: PPUSH
 828: PPUSH
 829: PPUSH
 830: PPUSH
 831: PPUSH
// spots = [ [ 58 , 6 ] , [ 68 , 6 ] , [ 78 , 6 ] , [ 72 , 23 ] , [ 78 , 45 ] , [ 61 , 25 ] , [ 157 , 124 ] ] ;
 832: LD_ADDR_VAR 0 3
 836: PUSH
 837: LD_INT 58
 839: PUSH
 840: LD_INT 6
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: PUSH
 847: LD_INT 68
 849: PUSH
 850: LD_INT 6
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: PUSH
 857: LD_INT 78
 859: PUSH
 860: LD_INT 6
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: PUSH
 867: LD_INT 72
 869: PUSH
 870: LD_INT 23
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PUSH
 877: LD_INT 78
 879: PUSH
 880: LD_INT 45
 882: PUSH
 883: EMPTY
 884: LIST
 885: LIST
 886: PUSH
 887: LD_INT 61
 889: PUSH
 890: LD_INT 25
 892: PUSH
 893: EMPTY
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 157
 899: PUSH
 900: LD_INT 124
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: ST_TO_ADDR
// InitUc ;
 916: CALL_OW 18
// InitHc ;
 920: CALL_OW 19
// uc_side = nature ;
 924: LD_ADDR_OWVAR 20
 928: PUSH
 929: LD_EXP 4
 933: ST_TO_ADDR
// uc_nation = nation_nature ;
 934: LD_ADDR_OWVAR 21
 938: PUSH
 939: LD_INT 0
 941: ST_TO_ADDR
// count = [ 5 , 3 , 2 ] [ difficulty ] ;
 942: LD_ADDR_VAR 0 6
 946: PUSH
 947: LD_INT 5
 949: PUSH
 950: LD_INT 3
 952: PUSH
 953: LD_INT 2
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_OWVAR 67
 965: ARRAY
 966: ST_TO_ADDR
// hc_class = class_apeman ;
 967: LD_ADDR_OWVAR 28
 971: PUSH
 972: LD_INT 12
 974: ST_TO_ADDR
// for i = 1 to count do
 975: LD_ADDR_VAR 0 2
 979: PUSH
 980: DOUBLE
 981: LD_INT 1
 983: DEC
 984: ST_TO_ADDR
 985: LD_VAR 0 6
 989: PUSH
 990: FOR_TO
 991: IFFALSE 1228
// begin if spots = 0 then
 993: LD_VAR 0 3
 997: PUSH
 998: LD_INT 0
1000: EQUAL
1001: IFFALSE 1007
// exit ;
1003: POP
1004: POP
1005: GO 1230
// uc_direction = Rand ( 0 , 5 ) ;
1007: LD_ADDR_OWVAR 24
1011: PUSH
1012: LD_INT 0
1014: PPUSH
1015: LD_INT 5
1017: PPUSH
1018: CALL_OW 12
1022: ST_TO_ADDR
// temp_value = - 10 + difficulty * 20 ;
1023: LD_ADDR_VAR 0 5
1027: PUSH
1028: LD_INT 10
1030: NEG
1031: PUSH
1032: LD_OWVAR 67
1036: PUSH
1037: LD_INT 20
1039: MUL
1040: PLUS
1041: ST_TO_ADDR
// hc_agressivity = Rand ( - 1 * temp_value , 0 ) ;
1042: LD_ADDR_OWVAR 35
1046: PUSH
1047: LD_INT 1
1049: NEG
1050: PUSH
1051: LD_VAR 0 5
1055: MUL
1056: PPUSH
1057: LD_INT 0
1059: PPUSH
1060: CALL_OW 12
1064: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
1065: LD_ADDR_OWVAR 29
1069: PUSH
1070: LD_INT 11
1072: PPUSH
1073: LD_INT 13
1075: PPUSH
1076: CALL_OW 12
1080: PUSH
1081: LD_INT 10
1083: PPUSH
1084: LD_INT 11
1086: PPUSH
1087: CALL_OW 12
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: ST_TO_ADDR
// hc_sex = Rand ( sex_male , sex_female ) ;
1096: LD_ADDR_OWVAR 27
1100: PUSH
1101: LD_INT 1
1103: PPUSH
1104: LD_INT 2
1106: PPUSH
1107: CALL_OW 12
1111: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 1 ) , 0 , 0 , 0 ] ;
1112: LD_ADDR_OWVAR 31
1116: PUSH
1117: LD_INT 0
1119: PPUSH
1120: LD_INT 1
1122: PPUSH
1123: CALL_OW 12
1127: PUSH
1128: LD_INT 0
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: LD_INT 0
1136: PUSH
1137: EMPTY
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: ST_TO_ADDR
// num = Rand ( 1 , spots ) ;
1143: LD_ADDR_VAR 0 4
1147: PUSH
1148: LD_INT 1
1150: PPUSH
1151: LD_VAR 0 3
1155: PPUSH
1156: CALL_OW 12
1160: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , spots [ num ] [ 1 ] , spots [ num ] [ 2 ] , 5 , false ) ;
1161: CALL_OW 44
1165: PPUSH
1166: LD_VAR 0 3
1170: PUSH
1171: LD_VAR 0 4
1175: ARRAY
1176: PUSH
1177: LD_INT 1
1179: ARRAY
1180: PPUSH
1181: LD_VAR 0 3
1185: PUSH
1186: LD_VAR 0 4
1190: ARRAY
1191: PUSH
1192: LD_INT 2
1194: ARRAY
1195: PPUSH
1196: LD_INT 5
1198: PPUSH
1199: LD_INT 0
1201: PPUSH
1202: CALL_OW 50
// spots = Delete ( spots , num ) ;
1206: LD_ADDR_VAR 0 3
1210: PUSH
1211: LD_VAR 0 3
1215: PPUSH
1216: LD_VAR 0 4
1220: PPUSH
1221: CALL_OW 3
1225: ST_TO_ADDR
// end ;
1226: GO 990
1228: POP
1229: POP
// end ;
1230: LD_VAR 0 1
1234: RET
// function PrepareArabians ; var temp_unit , veh_list , val , temp_list , un_list , i ; begin
1235: LD_INT 0
1237: PPUSH
1238: PPUSH
1239: PPUSH
1240: PPUSH
1241: PPUSH
1242: PPUSH
1243: PPUSH
// InitHc ;
1244: CALL_OW 19
// InitUc ;
1248: CALL_OW 18
// uc_side = you ;
1252: LD_ADDR_OWVAR 20
1256: PUSH
1257: LD_EXP 2
1261: ST_TO_ADDR
// uc_nation = nation_arabian ;
1262: LD_ADDR_OWVAR 21
1266: PUSH
1267: LD_INT 2
1269: ST_TO_ADDR
// uc_direction = 3 ;
1270: LD_ADDR_OWVAR 24
1274: PUSH
1275: LD_INT 3
1277: ST_TO_ADDR
// if not testing then
1278: LD_EXP 1
1282: NOT
1283: IFFALSE 2098
// begin Heike = CreateCharacter ( Heike_05_cont_sel ) ;
1285: LD_ADDR_EXP 7
1289: PUSH
1290: LD_STRING Heike_05_cont_sel
1292: PPUSH
1293: CALL_OW 34
1297: ST_TO_ADDR
// if TestCharacters ( Sonya_05_cont_sel ) then
1298: LD_STRING Sonya_05_cont_sel
1300: PPUSH
1301: CALL_OW 28
1305: IFFALSE 1322
// Sonya = CreateCharacter ( Sonya_05_cont_sel ) else
1307: LD_ADDR_EXP 8
1311: PUSH
1312: LD_STRING Sonya_05_cont_sel
1314: PPUSH
1315: CALL_OW 34
1319: ST_TO_ADDR
1320: GO 1330
// Sonya = 0 ;
1322: LD_ADDR_EXP 8
1326: PUSH
1327: LD_INT 0
1329: ST_TO_ADDR
// if TestCharacters ( Oswald_05_cont_sel ) then
1330: LD_STRING Oswald_05_cont_sel
1332: PPUSH
1333: CALL_OW 28
1337: IFFALSE 1354
// Oswald = CreateCharacter ( Oswald_05_cont_sel ) else
1339: LD_ADDR_EXP 9
1343: PUSH
1344: LD_STRING Oswald_05_cont_sel
1346: PPUSH
1347: CALL_OW 34
1351: ST_TO_ADDR
1352: GO 1362
// Oswald = 0 ;
1354: LD_ADDR_EXP 9
1358: PUSH
1359: LD_INT 0
1361: ST_TO_ADDR
// if TestCharacters ( Ralph_05_cont_sel ) then
1362: LD_STRING Ralph_05_cont_sel
1364: PPUSH
1365: CALL_OW 28
1369: IFFALSE 1386
// Ralph = CreateCharacter ( Ralph_05_cont_sel ) else
1371: LD_ADDR_EXP 10
1375: PUSH
1376: LD_STRING Ralph_05_cont_sel
1378: PPUSH
1379: CALL_OW 34
1383: ST_TO_ADDR
1384: GO 1394
// Ralph = 0 ;
1386: LD_ADDR_EXP 10
1390: PUSH
1391: LD_INT 0
1393: ST_TO_ADDR
// if TestCharacters ( Kowalski_05_cont_sel ) then
1394: LD_STRING Kowalski_05_cont_sel
1396: PPUSH
1397: CALL_OW 28
1401: IFFALSE 1418
// Kowalski = CreateCharacter ( Kowalski_05_cont_sel ) else
1403: LD_ADDR_EXP 11
1407: PUSH
1408: LD_STRING Kowalski_05_cont_sel
1410: PPUSH
1411: CALL_OW 34
1415: ST_TO_ADDR
1416: GO 1426
// Kowalski = 0 ;
1418: LD_ADDR_EXP 11
1422: PUSH
1423: LD_INT 0
1425: ST_TO_ADDR
// if TestCharacters ( Willard_05_cont_sel ) then
1426: LD_STRING Willard_05_cont_sel
1428: PPUSH
1429: CALL_OW 28
1433: IFFALSE 1450
// Willard = CreateCharacter ( Willard_05_cont_sel ) else
1435: LD_ADDR_EXP 12
1439: PUSH
1440: LD_STRING Willard_05_cont_sel
1442: PPUSH
1443: CALL_OW 34
1447: ST_TO_ADDR
1448: GO 1458
// Willard = 0 ;
1450: LD_ADDR_EXP 12
1454: PUSH
1455: LD_INT 0
1457: ST_TO_ADDR
// if TestCharacters ( Evelyn_05_cont_sel ) then
1458: LD_STRING Evelyn_05_cont_sel
1460: PPUSH
1461: CALL_OW 28
1465: IFFALSE 1482
// Evelyn = CreateCharacter ( Evelyn_05_cont_sel ) else
1467: LD_ADDR_EXP 13
1471: PUSH
1472: LD_STRING Evelyn_05_cont_sel
1474: PPUSH
1475: CALL_OW 34
1479: ST_TO_ADDR
1480: GO 1490
// Evelyn = 0 ;
1482: LD_ADDR_EXP 13
1486: PUSH
1487: LD_INT 0
1489: ST_TO_ADDR
// if TestCharacters ( Gordon_05_cont_sel ) then
1490: LD_STRING Gordon_05_cont_sel
1492: PPUSH
1493: CALL_OW 28
1497: IFFALSE 1514
// Gordon = CreateCharacter ( Gordon_05_cont_sel ) else
1499: LD_ADDR_EXP 14
1503: PUSH
1504: LD_STRING Gordon_05_cont_sel
1506: PPUSH
1507: CALL_OW 34
1511: ST_TO_ADDR
1512: GO 1522
// Gordon = 0 ;
1514: LD_ADDR_EXP 14
1518: PUSH
1519: LD_INT 0
1521: ST_TO_ADDR
// if TestCharacters ( Suze_05_cont_sel ) then
1522: LD_STRING Suze_05_cont_sel
1524: PPUSH
1525: CALL_OW 28
1529: IFFALSE 1546
// Suze = CreateCharacter ( Suze_05_cont_sel ) else
1531: LD_ADDR_EXP 15
1535: PUSH
1536: LD_STRING Suze_05_cont_sel
1538: PPUSH
1539: CALL_OW 34
1543: ST_TO_ADDR
1544: GO 1554
// Suze = 0 ;
1546: LD_ADDR_EXP 15
1550: PUSH
1551: LD_INT 0
1553: ST_TO_ADDR
// if TestCharacters ( Olaf_05_cont_sel ) then
1554: LD_STRING Olaf_05_cont_sel
1556: PPUSH
1557: CALL_OW 28
1561: IFFALSE 1586
// begin Olaf = CreateCharacter ( Olaf_05_cont_sel ) ;
1563: LD_ADDR_EXP 18
1567: PUSH
1568: LD_STRING Olaf_05_cont_sel
1570: PPUSH
1571: CALL_OW 34
1575: ST_TO_ADDR
// Messenger = 0 ;
1576: LD_ADDR_EXP 19
1580: PUSH
1581: LD_INT 0
1583: ST_TO_ADDR
// end else
1584: GO 1616
// if TestCharacters ( Messenger_05_cont_sel ) then
1586: LD_STRING Messenger_05_cont_sel
1588: PPUSH
1589: CALL_OW 28
1593: IFFALSE 1616
// begin Olaf = 0 ;
1595: LD_ADDR_EXP 18
1599: PUSH
1600: LD_INT 0
1602: ST_TO_ADDR
// Messenger = CreateCharacter ( Messenger_05_cont_sel ) ;
1603: LD_ADDR_EXP 19
1607: PUSH
1608: LD_STRING Messenger_05_cont_sel
1610: PPUSH
1611: CALL_OW 34
1615: ST_TO_ADDR
// end ; un_list = ( CreateCharacterSet ( Others_05_cont_sel ) ^ [ Heike , Sonya , Oswald , Ralph , Kowalski , Willard , Evelyn , Gordon , Suze , Olaf , Messenger ] ) diff 0 ;
1616: LD_ADDR_VAR 0 6
1620: PUSH
1621: LD_STRING Others_05_cont_sel
1623: PPUSH
1624: CALL_OW 31
1628: PUSH
1629: LD_EXP 7
1633: PUSH
1634: LD_EXP 8
1638: PUSH
1639: LD_EXP 9
1643: PUSH
1644: LD_EXP 10
1648: PUSH
1649: LD_EXP 11
1653: PUSH
1654: LD_EXP 12
1658: PUSH
1659: LD_EXP 13
1663: PUSH
1664: LD_EXP 14
1668: PUSH
1669: LD_EXP 15
1673: PUSH
1674: LD_EXP 18
1678: PUSH
1679: LD_EXP 19
1683: PUSH
1684: EMPTY
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: ADD
1697: PUSH
1698: LD_INT 0
1700: DIFF
1701: ST_TO_ADDR
// for i in un_list do
1702: LD_ADDR_VAR 0 7
1706: PUSH
1707: LD_VAR 0 6
1711: PUSH
1712: FOR_IN
1713: IFFALSE 1731
// SetDir ( i , uc_direction ) ;
1715: LD_VAR 0 7
1719: PPUSH
1720: LD_OWVAR 24
1724: PPUSH
1725: CALL_OW 233
1729: GO 1712
1731: POP
1732: POP
// veh_list = [ ] ;
1733: LD_ADDR_VAR 0 3
1737: PUSH
1738: EMPTY
1739: ST_TO_ADDR
// InitVc ;
1740: CALL_OW 20
// for i in LoadVariable ( Vehicles_05_cont , [ ] ) do
1744: LD_ADDR_VAR 0 7
1748: PUSH
1749: LD_STRING Vehicles_05_cont
1751: PPUSH
1752: EMPTY
1753: PPUSH
1754: CALL_OW 30
1758: PUSH
1759: FOR_IN
1760: IFFALSE 2086
// begin uc_nation = i [ 6 ] ;
1762: LD_ADDR_OWVAR 21
1766: PUSH
1767: LD_VAR 0 7
1771: PUSH
1772: LD_INT 6
1774: ARRAY
1775: ST_TO_ADDR
// vc_chassis = i [ 1 ] ;
1776: LD_ADDR_OWVAR 37
1780: PUSH
1781: LD_VAR 0 7
1785: PUSH
1786: LD_INT 1
1788: ARRAY
1789: ST_TO_ADDR
// vc_engine = i [ 2 ] ;
1790: LD_ADDR_OWVAR 39
1794: PUSH
1795: LD_VAR 0 7
1799: PUSH
1800: LD_INT 2
1802: ARRAY
1803: ST_TO_ADDR
// vc_control = i [ 3 ] ;
1804: LD_ADDR_OWVAR 38
1808: PUSH
1809: LD_VAR 0 7
1813: PUSH
1814: LD_INT 3
1816: ARRAY
1817: ST_TO_ADDR
// vc_weapon = i [ 4 ] ;
1818: LD_ADDR_OWVAR 40
1822: PUSH
1823: LD_VAR 0 7
1827: PUSH
1828: LD_INT 4
1830: ARRAY
1831: ST_TO_ADDR
// vc_fuel_battery = Rand ( 80 , 100 ) - 10 * difficulty ;
1832: LD_ADDR_OWVAR 41
1836: PUSH
1837: LD_INT 80
1839: PPUSH
1840: LD_INT 100
1842: PPUSH
1843: CALL_OW 12
1847: PUSH
1848: LD_INT 10
1850: PUSH
1851: LD_OWVAR 67
1855: MUL
1856: MINUS
1857: ST_TO_ADDR
// temp_unit = CreateVehicle ;
1858: LD_ADDR_VAR 0 2
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// val = Rand ( i [ 5 ] , 1000 ) ;
1868: LD_ADDR_VAR 0 4
1872: PUSH
1873: LD_VAR 0 7
1877: PUSH
1878: LD_INT 5
1880: ARRAY
1881: PPUSH
1882: LD_INT 1000
1884: PPUSH
1885: CALL_OW 12
1889: ST_TO_ADDR
// val = val - Rand ( 100 , 200 ) * difficulty ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_VAR 0 4
1899: PUSH
1900: LD_INT 100
1902: PPUSH
1903: LD_INT 200
1905: PPUSH
1906: CALL_OW 12
1910: PUSH
1911: LD_OWVAR 67
1915: MUL
1916: MINUS
1917: ST_TO_ADDR
// if val < [ 500 , 400 , 300 ] [ difficulty ] then
1918: LD_VAR 0 4
1922: PUSH
1923: LD_INT 500
1925: PUSH
1926: LD_INT 400
1928: PUSH
1929: LD_INT 300
1931: PUSH
1932: EMPTY
1933: LIST
1934: LIST
1935: LIST
1936: PUSH
1937: LD_OWVAR 67
1941: ARRAY
1942: LESS
1943: IFFALSE 1970
// val = [ 500 , 400 , 300 ] [ difficulty ] ;
1945: LD_ADDR_VAR 0 4
1949: PUSH
1950: LD_INT 500
1952: PUSH
1953: LD_INT 400
1955: PUSH
1956: LD_INT 300
1958: PUSH
1959: EMPTY
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_OWVAR 67
1968: ARRAY
1969: ST_TO_ADDR
// SetLives ( temp_unit , val ) ;
1970: LD_VAR 0 2
1974: PPUSH
1975: LD_VAR 0 4
1979: PPUSH
1980: CALL_OW 234
// if vc_weapon in [ ar_cargo_bay , ru_cargo_bay , us_cargo_bay ] then
1984: LD_OWVAR 40
1988: PUSH
1989: LD_INT 32
1991: PUSH
1992: LD_INT 51
1994: PUSH
1995: LD_INT 12
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: LIST
2002: IN
2003: IFFALSE 2068
// begin SetCargo ( temp_unit , mat_cans , i [ 7 ] ) ;
2005: LD_VAR 0 2
2009: PPUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_VAR 0 7
2017: PUSH
2018: LD_INT 7
2020: ARRAY
2021: PPUSH
2022: CALL_OW 290
// AddCargo ( temp_unit , mat_oil , i [ 8 ] ) ;
2026: LD_VAR 0 2
2030: PPUSH
2031: LD_INT 2
2033: PPUSH
2034: LD_VAR 0 7
2038: PUSH
2039: LD_INT 8
2041: ARRAY
2042: PPUSH
2043: CALL_OW 291
// AddCargo ( temp_unit , mat_siberit , i [ 9 ] ) ;
2047: LD_VAR 0 2
2051: PPUSH
2052: LD_INT 3
2054: PPUSH
2055: LD_VAR 0 7
2059: PUSH
2060: LD_INT 9
2062: ARRAY
2063: PPUSH
2064: CALL_OW 291
// end ; veh_list = veh_list ^ temp_unit ;
2068: LD_ADDR_VAR 0 3
2072: PUSH
2073: LD_VAR 0 3
2077: PUSH
2078: LD_VAR 0 2
2082: ADD
2083: ST_TO_ADDR
// end ;
2084: GO 1759
2086: POP
2087: POP
// uc_nation = nation_arabian ;
2088: LD_ADDR_OWVAR 21
2092: PUSH
2093: LD_INT 2
2095: ST_TO_ADDR
// end else
2096: GO 2576
// begin InitHc ;
2098: CALL_OW 19
// hc_name = Heike ;
2102: LD_ADDR_OWVAR 26
2106: PUSH
2107: LD_STRING Heike
2109: ST_TO_ADDR
// PrepareSoldier ( sex_female , 6 ) ;
2110: LD_INT 2
2112: PPUSH
2113: LD_INT 6
2115: PPUSH
2116: CALL_OW 381
// Heike = CreateHuman ;
2120: LD_ADDR_EXP 7
2124: PUSH
2125: CALL_OW 44
2129: ST_TO_ADDR
// hc_name := Sonya ;
2130: LD_ADDR_OWVAR 26
2134: PUSH
2135: LD_STRING Sonya
2137: ST_TO_ADDR
// PrepareScientist ( sex_female , 5 ) ;
2138: LD_INT 2
2140: PPUSH
2141: LD_INT 5
2143: PPUSH
2144: CALL_OW 384
// Sonya := CreateHuman ;
2148: LD_ADDR_EXP 8
2152: PUSH
2153: CALL_OW 44
2157: ST_TO_ADDR
// hc_name := Gordon ;
2158: LD_ADDR_OWVAR 26
2162: PUSH
2163: LD_STRING Gordon
2165: ST_TO_ADDR
// PrepareSoldier ( sex_male , 5 ) ;
2166: LD_INT 1
2168: PPUSH
2169: LD_INT 5
2171: PPUSH
2172: CALL_OW 381
// Gordon := CreateHuman ;
2176: LD_ADDR_EXP 14
2180: PUSH
2181: CALL_OW 44
2185: ST_TO_ADDR
// hc_name := Olaf ;
2186: LD_ADDR_OWVAR 26
2190: PUSH
2191: LD_STRING Olaf
2193: ST_TO_ADDR
// PrepareMechanic ( sex_male , 5 ) ;
2194: LD_INT 1
2196: PPUSH
2197: LD_INT 5
2199: PPUSH
2200: CALL_OW 383
// Olaf := CreateHuman ;
2204: LD_ADDR_EXP 18
2208: PUSH
2209: CALL_OW 44
2213: ST_TO_ADDR
// hc_name = Evelyn ;
2214: LD_ADDR_OWVAR 26
2218: PUSH
2219: LD_STRING Evelyn
2221: ST_TO_ADDR
// PrepareEngineer ( sex_female , 5 ) ;
2222: LD_INT 2
2224: PPUSH
2225: LD_INT 5
2227: PPUSH
2228: CALL_OW 382
// Evelyn = CreateHuman ;
2232: LD_ADDR_EXP 13
2236: PUSH
2237: CALL_OW 44
2241: ST_TO_ADDR
// InitHc ;
2242: CALL_OW 19
// Oswald = 0 ;
2246: LD_ADDR_EXP 9
2250: PUSH
2251: LD_INT 0
2253: ST_TO_ADDR
// Kowalski = 0 ;
2254: LD_ADDR_EXP 11
2258: PUSH
2259: LD_INT 0
2261: ST_TO_ADDR
// Ralph = 0 ;
2262: LD_ADDR_EXP 10
2266: PUSH
2267: LD_INT 0
2269: ST_TO_ADDR
// Suze = 0 ;
2270: LD_ADDR_EXP 15
2274: PUSH
2275: LD_INT 0
2277: ST_TO_ADDR
// Willard = 0 ;
2278: LD_ADDR_EXP 12
2282: PUSH
2283: LD_INT 0
2285: ST_TO_ADDR
// Messenger = 0 ;
2286: LD_ADDR_EXP 19
2290: PUSH
2291: LD_INT 0
2293: ST_TO_ADDR
// un_list = [ Heike , Sonya , Gordon , Olaf , Evelyn ] ;
2294: LD_ADDR_VAR 0 6
2298: PUSH
2299: LD_EXP 7
2303: PUSH
2304: LD_EXP 8
2308: PUSH
2309: LD_EXP 14
2313: PUSH
2314: LD_EXP 18
2318: PUSH
2319: LD_EXP 13
2323: PUSH
2324: EMPTY
2325: LIST
2326: LIST
2327: LIST
2328: LIST
2329: LIST
2330: ST_TO_ADDR
// veh_list = [ ] ;
2331: LD_ADDR_VAR 0 3
2335: PUSH
2336: EMPTY
2337: ST_TO_ADDR
// InitVc ;
2338: CALL_OW 20
// for i = 1 to 4 do
2342: LD_ADDR_VAR 0 7
2346: PUSH
2347: DOUBLE
2348: LD_INT 1
2350: DEC
2351: ST_TO_ADDR
2352: LD_INT 4
2354: PUSH
2355: FOR_TO
2356: IFFALSE 2574
// begin vc_chassis = ar_half_tracked ;
2358: LD_ADDR_OWVAR 37
2362: PUSH
2363: LD_INT 14
2365: ST_TO_ADDR
// vc_engine = engine_combustion ;
2366: LD_ADDR_OWVAR 39
2370: PUSH
2371: LD_INT 1
2373: ST_TO_ADDR
// vc_control = control_manual ;
2374: LD_ADDR_OWVAR 38
2378: PUSH
2379: LD_INT 1
2381: ST_TO_ADDR
// if i <= 2 then
2382: LD_VAR 0 7
2386: PUSH
2387: LD_INT 2
2389: LESSEQUAL
2390: IFFALSE 2402
// vc_weapon = ar_gun else
2392: LD_ADDR_OWVAR 40
2396: PUSH
2397: LD_INT 27
2399: ST_TO_ADDR
2400: GO 2410
// vc_weapon = ar_gatling_gun ;
2402: LD_ADDR_OWVAR 40
2406: PUSH
2407: LD_INT 25
2409: ST_TO_ADDR
// vc_fuel_battery = Rand ( 80 , 100 ) - 10 * difficulty ;
2410: LD_ADDR_OWVAR 41
2414: PUSH
2415: LD_INT 80
2417: PPUSH
2418: LD_INT 100
2420: PPUSH
2421: CALL_OW 12
2425: PUSH
2426: LD_INT 10
2428: PUSH
2429: LD_OWVAR 67
2433: MUL
2434: MINUS
2435: ST_TO_ADDR
// temp_unit = CreateVehicle ;
2436: LD_ADDR_VAR 0 2
2440: PUSH
2441: CALL_OW 45
2445: ST_TO_ADDR
// val = Rand ( 800 , 1000 ) ;
2446: LD_ADDR_VAR 0 4
2450: PUSH
2451: LD_INT 800
2453: PPUSH
2454: LD_INT 1000
2456: PPUSH
2457: CALL_OW 12
2461: ST_TO_ADDR
// val = val - Rand ( 100 , 200 ) * difficulty ;
2462: LD_ADDR_VAR 0 4
2466: PUSH
2467: LD_VAR 0 4
2471: PUSH
2472: LD_INT 100
2474: PPUSH
2475: LD_INT 200
2477: PPUSH
2478: CALL_OW 12
2482: PUSH
2483: LD_OWVAR 67
2487: MUL
2488: MINUS
2489: ST_TO_ADDR
// if val < [ 500 , 400 , 300 ] [ difficulty ] then
2490: LD_VAR 0 4
2494: PUSH
2495: LD_INT 500
2497: PUSH
2498: LD_INT 400
2500: PUSH
2501: LD_INT 300
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: LIST
2508: PUSH
2509: LD_OWVAR 67
2513: ARRAY
2514: LESS
2515: IFFALSE 2542
// val = [ 500 , 400 , 300 ] [ difficulty ] ;
2517: LD_ADDR_VAR 0 4
2521: PUSH
2522: LD_INT 500
2524: PUSH
2525: LD_INT 400
2527: PUSH
2528: LD_INT 300
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: LIST
2535: PUSH
2536: LD_OWVAR 67
2540: ARRAY
2541: ST_TO_ADDR
// SetLives ( temp_unit , val ) ;
2542: LD_VAR 0 2
2546: PPUSH
2547: LD_VAR 0 4
2551: PPUSH
2552: CALL_OW 234
// veh_list = veh_list ^ temp_unit ;
2556: LD_ADDR_VAR 0 3
2560: PUSH
2561: LD_VAR 0 3
2565: PUSH
2566: LD_VAR 0 2
2570: ADD
2571: ST_TO_ADDR
// end ;
2572: GO 2355
2574: POP
2575: POP
// end ; for i = 1 to un_list do
2576: LD_ADDR_VAR 0 7
2580: PUSH
2581: DOUBLE
2582: LD_INT 1
2584: DEC
2585: ST_TO_ADDR
2586: LD_VAR 0 6
2590: PUSH
2591: FOR_TO
2592: IFFALSE 2678
// if veh_list >= i then
2594: LD_VAR 0 3
2598: PUSH
2599: LD_VAR 0 7
2603: GREATEREQUAL
2604: IFFALSE 2655
// begin PlaceHumanInUnit ( un_list [ i ] , veh_list [ i ] ) ;
2606: LD_VAR 0 6
2610: PUSH
2611: LD_VAR 0 7
2615: ARRAY
2616: PPUSH
2617: LD_VAR 0 3
2621: PUSH
2622: LD_VAR 0 7
2626: ARRAY
2627: PPUSH
2628: CALL_OW 52
// PlaceUnitArea ( veh_list [ i ] , start_leave_area , false ) ;
2632: LD_VAR 0 3
2636: PUSH
2637: LD_VAR 0 7
2641: ARRAY
2642: PPUSH
2643: LD_INT 4
2645: PPUSH
2646: LD_INT 0
2648: PPUSH
2649: CALL_OW 49
// end else
2653: GO 2676
// PlaceUnitArea ( un_list [ i ] , start_leave_area , false ) ;
2655: LD_VAR 0 6
2659: PUSH
2660: LD_VAR 0 7
2664: ARRAY
2665: PPUSH
2666: LD_INT 4
2668: PPUSH
2669: LD_INT 0
2671: PPUSH
2672: CALL_OW 49
2676: GO 2591
2678: POP
2679: POP
// Abdul = NewCharacter ( Abdul ) ;
2680: LD_ADDR_EXP 16
2684: PUSH
2685: LD_STRING Abdul
2687: PPUSH
2688: CALL_OW 25
2692: ST_TO_ADDR
// Omar = NewCharacter ( Omar ) ;
2693: LD_ADDR_EXP 20
2697: PUSH
2698: LD_STRING Omar
2700: PPUSH
2701: CALL_OW 25
2705: ST_TO_ADDR
// end ;
2706: LD_VAR 0 1
2710: RET
// export function PrepareArabBase ( survivors_are_dead ) ; var un_list , situation , temp_list , val , i , temp_unit ; begin
2711: LD_INT 0
2713: PPUSH
2714: PPUSH
2715: PPUSH
2716: PPUSH
2717: PPUSH
2718: PPUSH
2719: PPUSH
// uc_side = you_alt ;
2720: LD_ADDR_OWVAR 20
2724: PUSH
2725: LD_EXP 5
2729: ST_TO_ADDR
// uc_nation = nation_arabian ;
2730: LD_ADDR_OWVAR 21
2734: PUSH
2735: LD_INT 2
2737: ST_TO_ADDR
// MarkB = NewCharacter ( Mark ) ;
2738: LD_ADDR_EXP 17
2742: PUSH
2743: LD_STRING Mark
2745: PPUSH
2746: CALL_OW 25
2750: ST_TO_ADDR
// SetClass ( MarkB , class_soldier ) ;
2751: LD_EXP 17
2755: PPUSH
2756: LD_INT 1
2758: PPUSH
2759: CALL_OW 336
// Swansson = NewCharacter ( Swansson ) ;
2763: LD_ADDR_EXP 21
2767: PUSH
2768: LD_STRING Swansson
2770: PPUSH
2771: CALL_OW 25
2775: ST_TO_ADDR
// SetClass ( Swansson , class_soldier ) ;
2776: LD_EXP 21
2780: PPUSH
2781: LD_INT 1
2783: PPUSH
2784: CALL_OW 336
// InitHc ;
2788: CALL_OW 19
// un_list = [ ] ;
2792: LD_ADDR_VAR 0 3
2796: PUSH
2797: EMPTY
2798: ST_TO_ADDR
// for i = 1 to 2 do
2799: LD_ADDR_VAR 0 7
2803: PUSH
2804: DOUBLE
2805: LD_INT 1
2807: DEC
2808: ST_TO_ADDR
2809: LD_INT 2
2811: PUSH
2812: FOR_TO
2813: IFFALSE 3011
// begin uc_direction = Rand ( 0 , 5 ) ;
2815: LD_ADDR_OWVAR 24
2819: PUSH
2820: LD_INT 0
2822: PPUSH
2823: LD_INT 5
2825: PPUSH
2826: CALL_OW 12
2830: ST_TO_ADDR
// case Rand ( 1 , 4 ) of 1 :
2831: LD_INT 1
2833: PPUSH
2834: LD_INT 4
2836: PPUSH
2837: CALL_OW 12
2841: PUSH
2842: LD_INT 1
2844: DOUBLE
2845: EQUAL
2846: IFTRUE 2850
2848: GO 2861
2850: POP
// val = class_soldier ; 2 :
2851: LD_ADDR_VAR 0 6
2855: PUSH
2856: LD_INT 1
2858: ST_TO_ADDR
2859: GO 2919
2861: LD_INT 2
2863: DOUBLE
2864: EQUAL
2865: IFTRUE 2869
2867: GO 2880
2869: POP
// val = class_engineer ; 3 :
2870: LD_ADDR_VAR 0 6
2874: PUSH
2875: LD_INT 2
2877: ST_TO_ADDR
2878: GO 2919
2880: LD_INT 3
2882: DOUBLE
2883: EQUAL
2884: IFTRUE 2888
2886: GO 2899
2888: POP
// val = class_mechanic ; 4 :
2889: LD_ADDR_VAR 0 6
2893: PUSH
2894: LD_INT 3
2896: ST_TO_ADDR
2897: GO 2919
2899: LD_INT 4
2901: DOUBLE
2902: EQUAL
2903: IFTRUE 2907
2905: GO 2918
2907: POP
// val = class_scientistic ; end ;
2908: LD_ADDR_VAR 0 6
2912: PUSH
2913: LD_INT 4
2915: ST_TO_ADDR
2916: GO 2919
2918: POP
// PrepareHuman ( false , val , 4 ) ;
2919: LD_INT 0
2921: PPUSH
2922: LD_VAR 0 6
2926: PPUSH
2927: LD_INT 4
2929: PPUSH
2930: CALL_OW 380
// temp_unit = CreateHuman ;
2934: LD_ADDR_VAR 0 8
2938: PUSH
2939: CALL_OW 44
2943: ST_TO_ADDR
// SetClass ( temp_unit , class_soldier ) ;
2944: LD_VAR 0 8
2948: PPUSH
2949: LD_INT 1
2951: PPUSH
2952: CALL_OW 336
// if GetSkill ( temp_unit , val ) > 4 then
2956: LD_VAR 0 8
2960: PPUSH
2961: LD_VAR 0 6
2965: PPUSH
2966: CALL_OW 259
2970: PUSH
2971: LD_INT 4
2973: GREATER
2974: IFFALSE 2993
// SetSkill ( temp_unit , val , 4 ) ;
2976: LD_VAR 0 8
2980: PPUSH
2981: LD_VAR 0 6
2985: PPUSH
2986: LD_INT 4
2988: PPUSH
2989: CALL_OW 237
// un_list = un_list ^ temp_unit ;
2993: LD_ADDR_VAR 0 3
2997: PUSH
2998: LD_VAR 0 3
3002: PUSH
3003: LD_VAR 0 8
3007: ADD
3008: ST_TO_ADDR
// end ;
3009: GO 2812
3011: POP
3012: POP
// un_list = un_list ^ Swansson ;
3013: LD_ADDR_VAR 0 3
3017: PUSH
3018: LD_VAR 0 3
3022: PUSH
3023: LD_EXP 21
3027: ADD
3028: ST_TO_ADDR
// if not survivors_are_dead then
3029: LD_VAR 0 1
3033: NOT
3034: IFFALSE 3054
// situation = LoadVariable ( Time_determined_situation_05_cont , 1 ) else
3036: LD_ADDR_VAR 0 4
3040: PUSH
3041: LD_STRING Time_determined_situation_05_cont
3043: PPUSH
3044: LD_INT 1
3046: PPUSH
3047: CALL_OW 30
3051: ST_TO_ADDR
3052: GO 3062
// situation = 1 ;
3054: LD_ADDR_VAR 0 4
3058: PUSH
3059: LD_INT 1
3061: ST_TO_ADDR
// temp_list = [ arb1 , arb2 , arb3 , arb4 ] ;
3062: LD_ADDR_VAR 0 5
3066: PUSH
3067: LD_INT 60
3069: PUSH
3070: LD_INT 62
3072: PUSH
3073: LD_INT 65
3075: PUSH
3076: LD_INT 99
3078: PUSH
3079: EMPTY
3080: LIST
3081: LIST
3082: LIST
3083: LIST
3084: ST_TO_ADDR
// for i = 3 downto situation do
3085: LD_ADDR_VAR 0 7
3089: PUSH
3090: DOUBLE
3091: LD_INT 3
3093: INC
3094: ST_TO_ADDR
3095: LD_VAR 0 4
3099: PUSH
3100: FOR_DOWNTO
3101: IFFALSE 3165
// begin val = Rand ( 1 , temp_list - 1 ) ;
3103: LD_ADDR_VAR 0 6
3107: PUSH
3108: LD_INT 1
3110: PPUSH
3111: LD_VAR 0 5
3115: PUSH
3116: LD_INT 1
3118: MINUS
3119: PPUSH
3120: CALL_OW 12
3124: ST_TO_ADDR
// SetLives ( temp_list [ val ] , 1 ) ;
3125: LD_VAR 0 5
3129: PUSH
3130: LD_VAR 0 6
3134: ARRAY
3135: PPUSH
3136: LD_INT 1
3138: PPUSH
3139: CALL_OW 234
// temp_list = Delete ( temp_list , val ) ;
3143: LD_ADDR_VAR 0 5
3147: PUSH
3148: LD_VAR 0 5
3152: PPUSH
3153: LD_VAR 0 6
3157: PPUSH
3158: CALL_OW 3
3162: ST_TO_ADDR
// end ;
3163: GO 3100
3165: POP
3166: POP
// for val in temp_list do
3167: LD_ADDR_VAR 0 6
3171: PUSH
3172: LD_VAR 0 5
3176: PUSH
3177: FOR_IN
3178: IFFALSE 3212
// SetLives ( val , Rand ( 250 , 400 ) + 75 * situation ) ;
3180: LD_VAR 0 6
3184: PPUSH
3185: LD_INT 250
3187: PPUSH
3188: LD_INT 400
3190: PPUSH
3191: CALL_OW 12
3195: PUSH
3196: LD_INT 75
3198: PUSH
3199: LD_VAR 0 4
3203: MUL
3204: PLUS
3205: PPUSH
3206: CALL_OW 234
3210: GO 3177
3212: POP
3213: POP
// SetLives ( ardep , Rand ( 250 + 50 * situation , 500 ) ) ;
3214: LD_INT 59
3216: PPUSH
3217: LD_INT 250
3219: PUSH
3220: LD_INT 50
3222: PUSH
3223: LD_VAR 0 4
3227: MUL
3228: PLUS
3229: PPUSH
3230: LD_INT 500
3232: PPUSH
3233: CALL_OW 12
3237: PPUSH
3238: CALL_OW 234
// PlaceUnitXYR ( MarkB , GetX ( arb4 ) , GetY ( arb4 ) , 4 , false ) ;
3242: LD_EXP 17
3246: PPUSH
3247: LD_INT 99
3249: PPUSH
3250: CALL_OW 250
3254: PPUSH
3255: LD_INT 99
3257: PPUSH
3258: CALL_OW 251
3262: PPUSH
3263: LD_INT 4
3265: PPUSH
3266: LD_INT 0
3268: PPUSH
3269: CALL_OW 50
// if not survivors_are_dead then
3273: LD_VAR 0 1
3277: NOT
3278: IFFALSE 3294
// ComEnterUnit ( MarkB , arb4 ) else
3280: LD_EXP 17
3284: PPUSH
3285: LD_INT 99
3287: PPUSH
3288: CALL_OW 120
3292: GO 3316
// begin SetLives ( arb4 , 220 ) ;
3294: LD_INT 99
3296: PPUSH
3297: LD_INT 220
3299: PPUSH
3300: CALL_OW 234
// SetLives ( MarkB , 1 ) ;
3304: LD_EXP 17
3308: PPUSH
3309: LD_INT 1
3311: PPUSH
3312: CALL_OW 234
// end ; temp_list = SortListByListAsc ( [ arb1 , arb2 , arb3 ] , [ GetLives ( arb1 ) , GetLives ( arb2 ) , GetLives ( arb3 ) ] ) ;
3316: LD_ADDR_VAR 0 5
3320: PUSH
3321: LD_INT 60
3323: PUSH
3324: LD_INT 62
3326: PUSH
3327: LD_INT 65
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: PPUSH
3335: LD_INT 60
3337: PPUSH
3338: CALL_OW 256
3342: PUSH
3343: LD_INT 62
3345: PPUSH
3346: CALL_OW 256
3350: PUSH
3351: LD_INT 65
3353: PPUSH
3354: CALL_OW 256
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 76
3368: ST_TO_ADDR
// for val = 1 to un_list do
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: DOUBLE
3375: LD_INT 1
3377: DEC
3378: ST_TO_ADDR
3379: LD_VAR 0 3
3383: PUSH
3384: FOR_TO
3385: IFFALSE 3506
// begin PlaceUnitXYR ( un_list [ val ] , GetX ( temp_list [ val ] ) , GetY ( temp_list [ val ] ) , 4 , false ) ;
3387: LD_VAR 0 3
3391: PUSH
3392: LD_VAR 0 6
3396: ARRAY
3397: PPUSH
3398: LD_VAR 0 5
3402: PUSH
3403: LD_VAR 0 6
3407: ARRAY
3408: PPUSH
3409: CALL_OW 250
3413: PPUSH
3414: LD_VAR 0 5
3418: PUSH
3419: LD_VAR 0 6
3423: ARRAY
3424: PPUSH
3425: CALL_OW 251
3429: PPUSH
3430: LD_INT 4
3432: PPUSH
3433: LD_INT 0
3435: PPUSH
3436: CALL_OW 50
// if not IsOk ( temp_list [ val ] ) then
3440: LD_VAR 0 5
3444: PUSH
3445: LD_VAR 0 6
3449: ARRAY
3450: PPUSH
3451: CALL_OW 302
3455: NOT
3456: IFFALSE 3478
// SetLives ( un_list [ val ] , 1 ) else
3458: LD_VAR 0 3
3462: PUSH
3463: LD_VAR 0 6
3467: ARRAY
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 234
3476: GO 3504
// ComEnterUnit ( un_list [ val ] , temp_list [ val ] ) ;
3478: LD_VAR 0 3
3482: PUSH
3483: LD_VAR 0 6
3487: ARRAY
3488: PPUSH
3489: LD_VAR 0 5
3493: PUSH
3494: LD_VAR 0 6
3498: ARRAY
3499: PPUSH
3500: CALL_OW 120
// end ;
3504: GO 3384
3506: POP
3507: POP
// SetResourceType ( GetBase ( ardep ) , mat_cans , [ 30 , 20 , 10 ] [ difficulty ] ) ;
3508: LD_INT 59
3510: PPUSH
3511: CALL_OW 274
3515: PPUSH
3516: LD_INT 1
3518: PPUSH
3519: LD_INT 30
3521: PUSH
3522: LD_INT 20
3524: PUSH
3525: LD_INT 10
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: LIST
3532: PUSH
3533: LD_OWVAR 67
3537: ARRAY
3538: PPUSH
3539: CALL_OW 277
// end ;
3543: LD_VAR 0 2
3547: RET
// function ScanBuildings ; var side , i , temp_list , base , area ; begin
3548: LD_INT 0
3550: PPUSH
3551: PPUSH
3552: PPUSH
3553: PPUSH
3554: PPUSH
3555: PPUSH
// side = russians ;
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_EXP 3
3565: ST_TO_ADDR
// for base in ai_bases do
3566: LD_ADDR_VAR 0 5
3570: PUSH
3571: LD_EXP 49
3575: PUSH
3576: FOR_IN
3577: IFFALSE 3963
// begin case base of 1 :
3579: LD_VAR 0 5
3583: PUSH
3584: LD_INT 1
3586: DOUBLE
3587: EQUAL
3588: IFTRUE 3592
3590: GO 3603
3592: POP
// area = rubase1 ; 2 :
3593: LD_ADDR_VAR 0 6
3597: PUSH
3598: LD_INT 3
3600: ST_TO_ADDR
3601: GO 3642
3603: LD_INT 2
3605: DOUBLE
3606: EQUAL
3607: IFTRUE 3611
3609: GO 3622
3611: POP
// area = rubase2 ; 3 :
3612: LD_ADDR_VAR 0 6
3616: PUSH
3617: LD_INT 2
3619: ST_TO_ADDR
3620: GO 3642
3622: LD_INT 3
3624: DOUBLE
3625: EQUAL
3626: IFTRUE 3630
3628: GO 3641
3630: POP
// area = rubase3 ; end ;
3631: LD_ADDR_VAR 0 6
3635: PUSH
3636: LD_INT 1
3638: ST_TO_ADDR
3639: GO 3642
3641: POP
// ai_all_buildings = Replace ( ai_all_buildings , base , FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_inarea , area ] ] ) ) ;
3642: LD_ADDR_EXP 36
3646: PUSH
3647: LD_EXP 36
3651: PPUSH
3652: LD_VAR 0 5
3656: PPUSH
3657: LD_INT 22
3659: PUSH
3660: LD_VAR 0 2
3664: PUSH
3665: EMPTY
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 21
3671: PUSH
3672: LD_INT 3
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 95
3681: PUSH
3682: LD_VAR 0 6
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: LIST
3695: PPUSH
3696: CALL_OW 69
3700: PPUSH
3701: CALL_OW 1
3705: ST_TO_ADDR
// for i in ai_all_buildings [ base ] do
3706: LD_ADDR_VAR 0 3
3710: PUSH
3711: LD_EXP 36
3715: PUSH
3716: LD_VAR 0 5
3720: ARRAY
3721: PUSH
3722: FOR_IN
3723: IFFALSE 3744
// UpdateBuildingBasicVariables ( base , i , true ) ;
3725: LD_VAR 0 5
3729: PPUSH
3730: LD_VAR 0 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL 3970 0 3
3742: GO 3722
3744: POP
3745: POP
// temp_list = [ ] ;
3746: LD_ADDR_VAR 0 4
3750: PUSH
3751: EMPTY
3752: ST_TO_ADDR
// for i in ai_all_buildings [ base ] do
3753: LD_ADDR_VAR 0 3
3757: PUSH
3758: LD_EXP 36
3762: PUSH
3763: LD_VAR 0 5
3767: ARRAY
3768: PUSH
3769: FOR_IN
3770: IFFALSE 3873
// temp_list = temp_list ^ [ [ GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBType ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
3772: LD_ADDR_VAR 0 4
3776: PUSH
3777: LD_VAR 0 4
3781: PUSH
3782: LD_VAR 0 3
3786: PPUSH
3787: CALL_OW 250
3791: PUSH
3792: LD_VAR 0 3
3796: PPUSH
3797: CALL_OW 251
3801: PUSH
3802: LD_VAR 0 3
3806: PPUSH
3807: CALL_OW 254
3811: PUSH
3812: LD_VAR 0 3
3816: PPUSH
3817: CALL_OW 266
3821: PUSH
3822: LD_VAR 0 3
3826: PPUSH
3827: LD_INT 1
3829: PPUSH
3830: CALL_OW 268
3834: PUSH
3835: LD_VAR 0 3
3839: PPUSH
3840: LD_INT 2
3842: PPUSH
3843: CALL_OW 268
3847: PUSH
3848: LD_VAR 0 3
3852: PPUSH
3853: CALL_OW 269
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: LIST
3866: PUSH
3867: EMPTY
3868: LIST
3869: ADD
3870: ST_TO_ADDR
3871: GO 3769
3873: POP
3874: POP
// ai_buildings_locations = Replace ( ai_buildings_locations , base , temp_list ) ;
3875: LD_ADDR_EXP 30
3879: PUSH
3880: LD_EXP 30
3884: PPUSH
3885: LD_VAR 0 5
3889: PPUSH
3890: LD_VAR 0 4
3894: PPUSH
3895: CALL_OW 1
3899: ST_TO_ADDR
// SortBuildingLocationsListInCorrectOrder ( base ) ;
3900: LD_VAR 0 5
3904: PPUSH
3905: CALL 4863 0 1
// for i in ai_oil_mine [ base ] do
3909: LD_ADDR_VAR 0 3
3913: PUSH
3914: LD_EXP 42
3918: PUSH
3919: LD_VAR 0 5
3923: ARRAY
3924: PUSH
3925: FOR_IN
3926: IFFALSE 3959
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
3928: LD_VAR 0 3
3932: PPUSH
3933: CALL_OW 250
3937: PPUSH
3938: LD_VAR 0 3
3942: PPUSH
3943: CALL_OW 251
3947: PPUSH
3948: LD_VAR 0 2
3952: PPUSH
3953: CALL_OW 441
3957: GO 3925
3959: POP
3960: POP
// end ;
3961: GO 3576
3963: POP
3964: POP
// end ;
3965: LD_VAR 0 1
3969: RET
// export function UpdateBuildingBasicVariables ( base , un , add ) ; var temp_list ; begin
3970: LD_INT 0
3972: PPUSH
3973: PPUSH
// case GetBType ( un ) of b_depot , b_warehouse :
3974: LD_VAR 0 2
3978: PPUSH
3979: CALL_OW 266
3983: PUSH
3984: LD_INT 0
3986: DOUBLE
3987: EQUAL
3988: IFTRUE 3998
3990: LD_INT 1
3992: DOUBLE
3993: EQUAL
3994: IFTRUE 3998
3996: GO 4075
3998: POP
// if add then
3999: LD_VAR 0 3
4003: IFFALSE 4032
// ai_depot = Replace ( ai_depot , base , un ) else
4005: LD_ADDR_EXP 27
4009: PUSH
4010: LD_EXP 27
4014: PPUSH
4015: LD_VAR 0 1
4019: PPUSH
4020: LD_VAR 0 2
4024: PPUSH
4025: CALL_OW 1
4029: ST_TO_ADDR
4030: GO 4073
// if un = ai_depot [ base ] then
4032: LD_VAR 0 2
4036: PUSH
4037: LD_EXP 27
4041: PUSH
4042: LD_VAR 0 1
4046: ARRAY
4047: EQUAL
4048: IFFALSE 4073
// ai_depot = Replace ( ai_depot , base , 0 ) ; b_lab , b_lab_half , b_lab_full :
4050: LD_ADDR_EXP 27
4054: PUSH
4055: LD_EXP 27
4059: PPUSH
4060: LD_VAR 0 1
4064: PPUSH
4065: LD_INT 0
4067: PPUSH
4068: CALL_OW 1
4072: ST_TO_ADDR
4073: GO 4858
4075: LD_INT 6
4077: DOUBLE
4078: EQUAL
4079: IFTRUE 4095
4081: LD_INT 7
4083: DOUBLE
4084: EQUAL
4085: IFTRUE 4095
4087: LD_INT 8
4089: DOUBLE
4090: EQUAL
4091: IFTRUE 4095
4093: GO 4172
4095: POP
// if add then
4096: LD_VAR 0 3
4100: IFFALSE 4129
// ai_lab = Replace ( ai_lab , base , un ) else
4102: LD_ADDR_EXP 28
4106: PUSH
4107: LD_EXP 28
4111: PPUSH
4112: LD_VAR 0 1
4116: PPUSH
4117: LD_VAR 0 2
4121: PPUSH
4122: CALL_OW 1
4126: ST_TO_ADDR
4127: GO 4170
// if un = ai_lab [ base ] then
4129: LD_VAR 0 2
4133: PUSH
4134: LD_EXP 28
4138: PUSH
4139: LD_VAR 0 1
4143: ARRAY
4144: EQUAL
4145: IFFALSE 4170
// ai_lab = Replace ( ai_lab , base , 0 ) ; b_factory , b_workshop :
4147: LD_ADDR_EXP 28
4151: PUSH
4152: LD_EXP 28
4156: PPUSH
4157: LD_VAR 0 1
4161: PPUSH
4162: LD_INT 0
4164: PPUSH
4165: CALL_OW 1
4169: ST_TO_ADDR
4170: GO 4858
4172: LD_INT 3
4174: DOUBLE
4175: EQUAL
4176: IFTRUE 4186
4178: LD_INT 2
4180: DOUBLE
4181: EQUAL
4182: IFTRUE 4186
4184: GO 4263
4186: POP
// if add then
4187: LD_VAR 0 3
4191: IFFALSE 4220
// ai_fact = Replace ( ai_fact , base , un ) else
4193: LD_ADDR_EXP 39
4197: PUSH
4198: LD_EXP 39
4202: PPUSH
4203: LD_VAR 0 1
4207: PPUSH
4208: LD_VAR 0 2
4212: PPUSH
4213: CALL_OW 1
4217: ST_TO_ADDR
4218: GO 4261
// if un = ai_fact [ base ] then
4220: LD_VAR 0 2
4224: PUSH
4225: LD_EXP 39
4229: PUSH
4230: LD_VAR 0 1
4234: ARRAY
4235: EQUAL
4236: IFFALSE 4261
// ai_fact = Replace ( ai_fact , base , 0 ) ; b_armoury , b_barracks :
4238: LD_ADDR_EXP 39
4242: PUSH
4243: LD_EXP 39
4247: PPUSH
4248: LD_VAR 0 1
4252: PPUSH
4253: LD_INT 0
4255: PPUSH
4256: CALL_OW 1
4260: ST_TO_ADDR
4261: GO 4858
4263: LD_INT 4
4265: DOUBLE
4266: EQUAL
4267: IFTRUE 4277
4269: LD_INT 5
4271: DOUBLE
4272: EQUAL
4273: IFTRUE 4277
4275: GO 4354
4277: POP
// if add then
4278: LD_VAR 0 3
4282: IFFALSE 4311
// ai_armoury = Replace ( ai_armoury , base , un ) else
4284: LD_ADDR_EXP 40
4288: PUSH
4289: LD_EXP 40
4293: PPUSH
4294: LD_VAR 0 1
4298: PPUSH
4299: LD_VAR 0 2
4303: PPUSH
4304: CALL_OW 1
4308: ST_TO_ADDR
4309: GO 4352
// if un = ai_armoury [ base ] then
4311: LD_VAR 0 2
4315: PUSH
4316: LD_EXP 40
4320: PUSH
4321: LD_VAR 0 1
4325: ARRAY
4326: EQUAL
4327: IFFALSE 4352
// ai_armoury = Replace ( ai_armoury , base , 0 ) ; b_breastwork , b_bunker :
4329: LD_ADDR_EXP 40
4333: PUSH
4334: LD_EXP 40
4338: PPUSH
4339: LD_VAR 0 1
4343: PPUSH
4344: LD_INT 0
4346: PPUSH
4347: CALL_OW 1
4351: ST_TO_ADDR
4352: GO 4858
4354: LD_INT 31
4356: DOUBLE
4357: EQUAL
4358: IFTRUE 4368
4360: LD_INT 32
4362: DOUBLE
4363: EQUAL
4364: IFTRUE 4368
4366: GO 4448
4368: POP
// begin if add then
4369: LD_VAR 0 3
4373: IFFALSE 4399
// temp_list = ai_bunkers [ base ] ^ un else
4375: LD_ADDR_VAR 0 5
4379: PUSH
4380: LD_EXP 41
4384: PUSH
4385: LD_VAR 0 1
4389: ARRAY
4390: PUSH
4391: LD_VAR 0 2
4395: ADD
4396: ST_TO_ADDR
4397: GO 4421
// temp_list = ai_bunkers [ base ] diff un ;
4399: LD_ADDR_VAR 0 5
4403: PUSH
4404: LD_EXP 41
4408: PUSH
4409: LD_VAR 0 1
4413: ARRAY
4414: PUSH
4415: LD_VAR 0 2
4419: DIFF
4420: ST_TO_ADDR
// ai_bunkers = Replace ( ai_bunkers , base , temp_list ) ;
4421: LD_ADDR_EXP 41
4425: PUSH
4426: LD_EXP 41
4430: PPUSH
4431: LD_VAR 0 1
4435: PPUSH
4436: LD_VAR 0 5
4440: PPUSH
4441: CALL_OW 1
4445: ST_TO_ADDR
// end ; b_turret :
4446: GO 4858
4448: LD_INT 33
4450: DOUBLE
4451: EQUAL
4452: IFTRUE 4456
4454: GO 4536
4456: POP
// begin if add then
4457: LD_VAR 0 3
4461: IFFALSE 4487
// temp_list = ai_turrets [ base ] ^ un else
4463: LD_ADDR_VAR 0 5
4467: PUSH
4468: LD_EXP 47
4472: PUSH
4473: LD_VAR 0 1
4477: ARRAY
4478: PUSH
4479: LD_VAR 0 2
4483: ADD
4484: ST_TO_ADDR
4485: GO 4509
// temp_list = ai_turrets [ base ] diff un ;
4487: LD_ADDR_VAR 0 5
4491: PUSH
4492: LD_EXP 47
4496: PUSH
4497: LD_VAR 0 1
4501: ARRAY
4502: PUSH
4503: LD_VAR 0 2
4507: DIFF
4508: ST_TO_ADDR
// ai_turrets = Replace ( ai_turrets , base , temp_list ) ;
4509: LD_ADDR_EXP 47
4513: PUSH
4514: LD_EXP 47
4518: PPUSH
4519: LD_VAR 0 1
4523: PPUSH
4524: LD_VAR 0 5
4528: PPUSH
4529: CALL_OW 1
4533: ST_TO_ADDR
// end ; b_oil_mine :
4534: GO 4858
4536: LD_INT 29
4538: DOUBLE
4539: EQUAL
4540: IFTRUE 4544
4542: GO 4621
4544: POP
// if add then
4545: LD_VAR 0 3
4549: IFFALSE 4578
// ai_oil_mine = Replace ( ai_oil_mine , base , un ) else
4551: LD_ADDR_EXP 42
4555: PUSH
4556: LD_EXP 42
4560: PPUSH
4561: LD_VAR 0 1
4565: PPUSH
4566: LD_VAR 0 2
4570: PPUSH
4571: CALL_OW 1
4575: ST_TO_ADDR
4576: GO 4619
// if un = ai_oil_mine [ base ] then
4578: LD_VAR 0 2
4582: PUSH
4583: LD_EXP 42
4587: PUSH
4588: LD_VAR 0 1
4592: ARRAY
4593: EQUAL
4594: IFFALSE 4619
// ai_oil_mine = Replace ( ai_oil_mine , base , 0 ) ; b_ext_gun , b_ext_noncombat , b_ext_laser , b_ext_computer , b_ext_radar , b_ext_rocket , b_ext_siberium , b_ext_track , b_ext_stitch :
4596: LD_ADDR_EXP 42
4600: PUSH
4601: LD_EXP 42
4605: PPUSH
4606: LD_VAR 0 1
4610: PPUSH
4611: LD_INT 0
4613: PPUSH
4614: CALL_OW 1
4618: ST_TO_ADDR
4619: GO 4858
4621: LD_INT 17
4623: DOUBLE
4624: EQUAL
4625: IFTRUE 4677
4627: LD_INT 19
4629: DOUBLE
4630: EQUAL
4631: IFTRUE 4677
4633: LD_INT 25
4635: DOUBLE
4636: EQUAL
4637: IFTRUE 4677
4639: LD_INT 24
4641: DOUBLE
4642: EQUAL
4643: IFTRUE 4677
4645: LD_INT 20
4647: DOUBLE
4648: EQUAL
4649: IFTRUE 4677
4651: LD_INT 18
4653: DOUBLE
4654: EQUAL
4655: IFTRUE 4677
4657: LD_INT 21
4659: DOUBLE
4660: EQUAL
4661: IFTRUE 4677
4663: LD_INT 16
4665: DOUBLE
4666: EQUAL
4667: IFTRUE 4677
4669: LD_INT 23
4671: DOUBLE
4672: EQUAL
4673: IFTRUE 4677
4675: GO 4757
4677: POP
// begin if add then
4678: LD_VAR 0 3
4682: IFFALSE 4708
// temp_list = ai_fact_extensions [ base ] ^ un else
4684: LD_ADDR_VAR 0 5
4688: PUSH
4689: LD_EXP 43
4693: PUSH
4694: LD_VAR 0 1
4698: ARRAY
4699: PUSH
4700: LD_VAR 0 2
4704: ADD
4705: ST_TO_ADDR
4706: GO 4730
// temp_list = ai_fact_extensions [ base ] diff un ;
4708: LD_ADDR_VAR 0 5
4712: PUSH
4713: LD_EXP 43
4717: PUSH
4718: LD_VAR 0 1
4722: ARRAY
4723: PUSH
4724: LD_VAR 0 2
4728: DIFF
4729: ST_TO_ADDR
// ai_fact_extensions = Replace ( ai_fact_extensions , base , temp_list ) ;
4730: LD_ADDR_EXP 43
4734: PUSH
4735: LD_EXP 43
4739: PPUSH
4740: LD_VAR 0 1
4744: PPUSH
4745: LD_VAR 0 5
4749: PPUSH
4750: CALL_OW 1
4754: ST_TO_ADDR
// end ; b_solar_power , b_oil_power , b_siberite_power :
4755: GO 4858
4757: LD_INT 27
4759: DOUBLE
4760: EQUAL
4761: IFTRUE 4777
4763: LD_INT 26
4765: DOUBLE
4766: EQUAL
4767: IFTRUE 4777
4769: LD_INT 28
4771: DOUBLE
4772: EQUAL
4773: IFTRUE 4777
4775: GO 4857
4777: POP
// begin if add then
4778: LD_VAR 0 3
4782: IFFALSE 4808
// temp_list = ai_power_plants [ base ] ^ un else
4784: LD_ADDR_VAR 0 5
4788: PUSH
4789: LD_EXP 29
4793: PUSH
4794: LD_VAR 0 1
4798: ARRAY
4799: PUSH
4800: LD_VAR 0 2
4804: ADD
4805: ST_TO_ADDR
4806: GO 4830
// temp_list = ai_power_plants [ base ] diff un ;
4808: LD_ADDR_VAR 0 5
4812: PUSH
4813: LD_EXP 29
4817: PUSH
4818: LD_VAR 0 1
4822: ARRAY
4823: PUSH
4824: LD_VAR 0 2
4828: DIFF
4829: ST_TO_ADDR
// ai_power_plants = Replace ( ai_power_plants , base , temp_list ) ;
4830: LD_ADDR_EXP 29
4834: PUSH
4835: LD_EXP 29
4839: PPUSH
4840: LD_VAR 0 1
4844: PPUSH
4845: LD_VAR 0 5
4849: PPUSH
4850: CALL_OW 1
4854: ST_TO_ADDR
// end ; end ;
4855: GO 4858
4857: POP
// end ;
4858: LD_VAR 0 4
4862: RET
// function SortBuildingLocationsListInCorrectOrder ( base ) ; var i , temp_list , p ; begin
4863: LD_INT 0
4865: PPUSH
4866: PPUSH
4867: PPUSH
4868: PPUSH
// temp_list = [ ] ;
4869: LD_ADDR_VAR 0 4
4873: PUSH
4874: EMPTY
4875: ST_TO_ADDR
// for i in ai_buildings_locations [ base ] do
4876: LD_ADDR_VAR 0 3
4880: PUSH
4881: LD_EXP 30
4885: PUSH
4886: LD_VAR 0 1
4890: ARRAY
4891: PUSH
4892: FOR_IN
4893: IFFALSE 5266
// begin case i [ 4 ] of b_depot , b_warehouse :
4895: LD_VAR 0 3
4899: PUSH
4900: LD_INT 4
4902: ARRAY
4903: PUSH
4904: LD_INT 0
4906: DOUBLE
4907: EQUAL
4908: IFTRUE 4918
4910: LD_INT 1
4912: DOUBLE
4913: EQUAL
4914: IFTRUE 4918
4916: GO 4929
4918: POP
// p = 100 ; b_armoury , b_barracks , b_fort :
4919: LD_ADDR_VAR 0 5
4923: PUSH
4924: LD_INT 100
4926: ST_TO_ADDR
4927: GO 5248
4929: LD_INT 4
4931: DOUBLE
4932: EQUAL
4933: IFTRUE 4949
4935: LD_INT 5
4937: DOUBLE
4938: EQUAL
4939: IFTRUE 4949
4941: LD_INT 35
4943: DOUBLE
4944: EQUAL
4945: IFTRUE 4949
4947: GO 4960
4949: POP
// p = 99 ; b_solar_power , b_oil_power , b_siberite_power :
4950: LD_ADDR_VAR 0 5
4954: PUSH
4955: LD_INT 99
4957: ST_TO_ADDR
4958: GO 5248
4960: LD_INT 27
4962: DOUBLE
4963: EQUAL
4964: IFTRUE 4980
4966: LD_INT 26
4968: DOUBLE
4969: EQUAL
4970: IFTRUE 4980
4972: LD_INT 28
4974: DOUBLE
4975: EQUAL
4976: IFTRUE 4980
4978: GO 4991
4980: POP
// p = 98 ; b_breastwork :
4981: LD_ADDR_VAR 0 5
4985: PUSH
4986: LD_INT 98
4988: ST_TO_ADDR
4989: GO 5248
4991: LD_INT 31
4993: DOUBLE
4994: EQUAL
4995: IFTRUE 4999
4997: GO 5010
4999: POP
// p = 97 ; b_factory , b_workshop :
5000: LD_ADDR_VAR 0 5
5004: PUSH
5005: LD_INT 97
5007: ST_TO_ADDR
5008: GO 5248
5010: LD_INT 3
5012: DOUBLE
5013: EQUAL
5014: IFTRUE 5024
5016: LD_INT 2
5018: DOUBLE
5019: EQUAL
5020: IFTRUE 5024
5022: GO 5035
5024: POP
// p = 96 ; b_ext_gun , b_ext_noncombat , b_ext_laser , b_ext_computer , b_ext_radar , b_ext_rocket , b_ext_siberium , b_ext_track , b_ext_stitch :
5025: LD_ADDR_VAR 0 5
5029: PUSH
5030: LD_INT 96
5032: ST_TO_ADDR
5033: GO 5248
5035: LD_INT 17
5037: DOUBLE
5038: EQUAL
5039: IFTRUE 5091
5041: LD_INT 19
5043: DOUBLE
5044: EQUAL
5045: IFTRUE 5091
5047: LD_INT 25
5049: DOUBLE
5050: EQUAL
5051: IFTRUE 5091
5053: LD_INT 24
5055: DOUBLE
5056: EQUAL
5057: IFTRUE 5091
5059: LD_INT 20
5061: DOUBLE
5062: EQUAL
5063: IFTRUE 5091
5065: LD_INT 18
5067: DOUBLE
5068: EQUAL
5069: IFTRUE 5091
5071: LD_INT 21
5073: DOUBLE
5074: EQUAL
5075: IFTRUE 5091
5077: LD_INT 16
5079: DOUBLE
5080: EQUAL
5081: IFTRUE 5091
5083: LD_INT 23
5085: DOUBLE
5086: EQUAL
5087: IFTRUE 5091
5089: GO 5102
5091: POP
// p = 95 ; b_bunker :
5092: LD_ADDR_VAR 0 5
5096: PUSH
5097: LD_INT 95
5099: ST_TO_ADDR
5100: GO 5248
5102: LD_INT 32
5104: DOUBLE
5105: EQUAL
5106: IFTRUE 5110
5108: GO 5121
5110: POP
// p = 94 ; b_control_tower :
5111: LD_ADDR_VAR 0 5
5115: PUSH
5116: LD_INT 94
5118: ST_TO_ADDR
5119: GO 5248
5121: LD_INT 36
5123: DOUBLE
5124: EQUAL
5125: IFTRUE 5129
5127: GO 5140
5129: POP
// p = 93 ; b_turret :
5130: LD_ADDR_VAR 0 5
5134: PUSH
5135: LD_INT 93
5137: ST_TO_ADDR
5138: GO 5248
5140: LD_INT 33
5142: DOUBLE
5143: EQUAL
5144: IFTRUE 5148
5146: GO 5159
5148: POP
// p = 92 ; b_lab , b_lab_half , b_lab_full :
5149: LD_ADDR_VAR 0 5
5153: PUSH
5154: LD_INT 92
5156: ST_TO_ADDR
5157: GO 5248
5159: LD_INT 6
5161: DOUBLE
5162: EQUAL
5163: IFTRUE 5179
5165: LD_INT 7
5167: DOUBLE
5168: EQUAL
5169: IFTRUE 5179
5171: LD_INT 8
5173: DOUBLE
5174: EQUAL
5175: IFTRUE 5179
5177: GO 5190
5179: POP
// p = 91 ; b_teleport :
5180: LD_ADDR_VAR 0 5
5184: PUSH
5185: LD_INT 91
5187: ST_TO_ADDR
5188: GO 5248
5190: LD_INT 34
5192: DOUBLE
5193: EQUAL
5194: IFTRUE 5198
5196: GO 5209
5198: POP
// p = 90 ; b_siberite_mine :
5199: LD_ADDR_VAR 0 5
5203: PUSH
5204: LD_INT 90
5206: ST_TO_ADDR
5207: GO 5248
5209: LD_INT 30
5211: DOUBLE
5212: EQUAL
5213: IFTRUE 5217
5215: GO 5228
5217: POP
// p = 89 ; b_oil_mine :
5218: LD_ADDR_VAR 0 5
5222: PUSH
5223: LD_INT 89
5225: ST_TO_ADDR
5226: GO 5248
5228: LD_INT 29
5230: DOUBLE
5231: EQUAL
5232: IFTRUE 5236
5234: GO 5247
5236: POP
// p = 88 ; end ;
5237: LD_ADDR_VAR 0 5
5241: PUSH
5242: LD_INT 88
5244: ST_TO_ADDR
5245: GO 5248
5247: POP
// temp_list = temp_list ^ p ;
5248: LD_ADDR_VAR 0 4
5252: PUSH
5253: LD_VAR 0 4
5257: PUSH
5258: LD_VAR 0 5
5262: ADD
5263: ST_TO_ADDR
// end ;
5264: GO 4892
5266: POP
5267: POP
// temp_list = SortListByListDesc ( ai_buildings_locations [ base ] , temp_list ) ;
5268: LD_ADDR_VAR 0 4
5272: PUSH
5273: LD_EXP 30
5277: PUSH
5278: LD_VAR 0 1
5282: ARRAY
5283: PPUSH
5284: LD_VAR 0 4
5288: PPUSH
5289: CALL_OW 77
5293: ST_TO_ADDR
// ai_buildings_locations = Replace ( ai_buildings_locations , base , temp_list ) ;
5294: LD_ADDR_EXP 30
5298: PUSH
5299: LD_EXP 30
5303: PPUSH
5304: LD_VAR 0 1
5308: PPUSH
5309: LD_VAR 0 4
5313: PPUSH
5314: CALL_OW 1
5318: ST_TO_ADDR
// end ;
5319: LD_VAR 0 2
5323: RET
// function PrepareComputerSides ; var i , temp_list , side , base , max , num , temp_list_2 ; begin
5324: LD_INT 0
5326: PPUSH
5327: PPUSH
5328: PPUSH
5329: PPUSH
5330: PPUSH
5331: PPUSH
5332: PPUSH
5333: PPUSH
// side = russians ;
5334: LD_ADDR_VAR 0 4
5338: PUSH
5339: LD_EXP 3
5343: ST_TO_ADDR
// for base in ai_bases do
5344: LD_ADDR_VAR 0 5
5348: PUSH
5349: LD_EXP 49
5353: PUSH
5354: FOR_IN
5355: IFFALSE 5867
// begin InitUc ;
5357: CALL_OW 18
// InitHc ;
5361: CALL_OW 19
// uc_side = side ;
5365: LD_ADDR_OWVAR 20
5369: PUSH
5370: LD_VAR 0 4
5374: ST_TO_ADDR
// case side of russians :
5375: LD_VAR 0 4
5379: PUSH
5380: LD_EXP 3
5384: DOUBLE
5385: EQUAL
5386: IFTRUE 5390
5388: GO 5401
5390: POP
// uc_nation = nation_russian ; end ;
5391: LD_ADDR_OWVAR 21
5395: PUSH
5396: LD_INT 3
5398: ST_TO_ADDR
5399: GO 5402
5401: POP
// num = ai_bunkers [ base ] + 0 ;
5402: LD_ADDR_VAR 0 7
5406: PUSH
5407: LD_EXP 41
5411: PUSH
5412: LD_VAR 0 5
5416: ARRAY
5417: PUSH
5418: LD_INT 0
5420: PLUS
5421: ST_TO_ADDR
// if base < 3 then
5422: LD_VAR 0 5
5426: PUSH
5427: LD_INT 3
5429: LESS
5430: IFFALSE 5446
// num = num + 3 ;
5432: LD_ADDR_VAR 0 7
5436: PUSH
5437: LD_VAR 0 7
5441: PUSH
5442: LD_INT 3
5444: PLUS
5445: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , base , CreateUnitsWithClass ( side , num , class_soldier , base = 3 ) ) ;
5446: LD_ADDR_EXP 22
5450: PUSH
5451: LD_EXP 22
5455: PPUSH
5456: LD_VAR 0 5
5460: PPUSH
5461: LD_VAR 0 4
5465: PPUSH
5466: LD_VAR 0 7
5470: PPUSH
5471: LD_INT 1
5473: PPUSH
5474: LD_VAR 0 5
5478: PUSH
5479: LD_INT 3
5481: EQUAL
5482: PPUSH
5483: CALL 6232 0 4
5487: PPUSH
5488: CALL_OW 1
5492: ST_TO_ADDR
// if base = 3 then
5493: LD_VAR 0 5
5497: PUSH
5498: LD_INT 3
5500: EQUAL
5501: IFFALSE 5513
// num = 1 else
5503: LD_ADDR_VAR 0 7
5507: PUSH
5508: LD_INT 1
5510: ST_TO_ADDR
5511: GO 5533
// num = 2 + Rand ( 0 , 1 ) ;
5513: LD_ADDR_VAR 0 7
5517: PUSH
5518: LD_INT 2
5520: PUSH
5521: LD_INT 0
5523: PPUSH
5524: LD_INT 1
5526: PPUSH
5527: CALL_OW 12
5531: PLUS
5532: ST_TO_ADDR
// ai_engineers = Replace ( ai_engineers , base , CreateUnitsWithClass ( side , num , class_engineer , base = 3 ) ) ;
5533: LD_ADDR_EXP 23
5537: PUSH
5538: LD_EXP 23
5542: PPUSH
5543: LD_VAR 0 5
5547: PPUSH
5548: LD_VAR 0 4
5552: PPUSH
5553: LD_VAR 0 7
5557: PPUSH
5558: LD_INT 2
5560: PPUSH
5561: LD_VAR 0 5
5565: PUSH
5566: LD_INT 3
5568: EQUAL
5569: PPUSH
5570: CALL 6232 0 4
5574: PPUSH
5575: CALL_OW 1
5579: ST_TO_ADDR
// temp_list = [ ] ;
5580: LD_ADDR_VAR 0 3
5584: PUSH
5585: EMPTY
5586: ST_TO_ADDR
// for i in ai_engineers [ base ] do
5587: LD_ADDR_VAR 0 2
5591: PUSH
5592: LD_EXP 23
5596: PUSH
5597: LD_VAR 0 5
5601: ARRAY
5602: PUSH
5603: FOR_IN
5604: IFFALSE 5632
// temp_list = temp_list ^ GetSkill ( i , skill_engineering ) ;
5606: LD_ADDR_VAR 0 3
5610: PUSH
5611: LD_VAR 0 3
5615: PUSH
5616: LD_VAR 0 2
5620: PPUSH
5621: LD_INT 2
5623: PPUSH
5624: CALL_OW 259
5628: ADD
5629: ST_TO_ADDR
5630: GO 5603
5632: POP
5633: POP
// max = BestFromListByList ( temp_list , temp_list ) ;
5634: LD_ADDR_VAR 0 6
5638: PUSH
5639: LD_VAR 0 3
5643: PPUSH
5644: LD_VAR 0 3
5648: PPUSH
5649: CALL_OW 79
5653: ST_TO_ADDR
// for i in ai_all_buildings [ base ] do
5654: LD_ADDR_VAR 0 2
5658: PUSH
5659: LD_EXP 36
5663: PUSH
5664: LD_VAR 0 5
5668: ARRAY
5669: PUSH
5670: FOR_IN
5671: IFFALSE 5689
// SetBLevel ( i , max ) ;
5673: LD_VAR 0 2
5677: PPUSH
5678: LD_VAR 0 6
5682: PPUSH
5683: CALL_OW 241
5687: GO 5670
5689: POP
5690: POP
// if base = 3 then
5691: LD_VAR 0 5
5695: PUSH
5696: LD_INT 3
5698: EQUAL
5699: IFFALSE 5711
// num = 0 else
5701: LD_ADDR_VAR 0 7
5705: PUSH
5706: LD_INT 0
5708: ST_TO_ADDR
5709: GO 5731
// num = 4 + Rand ( 0 , 1 ) ;
5711: LD_ADDR_VAR 0 7
5715: PUSH
5716: LD_INT 4
5718: PUSH
5719: LD_INT 0
5721: PPUSH
5722: LD_INT 1
5724: PPUSH
5725: CALL_OW 12
5729: PLUS
5730: ST_TO_ADDR
// ai_mechanics_defend = Replace ( ai_mechanics_defend , base , CreateUnitsWithClass ( side , num , class_mechanic , base = 3 ) ) ;
5731: LD_ADDR_EXP 24
5735: PUSH
5736: LD_EXP 24
5740: PPUSH
5741: LD_VAR 0 5
5745: PPUSH
5746: LD_VAR 0 4
5750: PPUSH
5751: LD_VAR 0 7
5755: PPUSH
5756: LD_INT 3
5758: PPUSH
5759: LD_VAR 0 5
5763: PUSH
5764: LD_INT 3
5766: EQUAL
5767: PPUSH
5768: CALL 6232 0 4
5772: PPUSH
5773: CALL_OW 1
5777: ST_TO_ADDR
// if base = 3 then
5778: LD_VAR 0 5
5782: PUSH
5783: LD_INT 3
5785: EQUAL
5786: IFFALSE 5798
// num = 0 else
5788: LD_ADDR_VAR 0 7
5792: PUSH
5793: LD_INT 0
5795: ST_TO_ADDR
5796: GO 5818
// num = 3 + Rand ( 0 , 1 ) ;
5798: LD_ADDR_VAR 0 7
5802: PUSH
5803: LD_INT 3
5805: PUSH
5806: LD_INT 0
5808: PPUSH
5809: LD_INT 1
5811: PPUSH
5812: CALL_OW 12
5816: PLUS
5817: ST_TO_ADDR
// ai_scientists = Replace ( ai_scientists , base , CreateUnitsWithClass ( side , num , class_scientistic , base = 3 ) ) ;
5818: LD_ADDR_EXP 25
5822: PUSH
5823: LD_EXP 25
5827: PPUSH
5828: LD_VAR 0 5
5832: PPUSH
5833: LD_VAR 0 4
5837: PPUSH
5838: LD_VAR 0 7
5842: PPUSH
5843: LD_INT 4
5845: PPUSH
5846: LD_VAR 0 5
5850: PUSH
5851: LD_INT 3
5853: EQUAL
5854: PPUSH
5855: CALL 6232 0 4
5859: PPUSH
5860: CALL_OW 1
5864: ST_TO_ADDR
// end ;
5865: GO 5354
5867: POP
5868: POP
// for base in ai_bases do
5869: LD_ADDR_VAR 0 5
5873: PUSH
5874: LD_EXP 49
5878: PUSH
5879: FOR_IN
5880: IFFALSE 5988
// for i in ai_soldiers [ base ] ^ ai_engineers [ base ] ^ ai_mechanics_defend [ base ] ^ ai_scientists [ base ] do
5882: LD_ADDR_VAR 0 2
5886: PUSH
5887: LD_EXP 22
5891: PUSH
5892: LD_VAR 0 5
5896: ARRAY
5897: PUSH
5898: LD_EXP 23
5902: PUSH
5903: LD_VAR 0 5
5907: ARRAY
5908: ADD
5909: PUSH
5910: LD_EXP 24
5914: PUSH
5915: LD_VAR 0 5
5919: ARRAY
5920: ADD
5921: PUSH
5922: LD_EXP 25
5926: PUSH
5927: LD_VAR 0 5
5931: ARRAY
5932: ADD
5933: PUSH
5934: FOR_IN
5935: IFFALSE 5984
// PlaceUnitXYR ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] , 7 , false ) ;
5937: LD_VAR 0 2
5941: PPUSH
5942: LD_EXP 33
5946: PUSH
5947: LD_VAR 0 5
5951: ARRAY
5952: PUSH
5953: LD_INT 1
5955: ARRAY
5956: PPUSH
5957: LD_EXP 33
5961: PUSH
5962: LD_VAR 0 5
5966: ARRAY
5967: PUSH
5968: LD_INT 2
5970: ARRAY
5971: PPUSH
5972: LD_INT 7
5974: PPUSH
5975: LD_INT 0
5977: PPUSH
5978: CALL_OW 50
5982: GO 5934
5984: POP
5985: POP
5986: GO 5879
5988: POP
5989: POP
// for base in ai_bases do
5990: LD_ADDR_VAR 0 5
5994: PUSH
5995: LD_EXP 49
5999: PUSH
6000: FOR_IN
6001: IFFALSE 6014
// ResetAttackDelay ( base ) ;
6003: LD_VAR 0 5
6007: PPUSH
6008: CALL 6550 0 1
6012: GO 6000
6014: POP
6015: POP
// ai_attack_delay = Replace ( ai_attack_delay , Rand ( 1 , 2 ) , ( ai_attack_delay [ 1 ] * 3 ) div 2 ) ;
6016: LD_ADDR_EXP 48
6020: PUSH
6021: LD_EXP 48
6025: PPUSH
6026: LD_INT 1
6028: PPUSH
6029: LD_INT 2
6031: PPUSH
6032: CALL_OW 12
6036: PPUSH
6037: LD_EXP 48
6041: PUSH
6042: LD_INT 1
6044: ARRAY
6045: PUSH
6046: LD_INT 3
6048: MUL
6049: PUSH
6050: LD_INT 2
6052: DIV
6053: PPUSH
6054: CALL_OW 1
6058: ST_TO_ADDR
// for base in ai_bases do
6059: LD_ADDR_VAR 0 5
6063: PUSH
6064: LD_EXP 49
6068: PUSH
6069: FOR_IN
6070: IFFALSE 6109
// ai_attack_delay = Replace ( ai_attack_delay , base , ai_attack_delay [ base ] + 3 3$0 ) ;
6072: LD_ADDR_EXP 48
6076: PUSH
6077: LD_EXP 48
6081: PPUSH
6082: LD_VAR 0 5
6086: PPUSH
6087: LD_EXP 48
6091: PUSH
6092: LD_VAR 0 5
6096: ARRAY
6097: PUSH
6098: LD_INT 6300
6100: PLUS
6101: PPUSH
6102: CALL_OW 1
6106: ST_TO_ADDR
6107: GO 6069
6109: POP
6110: POP
// temp_list = [ rub1 , rub2 ] ;
6111: LD_ADDR_VAR 0 3
6115: PUSH
6116: LD_INT 81
6118: PUSH
6119: LD_INT 80
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: ST_TO_ADDR
// temp_list_2 = CreateUnitsWithClass ( russians , 2 , class_soldier , true ) ;
6126: LD_ADDR_VAR 0 8
6130: PUSH
6131: LD_EXP 3
6135: PPUSH
6136: LD_INT 2
6138: PPUSH
6139: LD_INT 1
6141: PPUSH
6142: LD_INT 1
6144: PPUSH
6145: CALL 6232 0 4
6149: ST_TO_ADDR
// for i = 1 to 2 do
6150: LD_ADDR_VAR 0 2
6154: PUSH
6155: DOUBLE
6156: LD_INT 1
6158: DEC
6159: ST_TO_ADDR
6160: LD_INT 2
6162: PUSH
6163: FOR_TO
6164: IFFALSE 6194
// PlaceHumanInUnit ( temp_list_2 [ i ] , temp_list [ i ] ) ;
6166: LD_VAR 0 8
6170: PUSH
6171: LD_VAR 0 2
6175: ARRAY
6176: PPUSH
6177: LD_VAR 0 3
6181: PUSH
6182: LD_VAR 0 2
6186: ARRAY
6187: PPUSH
6188: CALL_OW 52
6192: GO 6163
6194: POP
6195: POP
// for i in temp_list do
6196: LD_ADDR_VAR 0 2
6200: PUSH
6201: LD_VAR 0 3
6205: PUSH
6206: FOR_IN
6207: IFFALSE 6225
// SetBLevel ( i , difficulty ) ;
6209: LD_VAR 0 2
6213: PPUSH
6214: LD_OWVAR 67
6218: PPUSH
6219: CALL_OW 241
6223: GO 6206
6225: POP
6226: POP
// end ;
6227: LD_VAR 0 1
6231: RET
// export function CreateUnitsWithClass ( side , num_units , un_class , use_difficulty ) ; var i , temp_unit , val , skill , overskill ; begin
6232: LD_INT 0
6234: PPUSH
6235: PPUSH
6236: PPUSH
6237: PPUSH
6238: PPUSH
6239: PPUSH
// result = [ ] ;
6240: LD_ADDR_VAR 0 5
6244: PUSH
6245: EMPTY
6246: ST_TO_ADDR
// case side of russians , russians_alt :
6247: LD_VAR 0 1
6251: PUSH
6252: LD_EXP 3
6256: DOUBLE
6257: EQUAL
6258: IFTRUE 6270
6260: LD_EXP 6
6264: DOUBLE
6265: EQUAL
6266: IFTRUE 6270
6268: GO 6281
6270: POP
// uc_nation = nation_russian ; end ;
6271: LD_ADDR_OWVAR 21
6275: PUSH
6276: LD_INT 3
6278: ST_TO_ADDR
6279: GO 6282
6281: POP
// uc_side = side ;
6282: LD_ADDR_OWVAR 20
6286: PUSH
6287: LD_VAR 0 1
6291: ST_TO_ADDR
// if use_difficulty then
6292: LD_VAR 0 4
6296: IFFALSE 6314
// overskill = difficulty + 2 else
6298: LD_ADDR_VAR 0 10
6302: PUSH
6303: LD_OWVAR 67
6307: PUSH
6308: LD_INT 2
6310: PLUS
6311: ST_TO_ADDR
6312: GO 6322
// overskill = 5 ;
6314: LD_ADDR_VAR 0 10
6318: PUSH
6319: LD_INT 5
6321: ST_TO_ADDR
// for i = 1 to num_units do
6322: LD_ADDR_VAR 0 6
6326: PUSH
6327: DOUBLE
6328: LD_INT 1
6330: DEC
6331: ST_TO_ADDR
6332: LD_VAR 0 2
6336: PUSH
6337: FOR_TO
6338: IFFALSE 6543
// begin if Rand ( 1 , 3 ) = 1 then
6340: LD_INT 1
6342: PPUSH
6343: LD_INT 3
6345: PPUSH
6346: CALL_OW 12
6350: PUSH
6351: LD_INT 1
6353: EQUAL
6354: IFFALSE 6375
// PrepareHuman ( false , un_class , overskill ) else
6356: LD_INT 0
6358: PPUSH
6359: LD_VAR 0 3
6363: PPUSH
6364: LD_VAR 0 10
6368: PPUSH
6369: CALL_OW 380
6373: GO 6393
// PrepareHuman ( false , un_class , - overskill ) ;
6375: LD_INT 0
6377: PPUSH
6378: LD_VAR 0 3
6382: PPUSH
6383: LD_VAR 0 10
6387: NEG
6388: PPUSH
6389: CALL_OW 380
// temp_unit = CreateHuman ;
6393: LD_ADDR_VAR 0 7
6397: PUSH
6398: CALL_OW 44
6402: ST_TO_ADDR
// case un_class of class_engineer :
6403: LD_VAR 0 3
6407: PUSH
6408: LD_INT 2
6410: DOUBLE
6411: EQUAL
6412: IFTRUE 6416
6414: GO 6427
6416: POP
// val = skill_engineering ; class_mechanic :
6417: LD_ADDR_VAR 0 8
6421: PUSH
6422: LD_INT 2
6424: ST_TO_ADDR
6425: GO 6474
6427: LD_INT 3
6429: DOUBLE
6430: EQUAL
6431: IFTRUE 6435
6433: GO 6446
6435: POP
// val = skill_mechanical ; class_scientistic :
6436: LD_ADDR_VAR 0 8
6440: PUSH
6441: LD_INT 3
6443: ST_TO_ADDR
6444: GO 6474
6446: LD_INT 4
6448: DOUBLE
6449: EQUAL
6450: IFTRUE 6454
6452: GO 6465
6454: POP
// val = skill_scientistic ; else
6455: LD_ADDR_VAR 0 8
6459: PUSH
6460: LD_INT 4
6462: ST_TO_ADDR
6463: GO 6474
6465: POP
// val = skill_combat ; end ;
6466: LD_ADDR_VAR 0 8
6470: PUSH
6471: LD_INT 1
6473: ST_TO_ADDR
// skill = GetSkill ( temp_unit , val ) ;
6474: LD_ADDR_VAR 0 9
6478: PUSH
6479: LD_VAR 0 7
6483: PPUSH
6484: LD_VAR 0 8
6488: PPUSH
6489: CALL_OW 259
6493: ST_TO_ADDR
// if skill < overskill then
6494: LD_VAR 0 9
6498: PUSH
6499: LD_VAR 0 10
6503: LESS
6504: IFFALSE 6525
// SetSkill ( temp_unit , val , overskill ) ;
6506: LD_VAR 0 7
6510: PPUSH
6511: LD_VAR 0 8
6515: PPUSH
6516: LD_VAR 0 10
6520: PPUSH
6521: CALL_OW 237
// result = result ^ temp_unit ;
6525: LD_ADDR_VAR 0 5
6529: PUSH
6530: LD_VAR 0 5
6534: PUSH
6535: LD_VAR 0 7
6539: ADD
6540: ST_TO_ADDR
// end ;
6541: GO 6337
6543: POP
6544: POP
// end ;
6545: LD_VAR 0 5
6549: RET
// export function ResetAttackDelay ( base ) ; begin
6550: LD_INT 0
6552: PPUSH
// ai_attack_delay = Replace ( ai_attack_delay , base , Rand ( 8 8$0 , 9 9$0 ) - 1 1$0 * difficulty ) ;
6553: LD_ADDR_EXP 48
6557: PUSH
6558: LD_EXP 48
6562: PPUSH
6563: LD_VAR 0 1
6567: PPUSH
6568: LD_INT 16800
6570: PPUSH
6571: LD_INT 18900
6573: PPUSH
6574: CALL_OW 12
6578: PUSH
6579: LD_INT 2100
6581: PUSH
6582: LD_OWVAR 67
6586: MUL
6587: MINUS
6588: PPUSH
6589: CALL_OW 1
6593: ST_TO_ADDR
// end ;
6594: LD_VAR 0 2
6598: RET
// function Action ; var un_list , temp_unit ; begin
6599: LD_INT 0
6601: PPUSH
6602: PPUSH
6603: PPUSH
// wait ( 2 ) ;
6604: LD_INT 2
6606: PPUSH
6607: CALL_OW 67
// CenterNowOnXY ( 104 , 10 ) ;
6611: LD_INT 104
6613: PPUSH
6614: LD_INT 10
6616: PPUSH
6617: CALL_OW 86
// InGameOn ;
6621: CALL_OW 8
// un_list = FilterAllUnits ( [ f_side , you ] ) ;
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: LD_INT 22
6632: PUSH
6633: LD_EXP 2
6637: PUSH
6638: EMPTY
6639: LIST
6640: LIST
6641: PPUSH
6642: CALL_OW 69
6646: ST_TO_ADDR
// ComMoveXY ( un_list , 98 , 17 ) ;
6647: LD_VAR 0 2
6651: PPUSH
6652: LD_INT 98
6654: PPUSH
6655: LD_INT 17
6657: PPUSH
6658: CALL_OW 111
// Wait ( 0 0$2.5 ) ;
6662: LD_INT 88
6664: PPUSH
6665: CALL_OW 67
// ComStop ( un_list ) ;
6669: LD_VAR 0 2
6673: PPUSH
6674: CALL_OW 141
// Wait ( 0 0$0.5 ) ;
6678: LD_INT 18
6680: PPUSH
6681: CALL_OW 67
// if Olaf > 0 then
6685: LD_EXP 18
6689: PUSH
6690: LD_INT 0
6692: GREATER
6693: IFFALSE 6709
// Say ( Olaf , D1Ol1 ) else
6695: LD_EXP 18
6699: PPUSH
6700: LD_STRING D1Ol1
6702: PPUSH
6703: CALL_OW 88
6707: GO 6745
// if Messenger > 0 then
6709: LD_EXP 19
6713: PUSH
6714: LD_INT 0
6716: GREATER
6717: IFFALSE 6733
// Say ( Messenger , D1MeM1 ) else
6719: LD_EXP 19
6723: PPUSH
6724: LD_STRING D1MeM1
6726: PPUSH
6727: CALL_OW 88
6731: GO 6745
// Say ( Heike , D1H1 ) ;
6733: LD_EXP 7
6737: PPUSH
6738: LD_STRING D1H1
6740: PPUSH
6741: CALL_OW 88
// un_list = [ Oswald , Gordon , Suze ] diff 0 ;
6745: LD_ADDR_VAR 0 2
6749: PUSH
6750: LD_EXP 9
6754: PUSH
6755: LD_EXP 14
6759: PUSH
6760: LD_EXP 15
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: LIST
6769: PUSH
6770: LD_INT 0
6772: DIFF
6773: ST_TO_ADDR
// if un_list > 0 then
6774: LD_VAR 0 2
6778: PUSH
6779: LD_INT 0
6781: GREATER
6782: IFFALSE 6923
// begin temp_unit = un_list [ Rand ( 1 , un_list ) ] ;
6784: LD_ADDR_VAR 0 3
6788: PUSH
6789: LD_VAR 0 2
6793: PUSH
6794: LD_INT 1
6796: PPUSH
6797: LD_VAR 0 2
6801: PPUSH
6802: CALL_OW 12
6806: ARRAY
6807: ST_TO_ADDR
// case temp_unit of Oswald :
6808: LD_VAR 0 3
6812: PUSH
6813: LD_EXP 9
6817: DOUBLE
6818: EQUAL
6819: IFTRUE 6823
6821: GO 6838
6823: POP
// Say ( Oswald , D1Os1 ) ; Suze :
6824: LD_EXP 9
6828: PPUSH
6829: LD_STRING D1Os1
6831: PPUSH
6832: CALL_OW 88
6836: GO 6889
6838: LD_EXP 15
6842: DOUBLE
6843: EQUAL
6844: IFTRUE 6848
6846: GO 6863
6848: POP
// Say ( Suze , D1Su1 ) ; Gordon :
6849: LD_EXP 15
6853: PPUSH
6854: LD_STRING D1Su1
6856: PPUSH
6857: CALL_OW 88
6861: GO 6889
6863: LD_EXP 14
6867: DOUBLE
6868: EQUAL
6869: IFTRUE 6873
6871: GO 6888
6873: POP
// Say ( Gordon , D1Go1 ) ; end ;
6874: LD_EXP 14
6878: PPUSH
6879: LD_STRING D1Go1
6881: PPUSH
6882: CALL_OW 88
6886: GO 6889
6888: POP
// Say ( Heike , D1H2 ) ;
6889: LD_EXP 7
6893: PPUSH
6894: LD_STRING D1H2
6896: PPUSH
6897: CALL_OW 88
// if Gordon > 0 then
6901: LD_EXP 14
6905: PUSH
6906: LD_INT 0
6908: GREATER
6909: IFFALSE 6923
// Say ( Gordon , D1Go2 ) ;
6911: LD_EXP 14
6915: PPUSH
6916: LD_STRING D1Go2
6918: PPUSH
6919: CALL_OW 88
// end ; InGameOff ;
6923: CALL_OW 9
// wait ( 0 0$0.2 ) ;
6927: LD_INT 7
6929: PPUSH
6930: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
6934: LD_STRING M1
6936: PPUSH
6937: CALL_OW 337
// wait ( 0 0$0.2 ) ;
6941: LD_INT 7
6943: PPUSH
6944: CALL_OW 67
// SaveForQuickRestart ;
6948: CALL_OW 22
// end ; end_of_file
6952: LD_VAR 0 1
6956: RET
// every 0 0$10 do var i , base ;
6957: GO 6959
6959: DISABLE
6960: LD_INT 0
6962: PPUSH
6963: PPUSH
// begin for i = 1 to ai_depot do
6964: LD_ADDR_VAR 0 1
6968: PUSH
6969: DOUBLE
6970: LD_INT 1
6972: DEC
6973: ST_TO_ADDR
6974: LD_EXP 27
6978: PUSH
6979: FOR_TO
6980: IFFALSE 7075
// if IsOk ( ai_depot [ i ] ) and GetSide ( ai_depot [ i ] ) = russians then
6982: LD_EXP 27
6986: PUSH
6987: LD_VAR 0 1
6991: ARRAY
6992: PPUSH
6993: CALL_OW 302
6997: PUSH
6998: LD_EXP 27
7002: PUSH
7003: LD_VAR 0 1
7007: ARRAY
7008: PPUSH
7009: CALL_OW 255
7013: PUSH
7014: LD_EXP 3
7018: EQUAL
7019: AND
7020: IFFALSE 7073
// begin base = GetBase ( ai_depot [ i ] ) ;
7022: LD_ADDR_VAR 0 2
7026: PUSH
7027: LD_EXP 27
7031: PUSH
7032: LD_VAR 0 1
7036: ARRAY
7037: PPUSH
7038: CALL_OW 274
7042: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 300 ) ;
7043: LD_VAR 0 2
7047: PPUSH
7048: LD_INT 1
7050: PPUSH
7051: LD_INT 300
7053: PPUSH
7054: CALL_OW 277
// SetResourceType ( base , mat_oil , 300 ) ;
7058: LD_VAR 0 2
7062: PPUSH
7063: LD_INT 2
7065: PPUSH
7066: LD_INT 300
7068: PPUSH
7069: CALL_OW 277
// end ;
7073: GO 6979
7075: POP
7076: POP
// enable ;
7077: ENABLE
// end ;
7078: PPOPN 2
7080: END
// on UnitDestroyed ( un ) do var side , temp_list , base ;
7081: LD_INT 0
7083: PPUSH
7084: PPUSH
7085: PPUSH
// begin if un = Heike then
7086: LD_VAR 0 1
7090: PUSH
7091: LD_EXP 7
7095: EQUAL
7096: IFFALSE 7120
// begin ExclusiveOn ;
7098: CALL_OW 4
// Wait ( 0 0$1 ) ;
7102: LD_INT 35
7104: PPUSH
7105: CALL_OW 67
// YouLost ( HeikeDead ) ;
7109: LD_STRING HeikeDead
7111: PPUSH
7112: CALL_OW 104
// ExclusiveOff ;
7116: CALL_OW 5
// end ; if un = MarkB and survivors_found > 0 then
7120: LD_VAR 0 1
7124: PUSH
7125: LD_EXP 17
7129: EQUAL
7130: PUSH
7131: LD_EXP 52
7135: PUSH
7136: LD_INT 0
7138: GREATER
7139: AND
7140: IFFALSE 7164
// begin ExclusiveOn ;
7142: CALL_OW 4
// wait ( 0 0$1 ) ;
7146: LD_INT 35
7148: PPUSH
7149: CALL_OW 67
// YouLost ( MarkDead ) ;
7153: LD_STRING MarkDead
7155: PPUSH
7156: CALL_OW 104
// ExclusiveOff ;
7160: CALL_OW 5
// end ; for base in ai_bases do
7164: LD_ADDR_VAR 0 4
7168: PUSH
7169: LD_EXP 49
7173: PUSH
7174: FOR_IN
7175: IFFALSE 7226
// begin temp_list = ai_captured_buildings [ base ] diff un ;
7177: LD_ADDR_VAR 0 3
7181: PUSH
7182: LD_EXP 51
7186: PUSH
7187: LD_VAR 0 4
7191: ARRAY
7192: PUSH
7193: LD_VAR 0 1
7197: DIFF
7198: ST_TO_ADDR
// ai_captured_buildings = Replace ( ai_captured_buildings , base , temp_list ) ;
7199: LD_ADDR_EXP 51
7203: PUSH
7204: LD_EXP 51
7208: PPUSH
7209: LD_VAR 0 4
7213: PPUSH
7214: LD_VAR 0 3
7218: PPUSH
7219: CALL_OW 1
7223: ST_TO_ADDR
// end ;
7224: GO 7174
7226: POP
7227: POP
// side = GetSide ( un ) ;
7228: LD_ADDR_VAR 0 2
7232: PUSH
7233: LD_VAR 0 1
7237: PPUSH
7238: CALL_OW 255
7242: ST_TO_ADDR
// if side <> russians then
7243: LD_VAR 0 2
7247: PUSH
7248: LD_EXP 3
7252: NONEQUAL
7253: IFFALSE 7257
// exit ;
7255: GO 7397
// case GetType ( un ) of unit_human :
7257: LD_VAR 0 1
7261: PPUSH
7262: CALL_OW 247
7266: PUSH
7267: LD_INT 1
7269: DOUBLE
7270: EQUAL
7271: IFTRUE 7275
7273: GO 7312
7275: POP
// for base in ai_bases do
7276: LD_ADDR_VAR 0 4
7280: PUSH
7281: LD_EXP 49
7285: PUSH
7286: FOR_IN
7287: IFFALSE 7308
// RemoveHumanFromVariables ( base , un , true ) ; unit_vehicle :
7289: LD_VAR 0 4
7293: PPUSH
7294: LD_VAR 0 1
7298: PPUSH
7299: LD_INT 1
7301: PPUSH
7302: CALL 7759 0 3
7306: GO 7286
7308: POP
7309: POP
7310: GO 7397
7312: LD_INT 2
7314: DOUBLE
7315: EQUAL
7316: IFTRUE 7320
7318: GO 7354
7320: POP
// for base in ai_bases do
7321: LD_ADDR_VAR 0 4
7325: PUSH
7326: LD_EXP 49
7330: PUSH
7331: FOR_IN
7332: IFFALSE 7350
// RemoveVehicleFromVariables ( base , un ) ; unit_building :
7334: LD_VAR 0 4
7338: PPUSH
7339: LD_VAR 0 1
7343: PPUSH
7344: CALL 7514 0 2
7348: GO 7331
7350: POP
7351: POP
7352: GO 7397
7354: LD_INT 3
7356: DOUBLE
7357: EQUAL
7358: IFTRUE 7362
7360: GO 7396
7362: POP
// for base in ai_bases do
7363: LD_ADDR_VAR 0 4
7367: PUSH
7368: LD_EXP 49
7372: PUSH
7373: FOR_IN
7374: IFFALSE 7392
// RemoveBuildingFromVariables ( base , un ) ; end ;
7376: LD_VAR 0 4
7380: PPUSH
7381: LD_VAR 0 1
7385: PPUSH
7386: CALL 7400 0 2
7390: GO 7373
7392: POP
7393: POP
7394: GO 7397
7396: POP
// end ;
7397: PPOPN 4
7399: END
// function RemoveBuildingFromVariables ( base , building ) ; var temp_list ; begin
7400: LD_INT 0
7402: PPUSH
7403: PPUSH
// temp_list = ai_all_buildings [ base ] diff building ;
7404: LD_ADDR_VAR 0 4
7408: PUSH
7409: LD_EXP 36
7413: PUSH
7414: LD_VAR 0 1
7418: ARRAY
7419: PUSH
7420: LD_VAR 0 2
7424: DIFF
7425: ST_TO_ADDR
// ai_all_buildings = Replace ( ai_all_buildings , base , temp_list ) ;
7426: LD_ADDR_EXP 36
7430: PUSH
7431: LD_EXP 36
7435: PPUSH
7436: LD_VAR 0 1
7440: PPUSH
7441: LD_VAR 0 4
7445: PPUSH
7446: CALL_OW 1
7450: ST_TO_ADDR
// if building = ai_building_under_construction [ base ] then
7451: LD_VAR 0 2
7455: PUSH
7456: LD_EXP 34
7460: PUSH
7461: LD_VAR 0 1
7465: ARRAY
7466: EQUAL
7467: IFFALSE 7492
// ai_building_under_construction = Replace ( ai_building_under_construction , base , 0 ) ;
7469: LD_ADDR_EXP 34
7473: PUSH
7474: LD_EXP 34
7478: PPUSH
7479: LD_VAR 0 1
7483: PPUSH
7484: LD_INT 0
7486: PPUSH
7487: CALL_OW 1
7491: ST_TO_ADDR
// UpdateBuildingBasicVariables ( base , building , false ) ;
7492: LD_VAR 0 1
7496: PPUSH
7497: LD_VAR 0 2
7501: PPUSH
7502: LD_INT 0
7504: PPUSH
7505: CALL 3970 0 3
// end ;
7509: LD_VAR 0 3
7513: RET
// function RemoveVehicleFromVariables ( base , vehicle ) ; var temp_list ; begin
7514: LD_INT 0
7516: PPUSH
7517: PPUSH
// if vehicle in ai_vehicles_defend [ base ] then
7518: LD_VAR 0 2
7522: PUSH
7523: LD_EXP 31
7527: PUSH
7528: LD_VAR 0 1
7532: ARRAY
7533: IN
7534: IFFALSE 7583
// begin temp_list = ai_vehicles_defend [ base ] diff vehicle ;
7536: LD_ADDR_VAR 0 4
7540: PUSH
7541: LD_EXP 31
7545: PUSH
7546: LD_VAR 0 1
7550: ARRAY
7551: PUSH
7552: LD_VAR 0 2
7556: DIFF
7557: ST_TO_ADDR
// ai_vehicles_defend = Replace ( ai_vehicles_defend , base , temp_list ) ;
7558: LD_ADDR_EXP 31
7562: PUSH
7563: LD_EXP 31
7567: PPUSH
7568: LD_VAR 0 1
7572: PPUSH
7573: LD_VAR 0 4
7577: PPUSH
7578: CALL_OW 1
7582: ST_TO_ADDR
// end ; if vehicle in ai_vehicles_attack [ base ] then
7583: LD_VAR 0 2
7587: PUSH
7588: LD_EXP 32
7592: PUSH
7593: LD_VAR 0 1
7597: ARRAY
7598: IN
7599: IFFALSE 7648
// begin temp_list = ai_vehicles_attack [ base ] diff vehicle ;
7601: LD_ADDR_VAR 0 4
7605: PUSH
7606: LD_EXP 32
7610: PUSH
7611: LD_VAR 0 1
7615: ARRAY
7616: PUSH
7617: LD_VAR 0 2
7621: DIFF
7622: ST_TO_ADDR
// ai_vehicles_attack = Replace ( ai_vehicles_attack , base , temp_list ) ;
7623: LD_ADDR_EXP 32
7627: PUSH
7628: LD_EXP 32
7632: PPUSH
7633: LD_VAR 0 1
7637: PPUSH
7638: LD_VAR 0 4
7642: PPUSH
7643: CALL_OW 1
7647: ST_TO_ADDR
// end ; if vehicle = ai_cargo_bay [ base ] then
7648: LD_VAR 0 2
7652: PUSH
7653: LD_EXP 50
7657: PUSH
7658: LD_VAR 0 1
7662: ARRAY
7663: EQUAL
7664: IFFALSE 7689
// ai_cargo_bay = Replace ( ai_cargo_bay , base , 0 ) ;
7666: LD_ADDR_EXP 50
7670: PUSH
7671: LD_EXP 50
7675: PPUSH
7676: LD_VAR 0 1
7680: PPUSH
7681: LD_INT 0
7683: PPUSH
7684: CALL_OW 1
7688: ST_TO_ADDR
// if vehicle in ai_refuel_vehicles_list [ base ] then
7689: LD_VAR 0 2
7693: PUSH
7694: LD_EXP 46
7698: PUSH
7699: LD_VAR 0 1
7703: ARRAY
7704: IN
7705: IFFALSE 7754
// begin temp_list = ai_refuel_vehicles_list [ base ] diff vehicle ;
7707: LD_ADDR_VAR 0 4
7711: PUSH
7712: LD_EXP 46
7716: PUSH
7717: LD_VAR 0 1
7721: ARRAY
7722: PUSH
7723: LD_VAR 0 2
7727: DIFF
7728: ST_TO_ADDR
// ai_refuel_vehicles_list = Replace ( ai_refuel_vehicles_list , base , temp_list ) ;
7729: LD_ADDR_EXP 46
7733: PUSH
7734: LD_EXP 46
7738: PPUSH
7739: LD_VAR 0 1
7743: PPUSH
7744: LD_VAR 0 4
7748: PPUSH
7749: CALL_OW 1
7753: ST_TO_ADDR
// end ; end ;
7754: LD_VAR 0 3
7758: RET
// function RemoveHumanFromVariables ( base , human , check_if_base_is_dead ) ; var temp_list ; begin
7759: LD_INT 0
7761: PPUSH
7762: PPUSH
// if human in ai_soldiers [ base ] then
7763: LD_VAR 0 2
7767: PUSH
7768: LD_EXP 22
7772: PUSH
7773: LD_VAR 0 1
7777: ARRAY
7778: IN
7779: IFFALSE 7828
// begin temp_list = ai_soldiers [ base ] diff human ;
7781: LD_ADDR_VAR 0 5
7785: PUSH
7786: LD_EXP 22
7790: PUSH
7791: LD_VAR 0 1
7795: ARRAY
7796: PUSH
7797: LD_VAR 0 2
7801: DIFF
7802: ST_TO_ADDR
// ai_soldiers = Replace ( ai_soldiers , base , temp_list ) ;
7803: LD_ADDR_EXP 22
7807: PUSH
7808: LD_EXP 22
7812: PPUSH
7813: LD_VAR 0 1
7817: PPUSH
7818: LD_VAR 0 5
7822: PPUSH
7823: CALL_OW 1
7827: ST_TO_ADDR
// end ; if human in ai_engineers [ base ] then
7828: LD_VAR 0 2
7832: PUSH
7833: LD_EXP 23
7837: PUSH
7838: LD_VAR 0 1
7842: ARRAY
7843: IN
7844: IFFALSE 7893
// begin temp_list = ai_engineers [ base ] diff human ;
7846: LD_ADDR_VAR 0 5
7850: PUSH
7851: LD_EXP 23
7855: PUSH
7856: LD_VAR 0 1
7860: ARRAY
7861: PUSH
7862: LD_VAR 0 2
7866: DIFF
7867: ST_TO_ADDR
// ai_engineers = Replace ( ai_engineers , base , temp_list ) ;
7868: LD_ADDR_EXP 23
7872: PUSH
7873: LD_EXP 23
7877: PPUSH
7878: LD_VAR 0 1
7882: PPUSH
7883: LD_VAR 0 5
7887: PPUSH
7888: CALL_OW 1
7892: ST_TO_ADDR
// end ; if human in ai_mechanics_defend [ base ] then
7893: LD_VAR 0 2
7897: PUSH
7898: LD_EXP 24
7902: PUSH
7903: LD_VAR 0 1
7907: ARRAY
7908: IN
7909: IFFALSE 7958
// begin temp_list = ai_mechanics_defend [ base ] diff human ;
7911: LD_ADDR_VAR 0 5
7915: PUSH
7916: LD_EXP 24
7920: PUSH
7921: LD_VAR 0 1
7925: ARRAY
7926: PUSH
7927: LD_VAR 0 2
7931: DIFF
7932: ST_TO_ADDR
// ai_mechanics_defend = Replace ( ai_mechanics_defend , base , temp_list ) ;
7933: LD_ADDR_EXP 24
7937: PUSH
7938: LD_EXP 24
7942: PPUSH
7943: LD_VAR 0 1
7947: PPUSH
7948: LD_VAR 0 5
7952: PPUSH
7953: CALL_OW 1
7957: ST_TO_ADDR
// end ; if human in ai_scientists [ base ] then
7958: LD_VAR 0 2
7962: PUSH
7963: LD_EXP 25
7967: PUSH
7968: LD_VAR 0 1
7972: ARRAY
7973: IN
7974: IFFALSE 8023
// begin temp_list = ai_scientists [ base ] diff human ;
7976: LD_ADDR_VAR 0 5
7980: PUSH
7981: LD_EXP 25
7985: PUSH
7986: LD_VAR 0 1
7990: ARRAY
7991: PUSH
7992: LD_VAR 0 2
7996: DIFF
7997: ST_TO_ADDR
// ai_scientists = Replace ( ai_scientists , base , temp_list ) ;
7998: LD_ADDR_EXP 25
8002: PUSH
8003: LD_EXP 25
8007: PPUSH
8008: LD_VAR 0 1
8012: PPUSH
8013: LD_VAR 0 5
8017: PPUSH
8018: CALL_OW 1
8022: ST_TO_ADDR
// end ; if human in ai_heal_these_humans [ base ] then
8023: LD_VAR 0 2
8027: PUSH
8028: LD_EXP 35
8032: PUSH
8033: LD_VAR 0 1
8037: ARRAY
8038: IN
8039: IFFALSE 8088
// begin temp_list = ai_heal_these_humans [ base ] diff human ;
8041: LD_ADDR_VAR 0 5
8045: PUSH
8046: LD_EXP 35
8050: PUSH
8051: LD_VAR 0 1
8055: ARRAY
8056: PUSH
8057: LD_VAR 0 2
8061: DIFF
8062: ST_TO_ADDR
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
8063: LD_ADDR_EXP 35
8067: PUSH
8068: LD_EXP 35
8072: PPUSH
8073: LD_VAR 0 1
8077: PPUSH
8078: LD_VAR 0 5
8082: PPUSH
8083: CALL_OW 1
8087: ST_TO_ADDR
// end ; if human = ai_building_constructor [ base ] then
8088: LD_VAR 0 2
8092: PUSH
8093: LD_EXP 37
8097: PUSH
8098: LD_VAR 0 1
8102: ARRAY
8103: EQUAL
8104: IFFALSE 8129
// ai_building_constructor = Replace ( ai_building_constructor , base , 0 ) ;
8106: LD_ADDR_EXP 37
8110: PUSH
8111: LD_EXP 37
8115: PPUSH
8116: LD_VAR 0 1
8120: PPUSH
8121: LD_INT 0
8123: PPUSH
8124: CALL_OW 1
8128: ST_TO_ADDR
// if check_if_base_is_dead then
8129: LD_VAR 0 3
8133: IFFALSE 8207
// if ( ( ai_soldiers [ base ] ^ ai_engineers [ base ] ^ ai_mechanics_defend [ base ] ^ ai_scientists [ base ] ) diff 0 ) = 0 then
8135: LD_EXP 22
8139: PUSH
8140: LD_VAR 0 1
8144: ARRAY
8145: PUSH
8146: LD_EXP 23
8150: PUSH
8151: LD_VAR 0 1
8155: ARRAY
8156: ADD
8157: PUSH
8158: LD_EXP 24
8162: PUSH
8163: LD_VAR 0 1
8167: ARRAY
8168: ADD
8169: PUSH
8170: LD_EXP 25
8174: PUSH
8175: LD_VAR 0 1
8179: ARRAY
8180: ADD
8181: PUSH
8182: LD_INT 0
8184: DIFF
8185: PUSH
8186: LD_INT 0
8188: EQUAL
8189: IFFALSE 8207
// ai_bases = ai_bases diff base ;
8191: LD_ADDR_EXP 49
8195: PUSH
8196: LD_EXP 49
8200: PUSH
8201: LD_VAR 0 1
8205: DIFF
8206: ST_TO_ADDR
// end ;
8207: LD_VAR 0 4
8211: RET
// function FindBase ( un ) ; var i , hexes , k ; begin
8212: LD_INT 0
8214: PPUSH
8215: PPUSH
8216: PPUSH
8217: PPUSH
// hexes = [ ] ;
8218: LD_ADDR_VAR 0 4
8222: PUSH
8223: EMPTY
8224: ST_TO_ADDR
// for i in ai_bases do
8225: LD_ADDR_VAR 0 3
8229: PUSH
8230: LD_EXP 49
8234: PUSH
8235: FOR_IN
8236: IFFALSE 8328
// for k in ai_buildings_locations [ i ] do
8238: LD_ADDR_VAR 0 5
8242: PUSH
8243: LD_EXP 30
8247: PUSH
8248: LD_VAR 0 3
8252: ARRAY
8253: PUSH
8254: FOR_IN
8255: IFFALSE 8324
// if k [ 4 ] in [ b_depot , b_warehouse ] then
8257: LD_VAR 0 5
8261: PUSH
8262: LD_INT 4
8264: ARRAY
8265: PUSH
8266: LD_INT 0
8268: PUSH
8269: LD_INT 1
8271: PUSH
8272: EMPTY
8273: LIST
8274: LIST
8275: IN
8276: IFFALSE 8322
// begin hexes = Replace ( hexes , i , [ k [ 1 ] , k [ 2 ] ] ) ;
8278: LD_ADDR_VAR 0 4
8282: PUSH
8283: LD_VAR 0 4
8287: PPUSH
8288: LD_VAR 0 3
8292: PPUSH
8293: LD_VAR 0 5
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: PUSH
8302: LD_VAR 0 5
8306: PUSH
8307: LD_INT 2
8309: ARRAY
8310: PUSH
8311: EMPTY
8312: LIST
8313: LIST
8314: PPUSH
8315: CALL_OW 1
8319: ST_TO_ADDR
// continue ;
8320: GO 8254
// end ;
8322: GO 8254
8324: POP
8325: POP
8326: GO 8235
8328: POP
8329: POP
// for i in ai_bases do
8330: LD_ADDR_VAR 0 3
8334: PUSH
8335: LD_EXP 49
8339: PUSH
8340: FOR_IN
8341: IFFALSE 8404
// if GetDistUnitXY ( un , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) <= 40 then
8343: LD_VAR 0 1
8347: PPUSH
8348: LD_VAR 0 4
8352: PUSH
8353: LD_VAR 0 3
8357: ARRAY
8358: PUSH
8359: LD_INT 1
8361: ARRAY
8362: PPUSH
8363: LD_VAR 0 4
8367: PUSH
8368: LD_VAR 0 3
8372: ARRAY
8373: PUSH
8374: LD_INT 2
8376: ARRAY
8377: PPUSH
8378: CALL_OW 297
8382: PUSH
8383: LD_INT 40
8385: LESSEQUAL
8386: IFFALSE 8402
// begin result = i ;
8388: LD_ADDR_VAR 0 2
8392: PUSH
8393: LD_VAR 0 3
8397: ST_TO_ADDR
// exit ;
8398: POP
8399: POP
8400: GO 8414
// end ;
8402: GO 8340
8404: POP
8405: POP
// result = 0 ;
8406: LD_ADDR_VAR 0 2
8410: PUSH
8411: LD_INT 0
8413: ST_TO_ADDR
// end ;
8414: LD_VAR 0 2
8418: RET
// function GetBaseSide ( base ) ; begin
8419: LD_INT 0
8421: PPUSH
// result = russians ;
8422: LD_ADDR_VAR 0 2
8426: PUSH
8427: LD_EXP 3
8431: ST_TO_ADDR
// end ;
8432: LD_VAR 0 2
8436: RET
// function GetBaseNation ( base ) ; begin
8437: LD_INT 0
8439: PPUSH
// result = nation_russian ;
8440: LD_ADDR_VAR 0 2
8444: PUSH
8445: LD_INT 3
8447: ST_TO_ADDR
// end ;
8448: LD_VAR 0 2
8452: RET
// export function GetBaseArea ( base ) ; begin
8453: LD_INT 0
8455: PPUSH
// case base of 1 :
8456: LD_VAR 0 1
8460: PUSH
8461: LD_INT 1
8463: DOUBLE
8464: EQUAL
8465: IFTRUE 8469
8467: GO 8480
8469: POP
// result = rubase1 ; 2 :
8470: LD_ADDR_VAR 0 2
8474: PUSH
8475: LD_INT 3
8477: ST_TO_ADDR
8478: GO 8519
8480: LD_INT 2
8482: DOUBLE
8483: EQUAL
8484: IFTRUE 8488
8486: GO 8499
8488: POP
// result = rubase2 ; 3 :
8489: LD_ADDR_VAR 0 2
8493: PUSH
8494: LD_INT 2
8496: ST_TO_ADDR
8497: GO 8519
8499: LD_INT 3
8501: DOUBLE
8502: EQUAL
8503: IFTRUE 8507
8505: GO 8518
8507: POP
// result = rubase3 ; end ;
8508: LD_ADDR_VAR 0 2
8512: PUSH
8513: LD_INT 1
8515: ST_TO_ADDR
8516: GO 8519
8518: POP
// end ;
8519: LD_VAR 0 2
8523: RET
// every 0 0$1 do var side , i , temp_list , buildings_list , soldiers_list , temp_unit , base , bunkers , under_attack , j ;
8524: GO 8526
8526: DISABLE
8527: LD_INT 0
8529: PPUSH
8530: PPUSH
8531: PPUSH
8532: PPUSH
8533: PPUSH
8534: PPUSH
8535: PPUSH
8536: PPUSH
8537: PPUSH
8538: PPUSH
// begin side = russians ;
8539: LD_ADDR_VAR 0 1
8543: PUSH
8544: LD_EXP 3
8548: ST_TO_ADDR
// for base in ai_bases do
8549: LD_ADDR_VAR 0 7
8553: PUSH
8554: LD_EXP 49
8558: PUSH
8559: FOR_IN
8560: IFFALSE 9797
// begin soldiers_list = ai_soldiers [ base ] ;
8562: LD_ADDR_VAR 0 5
8566: PUSH
8567: LD_EXP 22
8571: PUSH
8572: LD_VAR 0 7
8576: ARRAY
8577: ST_TO_ADDR
// under_attack := BaseUnderAttack ( side , base ) ;
8578: LD_ADDR_VAR 0 9
8582: PUSH
8583: LD_VAR 0 1
8587: PPUSH
8588: LD_VAR 0 7
8592: PPUSH
8593: CALL 13662 0 2
8597: ST_TO_ADDR
// temp_list = ai_heal_these_humans [ base ] ;
8598: LD_ADDR_VAR 0 3
8602: PUSH
8603: LD_EXP 35
8607: PUSH
8608: LD_VAR 0 7
8612: ARRAY
8613: ST_TO_ADDR
// for i in soldiers_list diff ai_heal_these_humans [ base ] do
8614: LD_ADDR_VAR 0 2
8618: PUSH
8619: LD_VAR 0 5
8623: PUSH
8624: LD_EXP 35
8628: PUSH
8629: LD_VAR 0 7
8633: ARRAY
8634: DIFF
8635: PUSH
8636: FOR_IN
8637: IFFALSE 8672
// if GetLives ( i ) < 800 then
8639: LD_VAR 0 2
8643: PPUSH
8644: CALL_OW 256
8648: PUSH
8649: LD_INT 800
8651: LESS
8652: IFFALSE 8670
// temp_list = temp_list ^ i ;
8654: LD_ADDR_VAR 0 3
8658: PUSH
8659: LD_VAR 0 3
8663: PUSH
8664: LD_VAR 0 2
8668: ADD
8669: ST_TO_ADDR
8670: GO 8636
8672: POP
8673: POP
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
8674: LD_ADDR_EXP 35
8678: PUSH
8679: LD_EXP 35
8683: PPUSH
8684: LD_VAR 0 7
8688: PPUSH
8689: LD_VAR 0 3
8693: PPUSH
8694: CALL_OW 1
8698: ST_TO_ADDR
// if not under_attack then
8699: LD_VAR 0 9
8703: NOT
8704: IFFALSE 8819
// begin for i in ai_heal_these_humans [ base ] do
8706: LD_ADDR_VAR 0 2
8710: PUSH
8711: LD_EXP 35
8715: PUSH
8716: LD_VAR 0 7
8720: ARRAY
8721: PUSH
8722: FOR_IN
8723: IFFALSE 8795
// if i in soldiers_list then
8725: LD_VAR 0 2
8729: PUSH
8730: LD_VAR 0 5
8734: IN
8735: IFFALSE 8793
// case GetType ( IsInUnit ( i ) ) of unit_vehicle :
8737: LD_VAR 0 2
8741: PPUSH
8742: CALL_OW 310
8746: PPUSH
8747: CALL_OW 247
8751: PUSH
8752: LD_INT 2
8754: DOUBLE
8755: EQUAL
8756: IFTRUE 8760
8758: GO 8772
8760: POP
// ComExitVehicle ( i ) ; unit_building :
8761: LD_VAR 0 2
8765: PPUSH
8766: CALL_OW 121
8770: GO 8793
8772: LD_INT 3
8774: DOUBLE
8775: EQUAL
8776: IFTRUE 8780
8778: GO 8792
8780: POP
// ComExitBuilding ( i ) ; end ;
8781: LD_VAR 0 2
8785: PPUSH
8786: CALL_OW 122
8790: GO 8793
8792: POP
8793: GO 8722
8795: POP
8796: POP
// soldiers_list = soldiers_list diff ai_heal_these_humans [ base ] ;
8797: LD_ADDR_VAR 0 5
8801: PUSH
8802: LD_VAR 0 5
8806: PUSH
8807: LD_EXP 35
8811: PUSH
8812: LD_VAR 0 7
8816: ARRAY
8817: DIFF
8818: ST_TO_ADDR
// end ; if soldiers_list = 0 then
8819: LD_VAR 0 5
8823: PUSH
8824: LD_INT 0
8826: EQUAL
8827: IFFALSE 8831
// continue ;
8829: GO 8559
// i = false ;
8831: LD_ADDR_VAR 0 2
8835: PUSH
8836: LD_INT 0
8838: ST_TO_ADDR
// if IsOk ( ai_depot [ base ] ) then
8839: LD_EXP 27
8843: PUSH
8844: LD_VAR 0 7
8848: ARRAY
8849: PPUSH
8850: CALL_OW 302
8854: IFFALSE 8894
// if GetEnergy ( GetBase ( ai_depot [ base ] ) ) [ 4 ] > 0 then
8856: LD_EXP 27
8860: PUSH
8861: LD_VAR 0 7
8865: ARRAY
8866: PPUSH
8867: CALL_OW 274
8871: PPUSH
8872: CALL_OW 278
8876: PUSH
8877: LD_INT 4
8879: ARRAY
8880: PUSH
8881: LD_INT 0
8883: GREATER
8884: IFFALSE 8894
// i = true ;
8886: LD_ADDR_VAR 0 2
8890: PUSH
8891: LD_INT 1
8893: ST_TO_ADDR
// if i then
8894: LD_VAR 0 2
8898: IFFALSE 8918
// bunkers = ai_bunkers [ base ] else
8900: LD_ADDR_VAR 0 8
8904: PUSH
8905: LD_EXP 41
8909: PUSH
8910: LD_VAR 0 7
8914: ARRAY
8915: ST_TO_ADDR
8916: GO 8979
// begin bunkers = [ ] ;
8918: LD_ADDR_VAR 0 8
8922: PUSH
8923: EMPTY
8924: ST_TO_ADDR
// for i in ai_bunkers [ base ] do
8925: LD_ADDR_VAR 0 2
8929: PUSH
8930: LD_EXP 41
8934: PUSH
8935: LD_VAR 0 7
8939: ARRAY
8940: PUSH
8941: FOR_IN
8942: IFFALSE 8977
// if GetBType ( i ) = b_breastwork then
8944: LD_VAR 0 2
8948: PPUSH
8949: CALL_OW 266
8953: PUSH
8954: LD_INT 31
8956: EQUAL
8957: IFFALSE 8975
// bunkers = bunkers ^ i ;
8959: LD_ADDR_VAR 0 8
8963: PUSH
8964: LD_VAR 0 8
8968: PUSH
8969: LD_VAR 0 2
8973: ADD
8974: ST_TO_ADDR
8975: GO 8941
8977: POP
8978: POP
// end ; buildings_list = [ ] ;
8979: LD_ADDR_VAR 0 4
8983: PUSH
8984: EMPTY
8985: ST_TO_ADDR
// for i in UnitFilter ( bunkers , [ f_ok ] ) do
8986: LD_ADDR_VAR 0 2
8990: PUSH
8991: LD_VAR 0 8
8995: PPUSH
8996: LD_INT 50
8998: PUSH
8999: EMPTY
9000: LIST
9001: PPUSH
9002: CALL_OW 72
9006: PUSH
9007: FOR_IN
9008: IFFALSE 9071
// begin temp_unit = UnitsInside ( i ) ;
9010: LD_ADDR_VAR 0 6
9014: PUSH
9015: LD_VAR 0 2
9019: PPUSH
9020: CALL_OW 313
9024: ST_TO_ADDR
// if temp_unit = 0 then
9025: LD_VAR 0 6
9029: PUSH
9030: LD_INT 0
9032: EQUAL
9033: IFFALSE 9053
// buildings_list = buildings_list ^ i else
9035: LD_ADDR_VAR 0 4
9039: PUSH
9040: LD_VAR 0 4
9044: PUSH
9045: LD_VAR 0 2
9049: ADD
9050: ST_TO_ADDR
9051: GO 9069
// soldiers_list = soldiers_list diff temp_unit ;
9053: LD_ADDR_VAR 0 5
9057: PUSH
9058: LD_VAR 0 5
9062: PUSH
9063: LD_VAR 0 6
9067: DIFF
9068: ST_TO_ADDR
// end ;
9069: GO 9007
9071: POP
9072: POP
// if buildings_list > 0 then
9073: LD_VAR 0 4
9077: PUSH
9078: LD_INT 0
9080: GREATER
9081: IFFALSE 9327
// begin if not under_attack then
9083: LD_VAR 0 9
9087: NOT
9088: IFFALSE 9158
// begin temp_list = [ ] ;
9090: LD_ADDR_VAR 0 3
9094: PUSH
9095: EMPTY
9096: ST_TO_ADDR
// for i in soldiers_list do
9097: LD_ADDR_VAR 0 2
9101: PUSH
9102: LD_VAR 0 5
9106: PUSH
9107: FOR_IN
9108: IFFALSE 9136
// temp_list = temp_list ^ GetSkill ( i , skill_combat ) ;
9110: LD_ADDR_VAR 0 3
9114: PUSH
9115: LD_VAR 0 3
9119: PUSH
9120: LD_VAR 0 2
9124: PPUSH
9125: LD_INT 1
9127: PPUSH
9128: CALL_OW 259
9132: ADD
9133: ST_TO_ADDR
9134: GO 9107
9136: POP
9137: POP
// soldiers_list = SortListByListDesc ( soldiers_list , temp_list ) ;
9138: LD_ADDR_VAR 0 5
9142: PUSH
9143: LD_VAR 0 5
9147: PPUSH
9148: LD_VAR 0 3
9152: PPUSH
9153: CALL_OW 77
9157: ST_TO_ADDR
// end ; for i = 1 to buildings_list do
9158: LD_ADDR_VAR 0 2
9162: PUSH
9163: DOUBLE
9164: LD_INT 1
9166: DEC
9167: ST_TO_ADDR
9168: LD_VAR 0 4
9172: PUSH
9173: FOR_TO
9174: IFFALSE 9325
// begin if soldiers_list = 0 then
9176: LD_VAR 0 5
9180: PUSH
9181: LD_INT 0
9183: EQUAL
9184: IFFALSE 9188
// break ;
9186: GO 9325
// if not under_attack then
9188: LD_VAR 0 9
9192: NOT
9193: IFFALSE 9211
// temp_unit = soldiers_list [ 1 ] else
9195: LD_ADDR_VAR 0 6
9199: PUSH
9200: LD_VAR 0 5
9204: PUSH
9205: LD_INT 1
9207: ARRAY
9208: ST_TO_ADDR
9209: GO 9287
// begin temp_list = [ ] ;
9211: LD_ADDR_VAR 0 3
9215: PUSH
9216: EMPTY
9217: ST_TO_ADDR
// for j in soldiers_list do
9218: LD_ADDR_VAR 0 10
9222: PUSH
9223: LD_VAR 0 5
9227: PUSH
9228: FOR_IN
9229: IFFALSE 9265
// temp_list = temp_list ^ GetDistUnits ( j , buildings_list [ i ] ) ;
9231: LD_ADDR_VAR 0 3
9235: PUSH
9236: LD_VAR 0 3
9240: PUSH
9241: LD_VAR 0 10
9245: PPUSH
9246: LD_VAR 0 4
9250: PUSH
9251: LD_VAR 0 2
9255: ARRAY
9256: PPUSH
9257: CALL_OW 296
9261: ADD
9262: ST_TO_ADDR
9263: GO 9228
9265: POP
9266: POP
// temp_unit = WorstFromListByList ( soldiers_list , temp_list ) ;
9267: LD_ADDR_VAR 0 6
9271: PUSH
9272: LD_VAR 0 5
9276: PPUSH
9277: LD_VAR 0 3
9281: PPUSH
9282: CALL_OW 78
9286: ST_TO_ADDR
// end ; ComEnterUnit ( temp_unit , buildings_list [ i ] ) ;
9287: LD_VAR 0 6
9291: PPUSH
9292: LD_VAR 0 4
9296: PUSH
9297: LD_VAR 0 2
9301: ARRAY
9302: PPUSH
9303: CALL_OW 120
// soldiers_list = soldiers_list diff temp_unit ;
9307: LD_ADDR_VAR 0 5
9311: PUSH
9312: LD_VAR 0 5
9316: PUSH
9317: LD_VAR 0 6
9321: DIFF
9322: ST_TO_ADDR
// end ;
9323: GO 9173
9325: POP
9326: POP
// end ; if IsOk ( ai_armoury [ base ] ) and BuildingStatus ( ai_armoury [ base ] ) <> bs_build then
9327: LD_EXP 40
9331: PUSH
9332: LD_VAR 0 7
9336: ARRAY
9337: PPUSH
9338: CALL_OW 302
9342: PUSH
9343: LD_EXP 40
9347: PUSH
9348: LD_VAR 0 7
9352: ARRAY
9353: PPUSH
9354: CALL_OW 461
9358: PUSH
9359: LD_INT 1
9361: NONEQUAL
9362: AND
9363: IFFALSE 9602
// begin if IsOk ( ai_armoury [ base ] ) then
9365: LD_EXP 40
9369: PUSH
9370: LD_VAR 0 7
9374: ARRAY
9375: PPUSH
9376: CALL_OW 302
9380: IFFALSE 9499
// begin temp_list = UnitsInside ( ai_armoury [ base ] ) ;
9382: LD_ADDR_VAR 0 3
9386: PUSH
9387: LD_EXP 40
9391: PUSH
9392: LD_VAR 0 7
9396: ARRAY
9397: PPUSH
9398: CALL_OW 313
9402: ST_TO_ADDR
// soldiers_list = soldiers_list diff temp_list ;
9403: LD_ADDR_VAR 0 5
9407: PUSH
9408: LD_VAR 0 5
9412: PUSH
9413: LD_VAR 0 3
9417: DIFF
9418: ST_TO_ADDR
// for i = 5 downto temp_list + 0 do
9419: LD_ADDR_VAR 0 2
9423: PUSH
9424: DOUBLE
9425: LD_INT 5
9427: INC
9428: ST_TO_ADDR
9429: LD_VAR 0 3
9433: PUSH
9434: LD_INT 0
9436: PLUS
9437: PUSH
9438: FOR_DOWNTO
9439: IFFALSE 9497
// begin if soldiers_list = 0 then
9441: LD_VAR 0 5
9445: PUSH
9446: LD_INT 0
9448: EQUAL
9449: IFFALSE 9453
// break ;
9451: GO 9497
// ComEnterUnit ( soldiers_list [ 1 ] , ai_armoury [ base ] ) ;
9453: LD_VAR 0 5
9457: PUSH
9458: LD_INT 1
9460: ARRAY
9461: PPUSH
9462: LD_EXP 40
9466: PUSH
9467: LD_VAR 0 7
9471: ARRAY
9472: PPUSH
9473: CALL_OW 120
// soldiers_list = Delete ( soldiers_list , 1 ) ;
9477: LD_ADDR_VAR 0 5
9481: PUSH
9482: LD_VAR 0 5
9486: PPUSH
9487: LD_INT 1
9489: PPUSH
9490: CALL_OW 3
9494: ST_TO_ADDR
// end ;
9495: GO 9438
9497: POP
9498: POP
// end ; for i in soldiers_list do
9499: LD_ADDR_VAR 0 2
9503: PUSH
9504: LD_VAR 0 5
9508: PUSH
9509: FOR_IN
9510: IFFALSE 9598
// if GetDistUnitXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) > 4 then
9512: LD_VAR 0 2
9516: PPUSH
9517: LD_EXP 33
9521: PUSH
9522: LD_VAR 0 7
9526: ARRAY
9527: PUSH
9528: LD_INT 1
9530: ARRAY
9531: PPUSH
9532: LD_EXP 33
9536: PUSH
9537: LD_VAR 0 7
9541: ARRAY
9542: PUSH
9543: LD_INT 2
9545: ARRAY
9546: PPUSH
9547: CALL_OW 297
9551: PUSH
9552: LD_INT 4
9554: GREATER
9555: IFFALSE 9596
// ComAgressiveMove ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
9557: LD_VAR 0 2
9561: PPUSH
9562: LD_EXP 33
9566: PUSH
9567: LD_VAR 0 7
9571: ARRAY
9572: PUSH
9573: LD_INT 1
9575: ARRAY
9576: PPUSH
9577: LD_EXP 33
9581: PUSH
9582: LD_VAR 0 7
9586: ARRAY
9587: PUSH
9588: LD_INT 2
9590: ARRAY
9591: PPUSH
9592: CALL_OW 114
9596: GO 9509
9598: POP
9599: POP
// end else
9600: GO 9795
// if ai_building_under_construction [ base ] > 0 and not under_attack then
9602: LD_EXP 34
9606: PUSH
9607: LD_VAR 0 7
9611: ARRAY
9612: PUSH
9613: LD_INT 0
9615: GREATER
9616: PUSH
9617: LD_VAR 0 9
9621: NOT
9622: AND
9623: IFFALSE 9694
// begin for i in soldiers_list do
9625: LD_ADDR_VAR 0 2
9629: PUSH
9630: LD_VAR 0 5
9634: PUSH
9635: FOR_IN
9636: IFFALSE 9690
// SetTaskList ( i , [ [ h , 0 , 0 , ai_building_under_construction [ base ] , 0 , 0 , 0 ] ] ) ;
9638: LD_VAR 0 2
9642: PPUSH
9643: LD_STRING h
9645: PUSH
9646: LD_INT 0
9648: PUSH
9649: LD_INT 0
9651: PUSH
9652: LD_EXP 34
9656: PUSH
9657: LD_VAR 0 7
9661: ARRAY
9662: PUSH
9663: LD_INT 0
9665: PUSH
9666: LD_INT 0
9668: PUSH
9669: LD_INT 0
9671: PUSH
9672: EMPTY
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: LIST
9678: LIST
9679: LIST
9680: PUSH
9681: EMPTY
9682: LIST
9683: PPUSH
9684: CALL_OW 446
9688: GO 9635
9690: POP
9691: POP
// end else
9692: GO 9795
// for i in soldiers_list do
9694: LD_ADDR_VAR 0 2
9698: PUSH
9699: LD_VAR 0 5
9703: PUSH
9704: FOR_IN
9705: IFFALSE 9793
// if GetDistUnitXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) > 4 then
9707: LD_VAR 0 2
9711: PPUSH
9712: LD_EXP 33
9716: PUSH
9717: LD_VAR 0 7
9721: ARRAY
9722: PUSH
9723: LD_INT 1
9725: ARRAY
9726: PPUSH
9727: LD_EXP 33
9731: PUSH
9732: LD_VAR 0 7
9736: ARRAY
9737: PUSH
9738: LD_INT 2
9740: ARRAY
9741: PPUSH
9742: CALL_OW 297
9746: PUSH
9747: LD_INT 4
9749: GREATER
9750: IFFALSE 9791
// ComAgressiveMove ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
9752: LD_VAR 0 2
9756: PPUSH
9757: LD_EXP 33
9761: PUSH
9762: LD_VAR 0 7
9766: ARRAY
9767: PUSH
9768: LD_INT 1
9770: ARRAY
9771: PPUSH
9772: LD_EXP 33
9776: PUSH
9777: LD_VAR 0 7
9781: ARRAY
9782: PUSH
9783: LD_INT 2
9785: ARRAY
9786: PPUSH
9787: CALL_OW 114
9791: GO 9704
9793: POP
9794: POP
// end ;
9795: GO 8559
9797: POP
9798: POP
// enable ;
9799: ENABLE
// end ;
9800: PPOPN 10
9802: END
// every 0 0$1 do var side , i , engineers_list , temp_list , buildings_list , temp_unit , away_dist , temp_list_2 , base , k ; var under_attack ;
9803: GO 9805
9805: DISABLE
9806: LD_INT 0
9808: PPUSH
9809: PPUSH
9810: PPUSH
9811: PPUSH
9812: PPUSH
9813: PPUSH
9814: PPUSH
9815: PPUSH
9816: PPUSH
9817: PPUSH
9818: PPUSH
// begin side = russians ;
9819: LD_ADDR_VAR 0 1
9823: PUSH
9824: LD_EXP 3
9828: ST_TO_ADDR
// for base in ai_bases do
9829: LD_ADDR_VAR 0 9
9833: PUSH
9834: LD_EXP 49
9838: PUSH
9839: FOR_IN
9840: IFFALSE 12612
// begin under_attack = BaseUnderAttack ( side , base ) ;
9842: LD_ADDR_VAR 0 11
9846: PUSH
9847: LD_VAR 0 1
9851: PPUSH
9852: LD_VAR 0 9
9856: PPUSH
9857: CALL 13662 0 2
9861: ST_TO_ADDR
// engineers_list = ai_engineers [ base ] diff ai_heal_these_humans [ base ] ;
9862: LD_ADDR_VAR 0 3
9866: PUSH
9867: LD_EXP 23
9871: PUSH
9872: LD_VAR 0 9
9876: ARRAY
9877: PUSH
9878: LD_EXP 35
9882: PUSH
9883: LD_VAR 0 9
9887: ARRAY
9888: DIFF
9889: ST_TO_ADDR
// temp_list = ai_heal_these_humans [ base ] ;
9890: LD_ADDR_VAR 0 4
9894: PUSH
9895: LD_EXP 35
9899: PUSH
9900: LD_VAR 0 9
9904: ARRAY
9905: ST_TO_ADDR
// i = 1 ;
9906: LD_ADDR_VAR 0 2
9910: PUSH
9911: LD_INT 1
9913: ST_TO_ADDR
// while i <= engineers_list do
9914: LD_VAR 0 2
9918: PUSH
9919: LD_VAR 0 3
9923: LESSEQUAL
9924: IFFALSE 10019
// begin if GetLives ( engineers_list [ i ] ) <= 700 then
9926: LD_VAR 0 3
9930: PUSH
9931: LD_VAR 0 2
9935: ARRAY
9936: PPUSH
9937: CALL_OW 256
9941: PUSH
9942: LD_INT 700
9944: LESSEQUAL
9945: IFFALSE 10003
// begin temp_list = temp_list ^ engineers_list [ i ] ;
9947: LD_ADDR_VAR 0 4
9951: PUSH
9952: LD_VAR 0 4
9956: PUSH
9957: LD_VAR 0 3
9961: PUSH
9962: LD_VAR 0 2
9966: ARRAY
9967: ADD
9968: ST_TO_ADDR
// engineers_list = Delete ( engineers_list , i ) ;
9969: LD_ADDR_VAR 0 3
9973: PUSH
9974: LD_VAR 0 3
9978: PPUSH
9979: LD_VAR 0 2
9983: PPUSH
9984: CALL_OW 3
9988: ST_TO_ADDR
// i = i - 1 ;
9989: LD_ADDR_VAR 0 2
9993: PUSH
9994: LD_VAR 0 2
9998: PUSH
9999: LD_INT 1
10001: MINUS
10002: ST_TO_ADDR
// end ; i = i + 1 ;
10003: LD_ADDR_VAR 0 2
10007: PUSH
10008: LD_VAR 0 2
10012: PUSH
10013: LD_INT 1
10015: PLUS
10016: ST_TO_ADDR
// end ;
10017: GO 9914
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
10019: LD_ADDR_EXP 35
10023: PUSH
10024: LD_EXP 35
10028: PPUSH
10029: LD_VAR 0 9
10033: PPUSH
10034: LD_VAR 0 4
10038: PPUSH
10039: CALL_OW 1
10043: ST_TO_ADDR
// if engineers_list = 0 then
10044: LD_VAR 0 3
10048: PUSH
10049: LD_INT 0
10051: EQUAL
10052: IFFALSE 10056
// continue ;
10054: GO 9839
// temp_list_2 = UnitFilter ( engineers_list , [ f_class , class_engineer ] ) ;
10056: LD_ADDR_VAR 0 8
10060: PUSH
10061: LD_VAR 0 3
10065: PPUSH
10066: LD_INT 25
10068: PUSH
10069: LD_INT 2
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: PPUSH
10076: CALL_OW 72
10080: ST_TO_ADDR
// if ai_captured_buildings [ base ] > 0 and temp_list_2 > 0 then
10081: LD_EXP 51
10085: PUSH
10086: LD_VAR 0 9
10090: ARRAY
10091: PUSH
10092: LD_INT 0
10094: GREATER
10095: PUSH
10096: LD_VAR 0 8
10100: PUSH
10101: LD_INT 0
10103: GREATER
10104: AND
10105: IFFALSE 10366
// begin temp_list = [ ] ;
10107: LD_ADDR_VAR 0 4
10111: PUSH
10112: EMPTY
10113: ST_TO_ADDR
// for i in ai_captured_buildings [ base ] do
10114: LD_ADDR_VAR 0 2
10118: PUSH
10119: LD_EXP 51
10123: PUSH
10124: LD_VAR 0 9
10128: ARRAY
10129: PUSH
10130: FOR_IN
10131: IFFALSE 10187
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
10133: LD_VAR 0 2
10137: PPUSH
10138: CALL_OW 266
10142: PUSH
10143: LD_INT 0
10145: PUSH
10146: LD_INT 1
10148: PUSH
10149: EMPTY
10150: LIST
10151: LIST
10152: IN
10153: IFFALSE 10171
// temp_list = temp_list ^ 1 else
10155: LD_ADDR_VAR 0 4
10159: PUSH
10160: LD_VAR 0 4
10164: PUSH
10165: LD_INT 1
10167: ADD
10168: ST_TO_ADDR
10169: GO 10185
// temp_list = temp_list ^ 0 ;
10171: LD_ADDR_VAR 0 4
10175: PUSH
10176: LD_VAR 0 4
10180: PUSH
10181: LD_INT 0
10183: ADD
10184: ST_TO_ADDR
10185: GO 10130
10187: POP
10188: POP
// temp_list = SortListByListDesc ( ai_captured_buildings [ base ] , temp_list ) ;
10189: LD_ADDR_VAR 0 4
10193: PUSH
10194: LD_EXP 51
10198: PUSH
10199: LD_VAR 0 9
10203: ARRAY
10204: PPUSH
10205: LD_VAR 0 4
10209: PPUSH
10210: CALL_OW 77
10214: ST_TO_ADDR
// temp_list_2 = GetHumansOutOfUnits ( temp_list_2 ) ;
10215: LD_ADDR_VAR 0 8
10219: PUSH
10220: LD_VAR 0 8
10224: PPUSH
10225: CALL 13557 0 1
10229: ST_TO_ADDR
// if temp_list_2 > 0 then
10230: LD_VAR 0 8
10234: PUSH
10235: LD_INT 0
10237: GREATER
10238: IFFALSE 10354
// begin temp_list_2 = SortListByListDesc ( temp_list_2 , temp_list_2 ) ;
10240: LD_ADDR_VAR 0 8
10244: PUSH
10245: LD_VAR 0 8
10249: PPUSH
10250: LD_VAR 0 8
10254: PPUSH
10255: CALL_OW 77
10259: ST_TO_ADDR
// SetTaskList ( temp_list_2 [ 1 ] , [ [ e , GetX ( temp_list [ 1 ] ) , GetY ( temp_list [ 1 ] ) , temp_list [ 1 ] , 0 , 0 , 0 ] ] ) ;
10260: LD_VAR 0 8
10264: PUSH
10265: LD_INT 1
10267: ARRAY
10268: PPUSH
10269: LD_STRING e
10271: PUSH
10272: LD_VAR 0 4
10276: PUSH
10277: LD_INT 1
10279: ARRAY
10280: PPUSH
10281: CALL_OW 250
10285: PUSH
10286: LD_VAR 0 4
10290: PUSH
10291: LD_INT 1
10293: ARRAY
10294: PPUSH
10295: CALL_OW 251
10299: PUSH
10300: LD_VAR 0 4
10304: PUSH
10305: LD_INT 1
10307: ARRAY
10308: PUSH
10309: LD_INT 0
10311: PUSH
10312: LD_INT 0
10314: PUSH
10315: LD_INT 0
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: PUSH
10327: EMPTY
10328: LIST
10329: PPUSH
10330: CALL_OW 446
// engineers_list = engineers_list diff temp_list_2 [ 1 ] ;
10334: LD_ADDR_VAR 0 3
10338: PUSH
10339: LD_VAR 0 3
10343: PUSH
10344: LD_VAR 0 8
10348: PUSH
10349: LD_INT 1
10351: ARRAY
10352: DIFF
10353: ST_TO_ADDR
// end ; if engineers_list = 0 then
10354: LD_VAR 0 3
10358: PUSH
10359: LD_INT 0
10361: EQUAL
10362: IFFALSE 10366
// continue ;
10364: GO 9839
// end ; i = 1 ;
10366: LD_ADDR_VAR 0 2
10370: PUSH
10371: LD_INT 1
10373: ST_TO_ADDR
// buildings_list = [ ] ;
10374: LD_ADDR_VAR 0 5
10378: PUSH
10379: EMPTY
10380: ST_TO_ADDR
// repeat case i of 1 :
10381: LD_VAR 0 2
10385: PUSH
10386: LD_INT 1
10388: DOUBLE
10389: EQUAL
10390: IFTRUE 10394
10392: GO 10431
10394: POP
// buildings_list = UnitFilter ( ai_all_buildings [ base ] , [ f_not , [ f_ok ] ] ) ; 2 :
10395: LD_ADDR_VAR 0 5
10399: PUSH
10400: LD_EXP 36
10404: PUSH
10405: LD_VAR 0 9
10409: ARRAY
10410: PPUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 50
10416: PUSH
10417: EMPTY
10418: LIST
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: PPUSH
10424: CALL_OW 72
10428: ST_TO_ADDR
10429: GO 10481
10431: LD_INT 2
10433: DOUBLE
10434: EQUAL
10435: IFTRUE 10439
10437: GO 10480
10439: POP
// buildings_list = UnitFilter ( ai_all_buildings [ base ] , [ f_not , [ f_lives , 1000 ] ] ) ; end ;
10440: LD_ADDR_VAR 0 5
10444: PUSH
10445: LD_EXP 36
10449: PUSH
10450: LD_VAR 0 9
10454: ARRAY
10455: PPUSH
10456: LD_INT 3
10458: PUSH
10459: LD_INT 24
10461: PUSH
10462: LD_INT 1000
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: EMPTY
10470: LIST
10471: LIST
10472: PPUSH
10473: CALL_OW 72
10477: ST_TO_ADDR
10478: GO 10481
10480: POP
// i = i + 1 ;
10481: LD_ADDR_VAR 0 2
10485: PUSH
10486: LD_VAR 0 2
10490: PUSH
10491: LD_INT 1
10493: PLUS
10494: ST_TO_ADDR
// until buildings_list > 0 or i > 2 ;
10495: LD_VAR 0 5
10499: PUSH
10500: LD_INT 0
10502: GREATER
10503: PUSH
10504: LD_VAR 0 2
10508: PUSH
10509: LD_INT 2
10511: GREATER
10512: OR
10513: IFFALSE 10381
// if buildings_list > 0 then
10515: LD_VAR 0 5
10519: PUSH
10520: LD_INT 0
10522: GREATER
10523: IFFALSE 10662
// begin engineers_list = GetHumansOutOfUnits ( engineers_list ) ;
10525: LD_ADDR_VAR 0 3
10529: PUSH
10530: LD_VAR 0 3
10534: PPUSH
10535: CALL 13557 0 1
10539: ST_TO_ADDR
// repeat i = 1 ;
10540: LD_ADDR_VAR 0 2
10544: PUSH
10545: LD_INT 1
10547: ST_TO_ADDR
// while i <= buildings_list do
10548: LD_VAR 0 2
10552: PUSH
10553: LD_VAR 0 5
10557: LESSEQUAL
10558: IFFALSE 10650
// begin if engineers_list = 0 then
10560: LD_VAR 0 3
10564: PUSH
10565: LD_INT 0
10567: EQUAL
10568: IFFALSE 10572
// break ;
10570: GO 10650
// temp_unit = NearestUnitToUnit ( engineers_list , buildings_list [ i ] ) ;
10572: LD_ADDR_VAR 0 6
10576: PUSH
10577: LD_VAR 0 3
10581: PPUSH
10582: LD_VAR 0 5
10586: PUSH
10587: LD_VAR 0 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 74
10597: ST_TO_ADDR
// ComRepairBuilding ( temp_unit , buildings_list [ i ] ) ;
10598: LD_VAR 0 6
10602: PPUSH
10603: LD_VAR 0 5
10607: PUSH
10608: LD_VAR 0 2
10612: ARRAY
10613: PPUSH
10614: CALL_OW 130
// engineers_list = engineers_list diff temp_unit ;
10618: LD_ADDR_VAR 0 3
10622: PUSH
10623: LD_VAR 0 3
10627: PUSH
10628: LD_VAR 0 6
10632: DIFF
10633: ST_TO_ADDR
// i = i + 1 ;
10634: LD_ADDR_VAR 0 2
10638: PUSH
10639: LD_VAR 0 2
10643: PUSH
10644: LD_INT 1
10646: PLUS
10647: ST_TO_ADDR
// end ;
10648: GO 10548
// until engineers_list = 0 ;
10650: LD_VAR 0 3
10654: PUSH
10655: LD_INT 0
10657: EQUAL
10658: IFFALSE 10540
// continue ;
10660: GO 9839
// end ; if not under_attack then
10662: LD_VAR 0 11
10666: NOT
10667: IFFALSE 12369
// begin if ai_building_under_construction [ base ] > 0 then
10669: LD_EXP 34
10673: PUSH
10674: LD_VAR 0 9
10678: ARRAY
10679: PUSH
10680: LD_INT 0
10682: GREATER
10683: IFFALSE 10790
// if BuildingStatus ( ai_building_under_construction [ base ] ) = bs_build then
10685: LD_EXP 34
10689: PUSH
10690: LD_VAR 0 9
10694: ARRAY
10695: PPUSH
10696: CALL_OW 461
10700: PUSH
10701: LD_INT 1
10703: EQUAL
10704: IFFALSE 10752
// begin for i in GetHumansOutOfUnits ( engineers_list ) do
10706: LD_ADDR_VAR 0 2
10710: PUSH
10711: LD_VAR 0 3
10715: PPUSH
10716: CALL 13557 0 1
10720: PUSH
10721: FOR_IN
10722: IFFALSE 10746
// ComRepairBuilding ( i , ai_building_under_construction [ base ] ) ;
10724: LD_VAR 0 2
10728: PPUSH
10729: LD_EXP 34
10733: PUSH
10734: LD_VAR 0 9
10738: ARRAY
10739: PPUSH
10740: CALL_OW 130
10744: GO 10721
10746: POP
10747: POP
// continue ;
10748: GO 9839
// end else
10750: GO 10790
// begin ComCancel ( ai_building_under_construction [ base ] ) ;
10752: LD_EXP 34
10756: PUSH
10757: LD_VAR 0 9
10761: ARRAY
10762: PPUSH
10763: CALL_OW 127
// ai_building_under_construction = Replace ( ai_building_under_construction , base , 0 ) ;
10767: LD_ADDR_EXP 34
10771: PUSH
10772: LD_EXP 34
10776: PPUSH
10777: LD_VAR 0 9
10781: PPUSH
10782: LD_INT 0
10784: PPUSH
10785: CALL_OW 1
10789: ST_TO_ADDR
// end ; if ai_all_buildings [ base ] < ai_buildings_locations [ base ] or ai_upcoming_building_data [ base ] > 0 then
10790: LD_EXP 36
10794: PUSH
10795: LD_VAR 0 9
10799: ARRAY
10800: PUSH
10801: LD_EXP 30
10805: PUSH
10806: LD_VAR 0 9
10810: ARRAY
10811: LESS
10812: PUSH
10813: LD_EXP 38
10817: PUSH
10818: LD_VAR 0 9
10822: ARRAY
10823: PUSH
10824: LD_INT 0
10826: GREATER
10827: OR
10828: IFFALSE 12231
// begin if ai_upcoming_building_data [ base ] = 0 then
10830: LD_EXP 38
10834: PUSH
10835: LD_VAR 0 9
10839: ARRAY
10840: PUSH
10841: LD_INT 0
10843: EQUAL
10844: IFFALSE 11253
// begin temp_list = [ ] ;
10846: LD_ADDR_VAR 0 4
10850: PUSH
10851: EMPTY
10852: ST_TO_ADDR
// for i in ai_buildings_locations [ base ] do
10853: LD_ADDR_VAR 0 2
10857: PUSH
10858: LD_EXP 30
10862: PUSH
10863: LD_VAR 0 9
10867: ARRAY
10868: PUSH
10869: FOR_IN
10870: IFFALSE 10920
// if GetBType ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) = - 1 then
10872: LD_VAR 0 2
10876: PUSH
10877: LD_INT 1
10879: ARRAY
10880: PPUSH
10881: LD_VAR 0 2
10885: PUSH
10886: LD_INT 2
10888: ARRAY
10889: PPUSH
10890: CALL_OW 428
10894: PPUSH
10895: CALL_OW 266
10899: PUSH
10900: LD_INT 1
10902: NEG
10903: EQUAL
10904: IFFALSE 10918
// begin temp_list = i ;
10906: LD_ADDR_VAR 0 4
10910: PUSH
10911: LD_VAR 0 2
10915: ST_TO_ADDR
// break ;
10916: GO 10920
// end ;
10918: GO 10869
10920: POP
10921: POP
// if temp_list > 0 then
10922: LD_VAR 0 4
10926: PUSH
10927: LD_INT 0
10929: GREATER
10930: IFFALSE 11253
// begin if temp_list [ 4 ] = b_bunker and GetBaseNation ( base ) in [ nation_american , nation_russian ] then
10932: LD_VAR 0 4
10936: PUSH
10937: LD_INT 4
10939: ARRAY
10940: PUSH
10941: LD_INT 32
10943: EQUAL
10944: PUSH
10945: LD_VAR 0 9
10949: PPUSH
10950: CALL 8437 0 1
10954: PUSH
10955: LD_INT 1
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: IN
10965: AND
10966: IFFALSE 11228
// begin k = 0 ;
10968: LD_ADDR_VAR 0 10
10972: PUSH
10973: LD_INT 0
10975: ST_TO_ADDR
// for i in ai_buildings_locations [ base ] do
10976: LD_ADDR_VAR 0 2
10980: PUSH
10981: LD_EXP 30
10985: PUSH
10986: LD_VAR 0 9
10990: ARRAY
10991: PUSH
10992: FOR_IN
10993: IFFALSE 11044
// if i [ 4 ] in [ b_breastwork , b_bunker , b_armoury , b_barracks , b_fort ] then
10995: LD_VAR 0 2
10999: PUSH
11000: LD_INT 4
11002: ARRAY
11003: PUSH
11004: LD_INT 31
11006: PUSH
11007: LD_INT 32
11009: PUSH
11010: LD_INT 4
11012: PUSH
11013: LD_INT 5
11015: PUSH
11016: LD_INT 35
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: IN
11026: IFFALSE 11042
// k = k + 1 ;
11028: LD_ADDR_VAR 0 10
11032: PUSH
11033: LD_VAR 0 10
11037: PUSH
11038: LD_INT 1
11040: PLUS
11041: ST_TO_ADDR
11042: GO 10992
11044: POP
11045: POP
// if k > ai_soldiers [ base ] then
11046: LD_VAR 0 10
11050: PUSH
11051: LD_EXP 22
11055: PUSH
11056: LD_VAR 0 9
11060: ARRAY
11061: GREATER
11062: IFFALSE 11228
// begin for i = 1 to ai_buildings_locations [ base ] do
11064: LD_ADDR_VAR 0 2
11068: PUSH
11069: DOUBLE
11070: LD_INT 1
11072: DEC
11073: ST_TO_ADDR
11074: LD_EXP 30
11078: PUSH
11079: LD_VAR 0 9
11083: ARRAY
11084: PUSH
11085: FOR_TO
11086: IFFALSE 11205
// if ai_buildings_locations [ base ] [ i ] = temp_list then
11088: LD_EXP 30
11092: PUSH
11093: LD_VAR 0 9
11097: ARRAY
11098: PUSH
11099: LD_VAR 0 2
11103: ARRAY
11104: PUSH
11105: LD_VAR 0 4
11109: EQUAL
11110: IFFALSE 11203
// begin temp_list_2 = Replace ( ai_buildings_locations [ base ] [ i ] , 4 , b_turret ) ;
11112: LD_ADDR_VAR 0 8
11116: PUSH
11117: LD_EXP 30
11121: PUSH
11122: LD_VAR 0 9
11126: ARRAY
11127: PUSH
11128: LD_VAR 0 2
11132: ARRAY
11133: PPUSH
11134: LD_INT 4
11136: PPUSH
11137: LD_INT 33
11139: PPUSH
11140: CALL_OW 1
11144: ST_TO_ADDR
// temp_list_2 = Replace ( ai_buildings_locations [ base ] , i , temp_list_2 ) ;
11145: LD_ADDR_VAR 0 8
11149: PUSH
11150: LD_EXP 30
11154: PUSH
11155: LD_VAR 0 9
11159: ARRAY
11160: PPUSH
11161: LD_VAR 0 2
11165: PPUSH
11166: LD_VAR 0 8
11170: PPUSH
11171: CALL_OW 1
11175: ST_TO_ADDR
// ai_buildings_locations = Replace ( ai_buildings_locations , base , temp_list_2 ) ;
11176: LD_ADDR_EXP 30
11180: PUSH
11181: LD_EXP 30
11185: PPUSH
11186: LD_VAR 0 9
11190: PPUSH
11191: LD_VAR 0 8
11195: PPUSH
11196: CALL_OW 1
11200: ST_TO_ADDR
// break ;
11201: GO 11205
// end ;
11203: GO 11085
11205: POP
11206: POP
// temp_list = Replace ( temp_list , 4 , b_turret ) ;
11207: LD_ADDR_VAR 0 4
11211: PUSH
11212: LD_VAR 0 4
11216: PPUSH
11217: LD_INT 4
11219: PPUSH
11220: LD_INT 33
11222: PPUSH
11223: CALL_OW 1
11227: ST_TO_ADDR
// end ; end ; ai_upcoming_building_data = Replace ( ai_upcoming_building_data , base , temp_list ) ;
11228: LD_ADDR_EXP 38
11232: PUSH
11233: LD_EXP 38
11237: PPUSH
11238: LD_VAR 0 9
11242: PPUSH
11243: LD_VAR 0 4
11247: PPUSH
11248: CALL_OW 1
11252: ST_TO_ADDR
// end ; end ; if ai_upcoming_building_data [ base ] > 0 then
11253: LD_EXP 38
11257: PUSH
11258: LD_VAR 0 9
11262: ARRAY
11263: PUSH
11264: LD_INT 0
11266: GREATER
11267: IFFALSE 12231
// begin if ai_building_constructor [ base ] = 0 then
11269: LD_EXP 37
11273: PUSH
11274: LD_VAR 0 9
11278: ARRAY
11279: PUSH
11280: LD_INT 0
11282: EQUAL
11283: IFFALSE 11409
// begin temp_list_2 = UnitFilter ( ai_engineers [ base ] , [ f_class , class_engineer ] ) ;
11285: LD_ADDR_VAR 0 8
11289: PUSH
11290: LD_EXP 23
11294: PUSH
11295: LD_VAR 0 9
11299: ARRAY
11300: PPUSH
11301: LD_INT 25
11303: PUSH
11304: LD_INT 2
11306: PUSH
11307: EMPTY
11308: LIST
11309: LIST
11310: PPUSH
11311: CALL_OW 72
11315: ST_TO_ADDR
// if temp_list_2 > 0 then
11316: LD_VAR 0 8
11320: PUSH
11321: LD_INT 0
11323: GREATER
11324: IFFALSE 11409
// begin temp_list = [ ] ;
11326: LD_ADDR_VAR 0 4
11330: PUSH
11331: EMPTY
11332: ST_TO_ADDR
// for i in temp_list_2 do
11333: LD_ADDR_VAR 0 2
11337: PUSH
11338: LD_VAR 0 8
11342: PUSH
11343: FOR_IN
11344: IFFALSE 11372
// temp_list = temp_list ^ GetSkill ( i , skill_engineering ) ;
11346: LD_ADDR_VAR 0 4
11350: PUSH
11351: LD_VAR 0 4
11355: PUSH
11356: LD_VAR 0 2
11360: PPUSH
11361: LD_INT 2
11363: PPUSH
11364: CALL_OW 259
11368: ADD
11369: ST_TO_ADDR
11370: GO 11343
11372: POP
11373: POP
// ai_building_constructor = Replace ( ai_building_constructor , base , BestFromListByList ( temp_list_2 , temp_list ) ) ;
11374: LD_ADDR_EXP 37
11378: PUSH
11379: LD_EXP 37
11383: PPUSH
11384: LD_VAR 0 9
11388: PPUSH
11389: LD_VAR 0 8
11393: PPUSH
11394: LD_VAR 0 4
11398: PPUSH
11399: CALL_OW 79
11403: PPUSH
11404: CALL_OW 1
11408: ST_TO_ADDR
// end ; end ; if ai_building_constructor [ base ] in engineers_list and ai_building_constructor [ base ] > 0 then
11409: LD_EXP 37
11413: PUSH
11414: LD_VAR 0 9
11418: ARRAY
11419: PUSH
11420: LD_VAR 0 3
11424: IN
11425: PUSH
11426: LD_EXP 37
11430: PUSH
11431: LD_VAR 0 9
11435: ARRAY
11436: PUSH
11437: LD_INT 0
11439: GREATER
11440: AND
11441: IFFALSE 12231
// begin engineers_list = engineers_list diff ai_building_constructor [ base ] ;
11443: LD_ADDR_VAR 0 3
11447: PUSH
11448: LD_VAR 0 3
11452: PUSH
11453: LD_EXP 37
11457: PUSH
11458: LD_VAR 0 9
11462: ARRAY
11463: DIFF
11464: ST_TO_ADDR
// case GetType ( IsInUnit ( ai_building_constructor [ base ] ) ) of unit_building :
11465: LD_EXP 37
11469: PUSH
11470: LD_VAR 0 9
11474: ARRAY
11475: PPUSH
11476: CALL_OW 310
11480: PPUSH
11481: CALL_OW 247
11485: PUSH
11486: LD_INT 3
11488: DOUBLE
11489: EQUAL
11490: IFTRUE 11494
11492: GO 11512
11494: POP
// ComExitBuilding ( ai_building_constructor [ base ] ) ; unit_vehicle :
11495: LD_EXP 37
11499: PUSH
11500: LD_VAR 0 9
11504: ARRAY
11505: PPUSH
11506: CALL_OW 122
11510: GO 12231
11512: LD_INT 2
11514: DOUBLE
11515: EQUAL
11516: IFTRUE 11520
11518: GO 11538
11520: POP
// ComExitVehicle ( ai_building_constructor [ base ] ) ; else
11521: LD_EXP 37
11525: PUSH
11526: LD_VAR 0 9
11530: ARRAY
11531: PPUSH
11532: CALL_OW 121
11536: GO 12231
11538: POP
// case GetBType ( HexInfo ( ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] ) ) of - 1 :
11539: LD_EXP 38
11543: PUSH
11544: LD_VAR 0 9
11548: ARRAY
11549: PUSH
11550: LD_INT 1
11552: ARRAY
11553: PPUSH
11554: LD_EXP 38
11558: PUSH
11559: LD_VAR 0 9
11563: ARRAY
11564: PUSH
11565: LD_INT 2
11567: ARRAY
11568: PPUSH
11569: CALL_OW 428
11573: PPUSH
11574: CALL_OW 266
11578: PUSH
11579: LD_INT 1
11581: NEG
11582: DOUBLE
11583: EQUAL
11584: IFTRUE 11588
11586: GO 11774
11588: POP
// begin case ai_upcoming_building_data [ base ] [ 4 ] of b_warehouse :
11589: LD_EXP 38
11593: PUSH
11594: LD_VAR 0 9
11598: ARRAY
11599: PUSH
11600: LD_INT 4
11602: ARRAY
11603: PUSH
11604: LD_INT 1
11606: DOUBLE
11607: EQUAL
11608: IFTRUE 11612
11610: GO 11623
11612: POP
// i = b_depot ; b_factory :
11613: LD_ADDR_VAR 0 2
11617: PUSH
11618: LD_INT 0
11620: ST_TO_ADDR
11621: GO 11707
11623: LD_INT 3
11625: DOUBLE
11626: EQUAL
11627: IFTRUE 11631
11629: GO 11642
11631: POP
// i = b_workshop ; b_lab_half , b_lab_full :
11632: LD_ADDR_VAR 0 2
11636: PUSH
11637: LD_INT 2
11639: ST_TO_ADDR
11640: GO 11707
11642: LD_INT 7
11644: DOUBLE
11645: EQUAL
11646: IFTRUE 11656
11648: LD_INT 8
11650: DOUBLE
11651: EQUAL
11652: IFTRUE 11656
11654: GO 11667
11656: POP
// i = b_lab ; b_barracks :
11657: LD_ADDR_VAR 0 2
11661: PUSH
11662: LD_INT 6
11664: ST_TO_ADDR
11665: GO 11707
11667: LD_INT 5
11669: DOUBLE
11670: EQUAL
11671: IFTRUE 11675
11673: GO 11686
11675: POP
// i = b_armoury ; else
11676: LD_ADDR_VAR 0 2
11680: PUSH
11681: LD_INT 4
11683: ST_TO_ADDR
11684: GO 11707
11686: POP
// i = ai_upcoming_building_data [ base ] [ 4 ] ; end ;
11687: LD_ADDR_VAR 0 2
11691: PUSH
11692: LD_EXP 38
11696: PUSH
11697: LD_VAR 0 9
11701: ARRAY
11702: PUSH
11703: LD_INT 4
11705: ARRAY
11706: ST_TO_ADDR
// ComBuild ( ai_building_constructor [ base ] , i , ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] , ai_upcoming_building_data [ base ] [ 3 ] ) ;
11707: LD_EXP 37
11711: PUSH
11712: LD_VAR 0 9
11716: ARRAY
11717: PPUSH
11718: LD_VAR 0 2
11722: PPUSH
11723: LD_EXP 38
11727: PUSH
11728: LD_VAR 0 9
11732: ARRAY
11733: PUSH
11734: LD_INT 1
11736: ARRAY
11737: PPUSH
11738: LD_EXP 38
11742: PUSH
11743: LD_VAR 0 9
11747: ARRAY
11748: PUSH
11749: LD_INT 2
11751: ARRAY
11752: PPUSH
11753: LD_EXP 38
11757: PUSH
11758: LD_VAR 0 9
11762: ARRAY
11763: PUSH
11764: LD_INT 3
11766: ARRAY
11767: PPUSH
11768: CALL_OW 145
// end ; b_depot :
11772: GO 12231
11774: LD_INT 0
11776: DOUBLE
11777: EQUAL
11778: IFTRUE 11782
11780: GO 11831
11782: POP
// begin ComUpgrade ( ai_depot [ base ] ) ;
11783: LD_EXP 27
11787: PUSH
11788: LD_VAR 0 9
11792: ARRAY
11793: PPUSH
11794: CALL_OW 146
// ai_building_under_construction = Replace ( ai_building_under_construction , base , ai_depot [ base ] ) ;
11798: LD_ADDR_EXP 34
11802: PUSH
11803: LD_EXP 34
11807: PPUSH
11808: LD_VAR 0 9
11812: PPUSH
11813: LD_EXP 27
11817: PUSH
11818: LD_VAR 0 9
11822: ARRAY
11823: PPUSH
11824: CALL_OW 1
11828: ST_TO_ADDR
// end ; b_workshop :
11829: GO 12231
11831: LD_INT 2
11833: DOUBLE
11834: EQUAL
11835: IFTRUE 11839
11837: GO 11888
11839: POP
// begin ComUpgrade ( ai_fact [ base ] ) ;
11840: LD_EXP 39
11844: PUSH
11845: LD_VAR 0 9
11849: ARRAY
11850: PPUSH
11851: CALL_OW 146
// ai_building_under_construction = Replace ( ai_building_under_construction , base , ai_fact [ base ] ) ;
11855: LD_ADDR_EXP 34
11859: PUSH
11860: LD_EXP 34
11864: PPUSH
11865: LD_VAR 0 9
11869: PPUSH
11870: LD_EXP 39
11874: PUSH
11875: LD_VAR 0 9
11879: ARRAY
11880: PPUSH
11881: CALL_OW 1
11885: ST_TO_ADDR
// end ; b_lab , b_lab_half :
11886: GO 12231
11888: LD_INT 6
11890: DOUBLE
11891: EQUAL
11892: IFTRUE 11902
11894: LD_INT 7
11896: DOUBLE
11897: EQUAL
11898: IFTRUE 11902
11900: GO 12145
11902: POP
// begin if ai_upcoming_building_data [ base ] [ 5 ] <> b_lab_basic and not ai_upcoming_building_data [ base ] [ 5 ] in [ GetLabKind ( ai_lab [ base ] , 1 ) , GetLabKind ( ai_lab [ base ] , 2 ) ] then
11903: LD_EXP 38
11907: PUSH
11908: LD_VAR 0 9
11912: ARRAY
11913: PUSH
11914: LD_INT 5
11916: ARRAY
11917: PUSH
11918: LD_INT 9
11920: NONEQUAL
11921: PUSH
11922: LD_EXP 38
11926: PUSH
11927: LD_VAR 0 9
11931: ARRAY
11932: PUSH
11933: LD_INT 5
11935: ARRAY
11936: PUSH
11937: LD_EXP 28
11941: PUSH
11942: LD_VAR 0 9
11946: ARRAY
11947: PPUSH
11948: LD_INT 1
11950: PPUSH
11951: CALL_OW 268
11955: PUSH
11956: LD_EXP 28
11960: PUSH
11961: LD_VAR 0 9
11965: ARRAY
11966: PPUSH
11967: LD_INT 2
11969: PPUSH
11970: CALL_OW 268
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: IN
11979: NOT
11980: AND
11981: IFFALSE 12015
// ComUpgradeLab ( ai_lab [ base ] , ai_upcoming_building_data [ base ] [ 5 ] ) else
11983: LD_EXP 28
11987: PUSH
11988: LD_VAR 0 9
11992: ARRAY
11993: PPUSH
11994: LD_EXP 38
11998: PUSH
11999: LD_VAR 0 9
12003: ARRAY
12004: PUSH
12005: LD_INT 5
12007: ARRAY
12008: PPUSH
12009: CALL_OW 147
12013: GO 12112
// if ai_upcoming_building_data [ base ] [ 6 ] <> b_lab_basic then
12015: LD_EXP 38
12019: PUSH
12020: LD_VAR 0 9
12024: ARRAY
12025: PUSH
12026: LD_INT 6
12028: ARRAY
12029: PUSH
12030: LD_INT 9
12032: NONEQUAL
12033: IFFALSE 12067
// ComUpgradeLab ( ai_lab [ base ] , ai_upcoming_building_data [ base ] [ 6 ] ) else
12035: LD_EXP 28
12039: PUSH
12040: LD_VAR 0 9
12044: ARRAY
12045: PPUSH
12046: LD_EXP 38
12050: PUSH
12051: LD_VAR 0 9
12055: ARRAY
12056: PUSH
12057: LD_INT 6
12059: ARRAY
12060: PPUSH
12061: CALL_OW 147
12065: GO 12112
// begin ai_building_constructor = Replace ( ai_building_constructor , base , 0 ) ;
12067: LD_ADDR_EXP 37
12071: PUSH
12072: LD_EXP 37
12076: PPUSH
12077: LD_VAR 0 9
12081: PPUSH
12082: LD_INT 0
12084: PPUSH
12085: CALL_OW 1
12089: ST_TO_ADDR
// ai_upcoming_building_data = Replace ( ai_upcoming_building_data , base , [ ] ) ;
12090: LD_ADDR_EXP 38
12094: PUSH
12095: LD_EXP 38
12099: PPUSH
12100: LD_VAR 0 9
12104: PPUSH
12105: EMPTY
12106: PPUSH
12107: CALL_OW 1
12111: ST_TO_ADDR
// end ; ai_building_under_construction = Replace ( ai_building_under_construction , base , ai_lab [ base ] ) ;
12112: LD_ADDR_EXP 34
12116: PUSH
12117: LD_EXP 34
12121: PPUSH
12122: LD_VAR 0 9
12126: PPUSH
12127: LD_EXP 28
12131: PUSH
12132: LD_VAR 0 9
12136: ARRAY
12137: PPUSH
12138: CALL_OW 1
12142: ST_TO_ADDR
// end ; b_armoury :
12143: GO 12231
12145: LD_INT 4
12147: DOUBLE
12148: EQUAL
12149: IFTRUE 12153
12151: GO 12230
12153: POP
// begin temp_unit = HexInfo ( ai_upcoming_building_data [ base ] [ 1 ] , ai_upcoming_building_data [ base ] [ 2 ] ) ;
12154: LD_ADDR_VAR 0 6
12158: PUSH
12159: LD_EXP 38
12163: PUSH
12164: LD_VAR 0 9
12168: ARRAY
12169: PUSH
12170: LD_INT 1
12172: ARRAY
12173: PPUSH
12174: LD_EXP 38
12178: PUSH
12179: LD_VAR 0 9
12183: ARRAY
12184: PUSH
12185: LD_INT 2
12187: ARRAY
12188: PPUSH
12189: CALL_OW 428
12193: ST_TO_ADDR
// ComUpgrade ( temp_unit ) ;
12194: LD_VAR 0 6
12198: PPUSH
12199: CALL_OW 146
// ai_building_under_construction = Replace ( ai_building_under_construction , base , temp_unit ) ;
12203: LD_ADDR_EXP 34
12207: PUSH
12208: LD_EXP 34
12212: PPUSH
12213: LD_VAR 0 9
12217: PPUSH
12218: LD_VAR 0 6
12222: PPUSH
12223: CALL_OW 1
12227: ST_TO_ADDR
// end ; end ; end ;
12228: GO 12231
12230: POP
// end ; end ; end ; case base of 1 :
12231: LD_VAR 0 9
12235: PUSH
12236: LD_INT 1
12238: DOUBLE
12239: EQUAL
12240: IFTRUE 12244
12242: GO 12255
12244: POP
// temp_unit = rubase1 ; 2 :
12245: LD_ADDR_VAR 0 6
12249: PUSH
12250: LD_INT 3
12252: ST_TO_ADDR
12253: GO 12294
12255: LD_INT 2
12257: DOUBLE
12258: EQUAL
12259: IFTRUE 12263
12261: GO 12274
12263: POP
// temp_unit = rubase2 ; 3 :
12264: LD_ADDR_VAR 0 6
12268: PUSH
12269: LD_INT 2
12271: ST_TO_ADDR
12272: GO 12294
12274: LD_INT 3
12276: DOUBLE
12277: EQUAL
12278: IFTRUE 12282
12280: GO 12293
12282: POP
// temp_unit = rubase3 ; end ;
12283: LD_ADDR_VAR 0 6
12287: PUSH
12288: LD_INT 1
12290: ST_TO_ADDR
12291: GO 12294
12293: POP
// temp_list = GetListOfCratesInArea ( temp_unit ) ;
12294: LD_ADDR_VAR 0 4
12298: PUSH
12299: LD_VAR 0 6
12303: PPUSH
12304: CALL_OW 435
12308: ST_TO_ADDR
// if temp_list > 0 and ai_depot [ base ] > 0 then
12309: LD_VAR 0 4
12313: PUSH
12314: LD_INT 0
12316: GREATER
12317: PUSH
12318: LD_EXP 27
12322: PUSH
12323: LD_VAR 0 9
12327: ARRAY
12328: PUSH
12329: LD_INT 0
12331: GREATER
12332: AND
12333: IFFALSE 12369
// begin ComCollect ( GetHumansOutOfUnits ( engineers_list ) , temp_list [ 1 ] , temp_list [ 2 ] ) ;
12335: LD_VAR 0 3
12339: PPUSH
12340: CALL 13557 0 1
12344: PPUSH
12345: LD_VAR 0 4
12349: PUSH
12350: LD_INT 1
12352: ARRAY
12353: PPUSH
12354: LD_VAR 0 4
12358: PUSH
12359: LD_INT 2
12361: ARRAY
12362: PPUSH
12363: CALL_OW 117
// continue ;
12367: GO 9839
// end ; end ; if IsOk ( ai_depot [ base ] ) then
12369: LD_EXP 27
12373: PUSH
12374: LD_VAR 0 9
12378: ARRAY
12379: PPUSH
12380: CALL_OW 302
12384: IFFALSE 12509
// begin for i in engineers_list do
12386: LD_ADDR_VAR 0 2
12390: PUSH
12391: LD_VAR 0 3
12395: PUSH
12396: FOR_IN
12397: IFFALSE 12505
// begin temp_unit = IsInUnit ( i ) ;
12399: LD_ADDR_VAR 0 6
12403: PUSH
12404: LD_VAR 0 2
12408: PPUSH
12409: CALL_OW 310
12413: ST_TO_ADDR
// if temp_unit <> ai_depot [ base ] then
12414: LD_VAR 0 6
12418: PUSH
12419: LD_EXP 27
12423: PUSH
12424: LD_VAR 0 9
12428: ARRAY
12429: NONEQUAL
12430: IFFALSE 12503
// case GetType ( temp_unit ) of unit_building :
12432: LD_VAR 0 6
12436: PPUSH
12437: CALL_OW 247
12441: PUSH
12442: LD_INT 3
12444: DOUBLE
12445: EQUAL
12446: IFTRUE 12450
12448: GO 12462
12450: POP
// ComExitBuilding ( i ) ; unit_vehicle :
12451: LD_VAR 0 2
12455: PPUSH
12456: CALL_OW 122
12460: GO 12503
12462: LD_INT 2
12464: DOUBLE
12465: EQUAL
12466: IFTRUE 12470
12468: GO 12482
12470: POP
// ComExitVehicle ( i ) ; else
12471: LD_VAR 0 2
12475: PPUSH
12476: CALL_OW 121
12480: GO 12503
12482: POP
// ComEnterUnit ( i , ai_depot [ base ] ) ; end ;
12483: LD_VAR 0 2
12487: PPUSH
12488: LD_EXP 27
12492: PUSH
12493: LD_VAR 0 9
12497: ARRAY
12498: PPUSH
12499: CALL_OW 120
// end ;
12503: GO 12396
12505: POP
12506: POP
// end else
12507: GO 12610
// for i in engineers_list do
12509: LD_ADDR_VAR 0 2
12513: PUSH
12514: LD_VAR 0 3
12518: PUSH
12519: FOR_IN
12520: IFFALSE 12608
// if GetDistUnitXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) > 4 then
12522: LD_VAR 0 2
12526: PPUSH
12527: LD_EXP 33
12531: PUSH
12532: LD_VAR 0 9
12536: ARRAY
12537: PUSH
12538: LD_INT 1
12540: ARRAY
12541: PPUSH
12542: LD_EXP 33
12546: PUSH
12547: LD_VAR 0 9
12551: ARRAY
12552: PUSH
12553: LD_INT 2
12555: ARRAY
12556: PPUSH
12557: CALL_OW 297
12561: PUSH
12562: LD_INT 4
12564: GREATER
12565: IFFALSE 12606
// ComMoveXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
12567: LD_VAR 0 2
12571: PPUSH
12572: LD_EXP 33
12576: PUSH
12577: LD_VAR 0 9
12581: ARRAY
12582: PUSH
12583: LD_INT 1
12585: ARRAY
12586: PPUSH
12587: LD_EXP 33
12591: PUSH
12592: LD_VAR 0 9
12596: ARRAY
12597: PUSH
12598: LD_INT 2
12600: ARRAY
12601: PPUSH
12602: CALL_OW 111
12606: GO 12519
12608: POP
12609: POP
// end ;
12610: GO 9839
12612: POP
12613: POP
// enable ;
12614: ENABLE
// end ;
12615: PPOPN 11
12617: END
// on BuildingStarted ( building , builder ) do var side , temp_list , base , i ;
12618: LD_INT 0
12620: PPUSH
12621: PPUSH
12622: PPUSH
12623: PPUSH
// begin side = GetSide ( building ) ;
12624: LD_ADDR_VAR 0 3
12628: PUSH
12629: LD_VAR 0 1
12633: PPUSH
12634: CALL_OW 255
12638: ST_TO_ADDR
// if side <> russians then
12639: LD_VAR 0 3
12643: PUSH
12644: LD_EXP 3
12648: NONEQUAL
12649: IFFALSE 12653
// exit ;
12651: GO 12728
// base = FindBase ( building ) ;
12653: LD_ADDR_VAR 0 5
12657: PUSH
12658: LD_VAR 0 1
12662: PPUSH
12663: CALL 8212 0 1
12667: ST_TO_ADDR
// if base = 0 then
12668: LD_VAR 0 5
12672: PUSH
12673: LD_INT 0
12675: EQUAL
12676: IFFALSE 12680
// exit ;
12678: GO 12728
// ai_building_constructor = Replace ( ai_building_constructor , base , 0 ) ;
12680: LD_ADDR_EXP 37
12684: PUSH
12685: LD_EXP 37
12689: PPUSH
12690: LD_VAR 0 5
12694: PPUSH
12695: LD_INT 0
12697: PPUSH
12698: CALL_OW 1
12702: ST_TO_ADDR
// ai_building_under_construction = Replace ( ai_building_under_construction , base , building ) ;
12703: LD_ADDR_EXP 34
12707: PUSH
12708: LD_EXP 34
12712: PPUSH
12713: LD_VAR 0 5
12717: PPUSH
12718: LD_VAR 0 1
12722: PPUSH
12723: CALL_OW 1
12727: ST_TO_ADDR
// end ;
12728: PPOPN 6
12730: END
// on BuildingComplete ( building ) do var side , temp_list , temp_unit , base , i ;
12731: LD_INT 0
12733: PPUSH
12734: PPUSH
12735: PPUSH
12736: PPUSH
12737: PPUSH
// begin side = GetSide ( building ) ;
12738: LD_ADDR_VAR 0 2
12742: PUSH
12743: LD_VAR 0 1
12747: PPUSH
12748: CALL_OW 255
12752: ST_TO_ADDR
// if side <> russians then
12753: LD_VAR 0 2
12757: PUSH
12758: LD_EXP 3
12762: NONEQUAL
12763: IFFALSE 12767
// exit ;
12765: GO 12872
// base = FindBase ( building ) ;
12767: LD_ADDR_VAR 0 5
12771: PUSH
12772: LD_VAR 0 1
12776: PPUSH
12777: CALL 8212 0 1
12781: ST_TO_ADDR
// if base = 0 then
12782: LD_VAR 0 5
12786: PUSH
12787: LD_INT 0
12789: EQUAL
12790: IFFALSE 12794
// exit ;
12792: GO 12872
// BuildUpgradeCommon ( base , building ) ;
12794: LD_VAR 0 5
12798: PPUSH
12799: LD_VAR 0 1
12803: PPUSH
12804: CALL 12953 0 2
// temp_list = ai_all_buildings [ base ] ^ building ;
12808: LD_ADDR_VAR 0 3
12812: PUSH
12813: LD_EXP 36
12817: PUSH
12818: LD_VAR 0 5
12822: ARRAY
12823: PUSH
12824: LD_VAR 0 1
12828: ADD
12829: ST_TO_ADDR
// ai_all_buildings = Replace ( ai_all_buildings , base , temp_list ) ;
12830: LD_ADDR_EXP 36
12834: PUSH
12835: LD_EXP 36
12839: PPUSH
12840: LD_VAR 0 5
12844: PPUSH
12845: LD_VAR 0 3
12849: PPUSH
12850: CALL_OW 1
12854: ST_TO_ADDR
// UpdateBuildingBasicVariables ( base , building , true ) ;
12855: LD_VAR 0 5
12859: PPUSH
12860: LD_VAR 0 1
12864: PPUSH
12865: LD_INT 1
12867: PPUSH
12868: CALL 3970 0 3
// end ;
12872: PPOPN 6
12874: END
// on UpgradeComplete ( building ) do var side , temp_list , base ;
12875: LD_INT 0
12877: PPUSH
12878: PPUSH
12879: PPUSH
// begin side = GetSide ( building ) ;
12880: LD_ADDR_VAR 0 2
12884: PUSH
12885: LD_VAR 0 1
12889: PPUSH
12890: CALL_OW 255
12894: ST_TO_ADDR
// if side <> russians then
12895: LD_VAR 0 2
12899: PUSH
12900: LD_EXP 3
12904: NONEQUAL
12905: IFFALSE 12909
// exit ;
12907: GO 12950
// base = FindBase ( building ) ;
12909: LD_ADDR_VAR 0 4
12913: PUSH
12914: LD_VAR 0 1
12918: PPUSH
12919: CALL 8212 0 1
12923: ST_TO_ADDR
// if base = 0 then
12924: LD_VAR 0 4
12928: PUSH
12929: LD_INT 0
12931: EQUAL
12932: IFFALSE 12936
// exit ;
12934: GO 12950
// BuildUpgradeCommon ( base , building ) ;
12936: LD_VAR 0 4
12940: PPUSH
12941: LD_VAR 0 1
12945: PPUSH
12946: CALL 12953 0 2
// end ;
12950: PPOPN 4
12952: END
// function BuildUpgradeCommon ( base , building ) ; begin
12953: LD_INT 0
12955: PPUSH
// if GetBType ( building ) = ai_upcoming_building_data [ base ] [ 4 ] then
12956: LD_VAR 0 2
12960: PPUSH
12961: CALL_OW 266
12965: PUSH
12966: LD_EXP 38
12970: PUSH
12971: LD_VAR 0 1
12975: ARRAY
12976: PUSH
12977: LD_INT 4
12979: ARRAY
12980: EQUAL
12981: IFFALSE 13005
// ai_upcoming_building_data = Replace ( ai_upcoming_building_data , base , [ ] ) ;
12983: LD_ADDR_EXP 38
12987: PUSH
12988: LD_EXP 38
12992: PPUSH
12993: LD_VAR 0 1
12997: PPUSH
12998: EMPTY
12999: PPUSH
13000: CALL_OW 1
13004: ST_TO_ADDR
// ai_building_under_construction = Replace ( ai_building_under_construction , base , 0 ) ;
13005: LD_ADDR_EXP 34
13009: PUSH
13010: LD_EXP 34
13014: PPUSH
13015: LD_VAR 0 1
13019: PPUSH
13020: LD_INT 0
13022: PPUSH
13023: CALL_OW 1
13027: ST_TO_ADDR
// end ;
13028: LD_VAR 0 3
13032: RET
// on BuildingCaptured ( captured_building , building_former_side , capturing_unit ) do var temp_list , base ;
13033: LD_INT 0
13035: PPUSH
13036: PPUSH
// begin if captured_building in ai_depot then
13037: LD_VAR 0 1
13041: PUSH
13042: LD_EXP 27
13046: IN
13047: IFFALSE 13165
// begin if captured_building = ai_depot [ 3 ] then
13049: LD_VAR 0 1
13053: PUSH
13054: LD_EXP 27
13058: PUSH
13059: LD_INT 3
13061: ARRAY
13062: EQUAL
13063: IFFALSE 13097
// SetResourceType ( GetBase ( captured_building ) , mat_cans , 120 - difficulty * 20 ) else
13065: LD_VAR 0 1
13069: PPUSH
13070: CALL_OW 274
13074: PPUSH
13075: LD_INT 1
13077: PPUSH
13078: LD_INT 120
13080: PUSH
13081: LD_OWVAR 67
13085: PUSH
13086: LD_INT 20
13088: MUL
13089: MINUS
13090: PPUSH
13091: CALL_OW 277
13095: GO 13133
// SetResourceType ( GetBase ( captured_building ) , mat_cans , 150 + Rand ( 0 , 7 ) * 10 ) ;
13097: LD_VAR 0 1
13101: PPUSH
13102: CALL_OW 274
13106: PPUSH
13107: LD_INT 1
13109: PPUSH
13110: LD_INT 150
13112: PUSH
13113: LD_INT 0
13115: PPUSH
13116: LD_INT 7
13118: PPUSH
13119: CALL_OW 12
13123: PUSH
13124: LD_INT 10
13126: MUL
13127: PLUS
13128: PPUSH
13129: CALL_OW 277
// SetResourceType ( GetBase ( captured_building ) , mat_oil , 300 + Rand ( 0 , 100 ) ) ;
13133: LD_VAR 0 1
13137: PPUSH
13138: CALL_OW 274
13142: PPUSH
13143: LD_INT 2
13145: PPUSH
13146: LD_INT 300
13148: PUSH
13149: LD_INT 0
13151: PPUSH
13152: LD_INT 100
13154: PPUSH
13155: CALL_OW 12
13159: PLUS
13160: PPUSH
13161: CALL_OW 277
// end ; base = FindBase ( captured_building ) ;
13165: LD_ADDR_VAR 0 5
13169: PUSH
13170: LD_VAR 0 1
13174: PPUSH
13175: CALL 8212 0 1
13179: ST_TO_ADDR
// if base = 0 then
13180: LD_VAR 0 5
13184: PUSH
13185: LD_INT 0
13187: EQUAL
13188: IFFALSE 13192
// exit ;
13190: GO 13423
// if building_former_side = GetBaseSide ( base ) then
13192: LD_VAR 0 2
13196: PUSH
13197: LD_VAR 0 5
13201: PPUSH
13202: CALL 8419 0 1
13206: EQUAL
13207: IFFALSE 13290
// begin if captured_building in ai_all_buildings [ base ] then
13209: LD_VAR 0 1
13213: PUSH
13214: LD_EXP 36
13218: PUSH
13219: LD_VAR 0 5
13223: ARRAY
13224: IN
13225: IFFALSE 13288
// begin RemoveBuildingFromVariables ( base , captured_building ) ;
13227: LD_VAR 0 5
13231: PPUSH
13232: LD_VAR 0 1
13236: PPUSH
13237: CALL 7400 0 2
// temp_list = ai_captured_buildings [ base ] ^ captured_building ;
13241: LD_ADDR_VAR 0 4
13245: PUSH
13246: LD_EXP 51
13250: PUSH
13251: LD_VAR 0 5
13255: ARRAY
13256: PUSH
13257: LD_VAR 0 1
13261: ADD
13262: ST_TO_ADDR
// ai_captured_buildings = Replace ( ai_captured_buildings , base , temp_list ) ;
13263: LD_ADDR_EXP 51
13267: PUSH
13268: LD_EXP 51
13272: PPUSH
13273: LD_VAR 0 5
13277: PPUSH
13278: LD_VAR 0 4
13282: PPUSH
13283: CALL_OW 1
13287: ST_TO_ADDR
// end ; end else
13288: GO 13423
// begin if GetSide ( captured_building ) = GetBaseSide ( base ) then
13290: LD_VAR 0 1
13294: PPUSH
13295: CALL_OW 255
13299: PUSH
13300: LD_VAR 0 5
13304: PPUSH
13305: CALL 8419 0 1
13309: EQUAL
13310: IFFALSE 13423
// begin temp_list = ai_all_buildings [ base ] ^ captured_building ;
13312: LD_ADDR_VAR 0 4
13316: PUSH
13317: LD_EXP 36
13321: PUSH
13322: LD_VAR 0 5
13326: ARRAY
13327: PUSH
13328: LD_VAR 0 1
13332: ADD
13333: ST_TO_ADDR
// ai_all_buildings = Replace ( ai_all_buildings , base , temp_list ) ;
13334: LD_ADDR_EXP 36
13338: PUSH
13339: LD_EXP 36
13343: PPUSH
13344: LD_VAR 0 5
13348: PPUSH
13349: LD_VAR 0 4
13353: PPUSH
13354: CALL_OW 1
13358: ST_TO_ADDR
// UpdateBuildingBasicVariables ( base , captured_building , true ) ;
13359: LD_VAR 0 5
13363: PPUSH
13364: LD_VAR 0 1
13368: PPUSH
13369: LD_INT 1
13371: PPUSH
13372: CALL 3970 0 3
// temp_list = ai_captured_buildings [ base ] diff captured_building ;
13376: LD_ADDR_VAR 0 4
13380: PUSH
13381: LD_EXP 51
13385: PUSH
13386: LD_VAR 0 5
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 1
13396: DIFF
13397: ST_TO_ADDR
// ai_captured_buildings = Replace ( ai_captured_buildings , base , temp_list ) ;
13398: LD_ADDR_EXP 51
13402: PUSH
13403: LD_EXP 51
13407: PPUSH
13408: LD_VAR 0 5
13412: PPUSH
13413: LD_VAR 0 4
13417: PPUSH
13418: CALL_OW 1
13422: ST_TO_ADDR
// end ; end ; end ;
13423: PPOPN 5
13425: END
// on UnitGoesToRed ( un ) do begin if un in ai_depot then
13426: LD_VAR 0 1
13430: PUSH
13431: LD_EXP 27
13435: IN
13436: IFFALSE 13554
// begin if un = ai_depot [ 3 ] then
13438: LD_VAR 0 1
13442: PUSH
13443: LD_EXP 27
13447: PUSH
13448: LD_INT 3
13450: ARRAY
13451: EQUAL
13452: IFFALSE 13486
// SetResourceType ( GetBase ( un ) , mat_cans , 120 - difficulty * 20 ) else
13454: LD_VAR 0 1
13458: PPUSH
13459: CALL_OW 274
13463: PPUSH
13464: LD_INT 1
13466: PPUSH
13467: LD_INT 120
13469: PUSH
13470: LD_OWVAR 67
13474: PUSH
13475: LD_INT 20
13477: MUL
13478: MINUS
13479: PPUSH
13480: CALL_OW 277
13484: GO 13522
// SetResourceType ( GetBase ( un ) , mat_cans , 150 + Rand ( 0 , 7 ) * 10 ) ;
13486: LD_VAR 0 1
13490: PPUSH
13491: CALL_OW 274
13495: PPUSH
13496: LD_INT 1
13498: PPUSH
13499: LD_INT 150
13501: PUSH
13502: LD_INT 0
13504: PPUSH
13505: LD_INT 7
13507: PPUSH
13508: CALL_OW 12
13512: PUSH
13513: LD_INT 10
13515: MUL
13516: PLUS
13517: PPUSH
13518: CALL_OW 277
// SetResourceType ( GetBase ( un ) , mat_oil , 300 + Rand ( 0 , 100 ) ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: CALL_OW 274
13531: PPUSH
13532: LD_INT 2
13534: PPUSH
13535: LD_INT 300
13537: PUSH
13538: LD_INT 0
13540: PPUSH
13541: LD_INT 100
13543: PPUSH
13544: CALL_OW 12
13548: PLUS
13549: PPUSH
13550: CALL_OW 277
// end ; end ;
13554: PPOPN 1
13556: END
// export function GetHumansOutOfUnits ( un_list ) ; var i ; begin
13557: LD_INT 0
13559: PPUSH
13560: PPUSH
// result = [ ] ;
13561: LD_ADDR_VAR 0 2
13565: PUSH
13566: EMPTY
13567: ST_TO_ADDR
// for i in un_list do
13568: LD_ADDR_VAR 0 3
13572: PUSH
13573: LD_VAR 0 1
13577: PUSH
13578: FOR_IN
13579: IFFALSE 13655
// case GetType ( IsInUnit ( i ) ) of unit_building :
13581: LD_VAR 0 3
13585: PPUSH
13586: CALL_OW 310
13590: PPUSH
13591: CALL_OW 247
13595: PUSH
13596: LD_INT 3
13598: DOUBLE
13599: EQUAL
13600: IFTRUE 13604
13602: GO 13616
13604: POP
// ComExitBuilding ( i ) ; unit_vehicle :
13605: LD_VAR 0 3
13609: PPUSH
13610: CALL_OW 122
13614: GO 13653
13616: LD_INT 2
13618: DOUBLE
13619: EQUAL
13620: IFTRUE 13624
13622: GO 13636
13624: POP
// ComExitVehicle ( i ) ; else
13625: LD_VAR 0 3
13629: PPUSH
13630: CALL_OW 121
13634: GO 13653
13636: POP
// result = result ^ i ; end ;
13637: LD_ADDR_VAR 0 2
13641: PUSH
13642: LD_VAR 0 2
13646: PUSH
13647: LD_VAR 0 3
13651: ADD
13652: ST_TO_ADDR
13653: GO 13578
13655: POP
13656: POP
// end ;
13657: LD_VAR 0 2
13661: RET
// export function BaseUnderAttack ( side , base ) ; begin
13662: LD_INT 0
13664: PPUSH
// result = ContactTime ( side ) < 0 0$10 and FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , ai_buildings_locations [ base ] [ 1 ] [ 1 ] , ai_buildings_locations [ base ] [ 1 ] [ 2 ] , ai_near_base_dist ] ] ) > 0 ;
13665: LD_ADDR_VAR 0 3
13669: PUSH
13670: LD_VAR 0 1
13674: PPUSH
13675: CALL_OW 462
13679: PUSH
13680: LD_INT 350
13682: LESS
13683: PUSH
13684: LD_INT 81
13686: PUSH
13687: LD_VAR 0 1
13691: PUSH
13692: EMPTY
13693: LIST
13694: LIST
13695: PUSH
13696: LD_INT 92
13698: PUSH
13699: LD_EXP 30
13703: PUSH
13704: LD_VAR 0 2
13708: ARRAY
13709: PUSH
13710: LD_INT 1
13712: ARRAY
13713: PUSH
13714: LD_INT 1
13716: ARRAY
13717: PUSH
13718: LD_EXP 30
13722: PUSH
13723: LD_VAR 0 2
13727: ARRAY
13728: PUSH
13729: LD_INT 1
13731: ARRAY
13732: PUSH
13733: LD_INT 2
13735: ARRAY
13736: PUSH
13737: LD_EXP 44
13741: PUSH
13742: EMPTY
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: PUSH
13748: EMPTY
13749: LIST
13750: LIST
13751: PPUSH
13752: CALL_OW 69
13756: PUSH
13757: LD_INT 0
13759: GREATER
13760: AND
13761: ST_TO_ADDR
// end ;
13762: LD_VAR 0 3
13766: RET
// every 0 0$1 do var side , i , mechanics_list , temp_list , taken_vehicles , temp_list_3 , temp_unit , vehicles_list , allowed_to_repair_vehicles ; var under_attack , free_parking_spots , k , ready_to_attack , base , base_area ;
13767: GO 13769
13769: DISABLE
13770: LD_INT 0
13772: PPUSH
13773: PPUSH
13774: PPUSH
13775: PPUSH
13776: PPUSH
13777: PPUSH
13778: PPUSH
13779: PPUSH
13780: PPUSH
13781: PPUSH
13782: PPUSH
13783: PPUSH
13784: PPUSH
13785: PPUSH
13786: PPUSH
// begin side = russians ;
13787: LD_ADDR_VAR 0 1
13791: PUSH
13792: LD_EXP 3
13796: ST_TO_ADDR
// for base in ai_bases do
13797: LD_ADDR_VAR 0 14
13801: PUSH
13802: LD_EXP 49
13806: PUSH
13807: FOR_IN
13808: IFFALSE 15685
// begin under_attack = BaseUnderAttack ( side , base ) ;
13810: LD_ADDR_VAR 0 10
13814: PUSH
13815: LD_VAR 0 1
13819: PPUSH
13820: LD_VAR 0 14
13824: PPUSH
13825: CALL 13662 0 2
13829: ST_TO_ADDR
// ready_to_attack = not under_attack ;
13830: LD_ADDR_VAR 0 13
13834: PUSH
13835: LD_VAR 0 10
13839: NOT
13840: ST_TO_ADDR
// case base of 1 :
13841: LD_VAR 0 14
13845: PUSH
13846: LD_INT 1
13848: DOUBLE
13849: EQUAL
13850: IFTRUE 13854
13852: GO 13865
13854: POP
// base_area = rubase1 ; 2 :
13855: LD_ADDR_VAR 0 15
13859: PUSH
13860: LD_INT 3
13862: ST_TO_ADDR
13863: GO 13904
13865: LD_INT 2
13867: DOUBLE
13868: EQUAL
13869: IFTRUE 13873
13871: GO 13884
13873: POP
// base_area = rubase2 ; 3 :
13874: LD_ADDR_VAR 0 15
13878: PUSH
13879: LD_INT 2
13881: ST_TO_ADDR
13882: GO 13904
13884: LD_INT 3
13886: DOUBLE
13887: EQUAL
13888: IFTRUE 13892
13890: GO 13903
13892: POP
// base_area = rubase3 ; end ;
13893: LD_ADDR_VAR 0 15
13897: PUSH
13898: LD_INT 1
13900: ST_TO_ADDR
13901: GO 13904
13903: POP
// mechanics_list = ai_mechanics_defend [ base ] diff ai_heal_these_humans [ base ] ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_EXP 24
13913: PUSH
13914: LD_VAR 0 14
13918: ARRAY
13919: PUSH
13920: LD_EXP 35
13924: PUSH
13925: LD_VAR 0 14
13929: ARRAY
13930: DIFF
13931: ST_TO_ADDR
// if base < 3 and ai_attack_delay [ base ] > 0 0$0 and UnitFilter ( ai_vehicles_attack [ base ] , [ f_ok ] ) = 0 then
13932: LD_VAR 0 14
13936: PUSH
13937: LD_INT 3
13939: LESS
13940: PUSH
13941: LD_EXP 48
13945: PUSH
13946: LD_VAR 0 14
13950: ARRAY
13951: PUSH
13952: LD_INT 0
13954: GREATER
13955: AND
13956: PUSH
13957: LD_EXP 32
13961: PUSH
13962: LD_VAR 0 14
13966: ARRAY
13967: PPUSH
13968: LD_INT 50
13970: PUSH
13971: EMPTY
13972: LIST
13973: PPUSH
13974: CALL_OW 72
13978: PUSH
13979: LD_INT 0
13981: EQUAL
13982: AND
13983: IFFALSE 14174
// begin ai_attack_delay = Replace ( ai_attack_delay , base , ai_attack_delay [ base ] - 0 0$1 ) ;
13985: LD_ADDR_EXP 48
13989: PUSH
13990: LD_EXP 48
13994: PPUSH
13995: LD_VAR 0 14
13999: PPUSH
14000: LD_EXP 48
14004: PUSH
14005: LD_VAR 0 14
14009: ARRAY
14010: PUSH
14011: LD_INT 35
14013: MINUS
14014: PPUSH
14015: CALL_OW 1
14019: ST_TO_ADDR
// if ai_attack_delay [ base ] <= 0 0$0 and UnitFilter ( ai_vehicles_attack [ [ 2 , 1 ] [ base ] ] , [ f_ok ] ) = 0 and Rand ( 1 , 2 ) = 1 then
14020: LD_EXP 48
14024: PUSH
14025: LD_VAR 0 14
14029: ARRAY
14030: PUSH
14031: LD_INT 0
14033: LESSEQUAL
14034: PUSH
14035: LD_EXP 32
14039: PUSH
14040: LD_INT 2
14042: PUSH
14043: LD_INT 1
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PUSH
14050: LD_VAR 0 14
14054: ARRAY
14055: ARRAY
14056: PPUSH
14057: LD_INT 50
14059: PUSH
14060: EMPTY
14061: LIST
14062: PPUSH
14063: CALL_OW 72
14067: PUSH
14068: LD_INT 0
14070: EQUAL
14071: AND
14072: PUSH
14073: LD_INT 1
14075: PPUSH
14076: LD_INT 2
14078: PPUSH
14079: CALL_OW 12
14083: PUSH
14084: LD_INT 1
14086: EQUAL
14087: AND
14088: IFFALSE 14166
// begin ai_attack_delay = Replace ( ai_attack_delay , base , ai_attack_delay [ [ 2 , 1 ] [ base ] ] ) ;
14090: LD_ADDR_EXP 48
14094: PUSH
14095: LD_EXP 48
14099: PPUSH
14100: LD_VAR 0 14
14104: PPUSH
14105: LD_EXP 48
14109: PUSH
14110: LD_INT 2
14112: PUSH
14113: LD_INT 1
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: PUSH
14120: LD_VAR 0 14
14124: ARRAY
14125: ARRAY
14126: PPUSH
14127: CALL_OW 1
14131: ST_TO_ADDR
// ai_attack_delay = Replace ( ai_attack_delay , [ 2 , 1 ] [ base ] , 0 0$0 ) ;
14132: LD_ADDR_EXP 48
14136: PUSH
14137: LD_EXP 48
14141: PPUSH
14142: LD_INT 2
14144: PUSH
14145: LD_INT 1
14147: PUSH
14148: EMPTY
14149: LIST
14150: LIST
14151: PUSH
14152: LD_VAR 0 14
14156: ARRAY
14157: PPUSH
14158: LD_INT 0
14160: PPUSH
14161: CALL_OW 1
14165: ST_TO_ADDR
// end ; ready_to_attack = false ;
14166: LD_ADDR_VAR 0 13
14170: PUSH
14171: LD_INT 0
14173: ST_TO_ADDR
// end ; temp_list = ai_heal_these_humans [ base ] ;
14174: LD_ADDR_VAR 0 4
14178: PUSH
14179: LD_EXP 35
14183: PUSH
14184: LD_VAR 0 14
14188: ARRAY
14189: ST_TO_ADDR
// i = 1 ;
14190: LD_ADDR_VAR 0 2
14194: PUSH
14195: LD_INT 1
14197: ST_TO_ADDR
// while i <= mechanics_list do
14198: LD_VAR 0 2
14202: PUSH
14203: LD_VAR 0 3
14207: LESSEQUAL
14208: IFFALSE 14303
// begin if GetLives ( mechanics_list [ i ] ) <= 900 then
14210: LD_VAR 0 3
14214: PUSH
14215: LD_VAR 0 2
14219: ARRAY
14220: PPUSH
14221: CALL_OW 256
14225: PUSH
14226: LD_INT 900
14228: LESSEQUAL
14229: IFFALSE 14287
// begin temp_list = temp_list ^ mechanics_list [ i ] ;
14231: LD_ADDR_VAR 0 4
14235: PUSH
14236: LD_VAR 0 4
14240: PUSH
14241: LD_VAR 0 3
14245: PUSH
14246: LD_VAR 0 2
14250: ARRAY
14251: ADD
14252: ST_TO_ADDR
// mechanics_list = Delete ( mechanics_list , i ) ;
14253: LD_ADDR_VAR 0 3
14257: PUSH
14258: LD_VAR 0 3
14262: PPUSH
14263: LD_VAR 0 2
14267: PPUSH
14268: CALL_OW 3
14272: ST_TO_ADDR
// i = i - 1 ;
14273: LD_ADDR_VAR 0 2
14277: PUSH
14278: LD_VAR 0 2
14282: PUSH
14283: LD_INT 1
14285: MINUS
14286: ST_TO_ADDR
// end ; i = i + 1 ;
14287: LD_ADDR_VAR 0 2
14291: PUSH
14292: LD_VAR 0 2
14296: PUSH
14297: LD_INT 1
14299: PLUS
14300: ST_TO_ADDR
// end ;
14301: GO 14198
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
14303: LD_ADDR_EXP 35
14307: PUSH
14308: LD_EXP 35
14312: PPUSH
14313: LD_VAR 0 14
14317: PPUSH
14318: LD_VAR 0 4
14322: PPUSH
14323: CALL_OW 1
14327: ST_TO_ADDR
// temp_list = [ ] ;
14328: LD_ADDR_VAR 0 4
14332: PUSH
14333: EMPTY
14334: ST_TO_ADDR
// for i in ai_refuel_vehicles_list [ base ] do
14335: LD_ADDR_VAR 0 2
14339: PUSH
14340: LD_EXP 46
14344: PUSH
14345: LD_VAR 0 14
14349: ARRAY
14350: PUSH
14351: FOR_IN
14352: IFFALSE 14387
// if GetFuel ( i ) < 95 then
14354: LD_VAR 0 2
14358: PPUSH
14359: CALL_OW 261
14363: PUSH
14364: LD_INT 95
14366: LESS
14367: IFFALSE 14385
// temp_list = temp_list ^ i ;
14369: LD_ADDR_VAR 0 4
14373: PUSH
14374: LD_VAR 0 4
14378: PUSH
14379: LD_VAR 0 2
14383: ADD
14384: ST_TO_ADDR
14385: GO 14351
14387: POP
14388: POP
// ai_refuel_vehicles_list = Replace ( ai_refuel_vehicles_list , base , temp_list ) ;
14389: LD_ADDR_EXP 46
14393: PUSH
14394: LD_EXP 46
14398: PPUSH
14399: LD_VAR 0 14
14403: PPUSH
14404: LD_VAR 0 4
14408: PPUSH
14409: CALL_OW 1
14413: ST_TO_ADDR
// if under_attack then
14414: LD_VAR 0 10
14418: IFFALSE 14507
// temp_list = FilterAllUnits ( [ [ f_enemy , side ] , [ f_ok ] , [ f_distxy , ai_buildings_locations [ base ] [ 1 ] [ 1 ] , ai_buildings_locations [ base ] [ 1 ] [ 2 ] , ai_near_base_dist ] ] ) else
14420: LD_ADDR_VAR 0 4
14424: PUSH
14425: LD_INT 81
14427: PUSH
14428: LD_VAR 0 1
14432: PUSH
14433: EMPTY
14434: LIST
14435: LIST
14436: PUSH
14437: LD_INT 50
14439: PUSH
14440: EMPTY
14441: LIST
14442: PUSH
14443: LD_INT 92
14445: PUSH
14446: LD_EXP 30
14450: PUSH
14451: LD_VAR 0 14
14455: ARRAY
14456: PUSH
14457: LD_INT 1
14459: ARRAY
14460: PUSH
14461: LD_INT 1
14463: ARRAY
14464: PUSH
14465: LD_EXP 30
14469: PUSH
14470: LD_VAR 0 14
14474: ARRAY
14475: PUSH
14476: LD_INT 1
14478: ARRAY
14479: PUSH
14480: LD_INT 2
14482: ARRAY
14483: PUSH
14484: LD_EXP 44
14488: PUSH
14489: EMPTY
14490: LIST
14491: LIST
14492: LIST
14493: LIST
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: PPUSH
14500: CALL_OW 69
14504: ST_TO_ADDR
14505: GO 14514
// temp_list = [ ] ;
14507: LD_ADDR_VAR 0 4
14511: PUSH
14512: EMPTY
14513: ST_TO_ADDR
// if temp_list > 0 then
14514: LD_VAR 0 4
14518: PUSH
14519: LD_INT 0
14521: GREATER
14522: IFFALSE 14579
// begin vehicles_list = ai_vehicles_defend [ base ] ;
14524: LD_ADDR_VAR 0 8
14528: PUSH
14529: LD_EXP 31
14533: PUSH
14534: LD_VAR 0 14
14538: ARRAY
14539: ST_TO_ADDR
// ComAgressiveMove ( vehicles_list , GetX ( temp_list [ 1 ] ) , GetY ( temp_list [ 1 ] ) ) ;
14540: LD_VAR 0 8
14544: PPUSH
14545: LD_VAR 0 4
14549: PUSH
14550: LD_INT 1
14552: ARRAY
14553: PPUSH
14554: CALL_OW 250
14558: PPUSH
14559: LD_VAR 0 4
14563: PUSH
14564: LD_INT 1
14566: ARRAY
14567: PPUSH
14568: CALL_OW 251
14572: PPUSH
14573: CALL_OW 114
// end else
14577: GO 14930
// begin if IsOk ( ai_depot [ base ] ) then
14579: LD_EXP 27
14583: PUSH
14584: LD_VAR 0 14
14588: ARRAY
14589: PPUSH
14590: CALL_OW 302
14594: IFFALSE 14831
// begin temp_list = ai_refuel_vehicles_list [ base ] ;
14596: LD_ADDR_VAR 0 4
14600: PUSH
14601: LD_EXP 46
14605: PUSH
14606: LD_VAR 0 14
14610: ARRAY
14611: ST_TO_ADDR
// for i in ai_vehicles_defend [ base ] diff ai_refuel_vehicles_list [ base ] do
14612: LD_ADDR_VAR 0 2
14616: PUSH
14617: LD_EXP 31
14621: PUSH
14622: LD_VAR 0 14
14626: ARRAY
14627: PUSH
14628: LD_EXP 46
14632: PUSH
14633: LD_VAR 0 14
14637: ARRAY
14638: DIFF
14639: PUSH
14640: FOR_IN
14641: IFFALSE 14676
// if GetFuel ( i ) < 80 then
14643: LD_VAR 0 2
14647: PPUSH
14648: CALL_OW 261
14652: PUSH
14653: LD_INT 80
14655: LESS
14656: IFFALSE 14674
// temp_list = temp_list ^ i ;
14658: LD_ADDR_VAR 0 4
14662: PUSH
14663: LD_VAR 0 4
14667: PUSH
14668: LD_VAR 0 2
14672: ADD
14673: ST_TO_ADDR
14674: GO 14640
14676: POP
14677: POP
// ai_refuel_vehicles_list = Replace ( ai_refuel_vehicles_list , base , temp_list ) ;
14678: LD_ADDR_EXP 46
14682: PUSH
14683: LD_EXP 46
14687: PPUSH
14688: LD_VAR 0 14
14692: PPUSH
14693: LD_VAR 0 4
14697: PPUSH
14698: CALL_OW 1
14702: ST_TO_ADDR
// for i in ai_refuel_vehicles_list [ base ] do
14703: LD_ADDR_VAR 0 2
14707: PUSH
14708: LD_EXP 46
14712: PUSH
14713: LD_VAR 0 14
14717: ARRAY
14718: PUSH
14719: FOR_IN
14720: IFFALSE 14829
// begin if IsInArea ( i , base_area ) then
14722: LD_VAR 0 2
14726: PPUSH
14727: LD_VAR 0 15
14731: PPUSH
14732: CALL_OW 308
14736: IFFALSE 14780
// begin ComMoveUnit ( i , ai_depot [ base ] ) ;
14738: LD_VAR 0 2
14742: PPUSH
14743: LD_EXP 27
14747: PUSH
14748: LD_VAR 0 14
14752: ARRAY
14753: PPUSH
14754: CALL_OW 112
// AddComRefuel ( i , ai_depot [ base ] ) ;
14758: LD_VAR 0 2
14762: PPUSH
14763: LD_EXP 27
14767: PUSH
14768: LD_VAR 0 14
14772: ARRAY
14773: PPUSH
14774: CALL_OW 210
// end else
14778: GO 14827
// ComAgressiveMove ( i , ai_buildings_locations [ base ] [ 1 ] [ 1 ] , ai_buildings_locations [ base ] [ 1 ] [ 2 ] ) ;
14780: LD_VAR 0 2
14784: PPUSH
14785: LD_EXP 30
14789: PUSH
14790: LD_VAR 0 14
14794: ARRAY
14795: PUSH
14796: LD_INT 1
14798: ARRAY
14799: PUSH
14800: LD_INT 1
14802: ARRAY
14803: PPUSH
14804: LD_EXP 30
14808: PUSH
14809: LD_VAR 0 14
14813: ARRAY
14814: PUSH
14815: LD_INT 1
14817: ARRAY
14818: PUSH
14819: LD_INT 2
14821: ARRAY
14822: PPUSH
14823: CALL_OW 114
// end ;
14827: GO 14719
14829: POP
14830: POP
// end ; for i in ai_vehicles_defend [ base ] diff ai_refuel_vehicles_list [ base ] do
14831: LD_ADDR_VAR 0 2
14835: PUSH
14836: LD_EXP 31
14840: PUSH
14841: LD_VAR 0 14
14845: ARRAY
14846: PUSH
14847: LD_EXP 46
14851: PUSH
14852: LD_VAR 0 14
14856: ARRAY
14857: DIFF
14858: PUSH
14859: FOR_IN
14860: IFFALSE 14928
// if not IsInArea ( i , base_area ) then
14862: LD_VAR 0 2
14866: PPUSH
14867: LD_VAR 0 15
14871: PPUSH
14872: CALL_OW 308
14876: NOT
14877: IFFALSE 14926
// ComAgressiveMove ( i , ai_buildings_locations [ base ] [ 1 ] [ 1 ] , ai_buildings_locations [ base ] [ 1 ] [ 2 ] ) ;
14879: LD_VAR 0 2
14883: PPUSH
14884: LD_EXP 30
14888: PUSH
14889: LD_VAR 0 14
14893: ARRAY
14894: PUSH
14895: LD_INT 1
14897: ARRAY
14898: PUSH
14899: LD_INT 1
14901: ARRAY
14902: PPUSH
14903: LD_EXP 30
14907: PUSH
14908: LD_VAR 0 14
14912: ARRAY
14913: PUSH
14914: LD_INT 1
14916: ARRAY
14917: PUSH
14918: LD_INT 2
14920: ARRAY
14921: PPUSH
14922: CALL_OW 114
14926: GO 14859
14928: POP
14929: POP
// end ; if mechanics_list = 0 then
14930: LD_VAR 0 3
14934: PUSH
14935: LD_INT 0
14937: EQUAL
14938: IFFALSE 14942
// continue ;
14940: GO 13807
// allowed_to_repair_vehicles = UnitFilter ( ai_vehicles_defend [ base ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_inarea , base_area ] ] ) ;
14942: LD_ADDR_VAR 0 9
14946: PUSH
14947: LD_EXP 31
14951: PUSH
14952: LD_VAR 0 14
14956: ARRAY
14957: PPUSH
14958: LD_INT 3
14960: PUSH
14961: LD_INT 24
14963: PUSH
14964: LD_INT 1000
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PUSH
14971: EMPTY
14972: LIST
14973: LIST
14974: PUSH
14975: LD_INT 95
14977: PUSH
14978: LD_VAR 0 15
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: PPUSH
14991: CALL_OW 72
14995: ST_TO_ADDR
// if not under_attack then
14996: LD_VAR 0 10
15000: NOT
15001: IFFALSE 15067
// allowed_to_repair_vehicles = allowed_to_repair_vehicles ^ UnitFilter ( ai_cargo_bay [ base ] diff 0 , [ [ f_not , [ f_lives , 1000 ] ] , [ f_inarea , base_area ] ] ) ;
15003: LD_ADDR_VAR 0 9
15007: PUSH
15008: LD_VAR 0 9
15012: PUSH
15013: LD_EXP 50
15017: PUSH
15018: LD_VAR 0 14
15022: ARRAY
15023: PUSH
15024: LD_INT 0
15026: DIFF
15027: PPUSH
15028: LD_INT 3
15030: PUSH
15031: LD_INT 24
15033: PUSH
15034: LD_INT 1000
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: PUSH
15045: LD_INT 95
15047: PUSH
15048: LD_VAR 0 15
15052: PUSH
15053: EMPTY
15054: LIST
15055: LIST
15056: PUSH
15057: EMPTY
15058: LIST
15059: LIST
15060: PPUSH
15061: CALL_OW 72
15065: ADD
15066: ST_TO_ADDR
// if allowed_to_repair_vehicles > 0 then
15067: LD_VAR 0 9
15071: PUSH
15072: LD_INT 0
15074: GREATER
15075: IFFALSE 15102
// begin ComRepairVehicle ( GetHumansOutOfUnits ( mechanics_list ) , allowed_to_repair_vehicles [ 1 ] ) ;
15077: LD_VAR 0 3
15081: PPUSH
15082: CALL 13557 0 1
15086: PPUSH
15087: LD_VAR 0 9
15091: PUSH
15092: LD_INT 1
15094: ARRAY
15095: PPUSH
15096: CALL_OW 129
// end else
15100: GO 15683
// begin if UnitFilter ( ai_vehicles_attack [ base ] , [ f_ok ] ) = 0 and ready_to_attack and ai_refuel_vehicles_list [ base ] = 0 and ai_vehicles_defend [ base ] >= NumOfVehicleReqToAttack then
15102: LD_EXP 32
15106: PUSH
15107: LD_VAR 0 14
15111: ARRAY
15112: PPUSH
15113: LD_INT 50
15115: PUSH
15116: EMPTY
15117: LIST
15118: PPUSH
15119: CALL_OW 72
15123: PUSH
15124: LD_INT 0
15126: EQUAL
15127: PUSH
15128: LD_VAR 0 13
15132: AND
15133: PUSH
15134: LD_EXP 46
15138: PUSH
15139: LD_VAR 0 14
15143: ARRAY
15144: PUSH
15145: LD_INT 0
15147: EQUAL
15148: AND
15149: PUSH
15150: LD_EXP 31
15154: PUSH
15155: LD_VAR 0 14
15159: ARRAY
15160: PUSH
15161: CALL 15691 0 0
15165: GREATEREQUAL
15166: AND
15167: IFFALSE 15415
// begin if FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_inarea , rubase3 ] ] ) > 0 and Rand ( 1 , 100 ) <= [ 0 , 50 , 50 ] [ difficulty ] and base = 2 then
15169: LD_INT 22
15171: PUSH
15172: LD_EXP 2
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: PUSH
15181: LD_INT 21
15183: PUSH
15184: LD_INT 3
15186: PUSH
15187: EMPTY
15188: LIST
15189: LIST
15190: PUSH
15191: LD_INT 95
15193: PUSH
15194: LD_INT 1
15196: PUSH
15197: EMPTY
15198: LIST
15199: LIST
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: LIST
15205: PPUSH
15206: CALL_OW 69
15210: PUSH
15211: LD_INT 0
15213: GREATER
15214: PUSH
15215: LD_INT 1
15217: PPUSH
15218: LD_INT 100
15220: PPUSH
15221: CALL_OW 12
15225: PUSH
15226: LD_INT 0
15228: PUSH
15229: LD_INT 50
15231: PUSH
15232: LD_INT 50
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: LIST
15239: PUSH
15240: LD_OWVAR 67
15244: ARRAY
15245: LESSEQUAL
15246: AND
15247: PUSH
15248: LD_VAR 0 14
15252: PUSH
15253: LD_INT 2
15255: EQUAL
15256: AND
15257: IFFALSE 15269
// k = 2 else
15259: LD_ADDR_VAR 0 12
15263: PUSH
15264: LD_INT 2
15266: ST_TO_ADDR
15267: GO 15277
// k = 1 ;
15269: LD_ADDR_VAR 0 12
15273: PUSH
15274: LD_INT 1
15276: ST_TO_ADDR
// ai_going_to_attack_this_base = Replace ( ai_going_to_attack_this_base , base , k ) ;
15277: LD_ADDR_EXP 45
15281: PUSH
15282: LD_EXP 45
15286: PPUSH
15287: LD_VAR 0 14
15291: PPUSH
15292: LD_VAR 0 12
15296: PPUSH
15297: CALL_OW 1
15301: ST_TO_ADDR
// temp_list = [ ] ;
15302: LD_ADDR_VAR 0 4
15306: PUSH
15307: EMPTY
15308: ST_TO_ADDR
// for k = 1 to NumOfVehicleReqToAttack do
15309: LD_ADDR_VAR 0 12
15313: PUSH
15314: DOUBLE
15315: LD_INT 1
15317: DEC
15318: ST_TO_ADDR
15319: CALL 15691 0 0
15323: PUSH
15324: FOR_TO
15325: IFFALSE 15379
// begin temp_list = temp_list ^ ai_vehicles_defend [ base ] [ 1 ] ;
15327: LD_ADDR_VAR 0 4
15331: PUSH
15332: LD_VAR 0 4
15336: PUSH
15337: LD_EXP 31
15341: PUSH
15342: LD_VAR 0 14
15346: ARRAY
15347: PUSH
15348: LD_INT 1
15350: ARRAY
15351: ADD
15352: ST_TO_ADDR
// RemoveVehicleFromVariables ( base , ai_vehicles_defend [ base ] [ 1 ] ) ;
15353: LD_VAR 0 14
15357: PPUSH
15358: LD_EXP 31
15362: PUSH
15363: LD_VAR 0 14
15367: ARRAY
15368: PUSH
15369: LD_INT 1
15371: ARRAY
15372: PPUSH
15373: CALL 7514 0 2
// end ;
15377: GO 15324
15379: POP
15380: POP
// ai_vehicles_attack = Replace ( ai_vehicles_attack , base , temp_list ) ;
15381: LD_ADDR_EXP 32
15385: PUSH
15386: LD_EXP 32
15390: PPUSH
15391: LD_VAR 0 14
15395: PPUSH
15396: LD_VAR 0 4
15400: PPUSH
15401: CALL_OW 1
15405: ST_TO_ADDR
// ResetAttackDelay ( base ) ;
15406: LD_VAR 0 14
15410: PPUSH
15411: CALL 6550 0 1
// end ; if IsOk ( ai_fact [ base ] ) then
15415: LD_EXP 39
15419: PUSH
15420: LD_VAR 0 14
15424: ARRAY
15425: PPUSH
15426: CALL_OW 302
15430: IFFALSE 15582
// begin for i in mechanics_list do
15432: LD_ADDR_VAR 0 2
15436: PUSH
15437: LD_VAR 0 3
15441: PUSH
15442: FOR_IN
15443: IFFALSE 15578
// begin temp_unit = IsInUnit ( i ) ;
15445: LD_ADDR_VAR 0 7
15449: PUSH
15450: LD_VAR 0 2
15454: PPUSH
15455: CALL_OW 310
15459: ST_TO_ADDR
// if temp_unit <> ai_fact [ base ] then
15460: LD_VAR 0 7
15464: PUSH
15465: LD_EXP 39
15469: PUSH
15470: LD_VAR 0 14
15474: ARRAY
15475: NONEQUAL
15476: IFFALSE 15576
// case GetType ( temp_unit ) of unit_vehicle :
15478: LD_VAR 0 7
15482: PPUSH
15483: CALL_OW 247
15487: PUSH
15488: LD_INT 2
15490: DOUBLE
15491: EQUAL
15492: IFTRUE 15496
15494: GO 15508
15496: POP
// ComExitVehicle ( i ) ; unit_building :
15497: LD_VAR 0 2
15501: PPUSH
15502: CALL_OW 121
15506: GO 15576
15508: LD_INT 3
15510: DOUBLE
15511: EQUAL
15512: IFTRUE 15516
15514: GO 15528
15516: POP
// ComExitBuilding ( i ) ; else
15517: LD_VAR 0 2
15521: PPUSH
15522: CALL_OW 122
15526: GO 15576
15528: POP
// begin ComEnterUnit ( i , ai_fact [ base ] ) ;
15529: LD_VAR 0 2
15533: PPUSH
15534: LD_EXP 39
15538: PUSH
15539: LD_VAR 0 14
15543: ARRAY
15544: PPUSH
15545: CALL_OW 120
// if GetClass ( i ) <> class_mechanic then
15549: LD_VAR 0 2
15553: PPUSH
15554: CALL_OW 257
15558: PUSH
15559: LD_INT 3
15561: NONEQUAL
15562: IFFALSE 15576
// AddComChangeProfession ( i , class_mechanic ) ;
15564: LD_VAR 0 2
15568: PPUSH
15569: LD_INT 3
15571: PPUSH
15572: CALL_OW 183
// end ; end ; end ;
15576: GO 15442
15578: POP
15579: POP
// end else
15580: GO 15683
// for i in mechanics_list do
15582: LD_ADDR_VAR 0 2
15586: PUSH
15587: LD_VAR 0 3
15591: PUSH
15592: FOR_IN
15593: IFFALSE 15681
// if GetDistUnitXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) > 4 then
15595: LD_VAR 0 2
15599: PPUSH
15600: LD_EXP 33
15604: PUSH
15605: LD_VAR 0 14
15609: ARRAY
15610: PUSH
15611: LD_INT 1
15613: ARRAY
15614: PPUSH
15615: LD_EXP 33
15619: PUSH
15620: LD_VAR 0 14
15624: ARRAY
15625: PUSH
15626: LD_INT 2
15628: ARRAY
15629: PPUSH
15630: CALL_OW 297
15634: PUSH
15635: LD_INT 4
15637: GREATER
15638: IFFALSE 15679
// ComMoveXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
15640: LD_VAR 0 2
15644: PPUSH
15645: LD_EXP 33
15649: PUSH
15650: LD_VAR 0 14
15654: ARRAY
15655: PUSH
15656: LD_INT 1
15658: ARRAY
15659: PPUSH
15660: LD_EXP 33
15664: PUSH
15665: LD_VAR 0 14
15669: ARRAY
15670: PUSH
15671: LD_INT 2
15673: ARRAY
15674: PPUSH
15675: CALL_OW 111
15679: GO 15592
15681: POP
15682: POP
// end ; end ;
15683: GO 13807
15685: POP
15686: POP
// enable ;
15687: ENABLE
// end ;
15688: PPOPN 15
15690: END
// function NumOfVehicleReqToAttack ; begin
15691: LD_INT 0
15693: PPUSH
// if tick < 25 25$0 then
15694: LD_OWVAR 1
15698: PUSH
15699: LD_INT 52500
15701: LESS
15702: IFFALSE 15731
// result = [ 2 , 3 , 3 ] [ difficulty ] else
15704: LD_ADDR_VAR 0 1
15708: PUSH
15709: LD_INT 2
15711: PUSH
15712: LD_INT 3
15714: PUSH
15715: LD_INT 3
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: LIST
15722: PUSH
15723: LD_OWVAR 67
15727: ARRAY
15728: ST_TO_ADDR
15729: GO 15756
// result = [ 3 , 4 , 4 ] [ difficulty ] ;
15731: LD_ADDR_VAR 0 1
15735: PUSH
15736: LD_INT 3
15738: PUSH
15739: LD_INT 4
15741: PUSH
15742: LD_INT 4
15744: PUSH
15745: EMPTY
15746: LIST
15747: LIST
15748: LIST
15749: PUSH
15750: LD_OWVAR 67
15754: ARRAY
15755: ST_TO_ADDR
// end ;
15756: LD_VAR 0 1
15760: RET
// every 0 0$1 + 0 0$0.1 do var side , i , temp_value , temp_unit , temp_list , base ;
15761: GO 15763
15763: DISABLE
15764: LD_INT 0
15766: PPUSH
15767: PPUSH
15768: PPUSH
15769: PPUSH
15770: PPUSH
15771: PPUSH
// begin side = russians ;
15772: LD_ADDR_VAR 0 1
15776: PUSH
15777: LD_EXP 3
15781: ST_TO_ADDR
// for base in ai_bases do
15782: LD_ADDR_VAR 0 6
15786: PUSH
15787: LD_EXP 49
15791: PUSH
15792: FOR_IN
15793: IFFALSE 16392
// begin if BuildingStatus ( ai_fact [ base ] ) <> bs_idle or not IsOk ( ai_fact [ base ] ) or GetBType ( ai_fact [ base ] ) <> b_factory then
15795: LD_EXP 39
15799: PUSH
15800: LD_VAR 0 6
15804: ARRAY
15805: PPUSH
15806: CALL_OW 461
15810: PUSH
15811: LD_INT 2
15813: NONEQUAL
15814: PUSH
15815: LD_EXP 39
15819: PUSH
15820: LD_VAR 0 6
15824: ARRAY
15825: PPUSH
15826: CALL_OW 302
15830: NOT
15831: OR
15832: PUSH
15833: LD_EXP 39
15837: PUSH
15838: LD_VAR 0 6
15842: ARRAY
15843: PPUSH
15844: CALL_OW 266
15848: PUSH
15849: LD_INT 3
15851: NONEQUAL
15852: OR
15853: IFFALSE 15857
// continue ;
15855: GO 15792
// temp_value = false ;
15857: LD_ADDR_VAR 0 3
15861: PUSH
15862: LD_INT 0
15864: ST_TO_ADDR
// for i in ai_buildings_locations [ base ] do
15865: LD_ADDR_VAR 0 2
15869: PUSH
15870: LD_EXP 30
15874: PUSH
15875: LD_VAR 0 6
15879: ARRAY
15880: PUSH
15881: FOR_IN
15882: IFFALSE 16035
// if i [ 4 ] in [ b_bunker , b_turret ] then
15884: LD_VAR 0 2
15888: PUSH
15889: LD_INT 4
15891: ARRAY
15892: PUSH
15893: LD_INT 32
15895: PUSH
15896: LD_INT 33
15898: PUSH
15899: EMPTY
15900: LIST
15901: LIST
15902: IN
15903: IFFALSE 16033
// begin temp_unit = HexInfo ( i [ 1 ] , i [ 2 ] ) ;
15905: LD_ADDR_VAR 0 4
15909: PUSH
15910: LD_VAR 0 2
15914: PUSH
15915: LD_INT 1
15917: ARRAY
15918: PPUSH
15919: LD_VAR 0 2
15923: PUSH
15924: LD_INT 2
15926: ARRAY
15927: PPUSH
15928: CALL_OW 428
15932: ST_TO_ADDR
// if GetBType ( temp_unit ) in [ b_bunker , b_turret ] and not IsConstructed ( temp_unit ) and GetBWeapon ( temp_unit ) <> i [ 7 ] then
15933: LD_VAR 0 4
15937: PPUSH
15938: CALL_OW 266
15942: PUSH
15943: LD_INT 32
15945: PUSH
15946: LD_INT 33
15948: PUSH
15949: EMPTY
15950: LIST
15951: LIST
15952: IN
15953: PUSH
15954: LD_VAR 0 4
15958: PPUSH
15959: CALL_OW 304
15963: NOT
15964: AND
15965: PUSH
15966: LD_VAR 0 4
15970: PPUSH
15971: CALL_OW 269
15975: PUSH
15976: LD_VAR 0 2
15980: PUSH
15981: LD_INT 7
15983: ARRAY
15984: NONEQUAL
15985: AND
15986: IFFALSE 16033
// if IsWeaponFactory ( ai_fact [ base ] ) then
15988: LD_EXP 39
15992: PUSH
15993: LD_VAR 0 6
15997: ARRAY
15998: PPUSH
15999: CALL 16398 0 1
16003: IFFALSE 16033
// begin ComPlaceWeapon ( temp_unit , i [ 7 ] ) ;
16005: LD_VAR 0 4
16009: PPUSH
16010: LD_VAR 0 2
16014: PUSH
16015: LD_INT 7
16017: ARRAY
16018: PPUSH
16019: CALL_OW 148
// temp_value = true ;
16023: LD_ADDR_VAR 0 3
16027: PUSH
16028: LD_INT 1
16030: ST_TO_ADDR
// break ;
16031: GO 16035
// end ; end ;
16033: GO 15881
16035: POP
16036: POP
// if temp_value then
16037: LD_VAR 0 3
16041: IFFALSE 16045
// continue ;
16043: GO 15792
// temp_value = false ;
16045: LD_ADDR_VAR 0 3
16049: PUSH
16050: LD_INT 0
16052: ST_TO_ADDR
// if ai_cargo_bay [ base ] = 0 then
16053: LD_EXP 50
16057: PUSH
16058: LD_VAR 0 6
16062: ARRAY
16063: PUSH
16064: LD_INT 0
16066: EQUAL
16067: IFFALSE 16167
// if ru_medium_tracked in AvailableChassisList ( ai_fact [ base ] ) and ru_cargo_bay in AvailableWeaponList ( ai_fact [ base ] ) and control_computer in AvailableControlList ( ai_fact [ base ] ) then
16069: LD_INT 22
16071: PUSH
16072: LD_EXP 39
16076: PUSH
16077: LD_VAR 0 6
16081: ARRAY
16082: PPUSH
16083: CALL_OW 475
16087: IN
16088: PUSH
16089: LD_INT 51
16091: PUSH
16092: LD_EXP 39
16096: PUSH
16097: LD_VAR 0 6
16101: ARRAY
16102: PPUSH
16103: CALL_OW 478
16107: IN
16108: AND
16109: PUSH
16110: LD_INT 3
16112: PUSH
16113: LD_EXP 39
16117: PUSH
16118: LD_VAR 0 6
16122: ARRAY
16123: PPUSH
16124: CALL_OW 477
16128: IN
16129: AND
16130: IFFALSE 16167
// begin ComConstruct ( ai_fact [ base ] , ru_medium_tracked , engine_combustion , control_computer , ru_cargo_bay ) ;
16132: LD_EXP 39
16136: PUSH
16137: LD_VAR 0 6
16141: ARRAY
16142: PPUSH
16143: LD_INT 22
16145: PPUSH
16146: LD_INT 1
16148: PPUSH
16149: LD_INT 3
16151: PPUSH
16152: LD_INT 51
16154: PPUSH
16155: CALL_OW 125
// temp_value = true ;
16159: LD_ADDR_VAR 0 3
16163: PUSH
16164: LD_INT 1
16166: ST_TO_ADDR
// end ; if temp_value then
16167: LD_VAR 0 3
16171: IFFALSE 16175
// continue ;
16173: GO 15792
// if UnitFilter ( ai_vehicles_defend [ base ] , [ f_ok ] ) < NumOfVehicleReqToAttack and survivors_found > 0 then
16175: LD_EXP 31
16179: PUSH
16180: LD_VAR 0 6
16184: ARRAY
16185: PPUSH
16186: LD_INT 50
16188: PUSH
16189: EMPTY
16190: LIST
16191: PPUSH
16192: CALL_OW 72
16196: PUSH
16197: CALL 15691 0 0
16201: LESS
16202: PUSH
16203: LD_EXP 52
16207: PUSH
16208: LD_INT 0
16210: GREATER
16211: AND
16212: IFFALSE 16390
// case side of russians :
16214: LD_VAR 0 1
16218: PUSH
16219: LD_EXP 3
16223: DOUBLE
16224: EQUAL
16225: IFTRUE 16229
16227: GO 16389
16229: POP
// begin if Rand ( 1 , 3 ) = 1 then
16230: LD_INT 1
16232: PPUSH
16233: LD_INT 3
16235: PPUSH
16236: CALL_OW 12
16240: PUSH
16241: LD_INT 1
16243: EQUAL
16244: IFFALSE 16282
// begin if Rand ( 1 , 3 ) = 1 then
16246: LD_INT 1
16248: PPUSH
16249: LD_INT 3
16251: PPUSH
16252: CALL_OW 12
16256: PUSH
16257: LD_INT 1
16259: EQUAL
16260: IFFALSE 16272
// temp_value = ru_heavy_machine_gun else
16262: LD_ADDR_VAR 0 3
16266: PUSH
16267: LD_INT 42
16269: ST_TO_ADDR
16270: GO 16280
// temp_value = ru_gatling_gun ;
16272: LD_ADDR_VAR 0 3
16276: PUSH
16277: LD_INT 43
16279: ST_TO_ADDR
// end else
16280: GO 16290
// temp_value = ru_gun ;
16282: LD_ADDR_VAR 0 3
16286: PUSH
16287: LD_INT 44
16289: ST_TO_ADDR
// if not IsWeaponFactory ( ai_fact [ base ] ) then
16290: LD_EXP 39
16294: PUSH
16295: LD_VAR 0 6
16299: ARRAY
16300: PPUSH
16301: CALL 16398 0 1
16305: NOT
16306: IFFALSE 16316
// temp_value = ru_heavy_machine_gun ;
16308: LD_ADDR_VAR 0 3
16312: PUSH
16313: LD_INT 42
16315: ST_TO_ADDR
// if Rand ( 1 , difficulty + 1 ) = 1 then
16316: LD_INT 1
16318: PPUSH
16319: LD_OWVAR 67
16323: PUSH
16324: LD_INT 1
16326: PLUS
16327: PPUSH
16328: CALL_OW 12
16332: PUSH
16333: LD_INT 1
16335: EQUAL
16336: IFFALSE 16348
// i = ru_medium_tracked else
16338: LD_ADDR_VAR 0 2
16342: PUSH
16343: LD_INT 22
16345: ST_TO_ADDR
16346: GO 16356
// i = ru_heavy_tracked ;
16348: LD_ADDR_VAR 0 2
16352: PUSH
16353: LD_INT 24
16355: ST_TO_ADDR
// ComConstruct ( ai_fact [ base ] , i , engine_combustion , control_computer , temp_value ) ;
16356: LD_EXP 39
16360: PUSH
16361: LD_VAR 0 6
16365: ARRAY
16366: PPUSH
16367: LD_VAR 0 2
16371: PPUSH
16372: LD_INT 1
16374: PPUSH
16375: LD_INT 3
16377: PPUSH
16378: LD_VAR 0 3
16382: PPUSH
16383: CALL_OW 125
// end ; end ;
16387: GO 16390
16389: POP
// end ;
16390: GO 15792
16392: POP
16393: POP
// enable ;
16394: ENABLE
// end ;
16395: PPOPN 6
16397: END
// function IsWeaponFactory ( factory ) ; begin
16398: LD_INT 0
16400: PPUSH
// if FilterAllUnits ( [ [ f_dist , factory , 4 ] , [ f_btype , b_ext_gun ] ] ) > 0 then
16401: LD_INT 91
16403: PUSH
16404: LD_VAR 0 1
16408: PUSH
16409: LD_INT 4
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: LIST
16416: PUSH
16417: LD_INT 30
16419: PUSH
16420: LD_INT 17
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: PUSH
16427: EMPTY
16428: LIST
16429: LIST
16430: PPUSH
16431: CALL_OW 69
16435: PUSH
16436: LD_INT 0
16438: GREATER
16439: IFFALSE 16451
// result = true else
16441: LD_ADDR_VAR 0 2
16445: PUSH
16446: LD_INT 1
16448: ST_TO_ADDR
16449: GO 16459
// result = false ;
16451: LD_ADDR_VAR 0 2
16455: PUSH
16456: LD_INT 0
16458: ST_TO_ADDR
// end ;
16459: LD_VAR 0 2
16463: RET
// on VehicleCaptured ( new_identifier , old_identifier , old_side , capturing_unit ) do var temp_list , base ;
16464: LD_INT 0
16466: PPUSH
16467: PPUSH
// begin if old_side = russians_alt and GetSide ( capturing_unit ) = you and GetWeapon ( new_identifier ) = ru_cargo_bay then
16468: LD_VAR 0 3
16472: PUSH
16473: LD_EXP 6
16477: EQUAL
16478: PUSH
16479: LD_VAR 0 4
16483: PPUSH
16484: CALL_OW 255
16488: PUSH
16489: LD_EXP 2
16493: EQUAL
16494: AND
16495: PUSH
16496: LD_VAR 0 1
16500: PPUSH
16501: CALL_OW 264
16505: PUSH
16506: LD_INT 51
16508: EQUAL
16509: AND
16510: IFFALSE 16520
// cargo_bay_captured = true ;
16512: LD_ADDR_EXP 57
16516: PUSH
16517: LD_INT 1
16519: ST_TO_ADDR
// if old_side <> russians then
16520: LD_VAR 0 3
16524: PUSH
16525: LD_EXP 3
16529: NONEQUAL
16530: IFFALSE 16534
// exit ;
16532: GO 16565
// for base in ai_bases do
16534: LD_ADDR_VAR 0 6
16538: PUSH
16539: LD_EXP 49
16543: PUSH
16544: FOR_IN
16545: IFFALSE 16563
// RemoveVehicleFromVariables ( base , old_identifier ) ;
16547: LD_VAR 0 6
16551: PPUSH
16552: LD_VAR 0 2
16556: PPUSH
16557: CALL 7514 0 2
16561: GO 16544
16563: POP
16564: POP
// end ;
16565: PPOPN 6
16567: END
// on VehicleConstructed ( vehicle , factory ) do var side , temp_list , base ;
16568: LD_INT 0
16570: PPUSH
16571: PPUSH
16572: PPUSH
// begin side = GetSide ( vehicle ) ;
16573: LD_ADDR_VAR 0 3
16577: PUSH
16578: LD_VAR 0 1
16582: PPUSH
16583: CALL_OW 255
16587: ST_TO_ADDR
// if side <> russians then
16588: LD_VAR 0 3
16592: PUSH
16593: LD_EXP 3
16597: NONEQUAL
16598: IFFALSE 16602
// exit ;
16600: GO 16718
// base = FindBase ( vehicle ) ;
16602: LD_ADDR_VAR 0 5
16606: PUSH
16607: LD_VAR 0 1
16611: PPUSH
16612: CALL 8212 0 1
16616: ST_TO_ADDR
// if base = 0 then
16617: LD_VAR 0 5
16621: PUSH
16622: LD_INT 0
16624: EQUAL
16625: IFFALSE 16629
// exit ;
16627: GO 16718
// if GetWeapon ( vehicle ) <> ru_cargo_bay then
16629: LD_VAR 0 1
16633: PPUSH
16634: CALL_OW 264
16638: PUSH
16639: LD_INT 51
16641: NONEQUAL
16642: IFFALSE 16693
// begin temp_list = ai_vehicles_defend [ base ] ^ vehicle ;
16644: LD_ADDR_VAR 0 4
16648: PUSH
16649: LD_EXP 31
16653: PUSH
16654: LD_VAR 0 5
16658: ARRAY
16659: PUSH
16660: LD_VAR 0 1
16664: ADD
16665: ST_TO_ADDR
// ai_vehicles_defend = Replace ( ai_vehicles_defend , base , temp_list ) ;
16666: LD_ADDR_EXP 31
16670: PUSH
16671: LD_EXP 31
16675: PPUSH
16676: LD_VAR 0 5
16680: PPUSH
16681: LD_VAR 0 4
16685: PPUSH
16686: CALL_OW 1
16690: ST_TO_ADDR
// end else
16691: GO 16718
// ai_cargo_bay = Replace ( ai_cargo_bay , base , vehicle ) ;
16693: LD_ADDR_EXP 50
16697: PUSH
16698: LD_EXP 50
16702: PPUSH
16703: LD_VAR 0 5
16707: PPUSH
16708: LD_VAR 0 1
16712: PPUSH
16713: CALL_OW 1
16717: ST_TO_ADDR
// end ;
16718: PPOPN 5
16720: END
// every 0 0$1 do var side , i , temp_value , base , is_idle , temp_list , attack_hex , temp_unit , idle_check , temp_list_2 , k ; var idle_time , has_switched_base_target ;
16721: GO 16723
16723: DISABLE
16724: LD_INT 0
16726: PPUSH
16727: PPUSH
16728: PPUSH
16729: PPUSH
16730: PPUSH
16731: PPUSH
16732: PPUSH
16733: PPUSH
16734: PPUSH
16735: PPUSH
16736: PPUSH
16737: PPUSH
16738: PPUSH
// begin has_switched_base_target = [ false , false , false ] ;
16739: LD_ADDR_VAR 0 13
16743: PUSH
16744: LD_INT 0
16746: PUSH
16747: LD_INT 0
16749: PUSH
16750: LD_INT 0
16752: PUSH
16753: EMPTY
16754: LIST
16755: LIST
16756: LIST
16757: ST_TO_ADDR
// idle_time = [ 0 0$0 , 0 0$0 , 0 0$0 ] ;
16758: LD_ADDR_VAR 0 12
16762: PUSH
16763: LD_INT 0
16765: PUSH
16766: LD_INT 0
16768: PUSH
16769: LD_INT 0
16771: PUSH
16772: EMPTY
16773: LIST
16774: LIST
16775: LIST
16776: ST_TO_ADDR
// side = russians ;
16777: LD_ADDR_VAR 0 1
16781: PUSH
16782: LD_EXP 3
16786: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
16787: LD_INT 35
16789: PPUSH
16790: CALL_OW 67
// for base in ai_bases do
16794: LD_ADDR_VAR 0 4
16798: PUSH
16799: LD_EXP 49
16803: PUSH
16804: FOR_IN
16805: IFFALSE 18161
// begin if UnitFilter ( ai_vehicles_attack [ base ] , [ f_ok ] ) = 0 then
16807: LD_EXP 32
16811: PUSH
16812: LD_VAR 0 4
16816: ARRAY
16817: PPUSH
16818: LD_INT 50
16820: PUSH
16821: EMPTY
16822: LIST
16823: PPUSH
16824: CALL_OW 72
16828: PUSH
16829: LD_INT 0
16831: EQUAL
16832: IFFALSE 16882
// begin idle_time = Replace ( idle_time , base , 0 0$0 ) ;
16834: LD_ADDR_VAR 0 12
16838: PUSH
16839: LD_VAR 0 12
16843: PPUSH
16844: LD_VAR 0 4
16848: PPUSH
16849: LD_INT 0
16851: PPUSH
16852: CALL_OW 1
16856: ST_TO_ADDR
// has_switched_base_target = Replace ( has_switched_base_target , base , false ) ;
16857: LD_ADDR_VAR 0 13
16861: PUSH
16862: LD_VAR 0 13
16866: PPUSH
16867: LD_VAR 0 4
16871: PPUSH
16872: LD_INT 0
16874: PPUSH
16875: CALL_OW 1
16879: ST_TO_ADDR
// continue ;
16880: GO 16804
// end ; case ai_going_to_attack_this_base [ base ] of 1 :
16882: LD_EXP 45
16886: PUSH
16887: LD_VAR 0 4
16891: ARRAY
16892: PUSH
16893: LD_INT 1
16895: DOUBLE
16896: EQUAL
16897: IFTRUE 16901
16899: GO 16919
16901: POP
// attack_hex = [ 66 , 64 ] ; 2 :
16902: LD_ADDR_VAR 0 7
16906: PUSH
16907: LD_INT 66
16909: PUSH
16910: LD_INT 64
16912: PUSH
16913: EMPTY
16914: LIST
16915: LIST
16916: ST_TO_ADDR
16917: GO 17390
16919: LD_INT 2
16921: DOUBLE
16922: EQUAL
16923: IFTRUE 16927
16925: GO 16945
16927: POP
// attack_hex = [ 116 , 48 ] ; 3 :
16928: LD_ADDR_VAR 0 7
16932: PUSH
16933: LD_INT 116
16935: PUSH
16936: LD_INT 48
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: ST_TO_ADDR
16943: GO 17390
16945: LD_INT 3
16947: DOUBLE
16948: EQUAL
16949: IFTRUE 16953
16951: GO 17389
16953: POP
// begin temp_list = FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16954: LD_ADDR_VAR 0 6
16958: PUSH
16959: LD_INT 22
16961: PUSH
16962: LD_EXP 2
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 2
16973: PUSH
16974: LD_INT 30
16976: PUSH
16977: LD_INT 0
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PUSH
16984: LD_INT 30
16986: PUSH
16987: LD_INT 1
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: LIST
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: PPUSH
17003: CALL_OW 69
17007: ST_TO_ADDR
// if temp_list > 0 then
17008: LD_VAR 0 6
17012: PUSH
17013: LD_INT 0
17015: GREATER
17016: IFFALSE 17310
// begin if temp_list + 0 = 1 then
17018: LD_VAR 0 6
17022: PUSH
17023: LD_INT 0
17025: PLUS
17026: PUSH
17027: LD_INT 1
17029: EQUAL
17030: IFFALSE 17048
// temp_unit = temp_list [ 1 ] else
17032: LD_ADDR_VAR 0 8
17036: PUSH
17037: LD_VAR 0 6
17041: PUSH
17042: LD_INT 1
17044: ARRAY
17045: ST_TO_ADDR
17046: GO 17279
// begin temp_list_2 = [ ] ;
17048: LD_ADDR_VAR 0 10
17052: PUSH
17053: EMPTY
17054: ST_TO_ADDR
// for k in temp_list do
17055: LD_ADDR_VAR 0 11
17059: PUSH
17060: LD_VAR 0 6
17064: PUSH
17065: FOR_IN
17066: IFFALSE 17093
// temp_list_2 = Replace ( temp_list_2 , k , 0 ) ;
17068: LD_ADDR_VAR 0 10
17072: PUSH
17073: LD_VAR 0 10
17077: PPUSH
17078: LD_VAR 0 11
17082: PPUSH
17083: LD_INT 0
17085: PPUSH
17086: CALL_OW 1
17090: ST_TO_ADDR
17091: GO 17065
17093: POP
17094: POP
// for k in FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) do
17095: LD_ADDR_VAR 0 11
17099: PUSH
17100: LD_INT 22
17102: PUSH
17103: LD_EXP 2
17107: PUSH
17108: EMPTY
17109: LIST
17110: LIST
17111: PUSH
17112: LD_INT 21
17114: PUSH
17115: LD_INT 3
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: PUSH
17122: EMPTY
17123: LIST
17124: LIST
17125: PPUSH
17126: CALL_OW 69
17130: PUSH
17131: FOR_IN
17132: IFFALSE 17212
// for i in temp_list do
17134: LD_ADDR_VAR 0 2
17138: PUSH
17139: LD_VAR 0 6
17143: PUSH
17144: FOR_IN
17145: IFFALSE 17208
// if GetBase ( k ) = GetBase ( i ) then
17147: LD_VAR 0 11
17151: PPUSH
17152: CALL_OW 274
17156: PUSH
17157: LD_VAR 0 2
17161: PPUSH
17162: CALL_OW 274
17166: EQUAL
17167: IFFALSE 17206
// begin temp_list_2 = Replace ( temp_list_2 , i , temp_list_2 [ i ] + 1 ) ;
17169: LD_ADDR_VAR 0 10
17173: PUSH
17174: LD_VAR 0 10
17178: PPUSH
17179: LD_VAR 0 2
17183: PPUSH
17184: LD_VAR 0 10
17188: PUSH
17189: LD_VAR 0 2
17193: ARRAY
17194: PUSH
17195: LD_INT 1
17197: PLUS
17198: PPUSH
17199: CALL_OW 1
17203: ST_TO_ADDR
// break ;
17204: GO 17208
// end ;
17206: GO 17144
17208: POP
17209: POP
17210: GO 17131
17212: POP
17213: POP
// temp_unit = temp_list [ 1 ] ;
17214: LD_ADDR_VAR 0 8
17218: PUSH
17219: LD_VAR 0 6
17223: PUSH
17224: LD_INT 1
17226: ARRAY
17227: ST_TO_ADDR
// for i in temp_list do
17228: LD_ADDR_VAR 0 2
17232: PUSH
17233: LD_VAR 0 6
17237: PUSH
17238: FOR_IN
17239: IFFALSE 17277
// if temp_list_2 [ i ] > temp_list_2 [ temp_unit ] then
17241: LD_VAR 0 10
17245: PUSH
17246: LD_VAR 0 2
17250: ARRAY
17251: PUSH
17252: LD_VAR 0 10
17256: PUSH
17257: LD_VAR 0 8
17261: ARRAY
17262: GREATER
17263: IFFALSE 17275
// temp_unit = i ;
17265: LD_ADDR_VAR 0 8
17269: PUSH
17270: LD_VAR 0 2
17274: ST_TO_ADDR
17275: GO 17238
17277: POP
17278: POP
// end ; attack_hex = [ GetX ( temp_unit ) , GetY ( temp_unit ) ] ;
17279: LD_ADDR_VAR 0 7
17283: PUSH
17284: LD_VAR 0 8
17288: PPUSH
17289: CALL_OW 250
17293: PUSH
17294: LD_VAR 0 8
17298: PPUSH
17299: CALL_OW 251
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: ST_TO_ADDR
// end else
17308: GO 17387
// begin temp_list = ai_vehicles_defend [ base ] ^ ai_vehicles_attack [ base ] ;
17310: LD_ADDR_VAR 0 6
17314: PUSH
17315: LD_EXP 31
17319: PUSH
17320: LD_VAR 0 4
17324: ARRAY
17325: PUSH
17326: LD_EXP 32
17330: PUSH
17331: LD_VAR 0 4
17335: ARRAY
17336: ADD
17337: ST_TO_ADDR
// ai_vehicles_defend = Replace ( ai_vehicles_defend , base , temp_list ) ;
17338: LD_ADDR_EXP 31
17342: PUSH
17343: LD_EXP 31
17347: PPUSH
17348: LD_VAR 0 4
17352: PPUSH
17353: LD_VAR 0 6
17357: PPUSH
17358: CALL_OW 1
17362: ST_TO_ADDR
// ai_vehicles_attack = Replace ( ai_vehicles_attack , base , [ ] ) ;
17363: LD_ADDR_EXP 32
17367: PUSH
17368: LD_EXP 32
17372: PPUSH
17373: LD_VAR 0 4
17377: PPUSH
17378: EMPTY
17379: PPUSH
17380: CALL_OW 1
17384: ST_TO_ADDR
// continue ;
17385: GO 16804
// end ; end ; end ;
17387: GO 17390
17389: POP
// idle_check = 0 ;
17390: LD_ADDR_VAR 0 9
17394: PUSH
17395: LD_INT 0
17397: ST_TO_ADDR
// for i in ai_vehicles_attack [ base ] do
17398: LD_ADDR_VAR 0 2
17402: PUSH
17403: LD_EXP 32
17407: PUSH
17408: LD_VAR 0 4
17412: ARRAY
17413: PUSH
17414: FOR_IN
17415: IFFALSE 17882
// begin temp_value = GetTaskList ( i ) ;
17417: LD_ADDR_VAR 0 3
17421: PUSH
17422: LD_VAR 0 2
17426: PPUSH
17427: CALL_OW 437
17431: ST_TO_ADDR
// if GetDistUnitXY ( i , attack_hex [ 1 ] , attack_hex [ 2 ] ) > 14 then
17432: LD_VAR 0 2
17436: PPUSH
17437: LD_VAR 0 7
17441: PUSH
17442: LD_INT 1
17444: ARRAY
17445: PPUSH
17446: LD_VAR 0 7
17450: PUSH
17451: LD_INT 2
17453: ARRAY
17454: PPUSH
17455: CALL_OW 297
17459: PUSH
17460: LD_INT 14
17462: GREATER
17463: IFFALSE 17494
// ComAgressiveMove ( i , attack_hex [ 1 ] , attack_hex [ 2 ] ) else
17465: LD_VAR 0 2
17469: PPUSH
17470: LD_VAR 0 7
17474: PUSH
17475: LD_INT 1
17477: ARRAY
17478: PPUSH
17479: LD_VAR 0 7
17483: PUSH
17484: LD_INT 2
17486: ARRAY
17487: PPUSH
17488: CALL_OW 114
17492: GO 17880
// begin temp_list = FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_dist , i , 20 ] , [ f_see , russians ] ] ) ;
17494: LD_ADDR_VAR 0 6
17498: PUSH
17499: LD_INT 22
17501: PUSH
17502: LD_EXP 2
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PUSH
17511: LD_INT 21
17513: PUSH
17514: LD_INT 1
17516: PUSH
17517: EMPTY
17518: LIST
17519: LIST
17520: PUSH
17521: LD_INT 91
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: LD_INT 20
17531: PUSH
17532: EMPTY
17533: LIST
17534: LIST
17535: LIST
17536: PUSH
17537: LD_INT 101
17539: PUSH
17540: LD_EXP 3
17544: PUSH
17545: EMPTY
17546: LIST
17547: LIST
17548: PUSH
17549: EMPTY
17550: LIST
17551: LIST
17552: LIST
17553: LIST
17554: PPUSH
17555: CALL_OW 69
17559: ST_TO_ADDR
// temp_list_2 = UnitFilter ( temp_list , [ f_not , [ f_lives , 250 ] ] ) ;
17560: LD_ADDR_VAR 0 10
17564: PUSH
17565: LD_VAR 0 6
17569: PPUSH
17570: LD_INT 3
17572: PUSH
17573: LD_INT 24
17575: PUSH
17576: LD_INT 250
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: PPUSH
17587: CALL_OW 72
17591: ST_TO_ADDR
// if temp_list_2 > 0 then
17592: LD_VAR 0 10
17596: PUSH
17597: LD_INT 0
17599: GREATER
17600: IFFALSE 17612
// temp_list = temp_list_2 ;
17602: LD_ADDR_VAR 0 6
17606: PUSH
17607: LD_VAR 0 10
17611: ST_TO_ADDR
// if temp_list > 0 then
17612: LD_VAR 0 6
17616: PUSH
17617: LD_INT 0
17619: GREATER
17620: IFFALSE 17704
// begin temp_unit = AllNearestUnitToUnit ( temp_list , i ) ;
17622: LD_ADDR_VAR 0 8
17626: PUSH
17627: LD_VAR 0 6
17631: PPUSH
17632: LD_VAR 0 2
17636: PPUSH
17637: CALL_OW 75
17641: ST_TO_ADDR
// if GetLives ( temp_unit ) > 250 then
17642: LD_VAR 0 8
17646: PPUSH
17647: CALL_OW 256
17651: PUSH
17652: LD_INT 250
17654: GREATER
17655: IFFALSE 17688
// ComAgressiveMove ( i , GetX ( temp_unit ) , GetY ( temp_unit ) ) else
17657: LD_VAR 0 2
17661: PPUSH
17662: LD_VAR 0 8
17666: PPUSH
17667: CALL_OW 250
17671: PPUSH
17672: LD_VAR 0 8
17676: PPUSH
17677: CALL_OW 251
17681: PPUSH
17682: CALL_OW 114
17686: GO 17702
// ComAttackUnit ( i , temp_unit ) ;
17688: LD_VAR 0 2
17692: PPUSH
17693: LD_VAR 0 8
17697: PPUSH
17698: CALL_OW 115
// end else
17702: GO 17880
// begin temp_list = FindNonhumansNearUnit ( russians , i , 20 , true ) ;
17704: LD_ADDR_VAR 0 6
17708: PUSH
17709: LD_EXP 3
17713: PPUSH
17714: LD_VAR 0 2
17718: PPUSH
17719: LD_INT 20
17721: PPUSH
17722: LD_INT 1
17724: PPUSH
17725: CALL 18276 0 4
17729: ST_TO_ADDR
// if temp_list > 0 then
17730: LD_VAR 0 6
17734: PUSH
17735: LD_INT 0
17737: GREATER
17738: IFFALSE 17779
// begin ComAgressiveMove ( i , GetX ( temp_list [ 1 ] ) , GetY ( temp_list [ 1 ] ) ) ;
17740: LD_VAR 0 2
17744: PPUSH
17745: LD_VAR 0 6
17749: PUSH
17750: LD_INT 1
17752: ARRAY
17753: PPUSH
17754: CALL_OW 250
17758: PPUSH
17759: LD_VAR 0 6
17763: PUSH
17764: LD_INT 1
17766: ARRAY
17767: PPUSH
17768: CALL_OW 251
17772: PPUSH
17773: CALL_OW 114
// end else
17777: GO 17880
// begin temp_list = FindNonhumansNearUnit ( russians , i , 20 , false ) ;
17779: LD_ADDR_VAR 0 6
17783: PUSH
17784: LD_EXP 3
17788: PPUSH
17789: LD_VAR 0 2
17793: PPUSH
17794: LD_INT 20
17796: PPUSH
17797: LD_INT 0
17799: PPUSH
17800: CALL 18276 0 4
17804: ST_TO_ADDR
// if temp_list > 0 then
17805: LD_VAR 0 6
17809: PUSH
17810: LD_INT 0
17812: GREATER
17813: IFFALSE 17851
// begin temp_unit = NearestUnitToUnit ( temp_list , i ) ;
17815: LD_ADDR_VAR 0 8
17819: PUSH
17820: LD_VAR 0 6
17824: PPUSH
17825: LD_VAR 0 2
17829: PPUSH
17830: CALL_OW 74
17834: ST_TO_ADDR
// ComAttackUnit ( i , temp_unit ) ;
17835: LD_VAR 0 2
17839: PPUSH
17840: LD_VAR 0 8
17844: PPUSH
17845: CALL_OW 115
// end else
17849: GO 17880
// if Attacks ( i ) = 0 then
17851: LD_VAR 0 2
17855: PPUSH
17856: CALL_OW 320
17860: PUSH
17861: LD_INT 0
17863: EQUAL
17864: IFFALSE 17880
// idle_check = idle_check + 1 ;
17866: LD_ADDR_VAR 0 9
17870: PUSH
17871: LD_VAR 0 9
17875: PUSH
17876: LD_INT 1
17878: PLUS
17879: ST_TO_ADDR
// end ; end ; end ; end ;
17880: GO 17414
17882: POP
17883: POP
// if idle_check = ai_vehicles_attack [ base ] then
17884: LD_VAR 0 9
17888: PUSH
17889: LD_EXP 32
17893: PUSH
17894: LD_VAR 0 4
17898: ARRAY
17899: EQUAL
17900: IFFALSE 18136
// begin idle_time = Replace ( idle_time , base , idle_time [ base ] + 0 0$1 ) ;
17902: LD_ADDR_VAR 0 12
17906: PUSH
17907: LD_VAR 0 12
17911: PPUSH
17912: LD_VAR 0 4
17916: PPUSH
17917: LD_VAR 0 12
17921: PUSH
17922: LD_VAR 0 4
17926: ARRAY
17927: PUSH
17928: LD_INT 35
17930: PLUS
17931: PPUSH
17932: CALL_OW 1
17936: ST_TO_ADDR
// if idle_time [ base ] >= 0 0$10 then
17937: LD_VAR 0 12
17941: PUSH
17942: LD_VAR 0 4
17946: ARRAY
17947: PUSH
17948: LD_INT 350
17950: GREATEREQUAL
17951: IFFALSE 18134
// begin if has_switched_base_target [ base ] then
17953: LD_VAR 0 13
17957: PUSH
17958: LD_VAR 0 4
17962: ARRAY
17963: IFFALSE 18065
// begin temp_list = ai_vehicles_defend [ base ] ^ ai_vehicles_attack [ base ] ;
17965: LD_ADDR_VAR 0 6
17969: PUSH
17970: LD_EXP 31
17974: PUSH
17975: LD_VAR 0 4
17979: ARRAY
17980: PUSH
17981: LD_EXP 32
17985: PUSH
17986: LD_VAR 0 4
17990: ARRAY
17991: ADD
17992: ST_TO_ADDR
// ai_vehicles_defend = Replace ( ai_vehicles_defend , base , temp_list ) ;
17993: LD_ADDR_EXP 31
17997: PUSH
17998: LD_EXP 31
18002: PPUSH
18003: LD_VAR 0 4
18007: PPUSH
18008: LD_VAR 0 6
18012: PPUSH
18013: CALL_OW 1
18017: ST_TO_ADDR
// ai_vehicles_attack = Replace ( ai_vehicles_attack , base , [ ] ) ;
18018: LD_ADDR_EXP 32
18022: PUSH
18023: LD_EXP 32
18027: PPUSH
18028: LD_VAR 0 4
18032: PPUSH
18033: EMPTY
18034: PPUSH
18035: CALL_OW 1
18039: ST_TO_ADDR
// has_switched_base_target = Replace ( has_switched_base_target , base , false ) ;
18040: LD_ADDR_VAR 0 13
18044: PUSH
18045: LD_VAR 0 13
18049: PPUSH
18050: LD_VAR 0 4
18054: PPUSH
18055: LD_INT 0
18057: PPUSH
18058: CALL_OW 1
18062: ST_TO_ADDR
// end else
18063: GO 18111
// begin ai_going_to_attack_this_base = Replace ( ai_going_to_attack_this_base , base , 3 ) ;
18065: LD_ADDR_EXP 45
18069: PUSH
18070: LD_EXP 45
18074: PPUSH
18075: LD_VAR 0 4
18079: PPUSH
18080: LD_INT 3
18082: PPUSH
18083: CALL_OW 1
18087: ST_TO_ADDR
// has_switched_base_target = Replace ( has_switched_base_target , base , true ) ;
18088: LD_ADDR_VAR 0 13
18092: PUSH
18093: LD_VAR 0 13
18097: PPUSH
18098: LD_VAR 0 4
18102: PPUSH
18103: LD_INT 1
18105: PPUSH
18106: CALL_OW 1
18110: ST_TO_ADDR
// end ; idle_time = Replace ( idle_time , base , 0 0$0 ) ;
18111: LD_ADDR_VAR 0 12
18115: PUSH
18116: LD_VAR 0 12
18120: PPUSH
18121: LD_VAR 0 4
18125: PPUSH
18126: LD_INT 0
18128: PPUSH
18129: CALL_OW 1
18133: ST_TO_ADDR
// end ; end else
18134: GO 18159
// idle_time = Replace ( idle_time , base , 0 0$0 ) ;
18136: LD_ADDR_VAR 0 12
18140: PUSH
18141: LD_VAR 0 12
18145: PPUSH
18146: LD_VAR 0 4
18150: PPUSH
18151: LD_INT 0
18153: PPUSH
18154: CALL_OW 1
18158: ST_TO_ADDR
// end ;
18159: GO 16804
18161: POP
18162: POP
// until false ;
18163: LD_INT 0
18165: IFFALSE 16787
// end ;
18167: PPOPN 13
18169: END
// every 0 0$5 do var base , i ;
18170: GO 18172
18172: DISABLE
18173: LD_INT 0
18175: PPUSH
18176: PPUSH
// begin for base in ai_bases do
18177: LD_ADDR_VAR 0 1
18181: PUSH
18182: LD_EXP 49
18186: PUSH
18187: FOR_IN
18188: IFFALSE 18270
// for i in ( ai_vehicles_attack [ base ] ^ ai_vehicles_defend [ base ] ^ ai_cargo_bay [ base ] ) diff 0 do
18190: LD_ADDR_VAR 0 2
18194: PUSH
18195: LD_EXP 32
18199: PUSH
18200: LD_VAR 0 1
18204: ARRAY
18205: PUSH
18206: LD_EXP 31
18210: PUSH
18211: LD_VAR 0 1
18215: ARRAY
18216: ADD
18217: PUSH
18218: LD_EXP 50
18222: PUSH
18223: LD_VAR 0 1
18227: ARRAY
18228: ADD
18229: PUSH
18230: LD_INT 0
18232: DIFF
18233: PUSH
18234: FOR_IN
18235: IFFALSE 18266
// if GetFuel ( i ) < 10 then
18237: LD_VAR 0 2
18241: PPUSH
18242: CALL_OW 261
18246: PUSH
18247: LD_INT 10
18249: LESS
18250: IFFALSE 18264
// SetFuel ( i , 10 ) ;
18252: LD_VAR 0 2
18256: PPUSH
18257: LD_INT 10
18259: PPUSH
18260: CALL_OW 240
18264: GO 18234
18266: POP
18267: POP
18268: GO 18187
18270: POP
18271: POP
// enable ;
18272: ENABLE
// end ;
18273: PPOPN 2
18275: END
// export function FindNonhumansNearUnit ( side , un , dist , only_dangerous ) ; var weapon_list , temp_list , i , btype , b , val ; begin
18276: LD_INT 0
18278: PPUSH
18279: PPUSH
18280: PPUSH
18281: PPUSH
18282: PPUSH
18283: PPUSH
18284: PPUSH
// temp_list = FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_human ] ] , [ f_dist , un , dist ] , [ f_see , side ] ] ) ;
18285: LD_ADDR_VAR 0 7
18289: PUSH
18290: LD_INT 81
18292: PUSH
18293: LD_VAR 0 1
18297: PUSH
18298: EMPTY
18299: LIST
18300: LIST
18301: PUSH
18302: LD_INT 3
18304: PUSH
18305: LD_INT 21
18307: PUSH
18308: LD_INT 1
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: PUSH
18315: EMPTY
18316: LIST
18317: LIST
18318: PUSH
18319: LD_INT 91
18321: PUSH
18322: LD_VAR 0 2
18326: PUSH
18327: LD_VAR 0 3
18331: PUSH
18332: EMPTY
18333: LIST
18334: LIST
18335: LIST
18336: PUSH
18337: LD_INT 101
18339: PUSH
18340: LD_VAR 0 1
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PUSH
18349: EMPTY
18350: LIST
18351: LIST
18352: LIST
18353: LIST
18354: PPUSH
18355: CALL_OW 69
18359: ST_TO_ADDR
// if only_dangerous then
18360: LD_VAR 0 4
18364: IFFALSE 18383
// begin result = DangerousUnits ( temp_list ) ;
18366: LD_ADDR_VAR 0 5
18370: PUSH
18371: LD_VAR 0 7
18375: PPUSH
18376: CALL 18398 0 1
18380: ST_TO_ADDR
// end else
18381: GO 18393
// result = temp_list end ;
18383: LD_ADDR_VAR 0 5
18387: PUSH
18388: LD_VAR 0 7
18392: ST_TO_ADDR
18393: LD_VAR 0 5
18397: RET
// export function DangerousUnits ( list ) ; var weapon_list , i , btype , b , val ; begin
18398: LD_INT 0
18400: PPUSH
18401: PPUSH
18402: PPUSH
18403: PPUSH
18404: PPUSH
18405: PPUSH
// weapon_list = [ us_machine_gun , us_light_gun , us_gatling_gun , us_double_gun , us_heavy_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , ar_multimissile_ballista , ar_light_gun , ar_double_machine_gun , ar_gatling_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb , ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_heavy_gun , ru_rocket , ru_siberium_rocket , ru_time_lapser ] ;
18406: LD_ADDR_VAR 0 3
18410: PUSH
18411: LD_INT 2
18413: PUSH
18414: LD_INT 3
18416: PUSH
18417: LD_INT 4
18419: PUSH
18420: LD_INT 5
18422: PUSH
18423: LD_INT 6
18425: PUSH
18426: LD_INT 7
18428: PUSH
18429: LD_INT 8
18431: PUSH
18432: LD_INT 9
18434: PUSH
18435: LD_INT 10
18437: PUSH
18438: LD_INT 22
18440: PUSH
18441: LD_INT 23
18443: PUSH
18444: LD_INT 24
18446: PUSH
18447: LD_INT 25
18449: PUSH
18450: LD_INT 26
18452: PUSH
18453: LD_INT 27
18455: PUSH
18456: LD_INT 28
18458: PUSH
18459: LD_INT 29
18461: PUSH
18462: LD_INT 42
18464: PUSH
18465: LD_INT 43
18467: PUSH
18468: LD_INT 44
18470: PUSH
18471: LD_INT 45
18473: PUSH
18474: LD_INT 46
18476: PUSH
18477: LD_INT 47
18479: PUSH
18480: LD_INT 48
18482: PUSH
18483: LD_INT 49
18485: PUSH
18486: EMPTY
18487: LIST
18488: LIST
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: LIST
18494: LIST
18495: LIST
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: LIST
18502: LIST
18503: LIST
18504: LIST
18505: LIST
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: LIST
18511: LIST
18512: ST_TO_ADDR
// result = [ ] ;
18513: LD_ADDR_VAR 0 2
18517: PUSH
18518: EMPTY
18519: ST_TO_ADDR
// for i in list do
18520: LD_ADDR_VAR 0 4
18524: PUSH
18525: LD_VAR 0 1
18529: PUSH
18530: FOR_IN
18531: IFFALSE 18979
// case GetType ( i ) of unit_human :
18533: LD_VAR 0 4
18537: PPUSH
18538: CALL_OW 247
18542: PUSH
18543: LD_INT 1
18545: DOUBLE
18546: EQUAL
18547: IFTRUE 18551
18549: GO 18584
18551: POP
// begin if not IsOk ( i ) then
18552: LD_VAR 0 4
18556: PPUSH
18557: CALL_OW 302
18561: NOT
18562: IFFALSE 18566
// continue ;
18564: GO 18530
// result = result ^ i ;
18566: LD_ADDR_VAR 0 2
18570: PUSH
18571: LD_VAR 0 2
18575: PUSH
18576: LD_VAR 0 4
18580: ADD
18581: ST_TO_ADDR
// end ; unit_vehicle :
18582: GO 18977
18584: LD_INT 2
18586: DOUBLE
18587: EQUAL
18588: IFTRUE 18592
18590: GO 18732
18592: POP
// begin if not IsOk ( i ) then
18593: LD_VAR 0 4
18597: PPUSH
18598: CALL_OW 302
18602: NOT
18603: IFFALSE 18607
// continue ;
18605: GO 18530
// case GetControl ( i ) of control_manual , control_rider :
18607: LD_VAR 0 4
18611: PPUSH
18612: CALL_OW 263
18616: PUSH
18617: LD_INT 1
18619: DOUBLE
18620: EQUAL
18621: IFTRUE 18631
18623: LD_INT 4
18625: DOUBLE
18626: EQUAL
18627: IFTRUE 18631
18629: GO 18651
18631: POP
// begin if UnitsInside ( i ) = 0 then
18632: LD_VAR 0 4
18636: PPUSH
18637: CALL_OW 313
18641: PUSH
18642: LD_INT 0
18644: EQUAL
18645: IFFALSE 18649
// continue ;
18647: GO 18530
// end ; control_remote :
18649: GO 18697
18651: LD_INT 2
18653: DOUBLE
18654: EQUAL
18655: IFTRUE 18659
18657: GO 18679
18659: POP
// begin if IsControledBy ( i ) = 0 then
18660: LD_VAR 0 4
18664: PPUSH
18665: CALL_OW 312
18669: PUSH
18670: LD_INT 0
18672: EQUAL
18673: IFFALSE 18677
// continue ;
18675: GO 18530
// end ; control_computer , control_apeman :
18677: GO 18697
18679: LD_INT 3
18681: DOUBLE
18682: EQUAL
18683: IFTRUE 18693
18685: LD_INT 5
18687: DOUBLE
18688: EQUAL
18689: IFTRUE 18693
18691: GO 18696
18693: POP
// begin end ; end ;
18694: GO 18697
18696: POP
// if GetWeapon ( i ) in weapon_list then
18697: LD_VAR 0 4
18701: PPUSH
18702: CALL_OW 264
18706: PUSH
18707: LD_VAR 0 3
18711: IN
18712: IFFALSE 18730
// result = result ^ i ;
18714: LD_ADDR_VAR 0 2
18718: PUSH
18719: LD_VAR 0 2
18723: PUSH
18724: LD_VAR 0 4
18728: ADD
18729: ST_TO_ADDR
// end ; unit_building :
18730: GO 18977
18732: LD_INT 3
18734: DOUBLE
18735: EQUAL
18736: IFTRUE 18740
18738: GO 18976
18740: POP
// begin if not IsOk ( i ) then
18741: LD_VAR 0 4
18745: PPUSH
18746: CALL_OW 302
18750: NOT
18751: IFFALSE 18755
// continue ;
18753: GO 18530
// btype = GetBType ( i ) ;
18755: LD_ADDR_VAR 0 5
18759: PUSH
18760: LD_VAR 0 4
18764: PPUSH
18765: CALL_OW 266
18769: ST_TO_ADDR
// case btype of b_turret :
18770: LD_VAR 0 5
18774: PUSH
18775: LD_INT 33
18777: DOUBLE
18778: EQUAL
18779: IFTRUE 18783
18781: GO 18786
18783: POP
// begin end ; b_bunker , b_breastwork , b_armoury , b_barracks , b_fort :
18784: GO 18841
18786: LD_INT 32
18788: DOUBLE
18789: EQUAL
18790: IFTRUE 18818
18792: LD_INT 31
18794: DOUBLE
18795: EQUAL
18796: IFTRUE 18818
18798: LD_INT 4
18800: DOUBLE
18801: EQUAL
18802: IFTRUE 18818
18804: LD_INT 5
18806: DOUBLE
18807: EQUAL
18808: IFTRUE 18818
18810: LD_INT 35
18812: DOUBLE
18813: EQUAL
18814: IFTRUE 18818
18816: GO 18838
18818: POP
// begin if UnitsInside ( i ) = 0 then
18819: LD_VAR 0 4
18823: PPUSH
18824: CALL_OW 313
18828: PUSH
18829: LD_INT 0
18831: EQUAL
18832: IFFALSE 18836
// continue ;
18834: GO 18530
// end ; else
18836: GO 18841
18838: POP
// continue ; end ;
18839: GO 18530
// if btype in [ b_bunker , b_turret ] then
18841: LD_VAR 0 5
18845: PUSH
18846: LD_INT 32
18848: PUSH
18849: LD_INT 33
18851: PUSH
18852: EMPTY
18853: LIST
18854: LIST
18855: IN
18856: IFFALSE 18958
// if not GetBWeapon ( i ) in weapon_list then
18858: LD_VAR 0 4
18862: PPUSH
18863: CALL_OW 269
18867: PUSH
18868: LD_VAR 0 3
18872: IN
18873: NOT
18874: IFFALSE 18880
// continue else
18876: GO 18530
18878: GO 18958
// begin b = GetBase ( i ) ;
18880: LD_ADDR_VAR 0 6
18884: PUSH
18885: LD_VAR 0 4
18889: PPUSH
18890: CALL_OW 274
18894: ST_TO_ADDR
// val = false ;
18895: LD_ADDR_VAR 0 7
18899: PUSH
18900: LD_INT 0
18902: ST_TO_ADDR
// if b = 0 then
18903: LD_VAR 0 6
18907: PUSH
18908: LD_INT 0
18910: EQUAL
18911: IFFALSE 18923
// val = true else
18913: LD_ADDR_VAR 0 7
18917: PUSH
18918: LD_INT 1
18920: ST_TO_ADDR
18921: GO 18950
// if GetEnergy ( b ) [ 4 ] = 0 then
18923: LD_VAR 0 6
18927: PPUSH
18928: CALL_OW 278
18932: PUSH
18933: LD_INT 4
18935: ARRAY
18936: PUSH
18937: LD_INT 0
18939: EQUAL
18940: IFFALSE 18950
// val = true ;
18942: LD_ADDR_VAR 0 7
18946: PUSH
18947: LD_INT 1
18949: ST_TO_ADDR
// if val then
18950: LD_VAR 0 7
18954: IFFALSE 18958
// continue ;
18956: GO 18530
// end ; result = result ^ i ;
18958: LD_ADDR_VAR 0 2
18962: PUSH
18963: LD_VAR 0 2
18967: PUSH
18968: LD_VAR 0 4
18972: ADD
18973: ST_TO_ADDR
// end ; end ;
18974: GO 18977
18976: POP
18977: GO 18530
18979: POP
18980: POP
// end ;
18981: LD_VAR 0 2
18985: RET
// every 0 0$1 + 0 0$0.5 do var base , area_list , area , c , temp_list , crates_list , b , temp_value ; var refueling ;
18986: GO 18988
18988: DISABLE
18989: LD_INT 0
18991: PPUSH
18992: PPUSH
18993: PPUSH
18994: PPUSH
18995: PPUSH
18996: PPUSH
18997: PPUSH
18998: PPUSH
18999: PPUSH
// begin refueling = [ false , false , false ] ;
19000: LD_ADDR_VAR 0 9
19004: PUSH
19005: LD_INT 0
19007: PUSH
19008: LD_INT 0
19010: PUSH
19011: LD_INT 0
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: LIST
19018: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19019: LD_INT 35
19021: PPUSH
19022: CALL_OW 67
// for base in ai_bases do
19026: LD_ADDR_VAR 0 1
19030: PUSH
19031: LD_EXP 49
19035: PUSH
19036: FOR_IN
19037: IFFALSE 19957
// begin if ai_cargo_bay [ base ] = 0 then
19039: LD_EXP 50
19043: PUSH
19044: LD_VAR 0 1
19048: ARRAY
19049: PUSH
19050: LD_INT 0
19052: EQUAL
19053: IFFALSE 19057
// continue ;
19055: GO 19036
// temp_value = GetLives ( ai_cargo_bay [ base ] ) ;
19057: LD_ADDR_VAR 0 8
19061: PUSH
19062: LD_EXP 50
19066: PUSH
19067: LD_VAR 0 1
19071: ARRAY
19072: PPUSH
19073: CALL_OW 256
19077: ST_TO_ADDR
// case base of 1 :
19078: LD_VAR 0 1
19082: PUSH
19083: LD_INT 1
19085: DOUBLE
19086: EQUAL
19087: IFTRUE 19091
19089: GO 19102
19091: POP
// area = rubase1 ; 2 :
19092: LD_ADDR_VAR 0 3
19096: PUSH
19097: LD_INT 3
19099: ST_TO_ADDR
19100: GO 19141
19102: LD_INT 2
19104: DOUBLE
19105: EQUAL
19106: IFTRUE 19110
19108: GO 19121
19110: POP
// area = rubase2 ; 3 :
19111: LD_ADDR_VAR 0 3
19115: PUSH
19116: LD_INT 2
19118: ST_TO_ADDR
19119: GO 19141
19121: LD_INT 3
19123: DOUBLE
19124: EQUAL
19125: IFTRUE 19129
19127: GO 19140
19129: POP
// area = rubase3 ; end ;
19130: LD_ADDR_VAR 0 3
19134: PUSH
19135: LD_INT 1
19137: ST_TO_ADDR
19138: GO 19141
19140: POP
// if IsInArea ( ai_cargo_bay [ base ] , area ) then
19141: LD_EXP 50
19145: PUSH
19146: LD_VAR 0 1
19150: ARRAY
19151: PPUSH
19152: LD_VAR 0 3
19156: PPUSH
19157: CALL_OW 308
19161: IFFALSE 19177
// begin if temp_value < 1000 then
19163: LD_VAR 0 8
19167: PUSH
19168: LD_INT 1000
19170: LESS
19171: IFFALSE 19175
// continue ;
19173: GO 19036
// end else
19175: GO 19279
// if temp_value < 600 then
19177: LD_VAR 0 8
19181: PUSH
19182: LD_INT 600
19184: LESS
19185: IFFALSE 19279
// begin if IsLive ( ai_depot [ base ] ) then
19187: LD_EXP 27
19191: PUSH
19192: LD_VAR 0 1
19196: ARRAY
19197: PPUSH
19198: CALL_OW 300
19202: IFFALSE 19232
// ComGive ( ai_cargo_bay [ base ] , ai_depot [ base ] ) else
19204: LD_EXP 50
19208: PUSH
19209: LD_VAR 0 1
19213: ARRAY
19214: PPUSH
19215: LD_EXP 27
19219: PUSH
19220: LD_VAR 0 1
19224: ARRAY
19225: PPUSH
19226: CALL_OW 161
19230: GO 19277
// ComMoveXY ( ai_cargo_bay [ base ] , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
19232: LD_EXP 50
19236: PUSH
19237: LD_VAR 0 1
19241: ARRAY
19242: PPUSH
19243: LD_EXP 33
19247: PUSH
19248: LD_VAR 0 1
19252: ARRAY
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: LD_EXP 33
19262: PUSH
19263: LD_VAR 0 1
19267: ARRAY
19268: PUSH
19269: LD_INT 2
19271: ARRAY
19272: PPUSH
19273: CALL_OW 111
// continue ;
19277: GO 19036
// end ; c = GetFuel ( ai_cargo_bay [ base ] ) ;
19279: LD_ADDR_VAR 0 4
19283: PUSH
19284: LD_EXP 50
19288: PUSH
19289: LD_VAR 0 1
19293: ARRAY
19294: PPUSH
19295: CALL_OW 261
19299: ST_TO_ADDR
// if c > 90 then
19300: LD_VAR 0 4
19304: PUSH
19305: LD_INT 90
19307: GREATER
19308: IFFALSE 19335
// refueling = Replace ( refueling , base , false ) else
19310: LD_ADDR_VAR 0 9
19314: PUSH
19315: LD_VAR 0 9
19319: PPUSH
19320: LD_VAR 0 1
19324: PPUSH
19325: LD_INT 0
19327: PPUSH
19328: CALL_OW 1
19332: ST_TO_ADDR
19333: GO 19451
// if ( c < 25 or refueling [ base ] ) and IsLive ( ai_depot [ base ] ) then
19335: LD_VAR 0 4
19339: PUSH
19340: LD_INT 25
19342: LESS
19343: PUSH
19344: LD_VAR 0 9
19348: PUSH
19349: LD_VAR 0 1
19353: ARRAY
19354: OR
19355: PUSH
19356: LD_EXP 27
19360: PUSH
19361: LD_VAR 0 1
19365: ARRAY
19366: PPUSH
19367: CALL_OW 300
19371: AND
19372: IFFALSE 19451
// begin ComMoveUnit ( ai_cargo_bay [ base ] , ai_depot [ base ] ) ;
19374: LD_EXP 50
19378: PUSH
19379: LD_VAR 0 1
19383: ARRAY
19384: PPUSH
19385: LD_EXP 27
19389: PUSH
19390: LD_VAR 0 1
19394: ARRAY
19395: PPUSH
19396: CALL_OW 112
// AddComRefuel ( ai_cargo_bay [ base ] , ai_depot [ base ] ) ;
19400: LD_EXP 50
19404: PUSH
19405: LD_VAR 0 1
19409: ARRAY
19410: PPUSH
19411: LD_EXP 27
19415: PUSH
19416: LD_VAR 0 1
19420: ARRAY
19421: PPUSH
19422: CALL_OW 210
// refueling = Replace ( refueling , base , true ) ;
19426: LD_ADDR_VAR 0 9
19430: PUSH
19431: LD_VAR 0 9
19435: PPUSH
19436: LD_VAR 0 1
19440: PPUSH
19441: LD_INT 1
19443: PPUSH
19444: CALL_OW 1
19448: ST_TO_ADDR
// continue ;
19449: GO 19036
// end ; case base of 1 :
19451: LD_VAR 0 1
19455: PUSH
19456: LD_INT 1
19458: DOUBLE
19459: EQUAL
19460: IFTRUE 19464
19462: GO 19478
19464: POP
// area_list = [ rucrate1 ] ; 2 :
19465: LD_ADDR_VAR 0 2
19469: PUSH
19470: LD_INT 9
19472: PUSH
19473: EMPTY
19474: LIST
19475: ST_TO_ADDR
19476: GO 19580
19478: LD_INT 2
19480: DOUBLE
19481: EQUAL
19482: IFTRUE 19486
19484: GO 19561
19486: POP
// begin area_list = [ rucrate2_safe ] ;
19487: LD_ADDR_VAR 0 2
19491: PUSH
19492: LD_INT 7
19494: PUSH
19495: EMPTY
19496: LIST
19497: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_inarea , rubase3 ] ] ) = 0 then
19498: LD_INT 22
19500: PUSH
19501: LD_EXP 2
19505: PUSH
19506: EMPTY
19507: LIST
19508: LIST
19509: PUSH
19510: LD_INT 21
19512: PUSH
19513: LD_INT 3
19515: PUSH
19516: EMPTY
19517: LIST
19518: LIST
19519: PUSH
19520: LD_INT 95
19522: PUSH
19523: LD_INT 1
19525: PUSH
19526: EMPTY
19527: LIST
19528: LIST
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: LIST
19534: PPUSH
19535: CALL_OW 69
19539: PUSH
19540: LD_INT 0
19542: EQUAL
19543: IFFALSE 19559
// area_list = area_list ^ rucrate2_relativesafe ;
19545: LD_ADDR_VAR 0 2
19549: PUSH
19550: LD_VAR 0 2
19554: PUSH
19555: LD_INT 8
19557: ADD
19558: ST_TO_ADDR
// end ; 3 :
19559: GO 19580
19561: LD_INT 3
19563: DOUBLE
19564: EQUAL
19565: IFTRUE 19569
19567: GO 19579
19569: POP
// area_list = [ ] ; end ;
19570: LD_ADDR_VAR 0 2
19574: PUSH
19575: EMPTY
19576: ST_TO_ADDR
19577: GO 19580
19579: POP
// crates_list = [ ] ;
19580: LD_ADDR_VAR 0 6
19584: PUSH
19585: EMPTY
19586: ST_TO_ADDR
// for b in area_list do
19587: LD_ADDR_VAR 0 7
19591: PUSH
19592: LD_VAR 0 2
19596: PUSH
19597: FOR_IN
19598: IFFALSE 19628
// begin crates_list = crates_list ^ GetListOfCratesInArea_ForGathering ( base , b ) ;
19600: LD_ADDR_VAR 0 6
19604: PUSH
19605: LD_VAR 0 6
19609: PUSH
19610: LD_VAR 0 1
19614: PPUSH
19615: LD_VAR 0 7
19619: PPUSH
19620: CALL 29882 0 2
19624: ADD
19625: ST_TO_ADDR
// end ;
19626: GO 19597
19628: POP
19629: POP
// if crates_list > 0 and ai_depot [ base ] > 0 then
19630: LD_VAR 0 6
19634: PUSH
19635: LD_INT 0
19637: GREATER
19638: PUSH
19639: LD_EXP 27
19643: PUSH
19644: LD_VAR 0 1
19648: ARRAY
19649: PUSH
19650: LD_INT 0
19652: GREATER
19653: AND
19654: IFFALSE 19780
// begin temp_list = [ ] ;
19656: LD_ADDR_VAR 0 5
19660: PUSH
19661: EMPTY
19662: ST_TO_ADDR
// for c in crates_list do
19663: LD_ADDR_VAR 0 4
19667: PUSH
19668: LD_VAR 0 6
19672: PUSH
19673: FOR_IN
19674: IFFALSE 19723
// temp_list = temp_list ^ GetDistUnitXY ( ai_cargo_bay [ base ] , c [ 1 ] , c [ 2 ] ) ;
19676: LD_ADDR_VAR 0 5
19680: PUSH
19681: LD_VAR 0 5
19685: PUSH
19686: LD_EXP 50
19690: PUSH
19691: LD_VAR 0 1
19695: ARRAY
19696: PPUSH
19697: LD_VAR 0 4
19701: PUSH
19702: LD_INT 1
19704: ARRAY
19705: PPUSH
19706: LD_VAR 0 4
19710: PUSH
19711: LD_INT 2
19713: ARRAY
19714: PPUSH
19715: CALL_OW 297
19719: ADD
19720: ST_TO_ADDR
19721: GO 19673
19723: POP
19724: POP
// temp_list = WorstFromListByList ( crates_list , temp_list ) ;
19725: LD_ADDR_VAR 0 5
19729: PUSH
19730: LD_VAR 0 6
19734: PPUSH
19735: LD_VAR 0 5
19739: PPUSH
19740: CALL_OW 78
19744: ST_TO_ADDR
// ComCollect ( ai_cargo_bay [ base ] , temp_list [ 1 ] , temp_list [ 2 ] ) ;
19745: LD_EXP 50
19749: PUSH
19750: LD_VAR 0 1
19754: ARRAY
19755: PPUSH
19756: LD_VAR 0 5
19760: PUSH
19761: LD_INT 1
19763: ARRAY
19764: PPUSH
19765: LD_VAR 0 5
19769: PUSH
19770: LD_INT 2
19772: ARRAY
19773: PPUSH
19774: CALL_OW 117
// end else
19778: GO 19955
// if IsOk ( ai_depot [ base ] ) and Carry ( ai_cargo_bay [ base ] ) then
19780: LD_EXP 27
19784: PUSH
19785: LD_VAR 0 1
19789: ARRAY
19790: PPUSH
19791: CALL_OW 302
19795: PUSH
19796: LD_EXP 50
19800: PUSH
19801: LD_VAR 0 1
19805: ARRAY
19806: PPUSH
19807: CALL_OW 281
19811: AND
19812: IFFALSE 19842
// ComGive ( ai_cargo_bay [ base ] , ai_depot [ base ] ) else
19814: LD_EXP 50
19818: PUSH
19819: LD_VAR 0 1
19823: ARRAY
19824: PPUSH
19825: LD_EXP 27
19829: PUSH
19830: LD_VAR 0 1
19834: ARRAY
19835: PPUSH
19836: CALL_OW 161
19840: GO 19955
// if not IsInArea ( ai_cargo_bay [ base ] , area ) then
19842: LD_EXP 50
19846: PUSH
19847: LD_VAR 0 1
19851: ARRAY
19852: PPUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: CALL_OW 308
19862: NOT
19863: IFFALSE 19955
// if IsOk ( ai_depot [ base ] ) then
19865: LD_EXP 27
19869: PUSH
19870: LD_VAR 0 1
19874: ARRAY
19875: PPUSH
19876: CALL_OW 302
19880: IFFALSE 19910
// ComGive ( ai_cargo_bay [ base ] , ai_depot [ base ] ) else
19882: LD_EXP 50
19886: PUSH
19887: LD_VAR 0 1
19891: ARRAY
19892: PPUSH
19893: LD_EXP 27
19897: PUSH
19898: LD_VAR 0 1
19902: ARRAY
19903: PPUSH
19904: CALL_OW 161
19908: GO 19955
// ComMoveXY ( ai_cargo_bay [ base ] , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
19910: LD_EXP 50
19914: PUSH
19915: LD_VAR 0 1
19919: ARRAY
19920: PPUSH
19921: LD_EXP 33
19925: PUSH
19926: LD_VAR 0 1
19930: ARRAY
19931: PUSH
19932: LD_INT 1
19934: ARRAY
19935: PPUSH
19936: LD_EXP 33
19940: PUSH
19941: LD_VAR 0 1
19945: ARRAY
19946: PUSH
19947: LD_INT 2
19949: ARRAY
19950: PPUSH
19951: CALL_OW 111
// end ;
19955: GO 19036
19957: POP
19958: POP
// until false ;
19959: LD_INT 0
19961: IFFALSE 19019
// end ;
19963: PPOPN 9
19965: END
// every 0 0$1 do var side , i , scientists_list , temp_list , temp_unit , base , under_attack ;
19966: GO 19968
19968: DISABLE
19969: LD_INT 0
19971: PPUSH
19972: PPUSH
19973: PPUSH
19974: PPUSH
19975: PPUSH
19976: PPUSH
19977: PPUSH
// begin side = russians ;
19978: LD_ADDR_VAR 0 1
19982: PUSH
19983: LD_EXP 3
19987: ST_TO_ADDR
// for base in ai_bases do
19988: LD_ADDR_VAR 0 6
19992: PUSH
19993: LD_EXP 49
19997: PUSH
19998: FOR_IN
19999: IFFALSE 20966
// begin scientists_list = ai_scientists [ base ] diff ai_heal_these_humans [ base ] ;
20001: LD_ADDR_VAR 0 3
20005: PUSH
20006: LD_EXP 25
20010: PUSH
20011: LD_VAR 0 6
20015: ARRAY
20016: PUSH
20017: LD_EXP 35
20021: PUSH
20022: LD_VAR 0 6
20026: ARRAY
20027: DIFF
20028: ST_TO_ADDR
// temp_list = ai_heal_these_humans [ base ] ;
20029: LD_ADDR_VAR 0 4
20033: PUSH
20034: LD_EXP 35
20038: PUSH
20039: LD_VAR 0 6
20043: ARRAY
20044: ST_TO_ADDR
// i = 1 ;
20045: LD_ADDR_VAR 0 2
20049: PUSH
20050: LD_INT 1
20052: ST_TO_ADDR
// while i <= scientists_list do
20053: LD_VAR 0 2
20057: PUSH
20058: LD_VAR 0 3
20062: LESSEQUAL
20063: IFFALSE 20158
// begin if GetLives ( scientists_list [ i ] ) <= 700 then
20065: LD_VAR 0 3
20069: PUSH
20070: LD_VAR 0 2
20074: ARRAY
20075: PPUSH
20076: CALL_OW 256
20080: PUSH
20081: LD_INT 700
20083: LESSEQUAL
20084: IFFALSE 20142
// begin temp_list = temp_list ^ scientists_list [ i ] ;
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: LD_VAR 0 4
20095: PUSH
20096: LD_VAR 0 3
20100: PUSH
20101: LD_VAR 0 2
20105: ARRAY
20106: ADD
20107: ST_TO_ADDR
// scientists_list = Delete ( scientists_list , i ) ;
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_VAR 0 3
20117: PPUSH
20118: LD_VAR 0 2
20122: PPUSH
20123: CALL_OW 3
20127: ST_TO_ADDR
// i = i - 1 ;
20128: LD_ADDR_VAR 0 2
20132: PUSH
20133: LD_VAR 0 2
20137: PUSH
20138: LD_INT 1
20140: MINUS
20141: ST_TO_ADDR
// end ; i = i + 1 ;
20142: LD_ADDR_VAR 0 2
20146: PUSH
20147: LD_VAR 0 2
20151: PUSH
20152: LD_INT 1
20154: PLUS
20155: ST_TO_ADDR
// end ;
20156: GO 20053
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
20158: LD_ADDR_EXP 35
20162: PUSH
20163: LD_EXP 35
20167: PPUSH
20168: LD_VAR 0 6
20172: PPUSH
20173: LD_VAR 0 4
20177: PPUSH
20178: CALL_OW 1
20182: ST_TO_ADDR
// temp_list = [ ] ;
20183: LD_ADDR_VAR 0 4
20187: PUSH
20188: EMPTY
20189: ST_TO_ADDR
// for i in ai_heal_these_humans [ base ] do
20190: LD_ADDR_VAR 0 2
20194: PUSH
20195: LD_EXP 35
20199: PUSH
20200: LD_VAR 0 6
20204: ARRAY
20205: PUSH
20206: FOR_IN
20207: IFFALSE 20257
// if GetLives ( i ) < 1000 and IsInUnit ( i ) = 0 then
20209: LD_VAR 0 2
20213: PPUSH
20214: CALL_OW 256
20218: PUSH
20219: LD_INT 1000
20221: LESS
20222: PUSH
20223: LD_VAR 0 2
20227: PPUSH
20228: CALL_OW 310
20232: PUSH
20233: LD_INT 0
20235: EQUAL
20236: AND
20237: IFFALSE 20255
// temp_list = temp_list ^ i ;
20239: LD_ADDR_VAR 0 4
20243: PUSH
20244: LD_VAR 0 4
20248: PUSH
20249: LD_VAR 0 2
20253: ADD
20254: ST_TO_ADDR
20255: GO 20206
20257: POP
20258: POP
// ai_heal_these_humans = Replace ( ai_heal_these_humans , base , temp_list ) ;
20259: LD_ADDR_EXP 35
20263: PUSH
20264: LD_EXP 35
20268: PPUSH
20269: LD_VAR 0 6
20273: PPUSH
20274: LD_VAR 0 4
20278: PPUSH
20279: CALL_OW 1
20283: ST_TO_ADDR
// under_attack = BaseUnderAttack ( side , base ) ;
20284: LD_ADDR_VAR 0 7
20288: PUSH
20289: LD_VAR 0 1
20293: PPUSH
20294: LD_VAR 0 6
20298: PPUSH
20299: CALL 13662 0 2
20303: ST_TO_ADDR
// for i in ai_heal_these_humans [ base ] do
20304: LD_ADDR_VAR 0 2
20308: PUSH
20309: LD_EXP 35
20313: PUSH
20314: LD_VAR 0 6
20318: ARRAY
20319: PUSH
20320: FOR_IN
20321: IFFALSE 20434
// if not ( under_attack and i in ai_soldiers [ base ] ) and GetDistUnitXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) > 4 then
20323: LD_VAR 0 7
20327: PUSH
20328: LD_VAR 0 2
20332: PUSH
20333: LD_EXP 22
20337: PUSH
20338: LD_VAR 0 6
20342: ARRAY
20343: IN
20344: AND
20345: NOT
20346: PUSH
20347: LD_VAR 0 2
20351: PPUSH
20352: LD_EXP 33
20356: PUSH
20357: LD_VAR 0 6
20361: ARRAY
20362: PUSH
20363: LD_INT 1
20365: ARRAY
20366: PPUSH
20367: LD_EXP 33
20371: PUSH
20372: LD_VAR 0 6
20376: ARRAY
20377: PUSH
20378: LD_INT 2
20380: ARRAY
20381: PPUSH
20382: CALL_OW 297
20386: PUSH
20387: LD_INT 4
20389: GREATER
20390: AND
20391: IFFALSE 20432
// ComMoveXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
20393: LD_VAR 0 2
20397: PPUSH
20398: LD_EXP 33
20402: PUSH
20403: LD_VAR 0 6
20407: ARRAY
20408: PUSH
20409: LD_INT 1
20411: ARRAY
20412: PPUSH
20413: LD_EXP 33
20417: PUSH
20418: LD_VAR 0 6
20422: ARRAY
20423: PUSH
20424: LD_INT 2
20426: ARRAY
20427: PPUSH
20428: CALL_OW 111
20432: GO 20320
20434: POP
20435: POP
// if scientists_list = 0 then
20436: LD_VAR 0 3
20440: PUSH
20441: LD_INT 0
20443: EQUAL
20444: IFFALSE 20448
// continue ;
20446: GO 19998
// if ai_heal_these_humans [ base ] > 0 then
20448: LD_EXP 35
20452: PUSH
20453: LD_VAR 0 6
20457: ARRAY
20458: PUSH
20459: LD_INT 0
20461: GREATER
20462: IFFALSE 20617
// begin scientists_list = GetHumansOutOfUnits ( scientists_list ) ;
20464: LD_ADDR_VAR 0 3
20468: PUSH
20469: LD_VAR 0 3
20473: PPUSH
20474: CALL 13557 0 1
20478: ST_TO_ADDR
// temp_list = ai_heal_these_humans [ base ] ;
20479: LD_ADDR_VAR 0 4
20483: PUSH
20484: LD_EXP 35
20488: PUSH
20489: LD_VAR 0 6
20493: ARRAY
20494: ST_TO_ADDR
// repeat i = 1 ;
20495: LD_ADDR_VAR 0 2
20499: PUSH
20500: LD_INT 1
20502: ST_TO_ADDR
// while i <= temp_list do
20503: LD_VAR 0 2
20507: PUSH
20508: LD_VAR 0 4
20512: LESSEQUAL
20513: IFFALSE 20605
// begin if scientists_list = 0 then
20515: LD_VAR 0 3
20519: PUSH
20520: LD_INT 0
20522: EQUAL
20523: IFFALSE 20527
// break ;
20525: GO 20605
// temp_unit = NearestUnitToUnit ( scientists_list , temp_list [ i ] ) ;
20527: LD_ADDR_VAR 0 5
20531: PUSH
20532: LD_VAR 0 3
20536: PPUSH
20537: LD_VAR 0 4
20541: PUSH
20542: LD_VAR 0 2
20546: ARRAY
20547: PPUSH
20548: CALL_OW 74
20552: ST_TO_ADDR
// ComHeal ( temp_unit , temp_list [ i ] ) ;
20553: LD_VAR 0 5
20557: PPUSH
20558: LD_VAR 0 4
20562: PUSH
20563: LD_VAR 0 2
20567: ARRAY
20568: PPUSH
20569: CALL_OW 128
// scientists_list = scientists_list diff temp_unit ;
20573: LD_ADDR_VAR 0 3
20577: PUSH
20578: LD_VAR 0 3
20582: PUSH
20583: LD_VAR 0 5
20587: DIFF
20588: ST_TO_ADDR
// i = i + 1 ;
20589: LD_ADDR_VAR 0 2
20593: PUSH
20594: LD_VAR 0 2
20598: PUSH
20599: LD_INT 1
20601: PLUS
20602: ST_TO_ADDR
// end ;
20603: GO 20503
// until scientists_list = 0 ;
20605: LD_VAR 0 3
20609: PUSH
20610: LD_INT 0
20612: EQUAL
20613: IFFALSE 20495
// end else
20615: GO 20964
// if IsOk ( ai_lab [ base ] ) and BuildingStatus ( ai_lab [ base ] ) <> bs_build then
20617: LD_EXP 28
20621: PUSH
20622: LD_VAR 0 6
20626: ARRAY
20627: PPUSH
20628: CALL_OW 302
20632: PUSH
20633: LD_EXP 28
20637: PUSH
20638: LD_VAR 0 6
20642: ARRAY
20643: PPUSH
20644: CALL_OW 461
20648: PUSH
20649: LD_INT 1
20651: NONEQUAL
20652: AND
20653: IFFALSE 20778
// begin for i in scientists_list do
20655: LD_ADDR_VAR 0 2
20659: PUSH
20660: LD_VAR 0 3
20664: PUSH
20665: FOR_IN
20666: IFFALSE 20774
// begin temp_unit = IsInUnit ( i ) ;
20668: LD_ADDR_VAR 0 5
20672: PUSH
20673: LD_VAR 0 2
20677: PPUSH
20678: CALL_OW 310
20682: ST_TO_ADDR
// if temp_unit <> ai_lab [ base ] then
20683: LD_VAR 0 5
20687: PUSH
20688: LD_EXP 28
20692: PUSH
20693: LD_VAR 0 6
20697: ARRAY
20698: NONEQUAL
20699: IFFALSE 20772
// case GetType ( temp_unit ) of unit_building :
20701: LD_VAR 0 5
20705: PPUSH
20706: CALL_OW 247
20710: PUSH
20711: LD_INT 3
20713: DOUBLE
20714: EQUAL
20715: IFTRUE 20719
20717: GO 20731
20719: POP
// ComExitBuilding ( i ) ; unit_vehicle :
20720: LD_VAR 0 2
20724: PPUSH
20725: CALL_OW 122
20729: GO 20772
20731: LD_INT 2
20733: DOUBLE
20734: EQUAL
20735: IFTRUE 20739
20737: GO 20751
20739: POP
// ComExitVehicle ( i ) ; else
20740: LD_VAR 0 2
20744: PPUSH
20745: CALL_OW 121
20749: GO 20772
20751: POP
// ComEnterUnit ( i , ai_lab [ base ] ) ; end ;
20752: LD_VAR 0 2
20756: PPUSH
20757: LD_EXP 28
20761: PUSH
20762: LD_VAR 0 6
20766: ARRAY
20767: PPUSH
20768: CALL_OW 120
// end ;
20772: GO 20665
20774: POP
20775: POP
// end else
20776: GO 20964
// if ai_building_under_construction [ base ] > 0 then
20778: LD_EXP 34
20782: PUSH
20783: LD_VAR 0 6
20787: ARRAY
20788: PUSH
20789: LD_INT 0
20791: GREATER
20792: IFFALSE 20863
// begin for i in scientists_list do
20794: LD_ADDR_VAR 0 2
20798: PUSH
20799: LD_VAR 0 3
20803: PUSH
20804: FOR_IN
20805: IFFALSE 20859
// SetTaskList ( i , [ [ h , 0 , 0 , ai_building_under_construction [ base ] , 0 , 0 , 0 ] ] ) ;
20807: LD_VAR 0 2
20811: PPUSH
20812: LD_STRING h
20814: PUSH
20815: LD_INT 0
20817: PUSH
20818: LD_INT 0
20820: PUSH
20821: LD_EXP 34
20825: PUSH
20826: LD_VAR 0 6
20830: ARRAY
20831: PUSH
20832: LD_INT 0
20834: PUSH
20835: LD_INT 0
20837: PUSH
20838: LD_INT 0
20840: PUSH
20841: EMPTY
20842: LIST
20843: LIST
20844: LIST
20845: LIST
20846: LIST
20847: LIST
20848: LIST
20849: PUSH
20850: EMPTY
20851: LIST
20852: PPUSH
20853: CALL_OW 446
20857: GO 20804
20859: POP
20860: POP
// end else
20861: GO 20964
// for i in scientists_list do
20863: LD_ADDR_VAR 0 2
20867: PUSH
20868: LD_VAR 0 3
20872: PUSH
20873: FOR_IN
20874: IFFALSE 20962
// if GetDistUnitXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) > 4 then
20876: LD_VAR 0 2
20880: PPUSH
20881: LD_EXP 33
20885: PUSH
20886: LD_VAR 0 6
20890: ARRAY
20891: PUSH
20892: LD_INT 1
20894: ARRAY
20895: PPUSH
20896: LD_EXP 33
20900: PUSH
20901: LD_VAR 0 6
20905: ARRAY
20906: PUSH
20907: LD_INT 2
20909: ARRAY
20910: PPUSH
20911: CALL_OW 297
20915: PUSH
20916: LD_INT 4
20918: GREATER
20919: IFFALSE 20960
// ComMoveXY ( i , ai_human_pullback_hex [ base ] [ 1 ] , ai_human_pullback_hex [ base ] [ 2 ] ) ;
20921: LD_VAR 0 2
20925: PPUSH
20926: LD_EXP 33
20930: PUSH
20931: LD_VAR 0 6
20935: ARRAY
20936: PUSH
20937: LD_INT 1
20939: ARRAY
20940: PPUSH
20941: LD_EXP 33
20945: PUSH
20946: LD_VAR 0 6
20950: ARRAY
20951: PUSH
20952: LD_INT 2
20954: ARRAY
20955: PPUSH
20956: CALL_OW 111
20960: GO 20873
20962: POP
20963: POP
// end ;
20964: GO 19998
20966: POP
20967: POP
// enable ;
20968: ENABLE
// end ; end_of_file
20969: PPOPN 7
20971: END
// export function GetApes ( side ) ; begin
20972: LD_INT 0
20974: PPUSH
// result = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
20975: LD_ADDR_VAR 0 2
20979: PUSH
20980: LD_INT 22
20982: PUSH
20983: LD_VAR 0 1
20987: PUSH
20988: EMPTY
20989: LIST
20990: LIST
20991: PUSH
20992: LD_INT 2
20994: PUSH
20995: LD_INT 25
20997: PUSH
20998: LD_INT 12
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: PUSH
21005: LD_INT 25
21007: PUSH
21008: LD_INT 15
21010: PUSH
21011: EMPTY
21012: LIST
21013: LIST
21014: PUSH
21015: LD_INT 25
21017: PUSH
21018: LD_INT 16
21020: PUSH
21021: EMPTY
21022: LIST
21023: LIST
21024: PUSH
21025: LD_INT 25
21027: PUSH
21028: LD_INT 17
21030: PUSH
21031: EMPTY
21032: LIST
21033: LIST
21034: PUSH
21035: EMPTY
21036: LIST
21037: LIST
21038: LIST
21039: LIST
21040: LIST
21041: PUSH
21042: EMPTY
21043: LIST
21044: LIST
21045: PPUSH
21046: CALL_OW 69
21050: ST_TO_ADDR
// end ;
21051: LD_VAR 0 2
21055: RET
// every 0 0$1 + 0 0$0.2 trigger FilterAllUnits ( [ [ f_not , [ f_inarea , int_area ] ] , [ f_side , you ] , [ f_ok ] , [ f_type , unit_human ] ] ) > 0 do
21056: LD_INT 3
21058: PUSH
21059: LD_INT 95
21061: PUSH
21062: LD_INT 5
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: PUSH
21073: LD_INT 22
21075: PUSH
21076: LD_EXP 2
21080: PUSH
21081: EMPTY
21082: LIST
21083: LIST
21084: PUSH
21085: LD_INT 50
21087: PUSH
21088: EMPTY
21089: LIST
21090: PUSH
21091: LD_INT 21
21093: PUSH
21094: LD_INT 1
21096: PUSH
21097: EMPTY
21098: LIST
21099: LIST
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: LIST
21105: LIST
21106: PPUSH
21107: CALL_OW 69
21111: PUSH
21112: LD_INT 0
21114: GREATER
21115: IFFALSE 21154
21117: GO 21119
21119: DISABLE
// begin if tick >= survivors_time then
21120: LD_OWVAR 1
21124: PUSH
21125: LD_EXP 53
21129: GREATEREQUAL
21130: IFFALSE 21144
// begin PrepareArabBase ( true ) ;
21132: LD_INT 1
21134: PPUSH
21135: CALL 2711 0 1
// enable ( 3 ) ;
21139: LD_INT 3
21141: ENABLE_MARKED
// end else
21142: GO 21154
// begin PrepareArabBase ( false ) ;
21144: LD_INT 0
21146: PPUSH
21147: CALL 2711 0 1
// enable ( 2 ) ;
21151: LD_INT 2
21153: ENABLE_MARKED
// end ; end ;
21154: END
// every 0 0$1 marked 2 do var temp_list , temp_unit , temp_list_2 , temp_list_3 , c , premature_retreat ;
21155: GO 21157
21157: DISABLE
21158: LD_INT 0
21160: PPUSH
21161: PPUSH
21162: PPUSH
21163: PPUSH
21164: PPUSH
21165: PPUSH
// begin temp_list = FilterAllUnits ( [ [ f_see , you ] , [ f_side , you_alt ] , [ f_btype , b_breastwork ] ] ) ;
21166: LD_ADDR_VAR 0 1
21170: PUSH
21171: LD_INT 101
21173: PUSH
21174: LD_EXP 2
21178: PUSH
21179: EMPTY
21180: LIST
21181: LIST
21182: PUSH
21183: LD_INT 22
21185: PUSH
21186: LD_EXP 5
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PUSH
21195: LD_INT 30
21197: PUSH
21198: LD_INT 31
21200: PUSH
21201: EMPTY
21202: LIST
21203: LIST
21204: PUSH
21205: EMPTY
21206: LIST
21207: LIST
21208: LIST
21209: PPUSH
21210: CALL_OW 69
21214: ST_TO_ADDR
// if temp_list = 0 then
21215: LD_VAR 0 1
21219: PUSH
21220: LD_INT 0
21222: EQUAL
21223: IFFALSE 21228
// begin enable ;
21225: ENABLE
// exit ;
21226: GO 23086
// end ; DialogueOn ;
21228: CALL_OW 6
// CenterOnUnits ( temp_list ) ;
21232: LD_VAR 0 1
21236: PPUSH
21237: CALL_OW 85
// Say ( MarkB , D2Ma1 ) ;
21241: LD_EXP 17
21245: PPUSH
21246: LD_STRING D2Ma1
21248: PPUSH
21249: CALL_OW 88
// Say ( Heike , D2H2 ) ;
21253: LD_EXP 7
21257: PPUSH
21258: LD_STRING D2H2
21260: PPUSH
21261: CALL_OW 88
// Say ( MarkB , D2Ma2 ) ;
21265: LD_EXP 17
21269: PPUSH
21270: LD_STRING D2Ma2
21272: PPUSH
21273: CALL_OW 88
// temp_list = [ Sonya , Oswald , Ralph , Kowalski , Willard , Evelyn , Gordon , Suze , Olaf ] diff 0 ;
21277: LD_ADDR_VAR 0 1
21281: PUSH
21282: LD_EXP 8
21286: PUSH
21287: LD_EXP 9
21291: PUSH
21292: LD_EXP 10
21296: PUSH
21297: LD_EXP 11
21301: PUSH
21302: LD_EXP 12
21306: PUSH
21307: LD_EXP 13
21311: PUSH
21312: LD_EXP 14
21316: PUSH
21317: LD_EXP 15
21321: PUSH
21322: LD_EXP 18
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: LIST
21331: LIST
21332: LIST
21333: LIST
21334: LIST
21335: LIST
21336: LIST
21337: PUSH
21338: LD_INT 0
21340: DIFF
21341: ST_TO_ADDR
// if temp_list > 0 then
21342: LD_VAR 0 1
21346: PUSH
21347: LD_INT 0
21349: GREATER
21350: IFFALSE 21609
// begin temp_unit = temp_list [ Rand ( 1 , temp_list ) ] ;
21352: LD_ADDR_VAR 0 2
21356: PUSH
21357: LD_VAR 0 1
21361: PUSH
21362: LD_INT 1
21364: PPUSH
21365: LD_VAR 0 1
21369: PPUSH
21370: CALL_OW 12
21374: ARRAY
21375: ST_TO_ADDR
// case temp_unit of Sonya :
21376: LD_VAR 0 2
21380: PUSH
21381: LD_EXP 8
21385: DOUBLE
21386: EQUAL
21387: IFTRUE 21391
21389: GO 21406
21391: POP
// Say ( temp_unit , D2So1 ) ; Oswald :
21392: LD_VAR 0 2
21396: PPUSH
21397: LD_STRING D2So1
21399: PPUSH
21400: CALL_OW 88
21404: GO 21607
21406: LD_EXP 9
21410: DOUBLE
21411: EQUAL
21412: IFTRUE 21416
21414: GO 21431
21416: POP
// Say ( temp_unit , D2Os1 ) ; Ralph :
21417: LD_VAR 0 2
21421: PPUSH
21422: LD_STRING D2Os1
21424: PPUSH
21425: CALL_OW 88
21429: GO 21607
21431: LD_EXP 10
21435: DOUBLE
21436: EQUAL
21437: IFTRUE 21441
21439: GO 21456
21441: POP
// Say ( temp_unit , D2Ra1 ) ; Kowalski :
21442: LD_VAR 0 2
21446: PPUSH
21447: LD_STRING D2Ra1
21449: PPUSH
21450: CALL_OW 88
21454: GO 21607
21456: LD_EXP 11
21460: DOUBLE
21461: EQUAL
21462: IFTRUE 21466
21464: GO 21481
21466: POP
// Say ( temp_unit , D2Ko1 ) ; Willard :
21467: LD_VAR 0 2
21471: PPUSH
21472: LD_STRING D2Ko1
21474: PPUSH
21475: CALL_OW 88
21479: GO 21607
21481: LD_EXP 12
21485: DOUBLE
21486: EQUAL
21487: IFTRUE 21491
21489: GO 21506
21491: POP
// Say ( temp_unit , D2Wi1 ) ; Evelyn :
21492: LD_VAR 0 2
21496: PPUSH
21497: LD_STRING D2Wi1
21499: PPUSH
21500: CALL_OW 88
21504: GO 21607
21506: LD_EXP 13
21510: DOUBLE
21511: EQUAL
21512: IFTRUE 21516
21514: GO 21531
21516: POP
// Say ( temp_unit , D2Ev1 ) ; Gordon :
21517: LD_VAR 0 2
21521: PPUSH
21522: LD_STRING D2Ev1
21524: PPUSH
21525: CALL_OW 88
21529: GO 21607
21531: LD_EXP 14
21535: DOUBLE
21536: EQUAL
21537: IFTRUE 21541
21539: GO 21556
21541: POP
// Say ( temp_unit , D2Go1 ) ; Suze :
21542: LD_VAR 0 2
21546: PPUSH
21547: LD_STRING D2Go1
21549: PPUSH
21550: CALL_OW 88
21554: GO 21607
21556: LD_EXP 15
21560: DOUBLE
21561: EQUAL
21562: IFTRUE 21566
21564: GO 21581
21566: POP
// Say ( temp_unit , D2Su1 ) ; Olaf :
21567: LD_VAR 0 2
21571: PPUSH
21572: LD_STRING D2Su1
21574: PPUSH
21575: CALL_OW 88
21579: GO 21607
21581: LD_EXP 18
21585: DOUBLE
21586: EQUAL
21587: IFTRUE 21591
21589: GO 21606
21591: POP
// Say ( temp_unit , D2Ol1 ) ; end ;
21592: LD_VAR 0 2
21596: PPUSH
21597: LD_STRING D2Ol1
21599: PPUSH
21600: CALL_OW 88
21604: GO 21607
21606: POP
// end else
21607: GO 21621
// Say ( Heike , D2H3 ) ;
21609: LD_EXP 7
21613: PPUSH
21614: LD_STRING D2H3
21616: PPUSH
21617: CALL_OW 88
// Say ( MarkB , D2Ma3 ) ;
21621: LD_EXP 17
21625: PPUSH
21626: LD_STRING D2Ma3
21628: PPUSH
21629: CALL_OW 88
// Say ( Heike , D2H4 ) ;
21633: LD_EXP 7
21637: PPUSH
21638: LD_STRING D2H4
21640: PPUSH
21641: CALL_OW 88
// temp_list = [ Oswald , Ralph , Kowalski , Willard , Gordon , Suze , Olaf ] diff 0 ;
21645: LD_ADDR_VAR 0 1
21649: PUSH
21650: LD_EXP 9
21654: PUSH
21655: LD_EXP 10
21659: PUSH
21660: LD_EXP 11
21664: PUSH
21665: LD_EXP 12
21669: PUSH
21670: LD_EXP 14
21674: PUSH
21675: LD_EXP 15
21679: PUSH
21680: LD_EXP 18
21684: PUSH
21685: EMPTY
21686: LIST
21687: LIST
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: LIST
21693: PUSH
21694: LD_INT 0
21696: DIFF
21697: ST_TO_ADDR
// if temp_list > 0 then
21698: LD_VAR 0 1
21702: PUSH
21703: LD_INT 0
21705: GREATER
21706: IFFALSE 21939
// begin if temp_list > 1 then
21708: LD_VAR 0 1
21712: PUSH
21713: LD_INT 1
21715: GREATER
21716: IFFALSE 21734
// temp_list = temp_list diff temp_unit ;
21718: LD_ADDR_VAR 0 1
21722: PUSH
21723: LD_VAR 0 1
21727: PUSH
21728: LD_VAR 0 2
21732: DIFF
21733: ST_TO_ADDR
// temp_unit = temp_list [ Rand ( 1 , temp_list ) ] ;
21734: LD_ADDR_VAR 0 2
21738: PUSH
21739: LD_VAR 0 1
21743: PUSH
21744: LD_INT 1
21746: PPUSH
21747: LD_VAR 0 1
21751: PPUSH
21752: CALL_OW 12
21756: ARRAY
21757: ST_TO_ADDR
// case temp_unit of Oswald :
21758: LD_VAR 0 2
21762: PUSH
21763: LD_EXP 9
21767: DOUBLE
21768: EQUAL
21769: IFTRUE 21773
21771: GO 21788
21773: POP
// Say ( temp_unit , D2Os2 ) ; Ralph :
21774: LD_VAR 0 2
21778: PPUSH
21779: LD_STRING D2Os2
21781: PPUSH
21782: CALL_OW 88
21786: GO 21939
21788: LD_EXP 10
21792: DOUBLE
21793: EQUAL
21794: IFTRUE 21798
21796: GO 21813
21798: POP
// Say ( temp_unit , D2Ra2 ) ; Kowalski :
21799: LD_VAR 0 2
21803: PPUSH
21804: LD_STRING D2Ra2
21806: PPUSH
21807: CALL_OW 88
21811: GO 21939
21813: LD_EXP 11
21817: DOUBLE
21818: EQUAL
21819: IFTRUE 21823
21821: GO 21838
21823: POP
// Say ( temp_unit , D2Ko2 ) ; Willard :
21824: LD_VAR 0 2
21828: PPUSH
21829: LD_STRING D2Ko2
21831: PPUSH
21832: CALL_OW 88
21836: GO 21939
21838: LD_EXP 12
21842: DOUBLE
21843: EQUAL
21844: IFTRUE 21848
21846: GO 21863
21848: POP
// Say ( temp_unit , D2Wi2 ) ; Gordon :
21849: LD_VAR 0 2
21853: PPUSH
21854: LD_STRING D2Wi2
21856: PPUSH
21857: CALL_OW 88
21861: GO 21939
21863: LD_EXP 14
21867: DOUBLE
21868: EQUAL
21869: IFTRUE 21873
21871: GO 21888
21873: POP
// Say ( temp_unit , D2Go2 ) ; Suze :
21874: LD_VAR 0 2
21878: PPUSH
21879: LD_STRING D2Go2
21881: PPUSH
21882: CALL_OW 88
21886: GO 21939
21888: LD_EXP 15
21892: DOUBLE
21893: EQUAL
21894: IFTRUE 21898
21896: GO 21913
21898: POP
// Say ( temp_unit , D2Su2 ) ; Olaf :
21899: LD_VAR 0 2
21903: PPUSH
21904: LD_STRING D2Su2
21906: PPUSH
21907: CALL_OW 88
21911: GO 21939
21913: LD_EXP 18
21917: DOUBLE
21918: EQUAL
21919: IFTRUE 21923
21921: GO 21938
21923: POP
// Say ( temp_unit , D2Ol2 ) ; end ;
21924: LD_VAR 0 2
21928: PPUSH
21929: LD_STRING D2Ol2
21931: PPUSH
21932: CALL_OW 88
21936: GO 21939
21938: POP
// end ; DialogueOff ;
21939: CALL_OW 7
// survivors_found = 1 ;
21943: LD_ADDR_EXP 52
21947: PUSH
21948: LD_INT 1
21950: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
21951: LD_INT 7
21953: PPUSH
21954: CALL_OW 67
// ChangeSideFog ( you_alt , you ) ;
21958: LD_EXP 5
21962: PPUSH
21963: LD_EXP 2
21967: PPUSH
21968: CALL_OW 343
// SetAreaMapShow ( arbase , 1 ) ;
21972: LD_INT 6
21974: PPUSH
21975: LD_INT 1
21977: PPUSH
21978: CALL_OW 424
// repeat wait ( 0 0$1 ) ;
21982: LD_INT 35
21984: PPUSH
21985: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] , [ f_exceptarea , arbase ] ] ) = 0 and FilterAllUnits ( [ [ f_or , [ f_side , russians ] , [ f_side , russians_alt ] ] , [ f_see , you ] , [ f_ok ] ] ) = 0 ;
21989: LD_INT 22
21991: PUSH
21992: LD_EXP 2
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 21
22003: PUSH
22004: LD_INT 1
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: PUSH
22011: LD_INT 50
22013: PUSH
22014: EMPTY
22015: LIST
22016: PUSH
22017: LD_INT 96
22019: PUSH
22020: LD_INT 6
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: PUSH
22027: EMPTY
22028: LIST
22029: LIST
22030: LIST
22031: LIST
22032: PPUSH
22033: CALL_OW 69
22037: PUSH
22038: LD_INT 0
22040: EQUAL
22041: PUSH
22042: LD_INT 2
22044: PUSH
22045: LD_INT 22
22047: PUSH
22048: LD_EXP 3
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PUSH
22057: LD_INT 22
22059: PUSH
22060: LD_EXP 6
22064: PUSH
22065: EMPTY
22066: LIST
22067: LIST
22068: PUSH
22069: EMPTY
22070: LIST
22071: LIST
22072: LIST
22073: PUSH
22074: LD_INT 101
22076: PUSH
22077: LD_EXP 2
22081: PUSH
22082: EMPTY
22083: LIST
22084: LIST
22085: PUSH
22086: LD_INT 50
22088: PUSH
22089: EMPTY
22090: LIST
22091: PUSH
22092: EMPTY
22093: LIST
22094: LIST
22095: LIST
22096: PPUSH
22097: CALL_OW 69
22101: PUSH
22102: LD_INT 0
22104: EQUAL
22105: AND
22106: IFFALSE 21982
// SetAreaMapShow ( arbase , 0 ) ;
22108: LD_INT 6
22110: PPUSH
22111: LD_INT 0
22113: PPUSH
22114: CALL_OW 424
// for c in all_units do
22118: LD_ADDR_VAR 0 5
22122: PUSH
22123: LD_OWVAR 3
22127: PUSH
22128: FOR_IN
22129: IFFALSE 22142
// ComStop ( c ) ;
22131: LD_VAR 0 5
22135: PPUSH
22136: CALL_OW 141
22140: GO 22128
22142: POP
22143: POP
// DeselectUnits ( FilterAllUnits ( [ f_side , you ] ) ) ;
22144: LD_INT 22
22146: PUSH
22147: LD_EXP 2
22151: PUSH
22152: EMPTY
22153: LIST
22154: LIST
22155: PPUSH
22156: CALL_OW 69
22160: PPUSH
22161: CALL_OW 491
// CenterOnXY ( 67 , 66 ) ;
22165: LD_INT 67
22167: PPUSH
22168: LD_INT 66
22170: PPUSH
22171: CALL_OW 84
// InGameOn ;
22175: CALL_OW 8
// wait ( 0 0$0.5 ) ;
22179: LD_INT 18
22181: PPUSH
22182: CALL_OW 67
// temp_list = FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
22186: LD_ADDR_VAR 0 1
22190: PUSH
22191: LD_INT 22
22193: PUSH
22194: LD_EXP 2
22198: PUSH
22199: EMPTY
22200: LIST
22201: LIST
22202: PUSH
22203: LD_INT 21
22205: PUSH
22206: LD_INT 1
22208: PUSH
22209: EMPTY
22210: LIST
22211: LIST
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PPUSH
22217: CALL_OW 69
22221: ST_TO_ADDR
// temp_list_2 = FilterAllUnits ( [ [ f_side , you_alt ] , [ f_type , unit_human ] ] ) ;
22222: LD_ADDR_VAR 0 3
22226: PUSH
22227: LD_INT 22
22229: PUSH
22230: LD_EXP 5
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PUSH
22239: LD_INT 21
22241: PUSH
22242: LD_INT 1
22244: PUSH
22245: EMPTY
22246: LIST
22247: LIST
22248: PUSH
22249: EMPTY
22250: LIST
22251: LIST
22252: PPUSH
22253: CALL_OW 69
22257: ST_TO_ADDR
// ComExitVehicle ( temp_list ) ;
22258: LD_VAR 0 1
22262: PPUSH
22263: CALL_OW 121
// ComExitBuilding ( temp_list_2 ) ;
22267: LD_VAR 0 3
22271: PPUSH
22272: CALL_OW 122
// wait ( 0 0$0.2 ) ;
22276: LD_INT 7
22278: PPUSH
22279: CALL_OW 67
// ComHold ( temp_list ) ;
22283: LD_VAR 0 1
22287: PPUSH
22288: CALL_OW 140
// ComMoveToArea ( temp_list_2 , arbase ) ;
22292: LD_VAR 0 3
22296: PPUSH
22297: LD_INT 6
22299: PPUSH
22300: CALL_OW 113
// AddComStand ( temp_list_2 ) ;
22304: LD_VAR 0 3
22308: PPUSH
22309: CALL_OW 225
// wait ( 0 0$0.4 ) ;
22313: LD_INT 14
22315: PPUSH
22316: CALL_OW 67
// Say ( Heike , D3H1 ) ;
22320: LD_EXP 7
22324: PPUSH
22325: LD_STRING D3H1
22327: PPUSH
22328: CALL_OW 88
// SayRadio ( Abdul , D3Ab1 ) ;
22332: LD_EXP 16
22336: PPUSH
22337: LD_STRING D3Ab1
22339: PPUSH
22340: CALL_OW 94
// SayRadio ( Abdul , D3Ab2 ) ;
22344: LD_EXP 16
22348: PPUSH
22349: LD_STRING D3Ab2
22351: PPUSH
22352: CALL_OW 94
// wait ( 0 0$0.2 ) ;
22356: LD_INT 7
22358: PPUSH
22359: CALL_OW 67
// premature_retreat = false ;
22363: LD_ADDR_VAR 0 6
22367: PUSH
22368: LD_INT 0
22370: ST_TO_ADDR
// case Query ( Q1 ) of 1 :
22371: LD_STRING Q1
22373: PPUSH
22374: CALL_OW 97
22378: PUSH
22379: LD_INT 1
22381: DOUBLE
22382: EQUAL
22383: IFTRUE 22387
22385: GO 22402
22387: POP
// begin Say ( Heike , D3xH3 ) ;
22388: LD_EXP 7
22392: PPUSH
22393: LD_STRING D3xH3
22395: PPUSH
22396: CALL_OW 88
// end ; 2 :
22400: GO 22527
22402: LD_INT 2
22404: DOUBLE
22405: EQUAL
22406: IFTRUE 22410
22408: GO 22526
22410: POP
// begin Say ( Heike , D3xH1 ) ;
22411: LD_EXP 7
22415: PPUSH
22416: LD_STRING D3xH1
22418: PPUSH
22419: CALL_OW 88
// SayRadio ( Abdul , D3xAb1 ) ;
22423: LD_EXP 16
22427: PPUSH
22428: LD_STRING D3xAb1
22430: PPUSH
22431: CALL_OW 94
// wait ( 0 0$0.2 ) ;
22435: LD_INT 7
22437: PPUSH
22438: CALL_OW 67
// case Query ( Q2 ) of 1 :
22442: LD_STRING Q2
22444: PPUSH
22445: CALL_OW 97
22449: PUSH
22450: LD_INT 1
22452: DOUBLE
22453: EQUAL
22454: IFTRUE 22458
22456: GO 22492
22458: POP
// begin Say ( Heike , D3xH3 ) ;
22459: LD_EXP 7
22463: PPUSH
22464: LD_STRING D3xH3
22466: PPUSH
22467: CALL_OW 88
// wait ( 0 0$0.5 ) ;
22471: LD_INT 18
22473: PPUSH
22474: CALL_OW 67
// Say ( Heike , D3xH4 ) ;
22478: LD_EXP 7
22482: PPUSH
22483: LD_STRING D3xH4
22485: PPUSH
22486: CALL_OW 88
// end ; 2 :
22490: GO 22524
22492: LD_INT 2
22494: DOUBLE
22495: EQUAL
22496: IFTRUE 22500
22498: GO 22523
22500: POP
// begin Say ( Heike , D3xH2 ) ;
22501: LD_EXP 7
22505: PPUSH
22506: LD_STRING D3xH2
22508: PPUSH
22509: CALL_OW 88
// premature_retreat = true ;
22513: LD_ADDR_VAR 0 6
22517: PUSH
22518: LD_INT 1
22520: ST_TO_ADDR
// end ; end ;
22521: GO 22524
22523: POP
// end ; end ;
22524: GO 22527
22526: POP
// if premature_retreat then
22527: LD_VAR 0 6
22531: IFFALSE 22642
// begin wait ( 0 0$0.2 ) ;
22533: LD_INT 7
22535: PPUSH
22536: CALL_OW 67
// InGameOff ;
22540: CALL_OW 9
// wait ( 0 0$0.2 ) ;
22544: LD_INT 7
22546: PPUSH
22547: CALL_OW 67
// ChangeMissionObjectives ( M2b ) ;
22551: LD_STRING M2b
22553: PPUSH
22554: CALL_OW 337
// SetSide ( FilterAllUnits ( [ f_side , you_alt ] ) , you ) ;
22558: LD_INT 22
22560: PUSH
22561: LD_EXP 5
22565: PUSH
22566: EMPTY
22567: LIST
22568: LIST
22569: PPUSH
22570: CALL_OW 69
22574: PPUSH
22575: LD_EXP 2
22579: PPUSH
22580: CALL_OW 235
// MakeReadyForMissionEnd ;
22584: CALL 23846 0 0
// for c in FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) do
22588: LD_ADDR_VAR 0 5
22592: PUSH
22593: LD_INT 22
22595: PUSH
22596: LD_EXP 2
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: PUSH
22605: LD_INT 21
22607: PUSH
22608: LD_INT 1
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: PPUSH
22619: CALL_OW 69
22623: PUSH
22624: FOR_IN
22625: IFFALSE 22638
// ComFree ( c ) ;
22627: LD_VAR 0 5
22631: PPUSH
22632: CALL_OW 139
22636: GO 22624
22638: POP
22639: POP
// exit ;
22640: GO 23086
// end ; wait ( 0 0$0.7 ) ;
22642: LD_INT 24
22644: PPUSH
22645: CALL_OW 67
// Say ( Heike , D3H2 ) ;
22649: LD_EXP 7
22653: PPUSH
22654: LD_STRING D3H2
22656: PPUSH
22657: CALL_OW 88
// Say ( MarkB , D3Ma1 ) ;
22661: LD_EXP 17
22665: PPUSH
22666: LD_STRING D3Ma1
22668: PPUSH
22669: CALL_OW 88
// if IsOk ( Swansson ) then
22673: LD_EXP 21
22677: PPUSH
22678: CALL_OW 302
22682: IFFALSE 22710
// begin Say ( Swansson , D3Sw1 ) ;
22684: LD_EXP 21
22688: PPUSH
22689: LD_STRING D3Sw1
22691: PPUSH
22692: CALL_OW 88
// Say ( Swansson , D3Sw2 ) ;
22696: LD_EXP 21
22700: PPUSH
22701: LD_STRING D3Sw2
22703: PPUSH
22704: CALL_OW 88
// end else
22708: GO 22734
// begin Say ( Heike , D3H3b ) ;
22710: LD_EXP 7
22714: PPUSH
22715: LD_STRING D3H3b
22717: PPUSH
22718: CALL_OW 88
// Say ( MarkB , D3Ma2b ) ;
22722: LD_EXP 17
22726: PPUSH
22727: LD_STRING D3Ma2b
22729: PPUSH
22730: CALL_OW 88
// end ; Say ( MarkB , D3Ma2 ) ;
22734: LD_EXP 17
22738: PPUSH
22739: LD_STRING D3Ma2
22741: PPUSH
22742: CALL_OW 88
// if IsOk ( Swansson ) then
22746: LD_EXP 21
22750: PPUSH
22751: CALL_OW 302
22755: IFFALSE 22769
// Say ( Swansson , D3Sw3 ) ;
22757: LD_EXP 21
22761: PPUSH
22762: LD_STRING D3Sw3
22764: PPUSH
22765: CALL_OW 88
// Say ( Heike , D3H3 ) ;
22769: LD_EXP 7
22773: PPUSH
22774: LD_STRING D3H3
22776: PPUSH
22777: CALL_OW 88
// Say ( MarkB , D3Ma3 ) ;
22781: LD_EXP 17
22785: PPUSH
22786: LD_STRING D3Ma3
22788: PPUSH
22789: CALL_OW 88
// Say ( Heike , D3H4 ) ;
22793: LD_EXP 7
22797: PPUSH
22798: LD_STRING D3H4
22800: PPUSH
22801: CALL_OW 88
// Say ( Heike , D3H5 ) ;
22805: LD_EXP 7
22809: PPUSH
22810: LD_STRING D3H5
22812: PPUSH
22813: CALL_OW 88
// Say ( MarkB , D3Ma4 ) ;
22817: LD_EXP 17
22821: PPUSH
22822: LD_STRING D3Ma4
22824: PPUSH
22825: CALL_OW 88
// Say ( Heike , D3H6 ) ;
22829: LD_EXP 7
22833: PPUSH
22834: LD_STRING D3H6
22836: PPUSH
22837: CALL_OW 88
// Say ( MarkB , D3Ma5 ) ;
22841: LD_EXP 17
22845: PPUSH
22846: LD_STRING D3Ma5
22848: PPUSH
22849: CALL_OW 88
// Say ( Heike , D3H7 ) ;
22853: LD_EXP 7
22857: PPUSH
22858: LD_STRING D3H7
22860: PPUSH
22861: CALL_OW 88
// if IsOk ( Swansson ) then
22865: LD_EXP 21
22869: PPUSH
22870: CALL_OW 302
22874: IFFALSE 22902
// begin Say ( Swansson , D3Sw4 ) ;
22876: LD_EXP 21
22880: PPUSH
22881: LD_STRING D3Sw4
22883: PPUSH
22884: CALL_OW 88
// Say ( MarkB , D3Ma6 ) ;
22888: LD_EXP 17
22892: PPUSH
22893: LD_STRING D3Ma6
22895: PPUSH
22896: CALL_OW 88
// end else
22900: GO 22926
// begin Say ( MarkB , D3Ma6b ) ;
22902: LD_EXP 17
22906: PPUSH
22907: LD_STRING D3Ma6b
22909: PPUSH
22910: CALL_OW 88
// Say ( MarkB , D3Ma7b ) ;
22914: LD_EXP 17
22918: PPUSH
22919: LD_STRING D3Ma7b
22921: PPUSH
22922: CALL_OW 88
// end ; Say ( Heike , D3H8 ) ;
22926: LD_EXP 7
22930: PPUSH
22931: LD_STRING D3H8
22933: PPUSH
22934: CALL_OW 88
// wait ( 0 0$0.2 ) ;
22938: LD_INT 7
22940: PPUSH
22941: CALL_OW 67
// InGameOff ;
22945: CALL_OW 9
// wait ( 0 0$0.2 ) ;
22949: LD_INT 7
22951: PPUSH
22952: CALL_OW 67
// ChangeMissionObjectives ( M2 ) ;
22956: LD_STRING M2
22958: PPUSH
22959: CALL_OW 337
// SetSide ( FilterAllUnits ( [ f_side , you_alt ] ) , you ) ;
22963: LD_INT 22
22965: PUSH
22966: LD_EXP 5
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: PPUSH
22975: CALL_OW 69
22979: PPUSH
22980: LD_EXP 2
22984: PPUSH
22985: CALL_OW 235
// for c in FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) do
22989: LD_ADDR_VAR 0 5
22993: PUSH
22994: LD_INT 22
22996: PUSH
22997: LD_EXP 2
23001: PUSH
23002: EMPTY
23003: LIST
23004: LIST
23005: PUSH
23006: LD_INT 21
23008: PUSH
23009: LD_INT 1
23011: PUSH
23012: EMPTY
23013: LIST
23014: LIST
23015: PUSH
23016: EMPTY
23017: LIST
23018: LIST
23019: PPUSH
23020: CALL_OW 69
23024: PUSH
23025: FOR_IN
23026: IFFALSE 23039
// ComFree ( c ) ;
23028: LD_VAR 0 5
23032: PPUSH
23033: CALL_OW 139
23037: GO 23025
23039: POP
23040: POP
// if wave_num > 0 then
23041: LD_EXP 55
23045: PUSH
23046: LD_INT 0
23048: GREATER
23049: IFFALSE 23078
// begin wait ( 0 0$10 ) ;
23051: LD_INT 350
23053: PPUSH
23054: CALL_OW 67
// DialogueOn ;
23058: CALL_OW 6
// SayRadio ( Omar , D5Om1b ) ;
23062: LD_EXP 20
23066: PPUSH
23067: LD_STRING D5Om1b
23069: PPUSH
23070: CALL_OW 94
// DialogueOff ;
23074: CALL_OW 7
// end ; survivors_found = 2 ;
23078: LD_ADDR_EXP 52
23082: PUSH
23083: LD_INT 2
23085: ST_TO_ADDR
// end ;
23086: PPOPN 6
23088: END
// every 0 0$1 marked 3 do var b_list , b ;
23089: GO 23091
23091: DISABLE
23092: LD_INT 0
23094: PPUSH
23095: PPUSH
// begin b_list = [ [ 65 , 55 ] , [ 54 , 62 ] , [ 74 , 77 ] , [ 82 , 77 ] ] ;
23096: LD_ADDR_VAR 0 1
23100: PUSH
23101: LD_INT 65
23103: PUSH
23104: LD_INT 55
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: PUSH
23111: LD_INT 54
23113: PUSH
23114: LD_INT 62
23116: PUSH
23117: EMPTY
23118: LIST
23119: LIST
23120: PUSH
23121: LD_INT 74
23123: PUSH
23124: LD_INT 77
23126: PUSH
23127: EMPTY
23128: LIST
23129: LIST
23130: PUSH
23131: LD_INT 82
23133: PUSH
23134: LD_INT 77
23136: PUSH
23137: EMPTY
23138: LIST
23139: LIST
23140: PUSH
23141: EMPTY
23142: LIST
23143: LIST
23144: LIST
23145: LIST
23146: ST_TO_ADDR
// while b_list > 0 do
23147: LD_VAR 0 1
23151: PUSH
23152: LD_INT 0
23154: GREATER
23155: IFFALSE 23231
// begin wait ( 0 0$1 ) ;
23157: LD_INT 35
23159: PPUSH
23160: CALL_OW 67
// for b in b_list do
23164: LD_ADDR_VAR 0 2
23168: PUSH
23169: LD_VAR 0 1
23173: PUSH
23174: FOR_IN
23175: IFFALSE 23227
// if SeeXY ( you , b [ 1 ] , b [ 2 ] ) then
23177: LD_EXP 2
23181: PPUSH
23182: LD_VAR 0 2
23186: PUSH
23187: LD_INT 1
23189: ARRAY
23190: PPUSH
23191: LD_VAR 0 2
23195: PUSH
23196: LD_INT 2
23198: ARRAY
23199: PPUSH
23200: CALL_OW 293
23204: IFFALSE 23225
// b_list = b_list diff [ b ] ;
23206: LD_ADDR_VAR 0 1
23210: PUSH
23211: LD_VAR 0 1
23215: PUSH
23216: LD_VAR 0 2
23220: PUSH
23221: EMPTY
23222: LIST
23223: DIFF
23224: ST_TO_ADDR
23225: GO 23174
23227: POP
23228: POP
// end ;
23229: GO 23147
// DialogueOn ;
23231: CALL_OW 6
// Say ( Heike , D2H1 ) ;
23235: LD_EXP 7
23239: PPUSH
23240: LD_STRING D2H1
23242: PPUSH
23243: CALL_OW 88
// DialogueOff ;
23247: CALL_OW 7
// Wait ( 0 0$0.2 ) ;
23251: LD_INT 7
23253: PPUSH
23254: CALL_OW 67
// YouLost ( SurvivorsDead ) ;
23258: LD_STRING SurvivorsDead
23260: PPUSH
23261: CALL_OW 104
// end ;
23265: PPOPN 2
23267: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_remcont then
23268: LD_VAR 0 1
23272: PUSH
23273: LD_INT 15
23275: EQUAL
23276: IFFALSE 23356
// if IsLive ( Heike ) and IsLive ( MarkB ) then
23278: LD_EXP 7
23282: PPUSH
23283: CALL_OW 300
23287: PUSH
23288: LD_EXP 17
23292: PPUSH
23293: CALL_OW 300
23297: AND
23298: IFFALSE 23356
// begin DialogueOn ;
23300: CALL_OW 6
// ForceSay ( MarkB , D4Ma1 ) ;
23304: LD_EXP 17
23308: PPUSH
23309: LD_STRING D4Ma1
23311: PPUSH
23312: CALL_OW 91
// ForceSay ( Heike , D4H1 ) ;
23316: LD_EXP 7
23320: PPUSH
23321: LD_STRING D4H1
23323: PPUSH
23324: CALL_OW 91
// ForceSay ( MarkB , D4Ma2 ) ;
23328: LD_EXP 17
23332: PPUSH
23333: LD_STRING D4Ma2
23335: PPUSH
23336: CALL_OW 91
// ForceSay ( Heike , D4H2 ) ;
23340: LD_EXP 7
23344: PPUSH
23345: LD_STRING D4H2
23347: PPUSH
23348: CALL_OW 91
// DialogueOff ;
23352: CALL_OW 7
// end ; end ;
23356: PPOPN 2
23358: END
// every 0 0$1 + 0 0$0.3 do var b ;
23359: GO 23361
23361: DISABLE
23362: LD_INT 0
23364: PPUSH
// begin for b in FilterAllUnits ( [ [ f_side , you ] , [ f_control , control_remote ] ] ) do
23365: LD_ADDR_VAR 0 1
23369: PUSH
23370: LD_INT 22
23372: PUSH
23373: LD_EXP 2
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: PUSH
23382: LD_INT 33
23384: PUSH
23385: LD_INT 2
23387: PUSH
23388: EMPTY
23389: LIST
23390: LIST
23391: PUSH
23392: EMPTY
23393: LIST
23394: LIST
23395: PPUSH
23396: CALL_OW 69
23400: PUSH
23401: FOR_IN
23402: IFFALSE 23448
// begin remote_built_and_tested = 1 ;
23404: LD_ADDR_EXP 56
23408: PUSH
23409: LD_INT 1
23411: ST_TO_ADDR
// if IsControledBy ( b ) > 0 then
23412: LD_VAR 0 1
23416: PPUSH
23417: CALL_OW 312
23421: PUSH
23422: LD_INT 0
23424: GREATER
23425: IFFALSE 23446
// begin ChangeMissionObjectives ( Moutremote ) ;
23427: LD_STRING Moutremote
23429: PPUSH
23430: CALL_OW 337
// remote_built_and_tested = 2 ;
23434: LD_ADDR_EXP 56
23438: PUSH
23439: LD_INT 2
23441: ST_TO_ADDR
// exit ;
23442: POP
23443: POP
23444: GO 23451
// end ; end ;
23446: GO 23401
23448: POP
23449: POP
// enable ;
23450: ENABLE
// end ;
23451: PPOPN 1
23453: END
// every 0 0$1 + 0 0$0.6 trigger survivors_found > 0 do
23454: LD_EXP 52
23458: PUSH
23459: LD_INT 0
23461: GREATER
23462: IFFALSE 23845
23464: GO 23466
23466: DISABLE
// begin repeat case wave_num of 0 :
23467: LD_EXP 55
23471: PUSH
23472: LD_INT 0
23474: DOUBLE
23475: EQUAL
23476: IFTRUE 23480
23478: GO 23599
23480: POP
// begin Wait ( [ 22 22$0 , 17 17$0 , 12 12$0 ] [ difficulty ] - survivors_time / 2 - wave_warning_times [ 1 ] + 7 7$0 ) ;
23481: LD_INT 46200
23483: PUSH
23484: LD_INT 35700
23486: PUSH
23487: LD_INT 25200
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: LIST
23494: PUSH
23495: LD_OWVAR 67
23499: ARRAY
23500: PUSH
23501: LD_EXP 53
23505: PUSH
23506: LD_INT 2
23508: DIVREAL
23509: MINUS
23510: PUSH
23511: LD_EXP 54
23515: PUSH
23516: LD_INT 1
23518: ARRAY
23519: MINUS
23520: PUSH
23521: LD_INT 14700
23523: PLUS
23524: PPUSH
23525: CALL_OW 67
// if survivors_found = 2 then
23529: LD_EXP 52
23533: PUSH
23534: LD_INT 2
23536: EQUAL
23537: IFFALSE 23597
// begin DialogueOn ;
23539: CALL_OW 6
// SayRadio ( Omar , D5Om1a ) ;
23543: LD_EXP 20
23547: PPUSH
23548: LD_STRING D5Om1a
23550: PPUSH
23551: CALL_OW 94
// DialogueOff ;
23555: CALL_OW 7
// enable ( 1 ) ;
23559: LD_INT 1
23561: ENABLE_MARKED
// wait ( Rand ( wave_warning_times [ 1 ] - 0 0$30 , wave_warning_times [ 1 ] + 0 0$30 ) ) ;
23562: LD_EXP 54
23566: PUSH
23567: LD_INT 1
23569: ARRAY
23570: PUSH
23571: LD_INT 1050
23573: MINUS
23574: PPUSH
23575: LD_EXP 54
23579: PUSH
23580: LD_INT 1
23582: ARRAY
23583: PUSH
23584: LD_INT 1050
23586: PLUS
23587: PPUSH
23588: CALL_OW 12
23592: PPUSH
23593: CALL_OW 67
// end ; end ; 1 , 2 , 3 :
23597: GO 23652
23599: LD_INT 1
23601: DOUBLE
23602: EQUAL
23603: IFTRUE 23619
23605: LD_INT 2
23607: DOUBLE
23608: EQUAL
23609: IFTRUE 23619
23611: LD_INT 3
23613: DOUBLE
23614: EQUAL
23615: IFTRUE 23619
23617: GO 23651
23619: POP
// wait ( 6 6$0 + Rand ( 0 0$0 , 2 2$0 - 0 0$30 * difficulty ) ) ; end ;
23620: LD_INT 12600
23622: PUSH
23623: LD_INT 0
23625: PPUSH
23626: LD_INT 4200
23628: PUSH
23629: LD_INT 1050
23631: PUSH
23632: LD_OWVAR 67
23636: MUL
23637: MINUS
23638: PPUSH
23639: CALL_OW 12
23643: PLUS
23644: PPUSH
23645: CALL_OW 67
23649: GO 23652
23651: POP
// if wave_num >= 1 and survivors_found = 2 then
23652: LD_EXP 55
23656: PUSH
23657: LD_INT 1
23659: GREATEREQUAL
23660: PUSH
23661: LD_EXP 52
23665: PUSH
23666: LD_INT 2
23668: EQUAL
23669: AND
23670: IFFALSE 23752
// begin DialogueOn ;
23672: CALL_OW 6
// SayRadio ( Omar , D5Om & ( wave_num + 1 ) ) ;
23676: LD_EXP 20
23680: PPUSH
23681: LD_STRING D5Om
23683: PUSH
23684: LD_EXP 55
23688: PUSH
23689: LD_INT 1
23691: PLUS
23692: STR
23693: PPUSH
23694: CALL_OW 94
// DialogueOff ;
23698: CALL_OW 7
// enable ( 1 ) ;
23702: LD_INT 1
23704: ENABLE_MARKED
// wait ( Rand ( wave_warning_times [ wave_num + 1 ] - 0 0$30 , wave_warning_times [ wave_num + 1 ] + 0 0$30 ) ) ;
23705: LD_EXP 54
23709: PUSH
23710: LD_EXP 55
23714: PUSH
23715: LD_INT 1
23717: PLUS
23718: ARRAY
23719: PUSH
23720: LD_INT 1050
23722: MINUS
23723: PPUSH
23724: LD_EXP 54
23728: PUSH
23729: LD_EXP 55
23733: PUSH
23734: LD_INT 1
23736: PLUS
23737: ARRAY
23738: PUSH
23739: LD_INT 1050
23741: PLUS
23742: PPUSH
23743: CALL_OW 12
23747: PPUSH
23748: CALL_OW 67
// end ; wave_num = wave_num + 1 ;
23752: LD_ADDR_EXP 55
23756: PUSH
23757: LD_EXP 55
23761: PUSH
23762: LD_INT 1
23764: PLUS
23765: ST_TO_ADDR
// RussianWave ;
23766: CALL 24047 0 0
// until wave_num = 4 ;
23770: LD_EXP 55
23774: PUSH
23775: LD_INT 4
23777: EQUAL
23778: IFFALSE 23467
// wait ( Rand ( 1 1$0 , 2 2$0 ) ) ;
23780: LD_INT 2100
23782: PPUSH
23783: LD_INT 4200
23785: PPUSH
23786: CALL_OW 12
23790: PPUSH
23791: CALL_OW 67
// DialogueOn ;
23795: CALL_OW 6
// SayRadio ( Abdul , D8Ab1 ) ;
23799: LD_EXP 16
23803: PPUSH
23804: LD_STRING D8Ab1
23806: PPUSH
23807: CALL_OW 94
// SayRadio ( Abdul , D8Ab2 ) ;
23811: LD_EXP 16
23815: PPUSH
23816: LD_STRING D8Ab2
23818: PPUSH
23819: CALL_OW 94
// DialogueOff ;
23823: CALL_OW 7
// wait ( 0 0$0.2 ) ;
23827: LD_INT 7
23829: PPUSH
23830: CALL_OW 67
// ChangeMissionObjectives ( M3 ) ;
23834: LD_STRING M3
23836: PPUSH
23837: CALL_OW 337
// MakeReadyForMissionEnd ;
23841: CALL 23846 0 0
// end ;
23845: END
// function MakeReadyForMissionEnd ; begin
23846: LD_INT 0
23848: PPUSH
// SetAreaMapShow ( start_leave_area , 1 ) ;
23849: LD_INT 4
23851: PPUSH
23852: LD_INT 1
23854: PPUSH
23855: CALL_OW 424
// repeat wait ( 0 0$1 ) ;
23859: LD_INT 35
23861: PPUSH
23862: CALL_OW 67
// until ( FilterAllUnits ( [ [ f_side , you ] , [ f_exceptarea , start_leave_area ] , [ f_type , unit_human ] ] ) diff GetApes ( you ) ) = 0 and UnitFilter ( [ Heike , MarkB ] , [ f_ok ] ) = 2 ;
23866: LD_INT 22
23868: PUSH
23869: LD_EXP 2
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: PUSH
23878: LD_INT 96
23880: PUSH
23881: LD_INT 4
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: PUSH
23888: LD_INT 21
23890: PUSH
23891: LD_INT 1
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: LIST
23902: PPUSH
23903: CALL_OW 69
23907: PUSH
23908: LD_EXP 2
23912: PPUSH
23913: CALL 20972 0 1
23917: DIFF
23918: PUSH
23919: LD_INT 0
23921: EQUAL
23922: PUSH
23923: LD_EXP 7
23927: PUSH
23928: LD_EXP 17
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: PPUSH
23937: LD_INT 50
23939: PUSH
23940: EMPTY
23941: LIST
23942: PPUSH
23943: CALL_OW 72
23947: PUSH
23948: LD_INT 2
23950: EQUAL
23951: AND
23952: IFFALSE 23859
// EndMission ;
23954: CALL 30118 0 0
// end ;
23958: LD_VAR 0 1
23962: RET
// every 0 0$1 marked 1 do var time ;
23963: GO 23965
23965: DISABLE
23966: LD_INT 0
23968: PPUSH
// begin time = wave_warning_times [ wave_num + 1 ] ;
23969: LD_ADDR_VAR 0 1
23973: PUSH
23974: LD_EXP 54
23978: PUSH
23979: LD_EXP 55
23983: PUSH
23984: LD_INT 1
23986: PLUS
23987: ARRAY
23988: ST_TO_ADDR
// repeat display_strings = [ #Ar06-RussiansETA , time ] ;
23989: LD_ADDR_OWVAR 47
23993: PUSH
23994: LD_STRING #Ar06-RussiansETA
23996: PUSH
23997: LD_VAR 0 1
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: ST_TO_ADDR
// wait ( 0 0$30 ) ;
24006: LD_INT 1050
24008: PPUSH
24009: CALL_OW 67
// time = time - 0 0$30 ;
24013: LD_ADDR_VAR 0 1
24017: PUSH
24018: LD_VAR 0 1
24022: PUSH
24023: LD_INT 1050
24025: MINUS
24026: ST_TO_ADDR
// until time < 0 0$0 ;
24027: LD_VAR 0 1
24031: PUSH
24032: LD_INT 0
24034: LESS
24035: IFFALSE 23989
// display_strings = [ ] ;
24037: LD_ADDR_OWVAR 47
24041: PUSH
24042: EMPTY
24043: ST_TO_ADDR
// end ;
24044: PPOPN 1
24046: END
// function RussianWave ; var human_list_north , human_list_south , vehicle_list_north , vehicle_list_south , temp_list , b , c , d , num , temp_list_2 , temp_list_3 ; var north_waypoints , south_waypoints , human_list , waypoints , vehicle_list , attackers , stay_together_dist , stop ; var excluded_units , vehicles_trying_to_occupy ; begin
24047: LD_INT 0
24049: PPUSH
24050: PPUSH
24051: PPUSH
24052: PPUSH
24053: PPUSH
24054: PPUSH
24055: PPUSH
24056: PPUSH
24057: PPUSH
24058: PPUSH
24059: PPUSH
24060: PPUSH
24061: PPUSH
24062: PPUSH
24063: PPUSH
24064: PPUSH
24065: PPUSH
24066: PPUSH
24067: PPUSH
24068: PPUSH
24069: PPUSH
24070: PPUSH
// case wave_num of 1 :
24071: LD_EXP 55
24075: PUSH
24076: LD_INT 1
24078: DOUBLE
24079: EQUAL
24080: IFTRUE 24084
24082: GO 24167
24084: POP
// begin temp_list = PrepareRetreatingRussians ( difficulty , difficulty + 1 , 0 , 0 ) ;
24085: LD_ADDR_VAR 0 6
24089: PUSH
24090: LD_OWVAR 67
24094: PPUSH
24095: LD_OWVAR 67
24099: PUSH
24100: LD_INT 1
24102: PLUS
24103: PPUSH
24104: LD_INT 0
24106: PPUSH
24107: LD_INT 0
24109: PPUSH
24110: CALL 26590 0 4
24114: ST_TO_ADDR
// human_list_north = temp_list [ 1 ] ;
24115: LD_ADDR_VAR 0 2
24119: PUSH
24120: LD_VAR 0 6
24124: PUSH
24125: LD_INT 1
24127: ARRAY
24128: ST_TO_ADDR
// vehicle_list_north = temp_list [ 2 ] ;
24129: LD_ADDR_VAR 0 4
24133: PUSH
24134: LD_VAR 0 6
24138: PUSH
24139: LD_INT 2
24141: ARRAY
24142: ST_TO_ADDR
// human_list_south = [ ] ;
24143: LD_ADDR_VAR 0 3
24147: PUSH
24148: EMPTY
24149: ST_TO_ADDR
// vehicle_list_south = [ ] ;
24150: LD_ADDR_VAR 0 5
24154: PUSH
24155: EMPTY
24156: ST_TO_ADDR
// stay_together_dist = 5 ;
24157: LD_ADDR_VAR 0 19
24161: PUSH
24162: LD_INT 5
24164: ST_TO_ADDR
// end ; 2 :
24165: GO 24489
24167: LD_INT 2
24169: DOUBLE
24170: EQUAL
24171: IFTRUE 24175
24173: GO 24258
24175: POP
// begin temp_list = PrepareRetreatingRussians ( difficulty , difficulty + 1 , 1 , 1 ) ;
24176: LD_ADDR_VAR 0 6
24180: PUSH
24181: LD_OWVAR 67
24185: PPUSH
24186: LD_OWVAR 67
24190: PUSH
24191: LD_INT 1
24193: PLUS
24194: PPUSH
24195: LD_INT 1
24197: PPUSH
24198: LD_INT 1
24200: PPUSH
24201: CALL 26590 0 4
24205: ST_TO_ADDR
// human_list_north = [ ] ;
24206: LD_ADDR_VAR 0 2
24210: PUSH
24211: EMPTY
24212: ST_TO_ADDR
// vehicle_list_north = [ ] ;
24213: LD_ADDR_VAR 0 4
24217: PUSH
24218: EMPTY
24219: ST_TO_ADDR
// human_list_south = temp_list [ 1 ] ;
24220: LD_ADDR_VAR 0 3
24224: PUSH
24225: LD_VAR 0 6
24229: PUSH
24230: LD_INT 1
24232: ARRAY
24233: ST_TO_ADDR
// vehicle_list_south = temp_list [ 2 ] ;
24234: LD_ADDR_VAR 0 5
24238: PUSH
24239: LD_VAR 0 6
24243: PUSH
24244: LD_INT 2
24246: ARRAY
24247: ST_TO_ADDR
// stay_together_dist = 7 ;
24248: LD_ADDR_VAR 0 19
24252: PUSH
24253: LD_INT 7
24255: ST_TO_ADDR
// end ; 3 :
24256: GO 24489
24258: LD_INT 3
24260: DOUBLE
24261: EQUAL
24262: IFTRUE 24266
24264: GO 24353
24266: POP
// begin temp_list = PrepareRetreatingRussians ( difficulty + 1 , difficulty + 2 , 2 , 1 ) ;
24267: LD_ADDR_VAR 0 6
24271: PUSH
24272: LD_OWVAR 67
24276: PUSH
24277: LD_INT 1
24279: PLUS
24280: PPUSH
24281: LD_OWVAR 67
24285: PUSH
24286: LD_INT 2
24288: PLUS
24289: PPUSH
24290: LD_INT 2
24292: PPUSH
24293: LD_INT 1
24295: PPUSH
24296: CALL 26590 0 4
24300: ST_TO_ADDR
// human_list_north = temp_list [ 1 ] ;
24301: LD_ADDR_VAR 0 2
24305: PUSH
24306: LD_VAR 0 6
24310: PUSH
24311: LD_INT 1
24313: ARRAY
24314: ST_TO_ADDR
// vehicle_list_north = temp_list [ 2 ] ;
24315: LD_ADDR_VAR 0 4
24319: PUSH
24320: LD_VAR 0 6
24324: PUSH
24325: LD_INT 2
24327: ARRAY
24328: ST_TO_ADDR
// human_list_south = [ ] ;
24329: LD_ADDR_VAR 0 3
24333: PUSH
24334: EMPTY
24335: ST_TO_ADDR
// vehicle_list_south = [ ] ;
24336: LD_ADDR_VAR 0 5
24340: PUSH
24341: EMPTY
24342: ST_TO_ADDR
// stay_together_dist = 8 ;
24343: LD_ADDR_VAR 0 19
24347: PUSH
24348: LD_INT 8
24350: ST_TO_ADDR
// end ; 4 :
24351: GO 24489
24353: LD_INT 4
24355: DOUBLE
24356: EQUAL
24357: IFTRUE 24361
24359: GO 24488
24361: POP
// begin temp_list = PrepareRetreatingRussians ( difficulty + 1 , difficulty , 2 , 1 ) ;
24362: LD_ADDR_VAR 0 6
24366: PUSH
24367: LD_OWVAR 67
24371: PUSH
24372: LD_INT 1
24374: PLUS
24375: PPUSH
24376: LD_OWVAR 67
24380: PPUSH
24381: LD_INT 2
24383: PPUSH
24384: LD_INT 1
24386: PPUSH
24387: CALL 26590 0 4
24391: ST_TO_ADDR
// human_list_north = temp_list [ 1 ] ;
24392: LD_ADDR_VAR 0 2
24396: PUSH
24397: LD_VAR 0 6
24401: PUSH
24402: LD_INT 1
24404: ARRAY
24405: ST_TO_ADDR
// vehicle_list_north = temp_list [ 2 ] ;
24406: LD_ADDR_VAR 0 4
24410: PUSH
24411: LD_VAR 0 6
24415: PUSH
24416: LD_INT 2
24418: ARRAY
24419: ST_TO_ADDR
// temp_list = PrepareRetreatingRussians ( difficulty , difficulty + 2 , 1 , 1 ) ;
24420: LD_ADDR_VAR 0 6
24424: PUSH
24425: LD_OWVAR 67
24429: PPUSH
24430: LD_OWVAR 67
24434: PUSH
24435: LD_INT 2
24437: PLUS
24438: PPUSH
24439: LD_INT 1
24441: PPUSH
24442: LD_INT 1
24444: PPUSH
24445: CALL 26590 0 4
24449: ST_TO_ADDR
// human_list_south = temp_list [ 1 ] ;
24450: LD_ADDR_VAR 0 3
24454: PUSH
24455: LD_VAR 0 6
24459: PUSH
24460: LD_INT 1
24462: ARRAY
24463: ST_TO_ADDR
// vehicle_list_south = temp_list [ 2 ] ;
24464: LD_ADDR_VAR 0 5
24468: PUSH
24469: LD_VAR 0 6
24473: PUSH
24474: LD_INT 2
24476: ARRAY
24477: ST_TO_ADDR
// stay_together_dist = 8 ;
24478: LD_ADDR_VAR 0 19
24482: PUSH
24483: LD_INT 8
24485: ST_TO_ADDR
// end ; end ;
24486: GO 24489
24488: POP
// for b in vehicle_list_north ^ human_list_north do
24489: LD_ADDR_VAR 0 7
24493: PUSH
24494: LD_VAR 0 4
24498: PUSH
24499: LD_VAR 0 2
24503: ADD
24504: PUSH
24505: FOR_IN
24506: IFFALSE 24525
// PlaceUnitArea ( b , start_leave_area , false ) ;
24508: LD_VAR 0 7
24512: PPUSH
24513: LD_INT 4
24515: PPUSH
24516: LD_INT 0
24518: PPUSH
24519: CALL_OW 49
24523: GO 24505
24525: POP
24526: POP
// for b in vehicle_list_south ^ human_list_south do
24527: LD_ADDR_VAR 0 7
24531: PUSH
24532: LD_VAR 0 5
24536: PUSH
24537: LD_VAR 0 3
24541: ADD
24542: PUSH
24543: FOR_IN
24544: IFFALSE 24563
// PlaceUnitArea ( b , south_incoming , false ) ;
24546: LD_VAR 0 7
24550: PPUSH
24551: LD_INT 13
24553: PPUSH
24554: LD_INT 0
24556: PPUSH
24557: CALL_OW 49
24561: GO 24543
24563: POP
24564: POP
// north_waypoints = [ [ 101 , 15 ] , [ 95 , 22 ] , [ 91 , 34 ] , [ 94 , 46 ] , [ 101 , 60 ] , [ 110 , 76 ] , [ 115 , 88 ] , [ 115 , 100 ] , [ 109 , 101 ] , [ 102 , 99 ] , [ 87 , 101 ] , [ 69 , 96 ] , [ 54 , 94 ] ] ;
24565: LD_ADDR_VAR 0 13
24569: PUSH
24570: LD_INT 101
24572: PUSH
24573: LD_INT 15
24575: PUSH
24576: EMPTY
24577: LIST
24578: LIST
24579: PUSH
24580: LD_INT 95
24582: PUSH
24583: LD_INT 22
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PUSH
24590: LD_INT 91
24592: PUSH
24593: LD_INT 34
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 94
24602: PUSH
24603: LD_INT 46
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 101
24612: PUSH
24613: LD_INT 60
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 110
24622: PUSH
24623: LD_INT 76
24625: PUSH
24626: EMPTY
24627: LIST
24628: LIST
24629: PUSH
24630: LD_INT 115
24632: PUSH
24633: LD_INT 88
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PUSH
24640: LD_INT 115
24642: PUSH
24643: LD_INT 100
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PUSH
24650: LD_INT 109
24652: PUSH
24653: LD_INT 101
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: PUSH
24660: LD_INT 102
24662: PUSH
24663: LD_INT 99
24665: PUSH
24666: EMPTY
24667: LIST
24668: LIST
24669: PUSH
24670: LD_INT 87
24672: PUSH
24673: LD_INT 101
24675: PUSH
24676: EMPTY
24677: LIST
24678: LIST
24679: PUSH
24680: LD_INT 69
24682: PUSH
24683: LD_INT 96
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: PUSH
24690: LD_INT 54
24692: PUSH
24693: LD_INT 94
24695: PUSH
24696: EMPTY
24697: LIST
24698: LIST
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: LIST
24704: LIST
24705: LIST
24706: LIST
24707: LIST
24708: LIST
24709: LIST
24710: LIST
24711: LIST
24712: LIST
24713: LIST
24714: ST_TO_ADDR
// south_waypoints = [ [ 150 , 110 ] , [ 141 , 104 ] , [ 127 , 96 ] , [ 115 , 97 ] , [ 102 , 99 ] , [ 87 , 101 ] , [ 69 , 96 ] , [ 54 , 94 ] ] ;
24715: LD_ADDR_VAR 0 14
24719: PUSH
24720: LD_INT 150
24722: PUSH
24723: LD_INT 110
24725: PUSH
24726: EMPTY
24727: LIST
24728: LIST
24729: PUSH
24730: LD_INT 141
24732: PUSH
24733: LD_INT 104
24735: PUSH
24736: EMPTY
24737: LIST
24738: LIST
24739: PUSH
24740: LD_INT 127
24742: PUSH
24743: LD_INT 96
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: PUSH
24750: LD_INT 115
24752: PUSH
24753: LD_INT 97
24755: PUSH
24756: EMPTY
24757: LIST
24758: LIST
24759: PUSH
24760: LD_INT 102
24762: PUSH
24763: LD_INT 99
24765: PUSH
24766: EMPTY
24767: LIST
24768: LIST
24769: PUSH
24770: LD_INT 87
24772: PUSH
24773: LD_INT 101
24775: PUSH
24776: EMPTY
24777: LIST
24778: LIST
24779: PUSH
24780: LD_INT 69
24782: PUSH
24783: LD_INT 96
24785: PUSH
24786: EMPTY
24787: LIST
24788: LIST
24789: PUSH
24790: LD_INT 54
24792: PUSH
24793: LD_INT 94
24795: PUSH
24796: EMPTY
24797: LIST
24798: LIST
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: LIST
24804: LIST
24805: LIST
24806: LIST
24807: LIST
24808: LIST
24809: ST_TO_ADDR
// vehicles_trying_to_occupy = [ ] ;
24810: LD_ADDR_VAR 0 22
24814: PUSH
24815: EMPTY
24816: ST_TO_ADDR
// repeat for num = 1 to 2 do
24817: LD_ADDR_VAR 0 10
24821: PUSH
24822: DOUBLE
24823: LD_INT 1
24825: DEC
24826: ST_TO_ADDR
24827: LD_INT 2
24829: PUSH
24830: FOR_TO
24831: IFFALSE 26369
// begin case num of 1 :
24833: LD_VAR 0 10
24837: PUSH
24838: LD_INT 1
24840: DOUBLE
24841: EQUAL
24842: IFTRUE 24846
24844: GO 24993
24846: POP
// begin human_list = UnitFilter ( human_list_north , [ [ f_not , [ f_driving ] ] , [ f_ok ] ] ) ;
24847: LD_ADDR_VAR 0 15
24851: PUSH
24852: LD_VAR 0 2
24856: PPUSH
24857: LD_INT 3
24859: PUSH
24860: LD_INT 55
24862: PUSH
24863: EMPTY
24864: LIST
24865: PUSH
24866: EMPTY
24867: LIST
24868: LIST
24869: PUSH
24870: LD_INT 50
24872: PUSH
24873: EMPTY
24874: LIST
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 72
24884: ST_TO_ADDR
// waypoints = north_waypoints ;
24885: LD_ADDR_VAR 0 16
24889: PUSH
24890: LD_VAR 0 13
24894: ST_TO_ADDR
// vehicle_list = UnitFilter ( vehicle_list_north , [ f_ok ] ) ;
24895: LD_ADDR_VAR 0 17
24899: PUSH
24900: LD_VAR 0 4
24904: PPUSH
24905: LD_INT 50
24907: PUSH
24908: EMPTY
24909: LIST
24910: PPUSH
24911: CALL_OW 72
24915: ST_TO_ADDR
// for b in UnitFilter ( human_list_north , [ f_driving ] ) do
24916: LD_ADDR_VAR 0 7
24920: PUSH
24921: LD_VAR 0 2
24925: PPUSH
24926: LD_INT 55
24928: PUSH
24929: EMPTY
24930: LIST
24931: PPUSH
24932: CALL_OW 72
24936: PUSH
24937: FOR_IN
24938: IFFALSE 24989
// begin c = IsInUnit ( b ) ;
24940: LD_ADDR_VAR 0 8
24944: PUSH
24945: LD_VAR 0 7
24949: PPUSH
24950: CALL_OW 310
24954: ST_TO_ADDR
// vehicle_list = vehicle_list union c ;
24955: LD_ADDR_VAR 0 17
24959: PUSH
24960: LD_VAR 0 17
24964: PUSH
24965: LD_VAR 0 8
24969: UNION
24970: ST_TO_ADDR
// vehicles_trying_to_occupy = vehicles_trying_to_occupy diff c ;
24971: LD_ADDR_VAR 0 22
24975: PUSH
24976: LD_VAR 0 22
24980: PUSH
24981: LD_VAR 0 8
24985: DIFF
24986: ST_TO_ADDR
// end ;
24987: GO 24937
24989: POP
24990: POP
// end ; 2 :
24991: GO 25149
24993: LD_INT 2
24995: DOUBLE
24996: EQUAL
24997: IFTRUE 25001
24999: GO 25148
25001: POP
// begin human_list = UnitFilter ( human_list_south , [ [ f_not , [ f_driving ] ] , [ f_ok ] ] ) ;
25002: LD_ADDR_VAR 0 15
25006: PUSH
25007: LD_VAR 0 3
25011: PPUSH
25012: LD_INT 3
25014: PUSH
25015: LD_INT 55
25017: PUSH
25018: EMPTY
25019: LIST
25020: PUSH
25021: EMPTY
25022: LIST
25023: LIST
25024: PUSH
25025: LD_INT 50
25027: PUSH
25028: EMPTY
25029: LIST
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PPUSH
25035: CALL_OW 72
25039: ST_TO_ADDR
// waypoints = south_waypoints ;
25040: LD_ADDR_VAR 0 16
25044: PUSH
25045: LD_VAR 0 14
25049: ST_TO_ADDR
// vehicle_list = UnitFilter ( vehicle_list_south , [ f_ok ] ) ;
25050: LD_ADDR_VAR 0 17
25054: PUSH
25055: LD_VAR 0 5
25059: PPUSH
25060: LD_INT 50
25062: PUSH
25063: EMPTY
25064: LIST
25065: PPUSH
25066: CALL_OW 72
25070: ST_TO_ADDR
// for b in UnitFilter ( human_list_south , [ f_driving ] ) do
25071: LD_ADDR_VAR 0 7
25075: PUSH
25076: LD_VAR 0 3
25080: PPUSH
25081: LD_INT 55
25083: PUSH
25084: EMPTY
25085: LIST
25086: PPUSH
25087: CALL_OW 72
25091: PUSH
25092: FOR_IN
25093: IFFALSE 25144
// begin c = IsInUnit ( b ) ;
25095: LD_ADDR_VAR 0 8
25099: PUSH
25100: LD_VAR 0 7
25104: PPUSH
25105: CALL_OW 310
25109: ST_TO_ADDR
// vehicle_list = vehicle_list union c ;
25110: LD_ADDR_VAR 0 17
25114: PUSH
25115: LD_VAR 0 17
25119: PUSH
25120: LD_VAR 0 8
25124: UNION
25125: ST_TO_ADDR
// vehicles_trying_to_occupy = vehicles_trying_to_occupy diff c ;
25126: LD_ADDR_VAR 0 22
25130: PUSH
25131: LD_VAR 0 22
25135: PUSH
25136: LD_VAR 0 8
25140: DIFF
25141: ST_TO_ADDR
// end ;
25142: GO 25092
25144: POP
25145: POP
// end ; end ;
25146: GO 25149
25148: POP
// if human_list ^ vehicle_list = 0 then
25149: LD_VAR 0 15
25153: PUSH
25154: LD_VAR 0 17
25158: ADD
25159: PUSH
25160: LD_INT 0
25162: EQUAL
25163: IFFALSE 25167
// continue ;
25165: GO 24830
// excluded_units = [ ] ;
25167: LD_ADDR_VAR 0 21
25171: PUSH
25172: EMPTY
25173: ST_TO_ADDR
// temp_list = FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) ;
25174: LD_ADDR_VAR 0 6
25178: PUSH
25179: LD_INT 21
25181: PUSH
25182: LD_INT 2
25184: PUSH
25185: EMPTY
25186: LIST
25187: LIST
25188: PUSH
25189: LD_INT 33
25191: PUSH
25192: LD_INT 1
25194: PUSH
25195: EMPTY
25196: LIST
25197: LIST
25198: PUSH
25199: LD_INT 58
25201: PUSH
25202: EMPTY
25203: LIST
25204: PUSH
25205: EMPTY
25206: LIST
25207: LIST
25208: LIST
25209: PPUSH
25210: CALL_OW 69
25214: ST_TO_ADDR
// if temp_list > 0 then
25215: LD_VAR 0 6
25219: PUSH
25220: LD_INT 0
25222: GREATER
25223: IFFALSE 25387
// for b in human_list do
25225: LD_ADDR_VAR 0 7
25229: PUSH
25230: LD_VAR 0 15
25234: PUSH
25235: FOR_IN
25236: IFFALSE 25385
// begin temp_list_2 = UnitFilter ( temp_list , [ f_dist , b , 8 ] ) ;
25238: LD_ADDR_VAR 0 11
25242: PUSH
25243: LD_VAR 0 6
25247: PPUSH
25248: LD_INT 91
25250: PUSH
25251: LD_VAR 0 7
25255: PUSH
25256: LD_INT 8
25258: PUSH
25259: EMPTY
25260: LIST
25261: LIST
25262: LIST
25263: PPUSH
25264: CALL_OW 72
25268: ST_TO_ADDR
// if temp_list_2 > 0 then
25269: LD_VAR 0 11
25273: PUSH
25274: LD_INT 0
25276: GREATER
25277: IFFALSE 25371
// begin c = AllNearestUnitToUnit ( temp_list_2 , b ) ;
25279: LD_ADDR_VAR 0 8
25283: PUSH
25284: LD_VAR 0 11
25288: PPUSH
25289: LD_VAR 0 7
25293: PPUSH
25294: CALL_OW 75
25298: ST_TO_ADDR
// if c > 0 then
25299: LD_VAR 0 8
25303: PUSH
25304: LD_INT 0
25306: GREATER
25307: IFFALSE 25371
// begin ComEnterUnit ( b , c ) ;
25309: LD_VAR 0 7
25313: PPUSH
25314: LD_VAR 0 8
25318: PPUSH
25319: CALL_OW 120
// excluded_units = excluded_units ^ b ;
25323: LD_ADDR_VAR 0 21
25327: PUSH
25328: LD_VAR 0 21
25332: PUSH
25333: LD_VAR 0 7
25337: ADD
25338: ST_TO_ADDR
// temp_list = temp_list diff c ;
25339: LD_ADDR_VAR 0 6
25343: PUSH
25344: LD_VAR 0 6
25348: PUSH
25349: LD_VAR 0 8
25353: DIFF
25354: ST_TO_ADDR
// vehicles_trying_to_occupy = vehicles_trying_to_occupy union c ;
25355: LD_ADDR_VAR 0 22
25359: PUSH
25360: LD_VAR 0 22
25364: PUSH
25365: LD_VAR 0 8
25369: UNION
25370: ST_TO_ADDR
// end end ; if temp_list = 0 then
25371: LD_VAR 0 6
25375: PUSH
25376: LD_INT 0
25378: EQUAL
25379: IFFALSE 25383
// break ;
25381: GO 25385
// end ;
25383: GO 25235
25385: POP
25386: POP
// c = false ;
25387: LD_ADDR_VAR 0 8
25391: PUSH
25392: LD_INT 0
25394: ST_TO_ADDR
// for d in FilterAllUnits ( [ f_side , you ] ) do
25395: LD_ADDR_VAR 0 9
25399: PUSH
25400: LD_INT 22
25402: PUSH
25403: LD_EXP 2
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PPUSH
25412: CALL_OW 69
25416: PUSH
25417: FOR_IN
25418: IFFALSE 25455
// if Attacks ( d ) in human_list ^ vehicle_list then
25420: LD_VAR 0 9
25424: PPUSH
25425: CALL_OW 320
25429: PUSH
25430: LD_VAR 0 15
25434: PUSH
25435: LD_VAR 0 17
25439: ADD
25440: IN
25441: IFFALSE 25453
// begin c = true ;
25443: LD_ADDR_VAR 0 8
25447: PUSH
25448: LD_INT 1
25450: ST_TO_ADDR
// break ;
25451: GO 25455
// end ;
25453: GO 25417
25455: POP
25456: POP
// if not c then
25457: LD_VAR 0 8
25461: NOT
25462: IFFALSE 25737
// begin for b in ( human_list ^ DangerousUnits ( vehicle_list ) ) diff excluded_units do
25464: LD_ADDR_VAR 0 7
25468: PUSH
25469: LD_VAR 0 15
25473: PUSH
25474: LD_VAR 0 17
25478: PPUSH
25479: CALL 18398 0 1
25483: ADD
25484: PUSH
25485: LD_VAR 0 21
25489: DIFF
25490: PUSH
25491: FOR_IN
25492: IFFALSE 25735
// begin temp_list_2 = FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_dist , b , 12 ] , [ f_inarea , choke_area ] ] ) ;
25494: LD_ADDR_VAR 0 11
25498: PUSH
25499: LD_INT 21
25501: PUSH
25502: LD_INT 2
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PUSH
25509: LD_INT 91
25511: PUSH
25512: LD_VAR 0 7
25516: PUSH
25517: LD_INT 12
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: PUSH
25525: LD_INT 95
25527: PUSH
25528: LD_INT 14
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: LIST
25539: PPUSH
25540: CALL_OW 69
25544: ST_TO_ADDR
// temp_list_2 = temp_list_2 diff vehicles_trying_to_occupy ;
25545: LD_ADDR_VAR 0 11
25549: PUSH
25550: LD_VAR 0 11
25554: PUSH
25555: LD_VAR 0 22
25559: DIFF
25560: ST_TO_ADDR
// temp_list_3 = [ ] ;
25561: LD_ADDR_VAR 0 12
25565: PUSH
25566: EMPTY
25567: ST_TO_ADDR
// for c in temp_list_2 do
25568: LD_ADDR_VAR 0 8
25572: PUSH
25573: LD_VAR 0 11
25577: PUSH
25578: FOR_IN
25579: IFFALSE 25659
// if ( GetControl ( c ) = control_manual and IsDrivenBy ( c ) = 0 ) or ( GetControl ( c ) = control_remote and IsControledBy ( c ) = 0 ) then
25581: LD_VAR 0 8
25585: PPUSH
25586: CALL_OW 263
25590: PUSH
25591: LD_INT 1
25593: EQUAL
25594: PUSH
25595: LD_VAR 0 8
25599: PPUSH
25600: CALL_OW 311
25604: PUSH
25605: LD_INT 0
25607: EQUAL
25608: AND
25609: PUSH
25610: LD_VAR 0 8
25614: PPUSH
25615: CALL_OW 263
25619: PUSH
25620: LD_INT 2
25622: EQUAL
25623: PUSH
25624: LD_VAR 0 8
25628: PPUSH
25629: CALL_OW 312
25633: PUSH
25634: LD_INT 0
25636: EQUAL
25637: AND
25638: OR
25639: IFFALSE 25657
// temp_list_3 = temp_list_3 ^ c ;
25641: LD_ADDR_VAR 0 12
25645: PUSH
25646: LD_VAR 0 12
25650: PUSH
25651: LD_VAR 0 8
25655: ADD
25656: ST_TO_ADDR
25657: GO 25578
25659: POP
25660: POP
// if temp_list_3 > 0 then
25661: LD_VAR 0 12
25665: PUSH
25666: LD_INT 0
25668: GREATER
25669: IFFALSE 25733
// begin c = AllNearestUnitToUnit ( temp_list_3 , b ) ;
25671: LD_ADDR_VAR 0 8
25675: PUSH
25676: LD_VAR 0 12
25680: PPUSH
25681: LD_VAR 0 7
25685: PPUSH
25686: CALL_OW 75
25690: ST_TO_ADDR
// if c > 0 then
25691: LD_VAR 0 8
25695: PUSH
25696: LD_INT 0
25698: GREATER
25699: IFFALSE 25733
// begin ComAttackUnit ( b , c ) ;
25701: LD_VAR 0 7
25705: PPUSH
25706: LD_VAR 0 8
25710: PPUSH
25711: CALL_OW 115
// excluded_units = excluded_units ^ b ;
25715: LD_ADDR_VAR 0 21
25719: PUSH
25720: LD_VAR 0 21
25724: PUSH
25725: LD_VAR 0 7
25729: ADD
25730: ST_TO_ADDR
// continue ;
25731: GO 25491
// end ; end ; end ;
25733: GO 25491
25735: POP
25736: POP
// end ; attackers = [ ] ;
25737: LD_ADDR_VAR 0 18
25741: PUSH
25742: EMPTY
25743: ST_TO_ADDR
// for b in human_list ^ vehicle_list do
25744: LD_ADDR_VAR 0 7
25748: PUSH
25749: LD_VAR 0 15
25753: PUSH
25754: LD_VAR 0 17
25758: ADD
25759: PUSH
25760: FOR_IN
25761: IFFALSE 25820
// begin c = Attacks ( b ) ;
25763: LD_ADDR_VAR 0 8
25767: PUSH
25768: LD_VAR 0 7
25772: PPUSH
25773: CALL_OW 320
25777: ST_TO_ADDR
// if c > 0 then
25778: LD_VAR 0 8
25782: PUSH
25783: LD_INT 0
25785: GREATER
25786: IFFALSE 25818
// begin attackers = attackers ^ b ;
25788: LD_ADDR_VAR 0 18
25792: PUSH
25793: LD_VAR 0 18
25797: PUSH
25798: LD_VAR 0 7
25802: ADD
25803: ST_TO_ADDR
// SetTag ( b , c ) ;
25804: LD_VAR 0 7
25808: PPUSH
25809: LD_VAR 0 8
25813: PPUSH
25814: CALL_OW 109
// end ; end ;
25818: GO 25760
25820: POP
25821: POP
// if attackers > 0 then
25822: LD_VAR 0 18
25826: PUSH
25827: LD_INT 0
25829: GREATER
25830: IFFALSE 25977
// begin temp_list = DangerousUnits ( vehicle_list ) ;
25832: LD_ADDR_VAR 0 6
25836: PUSH
25837: LD_VAR 0 17
25841: PPUSH
25842: CALL 18398 0 1
25846: ST_TO_ADDR
// for b in vehicle_list diff temp_list do
25847: LD_ADDR_VAR 0 7
25851: PUSH
25852: LD_VAR 0 17
25856: PUSH
25857: LD_VAR 0 6
25861: DIFF
25862: PUSH
25863: FOR_IN
25864: IFFALSE 25877
// ComStop ( b ) ;
25866: LD_VAR 0 7
25870: PPUSH
25871: CALL_OW 141
25875: GO 25863
25877: POP
25878: POP
// for b in ( human_list ^ temp_list ) diff excluded_units do
25879: LD_ADDR_VAR 0 7
25883: PUSH
25884: LD_VAR 0 15
25888: PUSH
25889: LD_VAR 0 6
25893: ADD
25894: PUSH
25895: LD_VAR 0 21
25899: DIFF
25900: PUSH
25901: FOR_IN
25902: IFFALSE 25973
// if not b in attackers then
25904: LD_VAR 0 7
25908: PUSH
25909: LD_VAR 0 18
25913: IN
25914: NOT
25915: IFFALSE 25971
// begin c = GetTag ( NearestUnitToUnit ( attackers , b ) ) ;
25917: LD_ADDR_VAR 0 8
25921: PUSH
25922: LD_VAR 0 18
25926: PPUSH
25927: LD_VAR 0 7
25931: PPUSH
25932: CALL_OW 74
25936: PPUSH
25937: CALL_OW 110
25941: ST_TO_ADDR
// ComAgressiveMove ( b , GetX ( c ) , GetY ( c ) ) ;
25942: LD_VAR 0 7
25946: PPUSH
25947: LD_VAR 0 8
25951: PPUSH
25952: CALL_OW 250
25956: PPUSH
25957: LD_VAR 0 8
25961: PPUSH
25962: CALL_OW 251
25966: PPUSH
25967: CALL_OW 114
// end ;
25971: GO 25901
25973: POP
25974: POP
// end else
25975: GO 26367
// begin temp_list = human_list ^ vehicle_list ;
25977: LD_ADDR_VAR 0 6
25981: PUSH
25982: LD_VAR 0 15
25986: PUSH
25987: LD_VAR 0 17
25991: ADD
25992: ST_TO_ADDR
// for b in temp_list diff excluded_units do
25993: LD_ADDR_VAR 0 7
25997: PUSH
25998: LD_VAR 0 6
26002: PUSH
26003: LD_VAR 0 21
26007: DIFF
26008: PUSH
26009: FOR_IN
26010: IFFALSE 26042
// SetTag ( b , FindClosestHexIndex ( b , waypoints ) + 1 ) ;
26012: LD_VAR 0 7
26016: PPUSH
26017: LD_VAR 0 7
26021: PPUSH
26022: LD_VAR 0 16
26026: PPUSH
26027: CALL 27293 0 2
26031: PUSH
26032: LD_INT 1
26034: PLUS
26035: PPUSH
26036: CALL_OW 109
26040: GO 26009
26042: POP
26043: POP
// for b in temp_list diff excluded_units do
26044: LD_ADDR_VAR 0 7
26048: PUSH
26049: LD_VAR 0 6
26053: PUSH
26054: LD_VAR 0 21
26058: DIFF
26059: PUSH
26060: FOR_IN
26061: IFFALSE 26365
// begin stop = false ;
26063: LD_ADDR_VAR 0 20
26067: PUSH
26068: LD_INT 0
26070: ST_TO_ADDR
// for c in temp_list do
26071: LD_ADDR_VAR 0 8
26075: PUSH
26076: LD_VAR 0 6
26080: PUSH
26081: FOR_IN
26082: IFFALSE 26264
// begin if c = b then
26084: LD_VAR 0 8
26088: PUSH
26089: LD_VAR 0 7
26093: EQUAL
26094: IFFALSE 26098
// continue ;
26096: GO 26081
// if GetTag ( b ) > GetTag ( c ) then
26098: LD_VAR 0 7
26102: PPUSH
26103: CALL_OW 110
26107: PUSH
26108: LD_VAR 0 8
26112: PPUSH
26113: CALL_OW 110
26117: GREATER
26118: IFFALSE 26137
// d = GetTag ( b ) else
26120: LD_ADDR_VAR 0 9
26124: PUSH
26125: LD_VAR 0 7
26129: PPUSH
26130: CALL_OW 110
26134: ST_TO_ADDR
26135: GO 26152
// d = GetTag ( c ) ;
26137: LD_ADDR_VAR 0 9
26141: PUSH
26142: LD_VAR 0 8
26146: PPUSH
26147: CALL_OW 110
26151: ST_TO_ADDR
// if d <= waypoints then
26152: LD_VAR 0 9
26156: PUSH
26157: LD_VAR 0 16
26161: LESSEQUAL
26162: IFFALSE 26262
// if GetDistUnitXY ( c , waypoints [ d ] [ 1 ] , waypoints [ d ] [ 2 ] ) - GetDistUnitXY ( b , waypoints [ d ] [ 1 ] , waypoints [ d ] [ 2 ] ) > stay_together_dist then
26164: LD_VAR 0 8
26168: PPUSH
26169: LD_VAR 0 16
26173: PUSH
26174: LD_VAR 0 9
26178: ARRAY
26179: PUSH
26180: LD_INT 1
26182: ARRAY
26183: PPUSH
26184: LD_VAR 0 16
26188: PUSH
26189: LD_VAR 0 9
26193: ARRAY
26194: PUSH
26195: LD_INT 2
26197: ARRAY
26198: PPUSH
26199: CALL_OW 297
26203: PUSH
26204: LD_VAR 0 7
26208: PPUSH
26209: LD_VAR 0 16
26213: PUSH
26214: LD_VAR 0 9
26218: ARRAY
26219: PUSH
26220: LD_INT 1
26222: ARRAY
26223: PPUSH
26224: LD_VAR 0 16
26228: PUSH
26229: LD_VAR 0 9
26233: ARRAY
26234: PUSH
26235: LD_INT 2
26237: ARRAY
26238: PPUSH
26239: CALL_OW 297
26243: MINUS
26244: PUSH
26245: LD_VAR 0 19
26249: GREATER
26250: IFFALSE 26262
// begin stop = true ;
26252: LD_ADDR_VAR 0 20
26256: PUSH
26257: LD_INT 1
26259: ST_TO_ADDR
// break ;
26260: GO 26264
// end ; end ;
26262: GO 26081
26264: POP
26265: POP
// if stop then
26266: LD_VAR 0 20
26270: IFFALSE 26283
// ComStop ( b ) else
26272: LD_VAR 0 7
26276: PPUSH
26277: CALL_OW 141
26281: GO 26363
// begin d = GetTag ( b ) ;
26283: LD_ADDR_VAR 0 9
26287: PUSH
26288: LD_VAR 0 7
26292: PPUSH
26293: CALL_OW 110
26297: ST_TO_ADDR
// if d <= waypoints then
26298: LD_VAR 0 9
26302: PUSH
26303: LD_VAR 0 16
26307: LESSEQUAL
26308: IFFALSE 26351
// ComAgressiveMove ( b , waypoints [ d ] [ 1 ] , waypoints [ d ] [ 2 ] ) else
26310: LD_VAR 0 7
26314: PPUSH
26315: LD_VAR 0 16
26319: PUSH
26320: LD_VAR 0 9
26324: ARRAY
26325: PUSH
26326: LD_INT 1
26328: ARRAY
26329: PPUSH
26330: LD_VAR 0 16
26334: PUSH
26335: LD_VAR 0 9
26339: ARRAY
26340: PUSH
26341: LD_INT 2
26343: ARRAY
26344: PPUSH
26345: CALL_OW 114
26349: GO 26363
// ComMoveToArea ( b , retreat_area ) ;
26351: LD_VAR 0 7
26355: PPUSH
26356: LD_INT 12
26358: PPUSH
26359: CALL_OW 113
// end ; end ;
26363: GO 26060
26365: POP
26366: POP
// end ; end ;
26367: GO 24830
26369: POP
26370: POP
// wait ( 0 0$1 ) ;
26371: LD_INT 35
26373: PPUSH
26374: CALL_OW 67
// if russians_got_away and survivors_found = 2 then
26378: LD_EXP 58
26382: PUSH
26383: LD_EXP 52
26387: PUSH
26388: LD_INT 2
26390: EQUAL
26391: AND
26392: IFFALSE 26401
// YouLost ( RussiansGotAway ) ;
26394: LD_STRING RussiansGotAway
26396: PPUSH
26397: CALL_OW 104
// until FilterAllUnits ( [ [ f_side , russians_alt ] , [ f_ok ] , [ f_type , unit_human ] ] ) = 0 ;
26401: LD_INT 22
26403: PUSH
26404: LD_EXP 6
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 50
26415: PUSH
26416: EMPTY
26417: LIST
26418: PUSH
26419: LD_INT 21
26421: PUSH
26422: LD_INT 1
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: LIST
26433: PPUSH
26434: CALL_OW 69
26438: PUSH
26439: LD_INT 0
26441: EQUAL
26442: IFFALSE 24817
// if russians_got_away then
26444: LD_EXP 58
26448: IFFALSE 26483
// begin while survivors_found <> 2 do
26450: LD_EXP 52
26454: PUSH
26455: LD_INT 2
26457: NONEQUAL
26458: IFFALSE 26469
// wait ( 0 0$1 ) ;
26460: LD_INT 35
26462: PPUSH
26463: CALL_OW 67
26467: GO 26450
// wait ( 0 0$2 ) ;
26469: LD_INT 70
26471: PPUSH
26472: CALL_OW 67
// YouLost ( RussiansGotAway ) ;
26476: LD_STRING RussiansGotAway
26478: PPUSH
26479: CALL_OW 104
// end ; end ;
26483: LD_VAR 0 1
26487: RET
// every 0 0$0.2 do var b ;
26488: GO 26490
26490: DISABLE
26491: LD_INT 0
26493: PPUSH
// begin for b in FilterAllUnits ( [ [ f_inarea , retreat_area ] , [ f_side , russians_alt ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_occupied ] ] ] ) do
26494: LD_ADDR_VAR 0 1
26498: PUSH
26499: LD_INT 95
26501: PUSH
26502: LD_INT 12
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 22
26511: PUSH
26512: LD_EXP 6
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: PUSH
26521: LD_INT 50
26523: PUSH
26524: EMPTY
26525: LIST
26526: PUSH
26527: LD_INT 2
26529: PUSH
26530: LD_INT 21
26532: PUSH
26533: LD_INT 1
26535: PUSH
26536: EMPTY
26537: LIST
26538: LIST
26539: PUSH
26540: LD_INT 59
26542: PUSH
26543: EMPTY
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: LIST
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: LIST
26555: LIST
26556: PPUSH
26557: CALL_OW 69
26561: PUSH
26562: FOR_IN
26563: IFFALSE 26584
// begin russians_got_away = true ;
26565: LD_ADDR_EXP 58
26569: PUSH
26570: LD_INT 1
26572: ST_TO_ADDR
// DestroyUnit ( b ) ;
26573: LD_VAR 0 1
26577: PPUSH
26578: CALL_OW 65
// end ;
26582: GO 26562
26584: POP
26585: POP
// enable ;
26586: ENABLE
// end ;
26587: PPOPN 1
26589: END
// function PrepareRetreatingRussians ( num_soldiers , num_other_humans , num_vehicles , num_cargo_bays ) ; var human_list , vehicle_list , c , temp_unit ; begin
26590: LD_INT 0
26592: PPUSH
26593: PPUSH
26594: PPUSH
26595: PPUSH
26596: PPUSH
// human_list = CreateUnitsWithClass ( russians_alt , num_soldiers , class_soldier , true ) ;
26597: LD_ADDR_VAR 0 6
26601: PUSH
26602: LD_EXP 6
26606: PPUSH
26607: LD_VAR 0 1
26611: PPUSH
26612: LD_INT 1
26614: PPUSH
26615: LD_INT 1
26617: PPUSH
26618: CALL 6232 0 4
26622: ST_TO_ADDR
// for c = 1 to num_other_humans do
26623: LD_ADDR_VAR 0 8
26627: PUSH
26628: DOUBLE
26629: LD_INT 1
26631: DEC
26632: ST_TO_ADDR
26633: LD_VAR 0 2
26637: PUSH
26638: FOR_TO
26639: IFFALSE 26696
// human_list = human_list ^ CreateUnitsWithClass ( russians_alt , 1 , [ class_mechanic , class_engineer , class_scientistic ] [ Rand ( 1 , 3 ) ] , true ) ;
26641: LD_ADDR_VAR 0 6
26645: PUSH
26646: LD_VAR 0 6
26650: PUSH
26651: LD_EXP 6
26655: PPUSH
26656: LD_INT 1
26658: PPUSH
26659: LD_INT 3
26661: PUSH
26662: LD_INT 2
26664: PUSH
26665: LD_INT 4
26667: PUSH
26668: EMPTY
26669: LIST
26670: LIST
26671: LIST
26672: PUSH
26673: LD_INT 1
26675: PPUSH
26676: LD_INT 3
26678: PPUSH
26679: CALL_OW 12
26683: ARRAY
26684: PPUSH
26685: LD_INT 1
26687: PPUSH
26688: CALL 6232 0 4
26692: ADD
26693: ST_TO_ADDR
26694: GO 26638
26696: POP
26697: POP
// InitUc ;
26698: CALL_OW 18
// InitVc ;
26702: CALL_OW 20
// uc_side = russians_alt ;
26706: LD_ADDR_OWVAR 20
26710: PUSH
26711: LD_EXP 6
26715: ST_TO_ADDR
// uc_nation = nation_russian ;
26716: LD_ADDR_OWVAR 21
26720: PUSH
26721: LD_INT 3
26723: ST_TO_ADDR
// for c = 1 to num_vehicles do
26724: LD_ADDR_VAR 0 8
26728: PUSH
26729: DOUBLE
26730: LD_INT 1
26732: DEC
26733: ST_TO_ADDR
26734: LD_VAR 0 3
26738: PUSH
26739: FOR_TO
26740: IFFALSE 26984
// begin vc_engine = engine_combustion ;
26742: LD_ADDR_OWVAR 39
26746: PUSH
26747: LD_INT 1
26749: ST_TO_ADDR
// vc_fuel_battery = 100 ;
26750: LD_ADDR_OWVAR 41
26754: PUSH
26755: LD_INT 100
26757: ST_TO_ADDR
// vc_control = control_manual ;
26758: LD_ADDR_OWVAR 38
26762: PUSH
26763: LD_INT 1
26765: ST_TO_ADDR
// vc_chassis = ru_medium_tracked ;
26766: LD_ADDR_OWVAR 37
26770: PUSH
26771: LD_INT 22
26773: ST_TO_ADDR
// case difficulty of 1 :
26774: LD_OWVAR 67
26778: PUSH
26779: LD_INT 1
26781: DOUBLE
26782: EQUAL
26783: IFTRUE 26787
26785: GO 26817
26787: POP
// vc_weapon = [ ru_heavy_machine_gun , ru_gatling_gun ] [ Rand ( 1 , 2 ) ] ; 2 :
26788: LD_ADDR_OWVAR 40
26792: PUSH
26793: LD_INT 42
26795: PUSH
26796: LD_INT 43
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: PUSH
26803: LD_INT 1
26805: PPUSH
26806: LD_INT 2
26808: PPUSH
26809: CALL_OW 12
26813: ARRAY
26814: ST_TO_ADDR
26815: GO 26898
26817: LD_INT 2
26819: DOUBLE
26820: EQUAL
26821: IFTRUE 26825
26823: GO 26855
26825: POP
// vc_weapon = [ ru_gatling_gun , ru_gun ] [ Rand ( 1 , 2 ) ] ; 3 :
26826: LD_ADDR_OWVAR 40
26830: PUSH
26831: LD_INT 43
26833: PUSH
26834: LD_INT 44
26836: PUSH
26837: EMPTY
26838: LIST
26839: LIST
26840: PUSH
26841: LD_INT 1
26843: PPUSH
26844: LD_INT 2
26846: PPUSH
26847: CALL_OW 12
26851: ARRAY
26852: ST_TO_ADDR
26853: GO 26898
26855: LD_INT 3
26857: DOUBLE
26858: EQUAL
26859: IFTRUE 26863
26861: GO 26897
26863: POP
// vc_weapon = [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ; end ;
26864: LD_ADDR_OWVAR 40
26868: PUSH
26869: LD_INT 43
26871: PUSH
26872: LD_INT 44
26874: PUSH
26875: LD_INT 44
26877: PUSH
26878: EMPTY
26879: LIST
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 1
26885: PPUSH
26886: LD_INT 3
26888: PPUSH
26889: CALL_OW 12
26893: ARRAY
26894: ST_TO_ADDR
26895: GO 26898
26897: POP
// vehicle_list = vehicle_list ^ CreateVehicle ;
26898: LD_ADDR_VAR 0 7
26902: PUSH
26903: LD_VAR 0 7
26907: PUSH
26908: CALL_OW 45
26912: ADD
26913: ST_TO_ADDR
// temp_unit = CreateUnitsWithClass ( russians_alt , 1 , class_mechanic , true ) ;
26914: LD_ADDR_VAR 0 9
26918: PUSH
26919: LD_EXP 6
26923: PPUSH
26924: LD_INT 1
26926: PPUSH
26927: LD_INT 3
26929: PPUSH
26930: LD_INT 1
26932: PPUSH
26933: CALL 6232 0 4
26937: ST_TO_ADDR
// human_list = human_list ^ temp_unit ;
26938: LD_ADDR_VAR 0 6
26942: PUSH
26943: LD_VAR 0 6
26947: PUSH
26948: LD_VAR 0 9
26952: ADD
26953: ST_TO_ADDR
// PlaceHumanInUnit ( temp_unit [ 1 ] , vehicle_list [ vehicle_list + 0 ] ) ;
26954: LD_VAR 0 9
26958: PUSH
26959: LD_INT 1
26961: ARRAY
26962: PPUSH
26963: LD_VAR 0 7
26967: PUSH
26968: LD_VAR 0 7
26972: PUSH
26973: LD_INT 0
26975: PLUS
26976: ARRAY
26977: PPUSH
26978: CALL_OW 52
// end ;
26982: GO 26739
26984: POP
26985: POP
// for c = 1 to num_cargo_bays do
26986: LD_ADDR_VAR 0 8
26990: PUSH
26991: DOUBLE
26992: LD_INT 1
26994: DEC
26995: ST_TO_ADDR
26996: LD_VAR 0 4
27000: PUSH
27001: FOR_TO
27002: IFFALSE 27209
// begin vc_weapon = ru_cargo_bay ;
27004: LD_ADDR_OWVAR 40
27008: PUSH
27009: LD_INT 51
27011: ST_TO_ADDR
// vehicle_list = vehicle_list ^ CreateVehicle ;
27012: LD_ADDR_VAR 0 7
27016: PUSH
27017: LD_VAR 0 7
27021: PUSH
27022: CALL_OW 45
27026: ADD
27027: ST_TO_ADDR
// temp_unit = CreateUnitsWithClass ( russians_alt , 1 , class_mechanic , true ) ;
27028: LD_ADDR_VAR 0 9
27032: PUSH
27033: LD_EXP 6
27037: PPUSH
27038: LD_INT 1
27040: PPUSH
27041: LD_INT 3
27043: PPUSH
27044: LD_INT 1
27046: PPUSH
27047: CALL 6232 0 4
27051: ST_TO_ADDR
// human_list = human_list ^ temp_unit ;
27052: LD_ADDR_VAR 0 6
27056: PUSH
27057: LD_VAR 0 6
27061: PUSH
27062: LD_VAR 0 9
27066: ADD
27067: ST_TO_ADDR
// PlaceHumanInUnit ( temp_unit [ 1 ] , vehicle_list [ vehicle_list + 0 ] ) ;
27068: LD_VAR 0 9
27072: PUSH
27073: LD_INT 1
27075: ARRAY
27076: PPUSH
27077: LD_VAR 0 7
27081: PUSH
27082: LD_VAR 0 7
27086: PUSH
27087: LD_INT 0
27089: PLUS
27090: ARRAY
27091: PPUSH
27092: CALL_OW 52
// AddCargo ( vehicle_list [ vehicle_list + 0 ] , mat_cans , Rand ( 0 , 2 ) * 10 ) ;
27096: LD_VAR 0 7
27100: PUSH
27101: LD_VAR 0 7
27105: PUSH
27106: LD_INT 0
27108: PLUS
27109: ARRAY
27110: PPUSH
27111: LD_INT 1
27113: PPUSH
27114: LD_INT 0
27116: PPUSH
27117: LD_INT 2
27119: PPUSH
27120: CALL_OW 12
27124: PUSH
27125: LD_INT 10
27127: MUL
27128: PPUSH
27129: CALL_OW 291
// AddCargo ( vehicle_list [ vehicle_list + 0 ] , mat_oil , Rand ( 2 , 4 ) * 10 ) ;
27133: LD_VAR 0 7
27137: PUSH
27138: LD_VAR 0 7
27142: PUSH
27143: LD_INT 0
27145: PLUS
27146: ARRAY
27147: PPUSH
27148: LD_INT 2
27150: PPUSH
27151: LD_INT 2
27153: PPUSH
27154: LD_INT 4
27156: PPUSH
27157: CALL_OW 12
27161: PUSH
27162: LD_INT 10
27164: MUL
27165: PPUSH
27166: CALL_OW 291
// AddCargo ( vehicle_list [ vehicle_list + 0 ] , mat_siberit , Rand ( 1 , 2 ) * 10 ) ;
27170: LD_VAR 0 7
27174: PUSH
27175: LD_VAR 0 7
27179: PUSH
27180: LD_INT 0
27182: PLUS
27183: ARRAY
27184: PPUSH
27185: LD_INT 3
27187: PPUSH
27188: LD_INT 1
27190: PPUSH
27191: LD_INT 2
27193: PPUSH
27194: CALL_OW 12
27198: PUSH
27199: LD_INT 10
27201: MUL
27202: PPUSH
27203: CALL_OW 291
// end ;
27207: GO 27001
27209: POP
27210: POP
// for c in vehicle_list do
27211: LD_ADDR_VAR 0 8
27215: PUSH
27216: LD_VAR 0 7
27220: PUSH
27221: FOR_IN
27222: IFFALSE 27267
// SetLives ( c , [ 600 , 700 , 800 ] [ difficulty ] - Rand ( 0 , 100 ) ) ;
27224: LD_VAR 0 8
27228: PPUSH
27229: LD_INT 600
27231: PUSH
27232: LD_INT 700
27234: PUSH
27235: LD_INT 800
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: LIST
27242: PUSH
27243: LD_OWVAR 67
27247: ARRAY
27248: PUSH
27249: LD_INT 0
27251: PPUSH
27252: LD_INT 100
27254: PPUSH
27255: CALL_OW 12
27259: MINUS
27260: PPUSH
27261: CALL_OW 234
27265: GO 27221
27267: POP
27268: POP
// result = [ human_list , vehicle_list ] ;
27269: LD_ADDR_VAR 0 5
27273: PUSH
27274: LD_VAR 0 6
27278: PUSH
27279: LD_VAR 0 7
27283: PUSH
27284: EMPTY
27285: LIST
27286: LIST
27287: ST_TO_ADDR
// end ;
27288: LD_VAR 0 5
27292: RET
// function FindClosestHexIndex ( un , hex_list ) ; var low_dist , dist , b ; begin
27293: LD_INT 0
27295: PPUSH
27296: PPUSH
27297: PPUSH
27298: PPUSH
// low_dist = GetDistUnitXY ( un , hex_list [ 1 ] [ 1 ] , hex_list [ 1 ] [ 2 ] ) ;
27299: LD_ADDR_VAR 0 4
27303: PUSH
27304: LD_VAR 0 1
27308: PPUSH
27309: LD_VAR 0 2
27313: PUSH
27314: LD_INT 1
27316: ARRAY
27317: PUSH
27318: LD_INT 1
27320: ARRAY
27321: PPUSH
27322: LD_VAR 0 2
27326: PUSH
27327: LD_INT 1
27329: ARRAY
27330: PUSH
27331: LD_INT 2
27333: ARRAY
27334: PPUSH
27335: CALL_OW 297
27339: ST_TO_ADDR
// result = 1 ;
27340: LD_ADDR_VAR 0 3
27344: PUSH
27345: LD_INT 1
27347: ST_TO_ADDR
// for b = 2 to hex_list do
27348: LD_ADDR_VAR 0 6
27352: PUSH
27353: DOUBLE
27354: LD_INT 2
27356: DEC
27357: ST_TO_ADDR
27358: LD_VAR 0 2
27362: PUSH
27363: FOR_TO
27364: IFFALSE 27445
// begin dist = GetDistUnitXY ( un , hex_list [ b ] [ 1 ] , hex_list [ b ] [ 2 ] ) ;
27366: LD_ADDR_VAR 0 5
27370: PUSH
27371: LD_VAR 0 1
27375: PPUSH
27376: LD_VAR 0 2
27380: PUSH
27381: LD_VAR 0 6
27385: ARRAY
27386: PUSH
27387: LD_INT 1
27389: ARRAY
27390: PPUSH
27391: LD_VAR 0 2
27395: PUSH
27396: LD_VAR 0 6
27400: ARRAY
27401: PUSH
27402: LD_INT 2
27404: ARRAY
27405: PPUSH
27406: CALL_OW 297
27410: ST_TO_ADDR
// if dist < low_dist then
27411: LD_VAR 0 5
27415: PUSH
27416: LD_VAR 0 4
27420: LESS
27421: IFFALSE 27443
// begin low_dist = dist ;
27423: LD_ADDR_VAR 0 4
27427: PUSH
27428: LD_VAR 0 5
27432: ST_TO_ADDR
// result = b ;
27433: LD_ADDR_VAR 0 3
27437: PUSH
27438: LD_VAR 0 6
27442: ST_TO_ADDR
// end ; end ;
27443: GO 27363
27445: POP
27446: POP
// end ;
27447: LD_VAR 0 3
27451: RET
// every 0 0$1 + 0 0$0.2 do var temp_list , temp_unit ;
27452: GO 27454
27454: DISABLE
27455: LD_INT 0
27457: PPUSH
27458: PPUSH
// begin temp_list = FilterAllUnits ( [ [ f_side , russians_alt ] , [ f_see , you ] , [ f_weapon , ru_cargo_bay ] ] ) ;
27459: LD_ADDR_VAR 0 1
27463: PUSH
27464: LD_INT 22
27466: PUSH
27467: LD_EXP 6
27471: PUSH
27472: EMPTY
27473: LIST
27474: LIST
27475: PUSH
27476: LD_INT 101
27478: PUSH
27479: LD_EXP 2
27483: PUSH
27484: EMPTY
27485: LIST
27486: LIST
27487: PUSH
27488: LD_INT 34
27490: PUSH
27491: LD_INT 51
27493: PUSH
27494: EMPTY
27495: LIST
27496: LIST
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: LIST
27502: PPUSH
27503: CALL_OW 69
27507: ST_TO_ADDR
// if temp_list = 0 then
27508: LD_VAR 0 1
27512: PUSH
27513: LD_INT 0
27515: EQUAL
27516: IFFALSE 27521
// begin enable ;
27518: ENABLE
// exit ;
27519: GO 27880
// end ; CenterOnUnits ( temp_list [ 1 ] ) ;
27521: LD_VAR 0 1
27525: PUSH
27526: LD_INT 1
27528: ARRAY
27529: PPUSH
27530: CALL_OW 85
// DialogueOn ;
27534: CALL_OW 6
// temp_list = UnitFilter ( [ Sonya , Oswald , Ralph , Kowalski , Willard , Evelyn , Gordon , Suze ] , [ f_ok ] ) ;
27538: LD_ADDR_VAR 0 1
27542: PUSH
27543: LD_EXP 8
27547: PUSH
27548: LD_EXP 9
27552: PUSH
27553: LD_EXP 10
27557: PUSH
27558: LD_EXP 11
27562: PUSH
27563: LD_EXP 12
27567: PUSH
27568: LD_EXP 13
27572: PUSH
27573: LD_EXP 14
27577: PUSH
27578: LD_EXP 15
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: PPUSH
27593: LD_INT 50
27595: PUSH
27596: EMPTY
27597: LIST
27598: PPUSH
27599: CALL_OW 72
27603: ST_TO_ADDR
// if temp_list > 0 then
27604: LD_VAR 0 1
27608: PUSH
27609: LD_INT 0
27611: GREATER
27612: IFFALSE 27850
// begin temp_unit = temp_list [ Rand ( 1 , temp_list + 0 ) ] ;
27614: LD_ADDR_VAR 0 2
27618: PUSH
27619: LD_VAR 0 1
27623: PUSH
27624: LD_INT 1
27626: PPUSH
27627: LD_VAR 0 1
27631: PUSH
27632: LD_INT 0
27634: PLUS
27635: PPUSH
27636: CALL_OW 12
27640: ARRAY
27641: ST_TO_ADDR
// case temp_unit of Sonya :
27642: LD_VAR 0 2
27646: PUSH
27647: LD_EXP 8
27651: DOUBLE
27652: EQUAL
27653: IFTRUE 27657
27655: GO 27672
27657: POP
// Say ( temp_unit , D6So1 ) ; Oswald :
27658: LD_VAR 0 2
27662: PPUSH
27663: LD_STRING D6So1
27665: PPUSH
27666: CALL_OW 88
27670: GO 27848
27672: LD_EXP 9
27676: DOUBLE
27677: EQUAL
27678: IFTRUE 27682
27680: GO 27697
27682: POP
// Say ( temp_unit , D6Os1 ) ; Ralph :
27683: LD_VAR 0 2
27687: PPUSH
27688: LD_STRING D6Os1
27690: PPUSH
27691: CALL_OW 88
27695: GO 27848
27697: LD_EXP 10
27701: DOUBLE
27702: EQUAL
27703: IFTRUE 27707
27705: GO 27722
27707: POP
// Say ( temp_unit , D6Ra1 ) ; Kowalski :
27708: LD_VAR 0 2
27712: PPUSH
27713: LD_STRING D6Ra1
27715: PPUSH
27716: CALL_OW 88
27720: GO 27848
27722: LD_EXP 11
27726: DOUBLE
27727: EQUAL
27728: IFTRUE 27732
27730: GO 27747
27732: POP
// Say ( temp_unit , D6Ko1 ) ; Willard :
27733: LD_VAR 0 2
27737: PPUSH
27738: LD_STRING D6Ko1
27740: PPUSH
27741: CALL_OW 88
27745: GO 27848
27747: LD_EXP 12
27751: DOUBLE
27752: EQUAL
27753: IFTRUE 27757
27755: GO 27772
27757: POP
// Say ( temp_unit , D6Wi1 ) ; Evelyn :
27758: LD_VAR 0 2
27762: PPUSH
27763: LD_STRING D6Wi1
27765: PPUSH
27766: CALL_OW 88
27770: GO 27848
27772: LD_EXP 13
27776: DOUBLE
27777: EQUAL
27778: IFTRUE 27782
27780: GO 27797
27782: POP
// Say ( temp_unit , D6Ev1 ) ; Gordon :
27783: LD_VAR 0 2
27787: PPUSH
27788: LD_STRING D6Ev1
27790: PPUSH
27791: CALL_OW 88
27795: GO 27848
27797: LD_EXP 14
27801: DOUBLE
27802: EQUAL
27803: IFTRUE 27807
27805: GO 27822
27807: POP
// Say ( temp_unit , D6Go1 ) ; Suze :
27808: LD_VAR 0 2
27812: PPUSH
27813: LD_STRING D6Go1
27815: PPUSH
27816: CALL_OW 88
27820: GO 27848
27822: LD_EXP 15
27826: DOUBLE
27827: EQUAL
27828: IFTRUE 27832
27830: GO 27847
27832: POP
// Say ( temp_unit , D6Su1 ) ; end ;
27833: LD_VAR 0 2
27837: PPUSH
27838: LD_STRING D6Su1
27840: PPUSH
27841: CALL_OW 88
27845: GO 27848
27847: POP
// end else
27848: GO 27862
// ForceSay ( Heike , D6H1 ) ;
27850: LD_EXP 7
27854: PPUSH
27855: LD_STRING D6H1
27857: PPUSH
27858: CALL_OW 91
// DialogueOff ;
27862: CALL_OW 7
// wait ( 0 0$0.2 ) ;
27866: LD_INT 7
27868: PPUSH
27869: CALL_OW 67
// ChangeMissionObjectives ( Maddcapturecargo ) ;
27873: LD_STRING Maddcapturecargo
27875: PPUSH
27876: CALL_OW 337
// end ;
27880: PPOPN 2
27882: END
// every 0 0$1 + 0 0$0.2 do var c , temp_list , temp_unit ;
27883: GO 27885
27885: DISABLE
27886: LD_INT 0
27888: PPUSH
27889: PPUSH
27890: PPUSH
// begin for c in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
27891: LD_ADDR_VAR 0 1
27895: PUSH
27896: LD_INT 22
27898: PUSH
27899: LD_EXP 2
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: LD_INT 2
27910: PUSH
27911: LD_INT 30
27913: PUSH
27914: LD_INT 0
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: LD_INT 30
27923: PUSH
27924: LD_INT 1
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: LIST
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: PPUSH
27940: CALL_OW 69
27944: PUSH
27945: FOR_IN
27946: IFFALSE 28366
// if GetResourceType ( GetBase ( c ) , mat_siberit ) > 0 then
27948: LD_VAR 0 1
27952: PPUSH
27953: CALL_OW 274
27957: PPUSH
27958: LD_INT 3
27960: PPUSH
27961: CALL_OW 275
27965: PUSH
27966: LD_INT 0
27968: GREATER
27969: IFFALSE 28364
// begin CenterOnUnits ( c ) ;
27971: LD_VAR 0 1
27975: PPUSH
27976: CALL_OW 85
// DialogueOn ;
27980: CALL_OW 6
// ForceSay ( Heike , D7H1 ) ;
27984: LD_EXP 7
27988: PPUSH
27989: LD_STRING D7H1
27991: PPUSH
27992: CALL_OW 91
// temp_list = UnitFilter ( [ Sonya , Oswald , Ralph , Kowalski , Willard , Evelyn , Gordon , Suze ] , [ f_ok ] ) ;
27996: LD_ADDR_VAR 0 2
28000: PUSH
28001: LD_EXP 8
28005: PUSH
28006: LD_EXP 9
28010: PUSH
28011: LD_EXP 10
28015: PUSH
28016: LD_EXP 11
28020: PUSH
28021: LD_EXP 12
28025: PUSH
28026: LD_EXP 13
28030: PUSH
28031: LD_EXP 14
28035: PUSH
28036: LD_EXP 15
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: LIST
28045: LIST
28046: LIST
28047: LIST
28048: LIST
28049: LIST
28050: PPUSH
28051: LD_INT 50
28053: PUSH
28054: EMPTY
28055: LIST
28056: PPUSH
28057: CALL_OW 72
28061: ST_TO_ADDR
// if temp_list > 0 then
28062: LD_VAR 0 2
28066: PUSH
28067: LD_INT 0
28069: GREATER
28070: IFFALSE 28306
// begin temp_unit = temp_list [ Rand ( 1 , temp_list + 0 ) ] ;
28072: LD_ADDR_VAR 0 3
28076: PUSH
28077: LD_VAR 0 2
28081: PUSH
28082: LD_INT 1
28084: PPUSH
28085: LD_VAR 0 2
28089: PUSH
28090: LD_INT 0
28092: PLUS
28093: PPUSH
28094: CALL_OW 12
28098: ARRAY
28099: ST_TO_ADDR
// case temp_unit of Sonya :
28100: LD_VAR 0 3
28104: PUSH
28105: LD_EXP 8
28109: DOUBLE
28110: EQUAL
28111: IFTRUE 28115
28113: GO 28130
28115: POP
// Say ( temp_unit , D7So1 ) ; Oswald :
28116: LD_VAR 0 3
28120: PPUSH
28121: LD_STRING D7So1
28123: PPUSH
28124: CALL_OW 88
28128: GO 28306
28130: LD_EXP 9
28134: DOUBLE
28135: EQUAL
28136: IFTRUE 28140
28138: GO 28155
28140: POP
// Say ( temp_unit , D7Os1 ) ; Ralph :
28141: LD_VAR 0 3
28145: PPUSH
28146: LD_STRING D7Os1
28148: PPUSH
28149: CALL_OW 88
28153: GO 28306
28155: LD_EXP 10
28159: DOUBLE
28160: EQUAL
28161: IFTRUE 28165
28163: GO 28180
28165: POP
// Say ( temp_unit , D7Ra1 ) ; Kowalski :
28166: LD_VAR 0 3
28170: PPUSH
28171: LD_STRING D7Ra1
28173: PPUSH
28174: CALL_OW 88
28178: GO 28306
28180: LD_EXP 11
28184: DOUBLE
28185: EQUAL
28186: IFTRUE 28190
28188: GO 28205
28190: POP
// Say ( temp_unit , D7Ko1 ) ; Willard :
28191: LD_VAR 0 3
28195: PPUSH
28196: LD_STRING D7Ko1
28198: PPUSH
28199: CALL_OW 88
28203: GO 28306
28205: LD_EXP 12
28209: DOUBLE
28210: EQUAL
28211: IFTRUE 28215
28213: GO 28230
28215: POP
// Say ( temp_unit , D7Wi1 ) ; Evelyn :
28216: LD_VAR 0 3
28220: PPUSH
28221: LD_STRING D7Wi1
28223: PPUSH
28224: CALL_OW 88
28228: GO 28306
28230: LD_EXP 13
28234: DOUBLE
28235: EQUAL
28236: IFTRUE 28240
28238: GO 28255
28240: POP
// Say ( temp_unit , D7Ev1 ) ; Gordon :
28241: LD_VAR 0 3
28245: PPUSH
28246: LD_STRING D7Ev1
28248: PPUSH
28249: CALL_OW 88
28253: GO 28306
28255: LD_EXP 14
28259: DOUBLE
28260: EQUAL
28261: IFTRUE 28265
28263: GO 28280
28265: POP
// Say ( temp_unit , D7Go1 ) ; Suze :
28266: LD_VAR 0 3
28270: PPUSH
28271: LD_STRING D7Go1
28273: PPUSH
28274: CALL_OW 88
28278: GO 28306
28280: LD_EXP 15
28284: DOUBLE
28285: EQUAL
28286: IFTRUE 28290
28288: GO 28305
28290: POP
// Say ( temp_unit , D7Su1 ) ; end ;
28291: LD_VAR 0 3
28295: PPUSH
28296: LD_STRING D7Su1
28298: PPUSH
28299: CALL_OW 88
28303: GO 28306
28305: POP
// end ; ForceSay ( MarkB , D7Ma1 ) ;
28306: LD_EXP 17
28310: PPUSH
28311: LD_STRING D7Ma1
28313: PPUSH
28314: CALL_OW 91
// ForceSay ( Heike , D7H2 ) ;
28318: LD_EXP 7
28322: PPUSH
28323: LD_STRING D7H2
28325: PPUSH
28326: CALL_OW 91
// ForceSay ( Heike , D7H3 ) ;
28330: LD_EXP 7
28334: PPUSH
28335: LD_STRING D7H3
28337: PPUSH
28338: CALL_OW 91
// DialogueOff ;
28342: CALL_OW 7
// wait ( 0 0$0.2 ) ;
28346: LD_INT 7
28348: PPUSH
28349: CALL_OW 67
// ChangeMissionObjectives ( Maddbringsiberite ) ;
28353: LD_STRING Maddbringsiberite
28355: PPUSH
28356: CALL_OW 337
// exit ;
28360: POP
28361: POP
28362: GO 28369
// end ;
28364: GO 27945
28366: POP
28367: POP
// enable ;
28368: ENABLE
// end ; end_of_file
28369: PPOPN 3
28371: END
// var dont_gather_crates , going_to_drop_material_units ; export function InitCrateModule ; begin
28372: LD_INT 0
28374: PPUSH
// dont_gather_crates = [ ] ;
28375: LD_ADDR_LOC 1
28379: PUSH
28380: EMPTY
28381: ST_TO_ADDR
// going_to_drop_material_units = [ ] ;
28382: LD_ADDR_LOC 2
28386: PUSH
28387: EMPTY
28388: ST_TO_ADDR
// end ;
28389: LD_VAR 0 1
28393: RET
// every 0 0$1 + 0 0$0.2 do var flip , t ;
28394: GO 28396
28396: DISABLE
28397: LD_INT 0
28399: PPUSH
28400: PPUSH
// begin flip = - 1 ;
28401: LD_ADDR_VAR 0 1
28405: PUSH
28406: LD_INT 1
28408: NEG
28409: ST_TO_ADDR
// t = 1 1$20 ;
28410: LD_ADDR_VAR 0 2
28414: PUSH
28415: LD_INT 2800
28417: ST_TO_ADDR
// repeat if flip = - 1 then
28418: LD_VAR 0 1
28422: PUSH
28423: LD_INT 1
28425: NEG
28426: EQUAL
28427: IFFALSE 28464
// begin flip = Rand ( t , t + 0 0$30 ) ;
28429: LD_ADDR_VAR 0 1
28433: PUSH
28434: LD_VAR 0 2
28438: PPUSH
28439: LD_VAR 0 2
28443: PUSH
28444: LD_INT 1050
28446: PLUS
28447: PPUSH
28448: CALL_OW 12
28452: ST_TO_ADDR
// wait ( flip ) ;
28453: LD_VAR 0 1
28457: PPUSH
28458: CALL_OW 67
// end else
28462: GO 28520
// begin wait ( ( t + 0 0$15 ) * 2 - flip ) ;
28464: LD_VAR 0 2
28468: PUSH
28469: LD_INT 525
28471: PLUS
28472: PUSH
28473: LD_INT 2
28475: MUL
28476: PUSH
28477: LD_VAR 0 1
28481: MINUS
28482: PPUSH
28483: CALL_OW 67
// flip = - 1 ;
28487: LD_ADDR_VAR 0 1
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: ST_TO_ADDR
// if t < 1 1$30 then
28496: LD_VAR 0 2
28500: PUSH
28501: LD_INT 3150
28503: LESS
28504: IFFALSE 28520
// t = t + 0 0$1 ;
28506: LD_ADDR_VAR 0 2
28510: PUSH
28511: LD_VAR 0 2
28515: PUSH
28516: LD_INT 35
28518: PLUS
28519: ST_TO_ADDR
// end ; CreateCratesArea ( Rand ( Rand ( 3 , 4 ) , 5 ) , arcrate , true ) ;
28520: LD_INT 3
28522: PPUSH
28523: LD_INT 4
28525: PPUSH
28526: CALL_OW 12
28530: PPUSH
28531: LD_INT 5
28533: PPUSH
28534: CALL_OW 12
28538: PPUSH
28539: LD_INT 10
28541: PPUSH
28542: LD_INT 1
28544: PPUSH
28545: CALL_OW 55
// until end_of_mission ;
28549: LD_OWVAR 63
28553: IFFALSE 28418
// end ;
28555: PPOPN 2
28557: END
// every 0 0$1 + 0 0$0.4 do
28558: GO 28560
28560: DISABLE
// begin wait ( Rand ( 1 1$0 , 2 2$15 ) ) ;
28561: LD_INT 2100
28563: PPUSH
28564: LD_INT 4725
28566: PPUSH
28567: CALL_OW 12
28571: PPUSH
28572: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , arcrate_inverse , true ) ;
28576: LD_INT 3
28578: PPUSH
28579: LD_INT 5
28581: PPUSH
28582: CALL_OW 12
28586: PPUSH
28587: LD_INT 11
28589: PPUSH
28590: LD_INT 1
28592: PPUSH
28593: CALL_OW 55
// enable ;
28597: ENABLE
// end ;
28598: END
// function OnCommand_CrateDropDetection ( com ) ; var b , temp_list , t ; begin
28599: LD_INT 0
28601: PPUSH
28602: PPUSH
28603: PPUSH
28604: PPUSH
// if com <> 74 then
28605: LD_VAR 0 1
28609: PUSH
28610: LD_INT 74
28612: NONEQUAL
28613: IFFALSE 28617
// exit ;
28615: GO 28789
// for b in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
28617: LD_ADDR_VAR 0 3
28621: PUSH
28622: LD_INT 22
28624: PUSH
28625: LD_EXP 2
28629: PUSH
28630: EMPTY
28631: LIST
28632: LIST
28633: PUSH
28634: LD_INT 2
28636: PUSH
28637: LD_INT 25
28639: PUSH
28640: LD_INT 2
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: LD_INT 25
28649: PUSH
28650: LD_INT 16
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: LD_INT 34
28659: PUSH
28660: LD_INT 12
28662: PUSH
28663: EMPTY
28664: LIST
28665: LIST
28666: PUSH
28667: LD_INT 34
28669: PUSH
28670: LD_INT 51
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: LIST
28681: LIST
28682: LIST
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PPUSH
28688: CALL_OW 69
28692: PUSH
28693: FOR_IN
28694: IFFALSE 28787
// if IsSelected ( b ) and not b in going_to_drop_material_units then
28696: LD_VAR 0 3
28700: PPUSH
28701: CALL_OW 306
28705: PUSH
28706: LD_VAR 0 3
28710: PUSH
28711: LD_LOC 2
28715: IN
28716: NOT
28717: AND
28718: IFFALSE 28785
// if HasTask ( b ) then
28720: LD_VAR 0 3
28724: PPUSH
28725: CALL_OW 314
28729: IFFALSE 28785
// begin for t in GetTaskList ( b ) do
28731: LD_ADDR_VAR 0 5
28735: PUSH
28736: LD_VAR 0 3
28740: PPUSH
28741: CALL_OW 437
28745: PUSH
28746: FOR_IN
28747: IFFALSE 28783
// begin if t [ 1 ] = m then
28749: LD_VAR 0 5
28753: PUSH
28754: LD_INT 1
28756: ARRAY
28757: PUSH
28758: LD_STRING m
28760: EQUAL
28761: IFFALSE 28781
// begin going_to_drop_material_units = going_to_drop_material_units ^ b ;
28763: LD_ADDR_LOC 2
28767: PUSH
28768: LD_LOC 2
28772: PUSH
28773: LD_VAR 0 3
28777: ADD
28778: ST_TO_ADDR
// break ;
28779: GO 28783
// end ; end ;
28781: GO 28746
28783: POP
28784: POP
// end ;
28785: GO 28693
28787: POP
28788: POP
// end ;
28789: LD_VAR 0 2
28793: RET
// on Command ( com ) do begin OnCommand_CrateDropDetection ( com ) ;
28794: LD_VAR 0 1
28798: PPUSH
28799: CALL 28599 0 1
// end ;
28803: PPOPN 1
28805: END
// every 0 0$1 + 0 0$0.1 do var un , temp_list , t , dist , hex ;
28806: GO 28808
28808: DISABLE
28809: LD_INT 0
28811: PPUSH
28812: PPUSH
28813: PPUSH
28814: PPUSH
28815: PPUSH
// begin repeat wait ( 0 0$0.5 ) ;
28816: LD_INT 18
28818: PPUSH
28819: CALL_OW 67
// if going_to_drop_material_units = 0 then
28823: LD_LOC 2
28827: PUSH
28828: LD_INT 0
28830: EQUAL
28831: IFFALSE 28835
// continue ;
28833: GO 28816
// for un in going_to_drop_material_units do
28835: LD_ADDR_VAR 0 1
28839: PUSH
28840: LD_LOC 2
28844: PUSH
28845: FOR_IN
28846: IFFALSE 28988
// if not Carry ( un ) then
28848: LD_VAR 0 1
28852: PPUSH
28853: CALL_OW 281
28857: NOT
28858: IFFALSE 28986
// begin if GetType ( un ) = unit_human then
28860: LD_VAR 0 1
28864: PPUSH
28865: CALL_OW 247
28869: PUSH
28870: LD_INT 1
28872: EQUAL
28873: IFFALSE 28885
// dist = 2 else
28875: LD_ADDR_VAR 0 4
28879: PUSH
28880: LD_INT 2
28882: ST_TO_ADDR
28883: GO 28893
// dist = 4 ;
28885: LD_ADDR_VAR 0 4
28889: PUSH
28890: LD_INT 4
28892: ST_TO_ADDR
// for hex in GetHexesNearHex ( GetX ( un ) , GetY ( un ) , dist ) do
28893: LD_ADDR_VAR 0 5
28897: PUSH
28898: LD_VAR 0 1
28902: PPUSH
28903: CALL_OW 250
28907: PPUSH
28908: LD_VAR 0 1
28912: PPUSH
28913: CALL_OW 251
28917: PPUSH
28918: LD_VAR 0 4
28922: PPUSH
28923: CALL 29106 0 3
28927: PUSH
28928: FOR_IN
28929: IFFALSE 28984
// if GetResourceAmountXY ( hex [ 1 ] , hex [ 2 ] ) > 0 then
28931: LD_VAR 0 5
28935: PUSH
28936: LD_INT 1
28938: ARRAY
28939: PPUSH
28940: LD_VAR 0 5
28944: PUSH
28945: LD_INT 2
28947: ARRAY
28948: PPUSH
28949: CALL_OW 284
28953: PUSH
28954: LD_INT 0
28956: GREATER
28957: IFFALSE 28982
// dont_gather_crates = Insert ( dont_gather_crates , 1 , hex ) ;
28959: LD_ADDR_LOC 1
28963: PUSH
28964: LD_LOC 1
28968: PPUSH
28969: LD_INT 1
28971: PPUSH
28972: LD_VAR 0 5
28976: PPUSH
28977: CALL_OW 2
28981: ST_TO_ADDR
28982: GO 28928
28984: POP
28985: POP
// end ;
28986: GO 28845
28988: POP
28989: POP
// going_to_drop_material_units = UnitFilter ( going_to_drop_material_units , [ f_hastask ] ) ;
28990: LD_ADDR_LOC 2
28994: PUSH
28995: LD_LOC 2
28999: PPUSH
29000: LD_INT 60
29002: PUSH
29003: EMPTY
29004: LIST
29005: PPUSH
29006: CALL_OW 72
29010: ST_TO_ADDR
// temp_list = [ ] ;
29011: LD_ADDR_VAR 0 2
29015: PUSH
29016: EMPTY
29017: ST_TO_ADDR
// for un in going_to_drop_material_units do
29018: LD_ADDR_VAR 0 1
29022: PUSH
29023: LD_LOC 2
29027: PUSH
29028: FOR_IN
29029: IFFALSE 29087
// begin for t in GetTaskList ( un ) do
29031: LD_ADDR_VAR 0 3
29035: PUSH
29036: LD_VAR 0 1
29040: PPUSH
29041: CALL_OW 437
29045: PUSH
29046: FOR_IN
29047: IFFALSE 29083
// if t [ 1 ] = m then
29049: LD_VAR 0 3
29053: PUSH
29054: LD_INT 1
29056: ARRAY
29057: PUSH
29058: LD_STRING m
29060: EQUAL
29061: IFFALSE 29081
// begin temp_list = temp_list ^ un ;
29063: LD_ADDR_VAR 0 2
29067: PUSH
29068: LD_VAR 0 2
29072: PUSH
29073: LD_VAR 0 1
29077: ADD
29078: ST_TO_ADDR
// break ;
29079: GO 29083
// end ;
29081: GO 29046
29083: POP
29084: POP
// end ;
29085: GO 29028
29087: POP
29088: POP
// going_to_drop_material_units = temp_list ;
29089: LD_ADDR_LOC 2
29093: PUSH
29094: LD_VAR 0 2
29098: ST_TO_ADDR
// until false ;
29099: LD_INT 0
29101: IFFALSE 28816
// end ;
29103: PPOPN 5
29105: END
// function GetHexesNearHex ( x , y , dist ) ; var d , list_coords , b ; begin
29106: LD_INT 0
29108: PPUSH
29109: PPUSH
29110: PPUSH
29111: PPUSH
// result = [ [ x , y ] ] ;
29112: LD_ADDR_VAR 0 4
29116: PUSH
29117: LD_VAR 0 1
29121: PUSH
29122: LD_VAR 0 2
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: EMPTY
29132: LIST
29133: ST_TO_ADDR
// for d = 1 to dist do
29134: LD_ADDR_VAR 0 5
29138: PUSH
29139: DOUBLE
29140: LD_INT 1
29142: DEC
29143: ST_TO_ADDR
29144: LD_VAR 0 3
29148: PUSH
29149: FOR_TO
29150: IFFALSE 29745
// begin list_coords = [ ] ;
29152: LD_ADDR_VAR 0 6
29156: PUSH
29157: EMPTY
29158: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x , y - d ] ) ;
29159: LD_ADDR_VAR 0 6
29163: PUSH
29164: LD_VAR 0 6
29168: PPUSH
29169: LD_INT 1
29171: PPUSH
29172: LD_VAR 0 1
29176: PUSH
29177: LD_VAR 0 2
29181: PUSH
29182: LD_VAR 0 5
29186: MINUS
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PPUSH
29192: CALL_OW 2
29196: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x + d , y ] ) ;
29197: LD_ADDR_VAR 0 6
29201: PUSH
29202: LD_VAR 0 6
29206: PPUSH
29207: LD_INT 1
29209: PPUSH
29210: LD_VAR 0 1
29214: PUSH
29215: LD_VAR 0 5
29219: PLUS
29220: PUSH
29221: LD_VAR 0 2
29225: PUSH
29226: EMPTY
29227: LIST
29228: LIST
29229: PPUSH
29230: CALL_OW 2
29234: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x + d , y + d ] ) ;
29235: LD_ADDR_VAR 0 6
29239: PUSH
29240: LD_VAR 0 6
29244: PPUSH
29245: LD_INT 1
29247: PPUSH
29248: LD_VAR 0 1
29252: PUSH
29253: LD_VAR 0 5
29257: PLUS
29258: PUSH
29259: LD_VAR 0 2
29263: PUSH
29264: LD_VAR 0 5
29268: PLUS
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PPUSH
29274: CALL_OW 2
29278: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x , y + d ] ) ;
29279: LD_ADDR_VAR 0 6
29283: PUSH
29284: LD_VAR 0 6
29288: PPUSH
29289: LD_INT 1
29291: PPUSH
29292: LD_VAR 0 1
29296: PUSH
29297: LD_VAR 0 2
29301: PUSH
29302: LD_VAR 0 5
29306: PLUS
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PPUSH
29312: CALL_OW 2
29316: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x - d , y ] ) ;
29317: LD_ADDR_VAR 0 6
29321: PUSH
29322: LD_VAR 0 6
29326: PPUSH
29327: LD_INT 1
29329: PPUSH
29330: LD_VAR 0 1
29334: PUSH
29335: LD_VAR 0 5
29339: MINUS
29340: PUSH
29341: LD_VAR 0 2
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PPUSH
29350: CALL_OW 2
29354: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x - d , y - d ] ) ;
29355: LD_ADDR_VAR 0 6
29359: PUSH
29360: LD_VAR 0 6
29364: PPUSH
29365: LD_INT 1
29367: PPUSH
29368: LD_VAR 0 1
29372: PUSH
29373: LD_VAR 0 5
29377: MINUS
29378: PUSH
29379: LD_VAR 0 2
29383: PUSH
29384: LD_VAR 0 5
29388: MINUS
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PPUSH
29394: CALL_OW 2
29398: ST_TO_ADDR
// b = 1 ;
29399: LD_ADDR_VAR 0 7
29403: PUSH
29404: LD_INT 1
29406: ST_TO_ADDR
// while b <= ( d - 1 ) do
29407: LD_VAR 0 7
29411: PUSH
29412: LD_VAR 0 5
29416: PUSH
29417: LD_INT 1
29419: MINUS
29420: LESSEQUAL
29421: IFFALSE 29727
// begin list_coords = Insert ( list_coords , 1 , [ x + b , y - d + b ] ) ;
29423: LD_ADDR_VAR 0 6
29427: PUSH
29428: LD_VAR 0 6
29432: PPUSH
29433: LD_INT 1
29435: PPUSH
29436: LD_VAR 0 1
29440: PUSH
29441: LD_VAR 0 7
29445: PLUS
29446: PUSH
29447: LD_VAR 0 2
29451: PUSH
29452: LD_VAR 0 5
29456: MINUS
29457: PUSH
29458: LD_VAR 0 7
29462: PLUS
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PPUSH
29468: CALL_OW 2
29472: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x + d , y + b ] ) ;
29473: LD_ADDR_VAR 0 6
29477: PUSH
29478: LD_VAR 0 6
29482: PPUSH
29483: LD_INT 1
29485: PPUSH
29486: LD_VAR 0 1
29490: PUSH
29491: LD_VAR 0 5
29495: PLUS
29496: PUSH
29497: LD_VAR 0 2
29501: PUSH
29502: LD_VAR 0 7
29506: PLUS
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PPUSH
29512: CALL_OW 2
29516: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x + d - b , y + d ] ) ;
29517: LD_ADDR_VAR 0 6
29521: PUSH
29522: LD_VAR 0 6
29526: PPUSH
29527: LD_INT 1
29529: PPUSH
29530: LD_VAR 0 1
29534: PUSH
29535: LD_VAR 0 5
29539: PLUS
29540: PUSH
29541: LD_VAR 0 7
29545: MINUS
29546: PUSH
29547: LD_VAR 0 2
29551: PUSH
29552: LD_VAR 0 5
29556: PLUS
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PPUSH
29562: CALL_OW 2
29566: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x - b , y + d - b ] ) ;
29567: LD_ADDR_VAR 0 6
29571: PUSH
29572: LD_VAR 0 6
29576: PPUSH
29577: LD_INT 1
29579: PPUSH
29580: LD_VAR 0 1
29584: PUSH
29585: LD_VAR 0 7
29589: MINUS
29590: PUSH
29591: LD_VAR 0 2
29595: PUSH
29596: LD_VAR 0 5
29600: PLUS
29601: PUSH
29602: LD_VAR 0 7
29606: MINUS
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL_OW 2
29616: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x - d , y - b ] ) ;
29617: LD_ADDR_VAR 0 6
29621: PUSH
29622: LD_VAR 0 6
29626: PPUSH
29627: LD_INT 1
29629: PPUSH
29630: LD_VAR 0 1
29634: PUSH
29635: LD_VAR 0 5
29639: MINUS
29640: PUSH
29641: LD_VAR 0 2
29645: PUSH
29646: LD_VAR 0 7
29650: MINUS
29651: PUSH
29652: EMPTY
29653: LIST
29654: LIST
29655: PPUSH
29656: CALL_OW 2
29660: ST_TO_ADDR
// list_coords = Insert ( list_coords , 1 , [ x - d + b , y - d ] ) ;
29661: LD_ADDR_VAR 0 6
29665: PUSH
29666: LD_VAR 0 6
29670: PPUSH
29671: LD_INT 1
29673: PPUSH
29674: LD_VAR 0 1
29678: PUSH
29679: LD_VAR 0 5
29683: MINUS
29684: PUSH
29685: LD_VAR 0 7
29689: PLUS
29690: PUSH
29691: LD_VAR 0 2
29695: PUSH
29696: LD_VAR 0 5
29700: MINUS
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PPUSH
29706: CALL_OW 2
29710: ST_TO_ADDR
// b = b + 1 ;
29711: LD_ADDR_VAR 0 7
29715: PUSH
29716: LD_VAR 0 7
29720: PUSH
29721: LD_INT 1
29723: PLUS
29724: ST_TO_ADDR
// end ;
29725: GO 29407
// result = result ^ list_coords ;
29727: LD_ADDR_VAR 0 4
29731: PUSH
29732: LD_VAR 0 4
29736: PUSH
29737: LD_VAR 0 6
29741: ADD
29742: ST_TO_ADDR
// end ;
29743: GO 29149
29745: POP
29746: POP
// end ;
29747: LD_VAR 0 4
29751: RET
// every 0 0$1 do var i ;
29752: GO 29754
29754: DISABLE
29755: LD_INT 0
29757: PPUSH
// begin repeat wait ( 0 0$1 ) ;
29758: LD_INT 35
29760: PPUSH
29761: CALL_OW 67
// if dont_gather_crates = 0 then
29765: LD_LOC 1
29769: PUSH
29770: LD_INT 0
29772: EQUAL
29773: IFFALSE 29777
// continue ;
29775: GO 29758
// i = 1 ;
29777: LD_ADDR_VAR 0 1
29781: PUSH
29782: LD_INT 1
29784: ST_TO_ADDR
// while i <= dont_gather_crates do
29785: LD_VAR 0 1
29789: PUSH
29790: LD_LOC 1
29794: LESSEQUAL
29795: IFFALSE 29875
// begin if GetResourceAmountXY ( dont_gather_crates [ i ] [ 1 ] , dont_gather_crates [ i ] [ 2 ] ) = 0 then
29797: LD_LOC 1
29801: PUSH
29802: LD_VAR 0 1
29806: ARRAY
29807: PUSH
29808: LD_INT 1
29810: ARRAY
29811: PPUSH
29812: LD_LOC 1
29816: PUSH
29817: LD_VAR 0 1
29821: ARRAY
29822: PUSH
29823: LD_INT 2
29825: ARRAY
29826: PPUSH
29827: CALL_OW 284
29831: PUSH
29832: LD_INT 0
29834: EQUAL
29835: IFFALSE 29859
// begin dont_gather_crates = Delete ( dont_gather_crates , i ) ;
29837: LD_ADDR_LOC 1
29841: PUSH
29842: LD_LOC 1
29846: PPUSH
29847: LD_VAR 0 1
29851: PPUSH
29852: CALL_OW 3
29856: ST_TO_ADDR
// continue ;
29857: GO 29785
// end ; i = i + 1 ;
29859: LD_ADDR_VAR 0 1
29863: PUSH
29864: LD_VAR 0 1
29868: PUSH
29869: LD_INT 1
29871: PLUS
29872: ST_TO_ADDR
// end ;
29873: GO 29785
// until false ;
29875: LD_INT 0
29877: IFFALSE 29758
// end ;
29879: PPOPN 1
29881: END
// export function GetListOfCratesInArea_ForGathering ( base , area ) ; var temp_list , c ; begin
29882: LD_INT 0
29884: PPUSH
29885: PPUSH
29886: PPUSH
// temp_list = GetListOfCratesInArea ( area ) ;
29887: LD_ADDR_VAR 0 4
29891: PUSH
29892: LD_VAR 0 2
29896: PPUSH
29897: CALL_OW 435
29901: ST_TO_ADDR
// result = [ ] ;
29902: LD_ADDR_VAR 0 3
29906: PUSH
29907: EMPTY
29908: ST_TO_ADDR
// if temp_list > 0 then
29909: LD_VAR 0 4
29913: PUSH
29914: LD_INT 0
29916: GREATER
29917: IFFALSE 30113
// begin c = 1 ;
29919: LD_ADDR_VAR 0 5
29923: PUSH
29924: LD_INT 1
29926: ST_TO_ADDR
// repeat if GetResourceTypeXY ( temp_list [ c ] , temp_list [ c + 1 ] ) <> mat_artifact and ( InArea ( temp_list [ c ] , temp_list [ c + 1 ] , GetBaseArea ( base ) ) or not [ temp_list [ c ] , temp_list [ c + 1 ] ] in dont_gather_crates ) then
29927: LD_VAR 0 4
29931: PUSH
29932: LD_VAR 0 5
29936: ARRAY
29937: PPUSH
29938: LD_VAR 0 4
29942: PUSH
29943: LD_VAR 0 5
29947: PUSH
29948: LD_INT 1
29950: PLUS
29951: ARRAY
29952: PPUSH
29953: CALL_OW 283
29957: PUSH
29958: LD_INT 4
29960: NONEQUAL
29961: PUSH
29962: LD_VAR 0 4
29966: PUSH
29967: LD_VAR 0 5
29971: ARRAY
29972: PPUSH
29973: LD_VAR 0 4
29977: PUSH
29978: LD_VAR 0 5
29982: PUSH
29983: LD_INT 1
29985: PLUS
29986: ARRAY
29987: PPUSH
29988: LD_VAR 0 1
29992: PPUSH
29993: CALL 8453 0 1
29997: PPUSH
29998: CALL_OW 309
30002: PUSH
30003: LD_VAR 0 4
30007: PUSH
30008: LD_VAR 0 5
30012: ARRAY
30013: PUSH
30014: LD_VAR 0 4
30018: PUSH
30019: LD_VAR 0 5
30023: PUSH
30024: LD_INT 1
30026: PLUS
30027: ARRAY
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_LOC 1
30037: IN
30038: NOT
30039: OR
30040: AND
30041: IFFALSE 30087
// result = result ^ [ [ temp_list [ c ] , temp_list [ c + 1 ] ] ] ;
30043: LD_ADDR_VAR 0 3
30047: PUSH
30048: LD_VAR 0 3
30052: PUSH
30053: LD_VAR 0 4
30057: PUSH
30058: LD_VAR 0 5
30062: ARRAY
30063: PUSH
30064: LD_VAR 0 4
30068: PUSH
30069: LD_VAR 0 5
30073: PUSH
30074: LD_INT 1
30076: PLUS
30077: ARRAY
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: EMPTY
30084: LIST
30085: ADD
30086: ST_TO_ADDR
// c = c + 2 ;
30087: LD_ADDR_VAR 0 5
30091: PUSH
30092: LD_VAR 0 5
30096: PUSH
30097: LD_INT 2
30099: PLUS
30100: ST_TO_ADDR
// until c > temp_list ;
30101: LD_VAR 0 5
30105: PUSH
30106: LD_VAR 0 4
30110: GREATER
30111: IFFALSE 29927
// end ; end ; end_of_file
30113: LD_VAR 0 3
30117: RET
// export function EndMission ; var val , b , temp_list , name_list , un_list ; begin
30118: LD_INT 0
30120: PPUSH
30121: PPUSH
30122: PPUSH
30123: PPUSH
30124: PPUSH
30125: PPUSH
// if survivors_found = 1 then
30126: LD_EXP 52
30130: PUSH
30131: LD_INT 1
30133: EQUAL
30134: IFFALSE 30147
// val = - 3 else
30136: LD_ADDR_VAR 0 2
30140: PUSH
30141: LD_INT 3
30143: NEG
30144: ST_TO_ADDR
30145: GO 30212
// case remote_built_and_tested of 0 :
30147: LD_EXP 56
30151: PUSH
30152: LD_INT 0
30154: DOUBLE
30155: EQUAL
30156: IFTRUE 30160
30158: GO 30172
30160: POP
// val = - 2 ; 1 :
30161: LD_ADDR_VAR 0 2
30165: PUSH
30166: LD_INT 2
30168: NEG
30169: ST_TO_ADDR
30170: GO 30212
30172: LD_INT 1
30174: DOUBLE
30175: EQUAL
30176: IFTRUE 30180
30178: GO 30192
30180: POP
// val = - 1 ; 2 :
30181: LD_ADDR_VAR 0 2
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: ST_TO_ADDR
30190: GO 30212
30192: LD_INT 2
30194: DOUBLE
30195: EQUAL
30196: IFTRUE 30200
30198: GO 30211
30200: POP
// val = 1 ; end ;
30201: LD_ADDR_VAR 0 2
30205: PUSH
30206: LD_INT 1
30208: ST_TO_ADDR
30209: GO 30212
30211: POP
// AddMedal ( RemoteControl , val ) ;
30212: LD_STRING RemoteControl
30214: PPUSH
30215: LD_VAR 0 2
30219: PPUSH
30220: CALL_OW 101
// SaveVariable ( val = 1 , Remote_control_tested_06 ) ;
30224: LD_VAR 0 2
30228: PUSH
30229: LD_INT 1
30231: EQUAL
30232: PPUSH
30233: LD_STRING Remote_control_tested_06
30235: PPUSH
30236: CALL_OW 39
// if survivors_found = 1 then
30240: LD_EXP 52
30244: PUSH
30245: LD_INT 1
30247: EQUAL
30248: IFFALSE 30261
// val = - 3 else
30250: LD_ADDR_VAR 0 2
30254: PUSH
30255: LD_INT 3
30257: NEG
30258: ST_TO_ADDR
30259: GO 30416
// begin val = 0 ;
30261: LD_ADDR_VAR 0 2
30265: PUSH
30266: LD_INT 0
30268: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_side , you ] , [ f_inarea , start_leave_area ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_engineer ] ] ] ) do
30269: LD_ADDR_VAR 0 3
30273: PUSH
30274: LD_INT 22
30276: PUSH
30277: LD_EXP 2
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 95
30288: PUSH
30289: LD_INT 4
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 2
30298: PUSH
30299: LD_INT 34
30301: PUSH
30302: LD_INT 32
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: PUSH
30309: LD_INT 34
30311: PUSH
30312: LD_INT 51
30314: PUSH
30315: EMPTY
30316: LIST
30317: LIST
30318: PUSH
30319: LD_INT 25
30321: PUSH
30322: LD_INT 2
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: LIST
30339: PPUSH
30340: CALL_OW 69
30344: PUSH
30345: FOR_IN
30346: IFFALSE 30378
// if GetCargo ( b , mat_siberit ) > 0 then
30348: LD_VAR 0 3
30352: PPUSH
30353: LD_INT 3
30355: PPUSH
30356: CALL_OW 289
30360: PUSH
30361: LD_INT 0
30363: GREATER
30364: IFFALSE 30376
// begin val = 1 ;
30366: LD_ADDR_VAR 0 2
30370: PUSH
30371: LD_INT 1
30373: ST_TO_ADDR
// break ;
30374: GO 30378
// end ;
30376: GO 30345
30378: POP
30379: POP
// if val = 0 then
30380: LD_VAR 0 2
30384: PUSH
30385: LD_INT 0
30387: EQUAL
30388: IFFALSE 30416
// if cargo_bay_captured then
30390: LD_EXP 57
30394: IFFALSE 30407
// val = - 1 else
30396: LD_ADDR_VAR 0 2
30400: PUSH
30401: LD_INT 1
30403: NEG
30404: ST_TO_ADDR
30405: GO 30416
// val = - 2 ;
30407: LD_ADDR_VAR 0 2
30411: PUSH
30412: LD_INT 2
30414: NEG
30415: ST_TO_ADDR
// end ; AddMedal ( SiberiteStolen , val ) ;
30416: LD_STRING SiberiteStolen
30418: PPUSH
30419: LD_VAR 0 2
30423: PPUSH
30424: CALL_OW 101
// SaveVariable ( val = 1 , Siberite_stolen_06 ) ;
30428: LD_VAR 0 2
30432: PUSH
30433: LD_INT 1
30435: EQUAL
30436: PPUSH
30437: LD_STRING Siberite_stolen_06
30439: PPUSH
30440: CALL_OW 39
// if survivors_found = 1 then
30444: LD_EXP 52
30448: PUSH
30449: LD_INT 1
30451: EQUAL
30452: IFFALSE 30465
// val = - 2 else
30454: LD_ADDR_VAR 0 2
30458: PUSH
30459: LD_INT 2
30461: NEG
30462: ST_TO_ADDR
30463: GO 30531
// if FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_arabian ] , [ f_type , unit_building ] ] ) = 0 then
30465: LD_INT 22
30467: PUSH
30468: LD_EXP 2
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 23
30479: PUSH
30480: LD_INT 2
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 21
30489: PUSH
30490: LD_INT 3
30492: PUSH
30493: EMPTY
30494: LIST
30495: LIST
30496: PUSH
30497: EMPTY
30498: LIST
30499: LIST
30500: LIST
30501: PPUSH
30502: CALL_OW 69
30506: PUSH
30507: LD_INT 0
30509: EQUAL
30510: IFFALSE 30522
// val = 1 else
30512: LD_ADDR_VAR 0 2
30516: PUSH
30517: LD_INT 1
30519: ST_TO_ADDR
30520: GO 30531
// val = - 1 ;
30522: LD_ADDR_VAR 0 2
30526: PUSH
30527: LD_INT 1
30529: NEG
30530: ST_TO_ADDR
// AddMedal ( DismantleBase , val ) ;
30531: LD_STRING DismantleBase
30533: PPUSH
30534: LD_VAR 0 2
30538: PPUSH
30539: CALL_OW 101
// SaveVariable ( val = 1 , Base_dismantled_06 ) ;
30543: LD_VAR 0 2
30547: PUSH
30548: LD_INT 1
30550: EQUAL
30551: PPUSH
30552: LD_STRING Base_dismantled_06
30554: PPUSH
30555: CALL_OW 39
// GiveMedals ( Medals ) ;
30559: LD_STRING Medals
30561: PPUSH
30562: CALL_OW 102
// SaveVariable ( survivors_found = 1 , Retreated_prematurely_06 ) ;
30566: LD_EXP 52
30570: PUSH
30571: LD_INT 1
30573: EQUAL
30574: PPUSH
30575: LD_STRING Retreated_prematurely_06
30577: PPUSH
30578: CALL_OW 39
// temp_list = FilterAllUnits ( [ [ f_side , you ] , [ f_inarea , start_leave_area ] , [ f_type , unit_human ] ] ) diff GetApes ( you ) ;
30582: LD_ADDR_VAR 0 4
30586: PUSH
30587: LD_INT 22
30589: PUSH
30590: LD_EXP 2
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 95
30601: PUSH
30602: LD_INT 4
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 21
30611: PUSH
30612: LD_INT 1
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: EMPTY
30620: LIST
30621: LIST
30622: LIST
30623: PPUSH
30624: CALL_OW 69
30628: PUSH
30629: LD_EXP 2
30633: PPUSH
30634: CALL 20972 0 1
30638: DIFF
30639: ST_TO_ADDR
// RewardPeople ( temp_list ) ;
30640: LD_VAR 0 4
30644: PPUSH
30645: CALL_OW 43
// SaveCharacters ( Heike , Heike_06 ) ;
30649: LD_EXP 7
30653: PPUSH
30654: LD_STRING Heike_06
30656: PPUSH
30657: CALL_OW 38
// SaveCharacters ( MarkB , MarkB_06 ) ;
30661: LD_EXP 17
30665: PPUSH
30666: LD_STRING MarkB_06
30668: PPUSH
30669: CALL_OW 38
// un_list = [ Sonya , Oswald , Ralph , Kowalski , Willard , Evelyn , Gordon , Suze , Olaf , Swansson ] ;
30673: LD_ADDR_VAR 0 6
30677: PUSH
30678: LD_EXP 8
30682: PUSH
30683: LD_EXP 9
30687: PUSH
30688: LD_EXP 10
30692: PUSH
30693: LD_EXP 11
30697: PUSH
30698: LD_EXP 12
30702: PUSH
30703: LD_EXP 13
30707: PUSH
30708: LD_EXP 14
30712: PUSH
30713: LD_EXP 15
30717: PUSH
30718: LD_EXP 18
30722: PUSH
30723: LD_EXP 21
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: LIST
30732: LIST
30733: LIST
30734: LIST
30735: LIST
30736: LIST
30737: LIST
30738: LIST
30739: ST_TO_ADDR
// name_list = [ Sonya , Oswald , Ralph , Kowalski , Willard , Evelyn , Gordon , Suze , Olaf , Swansson ] ;
30740: LD_ADDR_VAR 0 5
30744: PUSH
30745: LD_STRING Sonya
30747: PUSH
30748: LD_STRING Oswald
30750: PUSH
30751: LD_STRING Ralph
30753: PUSH
30754: LD_STRING Kowalski
30756: PUSH
30757: LD_STRING Willard
30759: PUSH
30760: LD_STRING Evelyn
30762: PUSH
30763: LD_STRING Gordon
30765: PUSH
30766: LD_STRING Suze
30768: PUSH
30769: LD_STRING Olaf
30771: PUSH
30772: LD_STRING Swansson
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: LIST
30779: LIST
30780: LIST
30781: LIST
30782: LIST
30783: LIST
30784: LIST
30785: LIST
30786: ST_TO_ADDR
// for val = 1 to un_list do
30787: LD_ADDR_VAR 0 2
30791: PUSH
30792: DOUBLE
30793: LD_INT 1
30795: DEC
30796: ST_TO_ADDR
30797: LD_VAR 0 6
30801: PUSH
30802: FOR_TO
30803: IFFALSE 30855
// if un_list [ val ] in temp_list then
30805: LD_VAR 0 6
30809: PUSH
30810: LD_VAR 0 2
30814: ARRAY
30815: PUSH
30816: LD_VAR 0 4
30820: IN
30821: IFFALSE 30853
// SaveCharacters ( un_list [ val ] , name_list [ val ] & _06 ) ;
30823: LD_VAR 0 6
30827: PUSH
30828: LD_VAR 0 2
30832: ARRAY
30833: PPUSH
30834: LD_VAR 0 5
30838: PUSH
30839: LD_VAR 0 2
30843: ARRAY
30844: PUSH
30845: LD_STRING _06
30847: STR
30848: PPUSH
30849: CALL_OW 38
30853: GO 30802
30855: POP
30856: POP
// SaveCharacters ( temp_list diff ( [ Heike , MarkB ] ^ un_list ) , Others_06 ) ;
30857: LD_VAR 0 4
30861: PUSH
30862: LD_EXP 7
30866: PUSH
30867: LD_EXP 17
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PUSH
30876: LD_VAR 0 6
30880: ADD
30881: DIFF
30882: PPUSH
30883: LD_STRING Others_06
30885: PPUSH
30886: CALL_OW 38
// YouWin ;
30890: CALL_OW 103
// end ;
30894: LD_VAR 0 1
30898: RET

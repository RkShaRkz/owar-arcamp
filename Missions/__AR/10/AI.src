

//Russians have unlimited resources
Every 0$10 do
     var base;
     begin
          if IsOk(ai_depot[1]) and GetSide(ai_depot[1]) = russians then  //Don't if the depot is burning, cf. module "Events" Function ResetRussianDepot
               begin
                    base = GetBase(ai_depot[1]);
                    SetResourceType(base,mat_cans,300);
                    SetResourceType(base,mat_oil,300);
                    SetResourceType(base,mat_siberit,0);
               end;

          enable;
     end;


On UnitDestroyed(un) do
     var side, temp_list, base;
     begin
          if un = Heike then
               begin
                    ExclusiveOn;
                    Wait(0$1);
                    YouLost('HeikeDead');
                    ExclusiveOff;
               end;

          traitors_humans = traitors_humans diff un;
          traitors_vehicles = traitors_vehicles diff un;
          russian_prisoners = russian_prisoners diff un;

          for base in ai_bases do
               begin
                    temp_list = ai_captured_buildings[base] diff un;
                    ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
               end;

          side = GetSide(un);

          if side <> russians then
               exit;

          //Update computer variables
          case GetType(un) of
               unit_human:
                    for base in ai_bases do
                         RemoveHumanFromVariables(base,un,true);
               unit_vehicle:
                    for base in ai_bases do
                         RemoveVehicleFromVariables(base,un);
               unit_building:
                    for base in ai_bases do
                         RemoveBuildingFromVariables(base,un);
          end;
     end;
Function RemoveBuildingFromVariables(base,building);
     var temp_list;
     begin
          temp_list = ai_all_buildings[base] diff building;
          ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

          if building = ai_building_under_construction[base] then
               ai_building_under_construction = Replace(ai_building_under_construction,base,0);

          UpdateBuildingBasicVariables(base,building,false);
     end;
Function RemoveVehicleFromVariables(base,vehicle);
     var temp_list;
     begin
          //Global "basis" lists of vehicles. If a vehicle belong to this base it will be in one
          //and only one of these lists.
          if vehicle in ai_vehicles_defend[base] then
               begin
                    temp_list = ai_vehicles_defend[base] diff vehicle;
                    ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
               end;

          if vehicle in ai_vehicles_attack[base] then
               begin
                    temp_list = ai_vehicles_attack[base] diff vehicle;
                    ai_vehicles_attack = Replace(ai_vehicles_attack,base,temp_list);
               end;

          if vehicle = ai_cargo_bay[base] then
               ai_cargo_bay = Replace(ai_cargo_bay,base,0);


          //Global "transient" lists of vehicles. Vehicles belonging to this base may be in one or more of these lists if
          //it performs a special or temporary job (you could say that the vehicle is in a special state).
          if vehicle in ai_retreating_vehicles_defend[base] then
               begin
                    temp_list = ai_retreating_vehicles_defend[base] diff vehicle;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);
               end;

          if vehicle in ai_vehicles_being_repaired[base] then
               begin
                    temp_list = ai_vehicles_being_repaired[base] diff vehicle;
                    ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);
               end;

          if vehicle in ai_refuel_vehicles_list[base] then
               begin
                    temp_list = ai_refuel_vehicles_list[base] diff vehicle;
                    ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);
               end;

          if vehicle = ai_vehicle_being_moved[base] then
               ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);

          if vehicle in ai_vehicles_having_been_moved[base] then
               begin
                    temp_list = ai_vehicles_having_been_moved[base] diff vehicle;
                    ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,temp_list);
               end;
     end;
Function RemoveHumanFromVariables(base,human,check_if_base_is_dead);
     var temp_list;
     begin        
          //Global "basis" lists of humans. If a human belong to this base he/she will be in one
          //and only one of these lists.
          if human in ai_soldiers[base] then
               begin
                    temp_list = ai_soldiers[base] diff human;
                    ai_soldiers = Replace(ai_soldiers,base,temp_list);
               end;

          if human in ai_attacking_soldiers[base] then
               begin
                    temp_list = ai_attacking_soldiers[base] diff human;
                    ai_attacking_soldiers = Replace(ai_attacking_soldiers,base,temp_list);
               end;

          if human in ai_engineers[base] then
               begin
                    temp_list = ai_engineers[base] diff human;
                    ai_engineers = Replace(ai_engineers,base,temp_list);
               end;

          if human in ai_apemen_engineers[base] then
               begin
                    temp_list = ai_apemen_engineers[base] diff human;
                    ai_apemen_engineers = Replace(ai_apemen_engineers,base,temp_list);
               end;

          if human in ai_mechanics_defend[base] then
               begin
                    temp_list = ai_mechanics_defend[base] diff human;
                    ai_mechanics_defend = Replace(ai_mechanics_defend,base,temp_list);
               end;

          if human in ai_mechanics_attack[base] then
               begin
                    temp_list = ai_mechanics_attack[base] diff human;
                    ai_mechanics_attack = Replace(ai_mechanics_attack,base,temp_list);
               end;

          if human in ai_scientists[base] then
               begin
                    temp_list = ai_scientists[base] diff human;
                    ai_scientists = Replace(ai_scientists,base,temp_list);
               end;

          if human in ai_attacking_scientists[base] then
               begin
                    temp_list = ai_attacking_scientists[base] diff human;
                    ai_attacking_scientists = Replace(ai_attacking_scientists,base,temp_list);
               end;


          //Global "transient" lists of humans. Humans belonging to this base may be in one or more of these lists if
          //he/she performs a special or temporary job (you could say that the human is in a special state).
          if human in ai_heal_these_humans[base] then
               begin
                    temp_list = ai_heal_these_humans[base] diff human;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);
               end;

          if human = ai_building_constructor[base] then
               ai_building_constructor = Replace(ai_building_constructor,base,0);

          if human in ai_retreating_attacking_humans[base] then
               begin
                    temp_list = ai_retreating_attacking_humans[base] diff human;
                    ai_retreating_attacking_humans = Replace(ai_retreating_attacking_humans,base,temp_list);
               end;

          //If there are no human units left the base is "dead"
          if check_if_base_is_dead then
               if ((ai_soldiers[base] ^ ai_attacking_soldiers[base] ^ ai_engineers[base] ^ ai_apemen_engineers[base] ^ ai_mechanics_defend[base] ^ ai_mechanics_attack[base] ^ ai_scientists[base] ^
                   ai_attacking_scientists[base]) diff 0) = 0 then
                    ai_bases = ai_bases diff base;
     end;


Function GetBaseNation(base);
     begin
          case base of
               1: result = nation_russian;
          end;
     end;

Function FindBase(un);
     var i, hexes, k;
     begin
          result = 1;
     end;

Function GetBaseSide(base);
     begin
          result = russians;
     end;

Function GetBaseArea(base);
     begin
          result = ru_base_area;
     end;


//Soldiers
//Keep them in bunkers/armouries. If that's not possible due to structure restrictions then help construct buildings. Else retreat to
//the center of the base.
Every 0$1 do
     var side, i, temp_list, buildings_list, soldiers_list, temp_unit, base, val, temp_list_2, temp_unit_2, j, leave_folks_for_defences, num_sol;
     var temp_list_3, bunkers, under_attack;
     begin
          side = russians;

          for base in ai_bases do
               begin
                    soldiers_list = ai_soldiers[base];
                    under_attack := BaseUnderAttack(base,-1);


                    //Identify soldiers who need healing.
                    temp_list = ai_heal_these_humans[base];
                    for i in soldiers_list diff ai_heal_these_humans[base] do
                         if GetLives(i) < 800 then
                              temp_list = temp_list ^ i;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);

                    if not under_attack then  //Soldiers don't care if they are wounded if the base is under attack
                         begin
                              //Make soldiers needing healing go outside (else they won't be healed, cf. the healing
                              //code (controlling scientists) below.
                              for i in ai_heal_these_humans[base] do
                                   if i in soldiers_list then
                                        case GetType(IsInUnit(i)) of
                                             unit_vehicle: ComExitVehicle(i);
                                             unit_building: ComExitBuilding(i);
                                        end;

                              soldiers_list = soldiers_list diff ai_heal_these_humans[base];
                         end;

                    if soldiers_list = 0 then
                         continue;


                    //Find the bunkers which need to be occupied.
                    //Remember which soldiers are already inside a building.
                    //Don't occupy b_bunker if there is no power.
                    i = false;
                    if IsOk(ai_depot[base]) then
                         if GetEnergy(GetBase(ai_depot[base]))[4] > 0 then
                              i = true;

                    if i then
                         bunkers = ai_bunkers[base]
                    else
                         begin
                              bunkers = [];
                              for i in ai_bunkers[base] do
                                   if GetBType(i) = b_breastwork then
                                        bunkers = bunkers ^ i;
                         end;

                    buildings_list = [];
                    for i in UnitFilter(bunkers,[f_ok]) do
                         begin
                              temp_unit = UnitsInside(i);
                              if temp_unit = 0 then
                                   buildings_list = buildings_list ^ i
                              else soldiers_list = soldiers_list diff temp_unit;
                         end;


                    //The best soldiers should go to the bunkers. The rest in the armoury.
                    //If the base is under attack then just the nearest soldier.
                    if buildings_list > 0 then
                         begin
                              if not under_attack then
                                   begin
                                        temp_list = [];
                                        for i in soldiers_list do
                                             temp_list = temp_list ^ GetSkill(i,skill_combat);
                                        soldiers_list = SortListByListDesc(soldiers_list,temp_list);
                                   end;

                              for i = 1 to buildings_list do
                                   begin
                                        if soldiers_list = 0 then
                                             break;

                                        if not under_attack then
                                             temp_unit = soldiers_list[1]
                                        else
                                             begin
                                                  temp_list = [];
                                                  for j in soldiers_list do
                                                       temp_list = temp_list ^ GetDistUnits(j,buildings_list[i]);

                                                  temp_unit = WorstFromListByList(soldiers_list,temp_list);
                                             end;

                                        ComEnterUnit(temp_unit,buildings_list[i]);
                                        soldiers_list = soldiers_list diff temp_unit;
                                   end;
                         end;


                    //The rest enter armouries (if possible)
                    DistributeHumansToBuildings(base,soldiers_list, UnitFilter(ai_armouries[base],[[f_ok],[f_not,[f_constructed]]]),
                         false,6,true,true);
               end;

          enable;
     end;


//Function which sends humans to buildings, distributing them equally and changing their class (if specified).
//The humans there wasn't space for will stay near the pullback hex.
//base - the base calling the function.
//human_list - list of humans
//building_list - list of buildings
//change_to_this_class - class to change to when the human has entered the building (false if none)
//building_capacity - the number of humans the building can handle
//help_building - boolean. If true then units which could not enter a building will help building the building under
//construction (if any).
//aggressive_pullback - boolean. True if movement to pullback hex should be aggressive (else just normal move)
Function DistributeHumansToBuildings(base,human_list,building_list,change_to_this_class,building_capacity,help_building,aggressive_pullback);
     var i, temp_list, val, temp_unit, area, under_attack;
     begin
          if human_list = 0 then
               exit;

          area = ru_base_area;
          under_attack = BaseUnderAttack(base,-1);

          val = building_list+0;
          while val > 0 and human_list > 0 do
               begin
                    //Rearrange "human_list" so humans already in inside this building goes
                    //first in the list. Else this algorithm could pick 6 people for a barracks
                    //let's say 2 outside and 4 actually in the barracks but there is a 5. unit
                    //inside the barracks already which is further down "human_list"- the result is
                    //one human can't get in because there isn't space.
                    temp_list = [];
                    for i in human_list do
                         if IsInUnit(i) = building_list[val] then
                              temp_list = temp_list ^ i;
                    human_list = temp_list ^ (human_list diff temp_list);

                    //Distribute humans equally to the buildings
                    temp_list = [];
                    for i = 1 to human_list div val do
                         begin
                              if i > building_capacity then
                                   break;

                              temp_list = temp_list ^ human_list[1];
                              human_list = Delete(human_list,1);
                         end;

                    for i in temp_list do
                         begin
                              temp_unit = IsInUnit(i);
                              if temp_unit <> building_list[val] then
                                   case GetType(IsInUnit(i)) of
                                        unit_vehicle: ComExitVehicle(i);
                                        unit_building: ComExitBuilding(i);
                                        else
                                             begin
                                                  if IsInArea(i,area) or not aggressive_pullback then
                                                       ComEnterUnit(i,building_list[val])
                                                  else
                                                       ComAgressiveMove(i,GetX(building_list[val]),GetY(building_list[val]));

                                                  if change_to_this_class > 0 then
                                                       if GetClass(i) <> change_to_this_class and GetNation(i) <> nation_nature then  //ignore apemen
                                                            AddComChangeProfession(i,change_to_this_class);
                                             end;
                                   end;
                         end;

                    val = val - 1;
               end;

          if human_list > 0 then
               if ai_building_under_construction[base] > 0 and help_building and not under_attack then
                    begin
                         for i in human_list do
                              SetTaskList(i,[['h',0,0,ai_building_under_construction[base],0,0,0]]);  //'h' is "help building building"
                    end
               else
                    for i in human_list do
                         if GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 4 then
                              if aggressive_pullback then
                                   ComAgressiveMove(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2])
                              else
                                   ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);
     end;


//Engineers and Apemen Engineers
//These are the priorities (descending order):
//- If an engineer is hurt, them pull him/her back for healing.
//- Reparation of red buildings
//- Reparation of any building
//- Reconstruct destroyed buildings if necessary, but only if the base is not under attack (only engineers)
//- Gather crates, but only if the base is not under attack
//- Return to and stay inside the depot (if possible).
Every 0$1 do
     var side, i, engineers_list, temp_list, buildings_list, temp_unit, away_dist, temp_list_2, base, apemen_engineers_list;
     var humans_list, k;
     var under_attack;
     begin
          side = russians;

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    under_attack = BaseUnderAttack(base,-1);

                    //Reset "move empty manual vehicles so we can build our building"-variables if we are under attack so we can use our vehicles freely.
                    if under_attack then
                         begin
                              ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);
                              ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,[]);
                         end;


                    engineers_list = ai_engineers[base] diff ai_heal_these_humans[base];
                    apemen_engineers_list = ai_apemen_engineers[base] diff ai_heal_these_humans[base];

                    //Identify engineers who need healing
                    temp_list = ai_heal_these_humans[base];
                    humans_list = engineers_list ^ apemen_engineers_list;
                    i = 1;
                    while i <= humans_list do
                         begin
                              if GetLives(humans_list[i]) <= 700 then
                                   begin
                                        temp_list = temp_list ^ humans_list[i];
                                        engineers_list = engineers_list diff humans_list[i];
                                        apemen_engineers_list = apemen_engineers_list diff humans_list[i];
                                        humans_list = Delete(humans_list,i);
                                        i = i - 1;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    if engineers_list = 0 and apemen_engineers_list = 0 then
                         continue;


                    //Recapture buildings if necessary. Depots first. Here we assume the player hasn't changed the base
                    //of the captured building.
                    //Apemen engineers can't capture buildings.
                    temp_list_2 = UnitFilter(engineers_list,[f_class,class_engineer]);
                    if ai_captured_buildings[base] > 0 and temp_list_2 > 0 then
                         begin
                              temp_list = [];
                              for i in ai_captured_buildings[base] do
                                   if GetBType(i) in [b_depot,b_warehouse] then
                                        temp_list = temp_list ^ 1
                                   else
                                        temp_list = temp_list ^ 0;

                              temp_list = SortListByListDesc(ai_captured_buildings[base],temp_list);

                              //Normal "ComEnterUnit" for capturing doesn't work for buildings which can't be entered (e.g. power plants).
                              temp_list_2 = GetHumansOutOfUnits(temp_list_2);
                              if temp_list_2 > 0 then
                                   begin
                                        temp_list_2 = SortListByListDesc(temp_list_2, temp_list_2);  //To ensure we take the same unit each time
                                        SetTaskList(temp_list_2[1],[['e',GetX(temp_list[1]),GetY(temp_list[1]),temp_list[1],0,0,0]]);
                                        engineers_list = engineers_list diff temp_list_2[1];
                                   end;

                              if engineers_list = 0 and apemen_engineers_list = 0 then
                                   continue;
                         end;


                    //Find buildings which need to be repaired. At least one engineer for each if possible.
                    i = 1;
                    buildings_list = [];
                    repeat
                         case i of
                              1: buildings_list = UnitFilter(ai_all_buildings[base],[f_not,[f_ok]]);  //If building is dead then it won't be part of ai_all_buildings
                              2: buildings_list = UnitFilter(ai_all_buildings[base],[f_not,[f_lives,1000]]);
                         end;

                         i = i + 1;
                    until buildings_list > 0 or i > 2;

                    if buildings_list > 0 then
                         begin
                              humans_list = engineers_list ^ apemen_engineers_list;
                              humans_list = GetHumansOutOfUnits(humans_list);

                              repeat
                                   i = 1;
                                   while i <= buildings_list do
                                        begin
                                             if humans_list = 0 then
                                                  break;

                                             temp_unit = NearestUnitToUnit(humans_list,buildings_list[i]);
                                             ComRepairBuilding(temp_unit,buildings_list[i]);

                                             humans_list = humans_list diff temp_unit;
                                             engineers_list = engineers_list diff temp_unit;
                                             apemen_engineers_list = apemen_engineers_list diff temp_unit;

                                             i = i + 1;
                                        end;

                              until humans_list = 0;

                              continue;
                         end;


                    if not under_attack then
                         begin
                              //Reconstruct buildings if any has been destroyed.
                              //First check if a building is already being constructed - then build that one first.
                              //Upgrading buildings can be hard if the building is working or something, so check if the
                              //building is actually under construction (or being upgraded) - if not then reset the
                              //relevant variables.
                              if ai_building_under_construction[base] > 0 then
                                   if BuildingStatus(ai_building_under_construction[base]) = bs_build then
                                        begin
                                             for i in GetHumansOutOfUnits(engineers_list ^ apemen_engineers_list) do
                                                  ComRepairBuilding(i,ai_building_under_construction[base]);

                                             continue;
                                        end
                                   else
                                        begin
                                             ComCancel(ai_building_under_construction[base]);  //To make sure upgrade of building is possible
                                             ai_building_under_construction = Replace(ai_building_under_construction,base,0);
                                        end;

                              //Only rebuilt as many buildings as legal
                              if ( ai_all_buildings[base] < ai_buildings_locations[base] and rus_num_building_rebuild > 0 ) or ai_upcoming_building_data[base] > 0 then
                                   begin
                                        //Decide which building to construct. We take the first building in the location list which is
                                        //arranged in prioritated order.
                                        if ai_upcoming_building_data[base] = 0 then
                                             begin
                                                  temp_list = [];
                                                  for i in ai_buildings_locations[base] do
                                                       if GetBType(HexInfo(i[1],i[2])) = -1 then  //no building on the spot
                                                            begin
                                                                 temp_list = i;
                                                                 break;
                                                            end;
                                                                        
                                                  if temp_list > 0 then //Not necessarily the case (one of our buildings could have been captured)
                                                       begin
                                                            //If the building is a bunker then check if we have enough soldiers
                                                            //to occupy it. If not then build a turret instead.
                                                            if temp_list[4] = b_bunker and GetBaseNation(base) in [nation_american,nation_russian] then
                                                                 begin
                                                                      k = 0;

                                                                      for i in ai_buildings_locations[base] do
                                                                           if i[4] in [b_breastwork,b_bunker,b_armoury,b_barracks,b_fort] then
                                                                                k = k + 1;

                                                                      if k > ai_soldiers[base] then
                                                                           begin
                                                                                //Permanently change this to a turret. It would be nice if it would still be built as a
                                                                                //bunker if soldiers are added later but that's a rare case and adds unnecessary complexity.
                                                                                for i = 1 to ai_buildings_locations[base] do
                                                                                     if ai_buildings_locations[base][i] = temp_list then
                                                                                          begin
                                                                                               temp_list_2 = Replace(ai_buildings_locations[base][i],4,b_turret);
                                                                                               temp_list_2 = Replace(ai_buildings_locations[base],i,temp_list_2);
                                                                                               ai_buildings_locations = Replace(ai_buildings_locations,base,temp_list_2);

                                                                                               break;
                                                                                          end;

                                                                                temp_list = Replace(temp_list,4,b_turret);
                                                                           end;
                                                                 end;

                                                            ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,temp_list);
                                                       end;
                                             end;


                                        if ai_upcoming_building_data[base] > 0 then
                                             begin
                                                  //Find the best engineer to construct the building
                                                  if ai_building_constructor[base] = 0 then
                                                       begin
                                                            temp_list_2 = UnitFilter(ai_engineers[base],[f_class,class_engineer]);

                                                            if temp_list_2 > 0 then
                                                                 begin
                                                                      temp_list = [];
                                                                      for i in temp_list_2 do
                                                                           temp_list = temp_list ^ GetSkill(i,skill_engineering);
                                                                      ai_building_constructor = Replace(ai_building_constructor,base, BestFromListByList(temp_list_2,temp_list) );
                                                                 end;
                                                       end;

                                                  if ai_building_constructor[base] in engineers_list and ai_building_constructor[base] > 0 then
                                                       begin
                                                            engineers_list = engineers_list diff ai_building_constructor[base];

                                                            //Move vehicles away from the building site.
                                                            away_dist = 7; //Max distance needed for a workshop
                                                            if ai_vehicle_being_moved[base] = 0 then
                                                                 begin
                                                                      temp_list = UnitFilter(ai_vehicles_defend[base] ^ ai_cargo_bay[base],
                                                                                             [[f_control,control_manual],[f_empty],[f_distxy,ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],away_dist]]);  //Don't consider "ai_vehicles_attack" - they will soon move by themselves
                                                                      if temp_list > 0 then
                                                                           begin
                                                                                ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,temp_list[1]);
                                                                                temp_list_2 = ai_vehicles_having_been_moved[base] ^ temp_list[1];
                                                                                ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,temp_list_2);
                                                                           end
                                                                      else
                                                                           //Build/upgrade the building
                                                                           case GetType(IsInUnit(ai_building_constructor[base])) of
                                                                                unit_building: ComExitBuilding(ai_building_constructor[base]);
                                                                                unit_vehicle: ComExitVehicle(ai_building_constructor[base]);
                                                                                else
                                                                                case GetBType(HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2])) of
                                                                                     -1: begin
                                                                                          case ai_upcoming_building_data[base][4] of
                                                                                               b_warehouse: i = b_depot;
                                                                                               b_factory: i = b_workshop;
                                                                                               b_lab_half,b_lab_full: i = b_lab;
                                                                                               b_barracks: i = b_armoury;
                                                                                               else i = ai_upcoming_building_data[base][4];
                                                                                          end;

                                                                                          ComBuild(ai_building_constructor[base],i,ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],ai_upcoming_building_data[base][3]);
                                                                                     end;
                                                                                     b_depot: begin
                                                                                          ComUpgrade(ai_depot[base]);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,ai_depot[base]);
                                                                                     end;
                                                                                     b_workshop: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_lab,b_lab_half: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);

                                                                                          if ai_upcoming_building_data[base][5] <> b_lab_basic and not ai_upcoming_building_data[base][5] in [GetLabKind(temp_unit,1),GetLabKind(temp_unit,2)] then
                                                                                               ComUpgradeLab(temp_unit,ai_upcoming_building_data[base][5])
                                                                                          else
                                                                                               if ai_upcoming_building_data[base][6] <> b_lab_basic then
                                                                                                    ComUpgradeLab(temp_unit,ai_upcoming_building_data[base][6])
                                                                                               else  //should never happen
                                                                                                    begin
                                                                                                         ai_building_constructor = Replace(ai_building_constructor,base,0);
                                                                                                         ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);
                                                                                                    end;

                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                     b_armoury: begin
                                                                                          temp_unit = HexInfo(ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]);
                                                                                          ComUpgrade(temp_unit);
                                                                                          ai_building_under_construction = Replace(ai_building_under_construction,base,temp_unit);
                                                                                     end;
                                                                                end;
                                                                           end;
                                                                 end
                                                            else
                                                                 if UnitsInside(ai_vehicle_being_moved[base]) > 0 then
                                                                      begin
                                                                           if GetDistUnitXY(ai_vehicle_being_moved[base],ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2]) <= away_dist then
                                                                                AI_GetAwayFromXY(ai_vehicle_being_moved[base],ai_upcoming_building_data[base][1],ai_upcoming_building_data[base][2],away_dist+2,false)
                                                                           else
                                                                                ai_vehicle_being_moved = Replace(ai_vehicle_being_moved,base,0);
                                                                      end
                                                                 else
                                                                      case GetType(IsInUnit(ai_building_constructor[base])) of
                                                                           unit_building: ComExitBuilding(ai_building_constructor[base]);
                                                                           unit_vehicle: ComExitVehicle(ai_building_constructor[base]);
                                                                           else
                                                                                ComEnterUnit(ai_building_constructor[base],ai_vehicle_being_moved[base]);
                                                                      end;
                                                       end;
                                             end;
                                   end;

                              //Gather crates in the vicinity of the base.
                              //Everyone go after the same bunch of crates.
                              case side of
                                   russians: temp_list = GetListOfCratesInArea(crate_gather_area);
                              end;
                              if temp_list > 0 and ai_depot[base] > 0 then
                                   begin
                                        while temp_list > 0 do
                                             begin
                                                  if GetResourceTypeXY(temp_list[1],temp_list[2]) = mat_artefact then  //Don't pick up artefact
                                                       begin
                                                            temp_list = Delete(temp_list,1);
                                                            temp_list = Delete(temp_list,1);
                                                       end
                                                  else
                                                       break;
                                             end;

                                        if temp_list > 0 then
                                             begin
                                                  ComCollect(GetHumansOutOfUnits(engineers_list ^ apemen_engineers_list),temp_list[1],temp_list[2]);
                                                  continue;
                                             end;
                                   end;
                         end;


                    //Return to and stay inside the depot (if possible)
                    DistributeHumansToBuildings(base,engineers_list ^ apemen_engineers_list, UnitFilter(ai_depot[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_engineer,6,false,false);
               end;

          until false;
     end;
On BuildingStarted(building,builder) do
     var side, base;
     begin
          side = GetSide(building);
          if side <> russians then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          ai_building_constructor = Replace(ai_building_constructor,base,0);
          ai_vehicles_having_been_moved = Replace(ai_vehicles_having_been_moved,base,[]);

          //ONLY 1 building is under construction at a time!
          ai_building_under_construction = Replace(ai_building_under_construction,base,building);

          rus_num_building_rebuild = rus_num_building_rebuild - 1;
     end;
On BuildingComplete(building) do
     var side, base, temp_list;
     begin
          side = GetSide(building);
          if side <> russians then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          BuildUpgradeCommon(base,building);

          temp_list = ai_all_buildings[base] ^ building;
          ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

          UpdateBuildingBasicVariables(base,building,true);
     end;
On UpgradeComplete(building) do
     var side, base;
     begin
          side = GetSide(building);
          if side <> russians then
               exit;

          base = FindBase(building);
          if base = 0 then
               exit;

          BuildUpgradeCommon(base,building);
     end;
Function BuildUpgradeCommon(base,building);
     begin
          //Some buildings require upgrade - e.g. workshop -> factory
          if GetBType(building) = ai_upcoming_building_data[base][4] then
               ai_upcoming_building_data = Replace(ai_upcoming_building_data,base,[]);

          ai_building_under_construction = Replace(ai_building_under_construction,base,0);
     end;
On BuildingCaptured(captured_building,building_former_side,capturing_unit) do
     var temp_list, base;
     begin
          base = FindBase(captured_building);

          if base = 0 then
               exit;

          if building_former_side = GetBaseSide(base) then
               begin
                    if captured_building in ai_all_buildings[base] then
                         begin
                              //Someone captured one of our buildings!
                              RemoveBuildingFromVariables(base,captured_building);

                              temp_list = ai_captured_buildings[base] ^ captured_building;
                              ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
                         end;
               end
          else
               begin
                    if GetSide(captured_building) = GetBaseSide(base) then
                         begin
                              //Ha! We captured it back again!
                              temp_list = ai_all_buildings[base] ^ captured_building;
                              ai_all_buildings = Replace(ai_all_buildings,base,temp_list);

                              UpdateBuildingBasicVariables(base,captured_building,true);

                              temp_list = ai_captured_buildings[base] diff captured_building;
                              ai_captured_buildings = Replace(ai_captured_buildings,base,temp_list);
                         end;
               end;
     end;


//Function which orders human units inside other units to exit them. Returns a list with the units which weren't inside other units.
Export Function GetHumansOutOfUnits(un_list);
     var i;
     begin
          result = [];
          for i in un_list do
               case GetType(IsInUnit(i)) of
                    unit_building: ComExitBuilding(i);
                    unit_vehicle: ComExitVehicle(i);
                    else result = result ^ i;
               end;
     end;


//Function which tells if a base is under attack.
//attack_side - side which is attacking def_side's base. -1 if any enemy side of the base's side.
Export Function BaseUnderAttack(base,attack_side);
     var area, def_side, temp_list, i;
     begin
          result = false;

          def_side = GetBaseSide(base);
          area = GetBaseArea(base);

          if attack_side = def_side then
               exit;

          if attack_side = -1 then
               begin
                    if FilterAllUnits([[f_enemy,def_side],[f_inarea,area]]) > 0 then
                         begin
                              result = true;
                              exit;
                         end;

                    if ContactTime(def_side) >= 0$10 then
                         exit;

                    //if ListFilterNearArea( FilterAllUnits([f_enemy,def_side]) ,area) = 0 then
                    //     exit;
                    //The above was the former way of checking if enemy units was nearby but this implied looping through
                    //a lot of units on the map (in function ListFilterNearArea). This caused laggs. Filter-functions like
                    //FilterAllUnits are much much faster than loops with function calls. All we need is to assume that no
                    //unit inside another base's area will ever attack another base which seems reasonable.
                    temp_list = [];
                    for i in (ai_bases diff base) do
                         temp_list = Insert(temp_list,1,[f_not,[f_inarea,GetBaseArea(i)]]);

                    temp_list = FilterAllUnits([[f_enemy,def_side],[f_not,[f_type,unit_building]]] ^ temp_list);
                    if not AnyNearBaseArea(temp_list,base) then
                         exit;
               end
          else
               begin
                    if FilterAllUnits([[f_side,attack_side],[f_inarea,area]]) > 0 then
                         begin
                              result = true;
                              exit;
                         end;

                    if ContactTime([def_side,attack_side]) >= 0$10 then
                         exit;

                    //if ListFilterNearArea( FilterAllUnits([f_side,attack_side]) ,area) = 0 then
                    //     exit;
                    temp_list = [];
                    for i in (ai_bases diff base) do
                         temp_list = Insert(temp_list,1,[f_not,[f_inarea,GetBaseArea(i)]]);

                    temp_list = FilterAllUnits([[f_side,attack_side],[f_not,[f_type,unit_building]]] ^ temp_list);
                    if not AnyNearBaseArea(temp_list,base) then
                         exit;
               end;

          result = true;
     end;
Export Function ListFilterNearArea(list,area);
     var i;
     begin
          result = [];

          for i in list do
               if GetDistUnitArea(i,area) <= ai_near_base_dist then
                    result = result ^ i;
     end;
Function AnyNearBaseArea(list,base);
     var i, area;
     begin
          result = false;
          area = GetBaseArea(base);

          for i in list do
               if GetDistUnitArea(i,area) <= ai_near_base_dist then
                    begin
                         result = true;
                         break;
                    end;
     end;



//Mechanics (defending, i.e. in the base)
//Priorities if base is under attack (descending):
//- If a mechanic is hurt, pull him back for healing, but not if he/she is driving a vehicle, but if he is near an empty vehicle then go inside that one instead.
//- Defend the base using the war vehicles in the base
//- Stay in factory
//Priorites if everything is normal (decending):
//- If a mechanic is hurt, pull him back for healing, but not if he/she is driving a vehicle.
//- Refuel vehicles
//- Drive away vehicles which are blocking the factory entrance / park vehicles properly on the vehicle pullback hexes
//- Repair damaged war vehicles within the base
//- Stay in factory (and possibly construct a vehicle or weapon)
Every 0$1 do
     var side, base, i, mechanics_list, temp_list, temp_list_3, temp_unit, vehicles_list, allowed_to_repair_vehicles;
     var under_attack, free_parking_spots, k, vehicles_drivers, temp_list_2, area;
     begin
          side = russians;
          area = ru_base_area;

          //Index is vehicle id, value is driver id.
          //For use to ensure the driver first chosen to drive the
          //vehicle goes for it (doesn't change to another driver).
          vehicles_drivers = [];

          repeat
          wait(0$1);
    
          for base in ai_bases do
               begin
                    under_attack = BaseUnderAttack(base,-1);


                    //Update vehicles drivers so vehicles with a driver no longer has that driver assigned
                    //so a possible new driver can be assigned next time.
                    for i in ai_vehicles_defend[base] do
                         if vehicles_drivers >= i then
                              if vehicles_drivers[i] > 0 then
                                   if IsInUnit(vehicles_drivers[i]) = i or IsDead(vehicles_drivers[i]) then
                                        vehicles_drivers = Replace(vehicles_drivers,i,0);
                    

                    mechanics_list = UnitFilter(ai_mechanics_defend[base] diff ai_heal_these_humans[base],[f_not,[f_driving]]);


                    //Identify mechanics who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= mechanics_list do
                         begin
                              if GetLives(mechanics_list[i]) <= 900 then
                                   begin
                                        temp_list = temp_list ^ mechanics_list[i];
                                        mechanics_list = Delete(mechanics_list,i);
                                        i = i - 1;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Find vehicles which no longer need to be repaired (fully repaired).
                    temp_list = [];
                    for i in ai_vehicles_being_repaired[base] do
                         if GetLives(i) < 1000 then
                              temp_list = temp_list ^ i;
                    ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);


                    //Find vehicles which do no longer need to retreat (they have been fully repaired or are being repaired)
                    temp_list = [];
                    for i in ai_retreating_vehicles_defend[base] diff ai_vehicles_being_repaired[base] do
                         if GetLives(i) < 1000 then
                              temp_list = temp_list ^ i;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);


                    //Identify defending vehicles which need to retreat.
                    //Make vehicles retreat if they exceed a certain threshold of damage. Works for any amount of health
                    //(except full health) but is only used when the vehicles are burning. Defend the base at all costs!
                    temp_list = ai_retreating_vehicles_defend[base];
                    for i in ai_vehicles_defend[base] diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base]) do
                         if GetLives(i) <= 250 then
                              temp_list = temp_list ^ i;
                    ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);


                    //Find vehicles which no longer need to refuel.
                    //If a vehicles was scheduled to refuel but didn't make it before the base was attacked
                    //and was added to retreating vehicles during the attack it must be removed from
                    //refueling vehicles.
                    temp_list = [];
                    for i in ai_refuel_vehicles_list[base] diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) do
                         if GetFuel(i) < 95 then
                              temp_list = temp_list ^ i;
                    ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);


                    if under_attack then
                         begin
                              //Find the vehicles which need a driver and get them a driver (take the
                              //nearest available mechanic).
                              vehicles_list = ai_vehicles_defend[base] diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]);

                              temp_list = UnitFilter(vehicles_list,[[f_control,control_manual],[f_ok],[f_empty],[f_inarea,area]]);
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];

                              //Order the vehicles to attack an enemy unit near the base.
                              //temp_list = FilterAllUnits([[f_enemy,side],[f_ok],[f_distxy,ai_buildings_locations[base][1][1],ai_buildings_locations[base][1][2],ai_near_base_dist]]);
                              temp_list = ListFilterNearArea( FilterAllUnits([[f_enemy,side],[f_ok]]) ,area);
                              if temp_list > 0 then
                                   ComAgressiveMove(vehicles_list,GetX(temp_list[1]),GetY(temp_list[1]));
                         end
                    else
                         if IsOk(ai_depot[base]) then
                         begin
                              //If some vehicles need to refuel then make 'em refuel.
                              temp_list = ai_refuel_vehicles_list[base];
                              for i in ai_vehicles_defend[base] diff ai_refuel_vehicles_list[base] do
                                   if GetFuel(i) < 70 and GetEngine(i) = engine_combustion then
                                        temp_list = temp_list ^ i;
                              temp_list = temp_list diff (ai_retreating_vehicles_defend[base] ^ ai_vehicles_being_repaired[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]);
                              ai_refuel_vehicles_list = Replace(ai_refuel_vehicles_list,base,temp_list);

                              temp_list = UnitFilter(ai_refuel_vehicles_list[base],[[f_empty],[f_ok]]);
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];

                              ComMoveUnit(ai_refuel_vehicles_list[base],ai_depot[base]);
                              AddComRefuel(ai_refuel_vehicles_list[base],ai_depot[base]);
                         end;


                    //Determine which vehicles are allowed to repair. If base is under attack then only the vehicles on the
                    //parking/retreat spots. If not under attack then all defending vehicles.
                    //Get mechanics in these vehicles out so they can repair too (if we are not under attack).
                    //If the base is not under attack then scan for vehicles which are not parked correctly.
                    free_parking_spots = [];  //Keeps track of the pullback hexes available
                    temp_list_3 = [];  //Keeps track of vehicles on pullback hexes
                    for i in ai_vehicle_pullback_hexes[base] do
                         begin
                              temp_unit = HexInfo(i[1],i[2]);

                              if temp_unit in ai_vehicles_defend[base] then
                                   begin
                                        if temp_unit = escape_cargo_bay then
                                             continue;

                                        temp_list_3 = temp_list_3 ^ temp_unit;

                                        if not under_attack and not temp_unit in (ai_refuel_vehicles_list[base] ^ ai_vehicles_attack[base] ^ ai_vehicle_being_moved[base] ^ ai_vehicles_having_been_moved[base]) then
                                             begin
                                                  if GetControl(temp_unit) = control_manual then
                                                       begin
                                                            ComExitVehicle(IsDrivenBy(temp_unit));
                                                       end;
                                             end;
                                   end
                              else
                                   if temp_unit = 0 or not ( GetType(temp_unit) = unit_building or ( GetType(temp_unit) = unit_vehicle and ( ( GetControl(temp_unit) = control_manual and IsDrivenBy(temp_unit) = 0 ) or ( GetControl(temp_unit) = control_remote and IsControledBy(temp_unit) = 0 ) ) ) ) then
                                        free_parking_spots = Insert(free_parking_spots,1,i);
                         end;

                    if under_attack then
                         begin
                              allowed_to_repair_vehicles = temp_list_3;
                              vehicles_list = UnitFilter((ai_vehicles_being_repaired[base] ^ ai_retreating_vehicles_defend[base]) diff temp_list_3,[f_ok]);

                              //Man only the vehicles being repaired and retreating vehicles which are parked on a parking spot and ( are under attack
                              //or where mechanics are under attack nearby (i.e. the enemy is near) ).
                              //Else use your time on repairing the vehicles.
                              //UnitShoot resets after 10 seconds and detects all kinds of contact (direct hit, bombs, attack ground etc.).
                              temp_list = [];
                              temp_list_3 = temp_list_3 isect UnitFilter(ai_vehicles_being_repaired[base] ^ ai_retreating_vehicles_defend[base],[f_ok]);
                              for i in temp_list_3 do
                                   if UnitShoot(i) > 0 and GetSide(UnitShoot(i)) <> side then
                                        temp_list = temp_list ^ i;

                              for i in ai_mechanics_defend[base] do
                                   if UnitShoot(i) > 0 and GetSide(UnitShoot(i)) <> side then
                                        temp_list = temp_list ^ UnitFilter(temp_list_3 diff temp_list,[f_dist,i,5]);

                              for i in temp_list_3 diff temp_list do
                                   if GetControl(i) = control_manual then
                                        begin
                                             ComExitVehicle(IsDrivenBy(i));
                                        end;

                              temp_list = FindDriverHelper(UnitFilter(temp_list,[[f_empty],[f_ok]]),mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];
                         end
                    else
                         begin
                              //Don't go near burning vehicles too far away from the base - could be dangerous if the
                              //enemy has set up an ambush.
                              allowed_to_repair_vehicles = ai_vehicles_defend[base] diff (ai_refuel_vehicles_list[base] ^ ai_vehicles_having_been_moved[base] ^ ai_vehicle_being_moved[base]);

                              i = 1;
                              while i <= allowed_to_repair_vehicles do
                                   begin
                                        if not IsOk(allowed_to_repair_vehicles[i]) and GetDistUnitArea(allowed_to_repair_vehicles[i],area) > 7 then
                                             begin
                                                  allowed_to_repair_vehicles = Delete(allowed_to_repair_vehicles,i);
                                                  continue;
                                             end;

                                        i = i + 1;
                                   end;

                              vehicles_list = UnitFilter(allowed_to_repair_vehicles diff temp_list_3,[f_ok]);

                              //Find drivers for the vehicles which aren't parked correctly
                              temp_list = UnitFilter(vehicles_list,[[f_empty],[f_ok]]);
                              temp_list = FindDriverHelper(temp_list,mechanics_list,vehicles_drivers);
                              mechanics_list = temp_list[1];
                              vehicles_drivers = temp_list[2];
                         end;

                    //Command (damaged vehicles)/(vehicles parked the wrong places) to retreat to the pullback hexes.
                    //If no pullback hexes are available then the vehicle won't retreat.
                    for i in vehicles_list do
                         if free_parking_spots > 0 then
                              begin
                                   //Take the closest spot
                                   temp_list = [];
                                   for k in free_parking_spots do
                                        temp_list = temp_list ^ GetDistUnitXY(i,k[1],k[2]);
                                   temp_list = WorstFromListByList(free_parking_spots,temp_list);

                                   ComMoveXY(i,temp_list[1],temp_list[2]);
                                   AddComHold(i);

                                   free_parking_spots = free_parking_spots diff [temp_list];
                              end
                         else
                              break;


                    if mechanics_list = 0 then
                         continue;


                    //Repair vehicles.
                    //All mechanics go for the same vehicle.
                    //Remember Gossudarov's escape cargo bay
                    if not under_attack and not IsDead(Gossudarov) and not IsDead(escape_cargo_bay) and IsInArea(escape_cargo_bay,ru_base_area) and gossudarov_escape_status = 0 then
                         allowed_to_repair_vehicles = allowed_to_repair_vehicles ^ escape_cargo_bay;

                    allowed_to_repair_vehicles = UnitFilter(allowed_to_repair_vehicles,[f_not,[f_lives,1000]]) diff ai_vehicles_being_repaired[base];
                    if allowed_to_repair_vehicles > 0 or ai_vehicles_being_repaired[base] > 0 then
                         begin
                              if allowed_to_repair_vehicles > 0 then
                                   begin
                                        k = false;
                                        if ai_vehicles_being_repaired[base] = 0 then
                                             k = true
                                        else
                                             if IsOk(ai_vehicles_being_repaired[base][1]) then
                                                  begin
                                                       allowed_to_repair_vehicles = UnitFilter(allowed_to_repair_vehicles,[f_not,[f_ok]]);
                                                       k := allowed_to_repair_vehicles > 0;
                                                  end;

                                        if k then
                                             begin
                                                  temp_list = [];
                                                  for i in allowed_to_repair_vehicles do
                                                       temp_list = temp_list ^ GetLives(i);
                                                  temp_unit = WorstFromListByList(allowed_to_repair_vehicles,temp_list);

                                                  temp_list = temp_unit ^ ai_vehicles_being_repaired[base];
                                                  ai_vehicles_being_repaired = Replace(ai_vehicles_being_repaired,base,temp_list);

                                                  temp_list = ai_retreating_vehicles_defend[base] diff temp_unit;
                                                  ai_retreating_vehicles_defend = Replace(ai_retreating_vehicles_defend,base,temp_list);
                                             end;
                                   end;

                              ComRepairVehicle( GetHumansOutOfUnits(mechanics_list) , ai_vehicles_being_repaired[base][1]);
                         end
                    else
                         begin
                              //Rest mechanics stay inside the factory (if possible).
                              //Change class if necessary
                              DistributeHumansToBuildings(base,mechanics_list, UnitFilter(ai_facts[base],[[f_ok],[f_not,[f_constructed]]]),
                                   class_mechanic,6,true,false);
                         end;
               end;

          until false;
     end;
Function FindDriverHelper(vehicles_list,mechanics_list,vehicles_drivers);
     var i, k, temp_unit;
     begin
          for i in vehicles_list do
               begin
                    if mechanics_list = 0 then
                         break;

                    k = false;
                    if vehicles_drivers < i then
                         k = true
                    else
                         if not vehicles_drivers[i] in mechanics_list then
                              k = true;

                    if k then
                         vehicles_drivers = Replace(vehicles_drivers,i,AllNearestUnitToUnit(mechanics_list,i));

                    if vehicles_drivers[i] > 0 then
                        begin
                             temp_unit = IsInUnit(vehicles_drivers[i]);

                             if temp_unit <> i then
                                  case GetType(temp_unit) of
                                       unit_vehicle: ComExitVehicle(vehicles_drivers[i]);  //could sit in a vehicle which is now parked correctly
                                       unit_building: ComExitBuilding(vehicles_drivers[i]);
                                       else ComEnterUnit(vehicles_drivers[i],i);
                                  end;

                             mechanics_list = mechanics_list diff vehicles_drivers[i];
                        end;
               end;

          result = [mechanics_list,vehicles_drivers];
     end;
//Construct combat vehicles and weapons for bunkers. Weapons for bunkers have highest priority.
Every 0$1+0$0.1 do
     var side, i, temp_value, temp_unit, temp_list, base, idle_factories, fact;
     begin
          side = russians;

          for base in ai_bases do
               begin
                    idle_factories = [];
                    for i in ai_facts[base] do
                         if BuildingStatus(i) = bs_idle and IsOk(i) and GetBType(i) = b_factory then
                              idle_factories = idle_factories ^ i;

                    if idle_factories = 0 then
                         continue;


                    //Check if any bunker needs a weapon
                    temp_value = false;
                    for i in ai_buildings_locations[base] do
                         if i[4] in [b_bunker,b_turret] then
                              begin
                                   temp_unit = HexInfo(i[1],i[2]);

                                   if GetBType(temp_unit) in [b_bunker,b_turret] and not IsConstructed(temp_unit) and GetBWeapon(temp_unit) <> i[7] then
                                        for fact in idle_factories do
                                             //if i[7] in AvailableWeaponList(fact) then  //Can the factory produce the weapon? (does it have the gun extension, that is).
                                             if IsWeaponFactory(fact) then
                                                  begin
                                                       //If there are multiple weapon factories and more than one or another factory than
                                                       //the factory getting the job invokes this part of the function the bunker/turret may
                                                       //get the weapon placed several times, but since factories don't have a task list
                                                       //there is no simple way to stop this. Better several times than never.
                                                       ComPlaceWeapon(temp_unit,i[7]);
                                                       temp_value = true;
                                                       break;
                                                  end;

                                   if temp_value then
                                        break;
                              end;

                    if temp_value then
                         continue;


                    //Construct vehicles.
                    if ai_vehicles_defend[base] + ai_vehicles_attack[base] < WorstFromListByList([num_base_vehicles,ai_mechanics_defend[base]+0],[num_base_vehicles,ai_mechanics_defend[base]+0]) and rus_num_vehicle_rebuild > 0 then
                         case side of
                              russians: begin
                                   InitiateRussianVehicleVariables;

                                   //if not vc_weapon in AvailableWeaponList(idle_factories[1]) then
                                   if not IsWeaponFactory(idle_factories[1]) then
                                        vc_weapon = ru_heavy_machine_gun;

                                   //The base is not necesarrily rebuilding everything so possibly we don't have a track extension.
                                   if FilterAllUnits([[f_dist,idle_factories[1],4],[f_btype,b_ext_track]]) = 0 then
                                        if vc_chassis = ru_medium_tracked then
                                             vc_chassis = ru_medium_wheeled
                                        else
                                             vc_chassis = ru_heavy_wheeled;

                                   ComConstruct(idle_factories[1],vc_chassis,vc_engine,vc_control,vc_weapon);
                                   rus_num_vehicle_rebuild = rus_num_vehicle_rebuild - 1;
                              end;
                         end;
               end;

          enable;
     end;
//If a factory has the gun extension we presume it has all necessary extensions to construct
//any weapon.
Function IsWeaponFactory(factory);
     begin
          if FilterAllUnits([[f_dist,factory,4],[f_btype,b_ext_gun]]) > 0 then
               result = true
          else
               result = false;
     end;
//If the player captures one of the computer's vehicles, then remove it from our variables-system.
On VehicleCaptured(new_identifier,old_identifier,old_side,capturing_unit) do
     var temp_list, base;
     begin
          vehicle_captured_events = vehicle_captured_events ^ [[old_identifier,new_identifier]];

          if old_identifier in traitors_vehicles then
               begin
                    traitors_vehicles = (traitors_vehicles diff old_identifier) ^ new_identifier;
               end;

          if old_side <> russians then
               exit;

          for base in ai_bases do
               RemoveVehicleFromVariables(base,old_identifier);

          if old_identifier = escape_cargo_bay then
               begin
                    escape_cargo_bay = new_identifier;
                    artifact_cargo_bay_status = 2;
               end;
     end;
//When a vehicle is constructed
On VehicleConstructed(vehicle,factory) do
     var side, temp_list, base;
     begin
          side = GetSide(vehicle);
          if side <> russians then
               exit;

          base = 1;

          if GetWeapon(vehicle) <> ru_cargo_bay then
               begin
                    temp_list = ai_vehicles_defend[base] ^ vehicle;
                    ai_vehicles_defend = Replace(ai_vehicles_defend,base,temp_list);
               end
          else
               begin
                    ai_cargo_bay = Replace(ai_cargo_bay,base,vehicle);
                    ai_cargo_bay_under_construction = Replace(ai_cargo_bay_under_construction,base,false);
               end;
     end;


//The computers's vehicles never seem to run completely out of fuel...
Every 0$5 do
     var base, i;
     begin
          for base in ai_bases do
               for i in ai_vehicles_attack[base] ^ ai_vehicles_defend[base] ^ ([ai_cargo_bay[base],escape_cargo_bay,escort_veh_front,escort_veh_rear] diff 0) do
                    if GetFuel(i) < 10 and GetEngine(i) = engine_combustion then
                         SetFuel(i,10);

          enable;
     end;


//Scientists
//If a scientist is wounded them pull him/her back. Else heal what people needs healing. Else stay inside a lab (if no lab is Ok then help
//construct buildings).
Every 0$1 do
     var side, i, scientists_list, temp_list, temp_unit, base, k, temp_list_3, free_spaces, area, val, j, under_attack;
     begin
          side = russians;

          repeat
          wait(0$1);

          for base in ai_bases do
               begin
                    scientists_list = ai_scientists[base] diff ai_heal_these_humans[base];


                    //Identify scientists who need healing
                    temp_list = ai_heal_these_humans[base];
                    i = 1;
                    while i <= scientists_list do
                         begin
                              if GetLives(scientists_list[i]) <= 700 then
                                   begin
                                        temp_list = temp_list ^ scientists_list[i];
                                        scientists_list = Delete(scientists_list,i);
                                        i = i - 1;
                                   end;

                              i = i + 1;
                         end;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Update people who need healing. People at full HP or people inside a unit (relevant for soldiers and mechanics)
                    //will not receive healing.
                    temp_list = [];
                    for i in ai_heal_these_humans[base] do
                         if GetLives(i) < 1000 and IsInUnit(i) = 0 then
                              temp_list = temp_list ^ i;
                    ai_heal_these_humans = Replace(ai_heal_these_humans,base,temp_list);


                    //Control people who need healing (except soldiers if base is under attack). Make 'em retreat to the human pullback hex.
                    //Control people who need healing (except soldiers if the base is under attack). Make 'em retreat to the human pullback hex.
                    under_attack = BaseUnderAttack(base,-1);
                    for i in ai_heal_these_humans[base] do
                         if not ( under_attack and i in ai_soldiers[base] ) and GetDistUnitXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]) > 4 then
                              ComMoveXY(i,ai_human_pullback_hex[base][1],ai_human_pullback_hex[base][2]);


                    if scientists_list = 0 then
                         continue; 


                    //Heal people. At least one scientist for each human if possible.
                    //Only heal red people who are (almost) inside the base so the healer is safe.
                    temp_list = ai_heal_these_humans[base];

                    case side of
                         russians: area = ru_base_area;
                    end;

                    i = 1;
                    while i <= temp_list do
                         begin
                              if not IsOk(temp_list[i]) and GetDistUnitArea(temp_list[i],area) > 7 then
                                   begin
                                        temp_list = Delete(temp_list,i);
                                        continue;
                                   end;

                              i = i + 1;
                         end;

                    if temp_list > 0 then
                         begin
                              scientists_list = GetHumansOutOfUnits(scientists_list);

                              repeat
                                   i = 1;
                                   while i <= temp_list do
                                        begin
                                             if scientists_list = 0 then
                                                  break;

                                             temp_unit = NearestUnitToUnit(scientists_list,temp_list[i]);
                                             ComHeal(temp_unit,temp_list[i]);
                                             scientists_list = scientists_list diff temp_unit;

                                             i = i + 1;
                                        end;

                              until scientists_list = 0;

                              continue;
                         end;


                    //Enter and stay in lab
                    DistributeHumansToBuildings(base,scientists_list, UnitFilter(ai_labs[base],[[f_ok],[f_not,[f_constructed]]]),
                         class_scientistic,6,true,false);
               end;

          until false;
     end;
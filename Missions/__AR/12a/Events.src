
//Patrols spawning from the west, south and east.
//Don't spawn (remote) vehicle patrols if there are noone to control them.
Every 0$1+0$0.3 do
     var time, status, area, temp_list, path_list;
     begin
          time = [1$20,1$15,1$05][difficulty];
          status = 1;

          wait([0$55,0$50,0$35][difficulty]);
          temp_list = CreateVehiclePatrol(enter_area_west, Rand(1,4) <= [1,3,4][difficulty], [1+Rand(0,1),1+Rand(0,1),2+Rand(0,1)][difficulty]);
          path_list = CreatePatrolPath(enter_area_west,false);
          ActivatePatrol(enter_area_west,temp_list,path_list);

          repeat
          wait(time);

          if Rand(1,2) = 1 then
               area = enter_area_south
          else
               area = enter_area_east;

          if status = 2 and UnitFilter(remote_controllers_control_tower,[f_ok]) > 0 and UnitFilter(remote_controllers,[f_ok]) > 0 then
               begin
                    temp_list = CreateVehiclePatrol(area, Rand(1,4) <= [1,3,4][difficulty], [1+Rand(0,1),1+Rand(0,1),2+Rand(0,1)][difficulty]);
                    path_list = CreatePatrolPath(area,false);
                    ActivatePatrol(area,temp_list,path_list);
               end
          else
               ActivatePatrol(area, CreateHumanPatrol, CreatePatrolPath(area,true));

          status = status + 1;
          if status = 3 then
               status = 1;

          wait(time);

          //Don't spawn the west patrol if the player is near the spawn area.
          if FilterAllUnits([[f_side,you],[f_inarea,near_exit_area]]) = 0 then
               if status = 1 and UnitFilter(remote_controllers_control_tower,[f_ok]) > 0 and UnitFilter(remote_controllers,[f_ok]) > 0 then
                    begin
                         temp_list = CreateVehiclePatrol(enter_area_west, Rand(1,4) <= [1,3,4][difficulty], [1+Rand(0,1),1+Rand(0,1),2+Rand(0,1)][difficulty]);
                         path_list = CreatePatrolPath(enter_area_west,false);
                         ActivatePatrol(enter_area_west,temp_list,path_list);
                    end
               else
                    ActivatePatrol(enter_area_west, CreateHumanPatrol, CreatePatrolPath(enter_area_west,true));

          until false;
     end;

//Function which creates a patrol consisting of humans.
Function CreateHumanPatrol;
     var temp_list, num_sol, num_mor, num_sci, n, i;
     begin
          num_sol = [1+Rand(0,1),2,3][difficulty];
          num_mor = [1,1,2][difficulty] + Rand(0,1);
          num_sci = [0,1,2][difficulty];

          case Rand(1,4) of
               1: begin
                    if num_sol > 0 then
                         begin
                              n = Rand(1,num_sol);

                              num_sol = num_sol - n;
                              num_mor = num_mor + n;
                         end;
               end;
               2: begin
                    if num_mor > 0 then
                         begin
                              n = Rand(1,num_mor);

                              num_mor = num_mor - n;
                              num_sol = num_sol + n;
                         end;
               end;
               3: begin
                    if Rand(1,2) = 1 then
                         num_sol = num_sol + num_sci
                    else
                         num_mor = num_mor + num_sci;

                    num_sci = 0;
               end;
               4: begin
                    //No changes
               end;
          end;

          temp_list = CreateUnitsWithClass(num_sol,class_soldier,upf,false);
          temp_list = temp_list ^ CreateUnitsWithClass(num_mor,class_mortar,upf,false);
          temp_list = temp_list ^ CreateUnitsWithClass(num_sci,class_scientistic,upf,false);

          result = temp_list;
     end;

Function ActivatePatrol(area,unit_list,patrol_path);
     var i, n;
     begin
          for i in unit_list do
               PlaceUnitArea(i,area,false);

          n = 0;
          for i = 1 to patrols+1 do
               if i = patrols+1 then
                    n = i
               else
                    if patrols[i] = 0 then
                         begin
                              n = i;
                              break;
                         end;

          patrols = Replace(patrols,n,unit_list);
          patrols_path = Replace(patrols_path,n,patrol_path);
          patrols_path_hex_index = Replace(patrols_path_hex_index,n,1);
     end;

//Function which createa a patrol consisting of vehicles.
//area - area where the vehicles spawn.
//bool_heavy_vehicles - true if the vehicles should be half tracked. Else hovercraft.
Function CreateVehiclePatrol(area, bool_heavy_vehicles, num_vehicles);
     var temp_list, i, candidate, num, veh, k, temp_list_2;
     begin
          InitUc;
          InitVc;

          uc_side = upf;
          uc_nation = nation_arabian;

          case area of
               enter_area_west: uc_direction = 1;
               enter_area_south: uc_direction = 0;
               enter_area_east: uc_direction = 5;
          end;

          vc_control = control_remote;

          if bool_heavy_vehicles then
               begin
                    vc_chassis = ar_half_tracked;
                    vc_engine = engine_siberite;
               end
          else
               begin
                    vc_chassis = ar_hovercraft;
                    vc_engine = engine_combustion;
               end;

          temp_list = [];
          for i = 1 to num_vehicles do
               begin
                    if vc_chassis = ar_hovercraft then
                         begin
                              if Rand(1,2) = 1 then
                                   vc_weapon = ar_double_machine_gun
                              else
                                   vc_weapon = ar_multimissile_ballista;
                         end
                    else
                         begin
                              if Rand(1,5) <= [2,3,4][difficulty] then
                                   vc_weapon = ar_gatling_gun
                              else
                                   case Rand(1,3) of
                                        1: vc_weapon = ar_double_machine_gun;
                                        2: vc_weapon = ar_multimissile_ballista;
                                        3: vc_weapon = ar_flame_thrower;
                                   end;
                         end;


                    //Find a controller
                    candidate = -1;
                    num = 11;

                    for k in remote_controllers do
                         if remote_controllers_vehicles[k] < num and remote_controllers_vehicles[k] < GetSkill(k,skill_mechanical) then
                              begin
                                   num = remote_controllers_vehicles[k]+0;
                                   candidate = k;
                              end;

                    if candidate = -1 then
                         vc_control = control_apeman;


                    veh = CreateVehicle;
                    temp_list = temp_list ^ veh;

                    if candidate > -1 then
                         begin
                              ComLinkTo(veh,candidate);

                              temp_list_2 = remote_controllers_vehicles[candidate] ^ veh;
                              remote_controllers_vehicles = Replace(remote_controllers_vehicles,candidate,temp_list_2);
                         end;
               end;

          //Wait for vehicles to make contact to their controllers
          wait(3);

          result = temp_list;
     end;

//Function which creates a random patrol path through the map.
//startarea - the area where the patrol spawns. Can be enter_area_west, enter_area_south, enter_area_east.
//CF. explanation of variable "patrols_subpaths" in module "MAIN".
{Function CreatePatrolPath(startarea);
     var possible_subpaths, subpaths_allowed, the_path, i, temp_list, allowed;
     begin
          the_path = [];

          case startarea of
               enter_area_west: subpaths_allowed = [[1000,1001][Rand(1,2)]];
               enter_area_south: subpaths_allowed = [1000];
               enter_area_east: subpaths_allowed = [1001];
          end;

          while subpaths_allowed > 0 do
               begin
                    possible_subpaths = [];
                    for i in patrols_subpaths do
                         if i[1] in subpaths_allowed then
                              possible_subpaths = possible_subpaths ^ [i];

                    if possible_subpaths = 0 then  //should never happen
                         break
                    else
                         begin
                              temp_list = possible_subpaths[Rand(1,possible_subpaths)];

                              //Remove the path ID and fetch the path IDs this path may lead to (and remove those too so we get
                              //a clean list with only coordinates).
                              temp_list = Delete(temp_list,1);  //Path ID for this path
                              subpaths_allowed = temp_list[1];
                              temp_list = Delete(temp_list,1);

                              the_path = the_path ^ temp_list;

                              //Weed out illegal paths
                              if group_3_position = 2 then
                                   begin
                                        allowed = false;
                                        temp_list = UnitFilter([Louis,Martin] ^ other_deserters_08,[f_alive]);

                                        if temp_list = 0 then
                                             allowed = true
                                        else
                                             if GetSide(temp_list[1]) = you then
                                                  allowed = true;
                                   end
                              else
                                   allowed = true;

                              if not allowed then
                                   begin
                                        for i in subpaths_allowed do
                                             if i mod 3000 < 1000 then
                                                  subpaths_allowed = subpaths_allowed diff i;
                                   end;

                              if group_4_position = 1 then
                                   begin
                                        allowed = false;
                                        temp_list = UnitFilter([Sonya,MarkB,Kowalski,Ralph],[f_alive]);

                                        if temp_list = 0 then
                                             allowed = true
                                        else
                                             if GetSide(temp_list[1]) = you then
                                                  allowed = true;
                                   end
                              else
                                   allowed = true;

                              if not allowed then
                                   begin
                                        for i in subpaths_allowed do
                                             if i mod 4000 < 1000 then
                                                  subpaths_allowed = subpaths_allowed diff i;
                                   end;
                         end;
               end;

          if startarea = enter_area_west then
               begin
                    temp_list = [];
                    for i = the_path+0 downto 1 do
                         temp_list = temp_list ^ [the_path[i]];
                    the_path = temp_list;
               end;

          result = the_path;
     end; }

//Function which creates a definite patrol path through the map.
//startarea - the area where the patrol spawns. Can be enter_area_west, enter_area_south, enter_area_east.
//human_group - boolean. True if it's a human group. False if it's a vehicle group.
//CF. explanation of variable "patrols_subpaths" in module "MAIN".
Function CreatePatrolPath(startarea, human_group);
     var subpaths, the_path, i, temp_list, allowed, p;
     begin
          the_path = [];
          subpaths = [];

          case startarea of
               enter_area_west: begin
                    if Rand(1,2) = 1 then
                         subpaths = [1000,1001]
                    else
                         subpaths = [1001];

                    if human_group then
                         begin
                              subpaths = subpaths ^ [1002];

                              if group_3_position = 2 and IsGroup3Active then
                                   subpaths = subpaths ^ [1003]
                              else
                                   subpaths = subpaths ^ [3001];
                         end
                    else
                         begin
                              if not ( group_4_position = 1 and IsGroup4Active ) then
                                   subpaths = subpaths ^ [4001];

                              subpaths = subpaths ^ [1002,1003];
                         end;
               end;
               else begin
                    if startarea = enter_area_south then
                         subpaths = [1000];

                    subpaths = subpaths ^ [1001,1002];

                    if human_group then
                         subpaths = subpaths ^ [1003]
                    else
                         if group_3_position = 2 and IsGroup3Active then
                              subpaths = subpaths ^ [1003]
                         else
                              subpaths = subpaths ^ [3001];
               end;
          end;

          result = ExtractPatrolPath(startarea, subpaths);
     end;
Export Function IsGroup3Active;
     var temp_list;
     begin
          result = true;
          temp_list = UnitFilter([Louis,Martin] ^ other_deserters_08,[f_alive]);

          if temp_list = 0 then
               result = false
          else
               if GetSide(temp_list[1]) = you then
                    result = false;
     end;
Function IsGroup4Active;
     var temp_list;
     begin
          result = true;
          temp_list = UnitFilter([Sonya,MarkB,Kowalski,Ralph],[f_alive]);

          if temp_list = 0 then
               result = false
          else
               if GetSide(temp_list[1]) = you then
                    result = false;
     end;
Function ExtractPatrolPath(startarea, subpaths);
     var temp_list, p, i;
     begin
          result = [];

          for p in subpaths do
               begin
                    for i in patrols_subpaths do
                         if i[1] = p then
                              begin
                                   temp_list = Delete(i,1);
                                   temp_list = Delete(temp_list,1);

                                   result = result ^ temp_list;

                                   break;
                              end;
               end;

          if startarea = enter_area_west then
               begin
                    temp_list = [];

                    for i = result+0 downto 1 do
                         temp_list = temp_list ^ [result[i]];

                    result = temp_list;
               end;
     end;

      
//After some time UPF finds some of the Legion groups and annihilates them.
//The exterminator group is not spawned if the group doesn't exist or has been
//rescued.
Every 0$1+0$0.9 do
     var time;
     begin
          //Timeout for UPF destroying Bodenhof group (group 4).
          wait([10$0,8$30,3$30][difficulty]);

          if IsGroup4Active then
               CreateExterminatorGroup(4);


          //Timeout for UPF destroying Louis group (group 3).
          wait([10$0,8$30,7$0][difficulty]);

          if IsGroup3Active then
               begin
                    CreateExterminatorGroup(3);
                    group_3_exterminators_spawned = true;
               end;
     end;

//Function to create an extermination group. Spawns to the west.
//The group consists of both vehicles and humans.
//group_to_exterminate - 3 if group 3, 4 if group 4.
Function CreateExterminatorGroup(group_to_exterminate);
     var unit_list, i;
     begin
          unit_list = [];

          //Vehicles
          InitUc;
          InitVc;

          uc_side = upf;
          uc_nation = nation_arabian;
          uc_direction = 1;

          vc_control = control_apeman;
          vc_chassis = ar_half_tracked;
          vc_engine = engine_siberite;

          case Rand(1,2) of
               1: vc_weapon = ar_gun;
               2: vc_weapon = ar_rocket_launcher;
          end;

          unit_list = unit_list ^ CreateVehicle;


          //Humans
          unit_list = unit_list ^ CreateUnitsWithClass(3,class_soldier,upf,false);
          unit_list = unit_list ^ CreateUnitsWithClass(3,class_mortar,upf,false);
          unit_list = unit_list ^ CreateUnitsWithClass(2,class_scientistic,upf,false);


          case group_to_exterminate of
               3: ActivatePatrol(enter_area_west,unit_list,CreateGroup3ExterminatorPath);
               4: ActivatePatrol(enter_area_west,unit_list,CreateGroup4ExterminatorPath);
          end;
     end;

//Functions to create the special paths for the extermination groups (destroys the Legion groups).
Function CreateGroup3ExterminatorPath;
     var i, temp_list;
     begin
          if group_3_position = 1 then
               begin
                    temp_list = [[61,87],[42,62],[38,41],[33,21],[55,24],[79,29]];
                    result = temp_list ^ [[87,31],[109,39],[114,33],[105,39]];

                    for i = temp_list+0 downto 1 do  //reverse order
                         result = result ^ [temp_list[i]];
               end
          else  //=2
               begin
                    temp_list = [[61,87],[42,62],[38,41],[30,21]];
                    result = temp_list ^ [[21,15]];

                    for i = temp_list+0 downto 1 do  //reverse order
                         result = result ^ [temp_list[i]];
               end;
     end;
Function CreateGroup4ExterminatorPath;
     var i, temp_list;
     begin
          if group_4_position = 1 then
               begin
                    temp_list = [[65,93],[76,90],[84,81],[94,73],[97,60],[116,71],[135,78],[154,85],[158,80],[152,66],[146,51],[143,38],[155,38]];
                    result = temp_list ^ [[164,48]];

                    for i = temp_list+0 downto 1 do  //reverse order
                         result = result ^ [temp_list[i]];
               end
          else  //=2
               begin
                    temp_list = [[65,93],[76,90],[97,96],[112,103]];
                    result = temp_list ^ [[125,117]];

                    for i = temp_list+0 downto 1 do  //reverse order
                         result = result ^ [temp_list[i]];
               end;
     end;


//When the guards in the breastworks in the mountains spot the player they call out
//and after some time a small patrol is spawned which patrols the roads around the
//breastwork (just like ordinary patrols but their path is just ensured to reach the
//area of the breastwork).
Every 0$1+0$0.6 do
     var temp_list, subpaths, path_list, east_called, north_called, west_called, i, time;
     var east_spoken, north_spoken, west_spoken, east_pat, north_pat, west_pat, pending_patrols;
     begin
          east_spoken = false;
          north_spoken = false;
          west_spoken = false;

          east_pat = [];  //Identifers of the units making up the east breastwork patrol
          north_pat = [];
          west_pat = [];

          pending_patrols = [];  //[unit_list,path_list,time] - controls when created patrols are spawned

          repeat
          //The approach used to set this variable means that if two guards spot the player at the same time
          //both spawned patrols will use the same path. This is just very unlikely to happen.
          subpaths = [];

          east_called = false;
          north_called = false;
          west_called = false;

          if See(you,mountain_guard_east) or See(you,IsInUnit(mountain_guard_east)) then
               begin
                    if not east_spoken then
                         begin
                              DialogueOn;

                              if GetSex(mountain_guard_east) = sex_male then
                                   SayRadio(mountain_guard_east,'D8-SomeMEast-1')
                              else
                                   SayRadio(mountain_guard_east,'D8-SomeFEast-1');

                              DialogueOff;

                              east_spoken = true;
                         end;

                    if UnitFilter(east_pat,[f_lives,1]) = 0 then
                         begin
                              subpaths = [1001,1002,1003];
                              east_called = true;
                         end;
               end;

          if See(you,mountain_guard_north) or See(you,IsInUnit(mountain_guard_north)) then
               begin
                    if not north_spoken then
                         begin
                              DialogueOn;

                              if GetSex(mountain_guard_north) = sex_male then
                                   SayRadio(mountain_guard_north,'D8-SomeMNorth-1')
                              else
                                   SayRadio(mountain_guard_north,'D8-SomeFNorth-1');

                              DialogueOff;

                              north_spoken = true;
                         end;

                    if UnitFilter(north_pat,[f_lives,1]) = 0 then
                         begin
                              subpaths = [1001,1002,3001];
                              north_called = true;
                         end;
               end;

          if See(you,mountain_guard_west) or See(you,IsInUnit(mountain_guard_west)) then
               begin
                    if not west_spoken then
                         begin
                              DialogueOn;

                              if GetSex(mountain_guard_west) = sex_male then
                                   SayRadio(mountain_guard_west,'D8-SomeMWest-1')
                              else
                                   SayRadio(mountain_guard_west,'D8-SomeFWest-1');

                              DialogueOff;

                              west_spoken = true;
                         end;

                    if UnitFilter(west_pat,[f_lives,1]) = 0 then
                         begin
                              subpaths = [1001,1002,1003];
                              west_called = true;
                         end;
               end;
                  
          if subpaths > 0 then
               begin
                    temp_list = CreateVehiclePatrol(enter_area_east, false, [1,1,2][difficulty]);
                    path_list = ExtractPatrolPath(enter_area_east, subpaths);

                    if east_called then
                         begin
                              east_pat = temp_list;
                              time = 0$45;
                         end
                    else
                         if north_called then
                              begin
                                   north_pat = temp_list;
                                   time = 0$25;
                              end
                         else
                              //if west_called then
                                   begin
                                        west_pat = temp_list;
                                        time = 0$10;
                                   end;

                    pending_patrols = Insert(pending_patrols,1,[temp_list, path_list, time]);
               end;

          wait(0$0.5);
          
          i = 1;
          while i <= pending_patrols do
               begin
                    temp_list = Replace(pending_patrols[i],3, pending_patrols[i][3] - 0$0.5);

                    if temp_list[3] <= 0$0 then
                         begin
                              ActivatePatrol(enter_area_east, pending_patrols[i][1], pending_patrols[i][2]);
                              pending_patrols = Delete(pending_patrols,i);

                              continue;
                         end
                    else
                         pending_patrols = Replace(pending_patrols,i,temp_list);

                    i = i + 1;
               end;

          until IsDead(mountain_guard_east) and IsDead(mountain_guard_north) and IsDead(mountain_guard_west);
     end;


//When someone steps on a landmine.
Every 0$1+0$0.2 do
     var mine_dialogue, mine_dialogue_speaker, temp_list, i, un, temp_list_2;
     var mine_list_1, mine_list_2, mine_list, mine_list_switch;
     begin
          mine_dialogue = 0;

          //Since the list of mines is large, iterating through it causes a little lagg.
          //To avoid this we split it up into two equally sized lists and check these
          //asynchronously instead.
          mine_list_1 = [];
          mine_list_2 = [];
          for i in all_mines_hexes do
               if mine_list_1 < mine_list_2 then
                    mine_list_1 = mine_list_1 ^ [i]
               else
                    mine_list_2 = mine_list_2 ^ [i];

          mine_list_switch = 1;


          repeat
          wait(0$0.25);
                 
          if mine_list_switch = 1 then
               mine_list = mine_list_1
          else
               mine_list = mine_list_2;

          mine_list_switch = [2,1][mine_list_switch];

          
          if mine_dialogue = 1 then
               begin
                    mine_dialogue = 2;

                    if mine_dialogue_speaker > 0 then
                         begin
                              DialogueOn;

                              case mine_dialogue_speaker of
                                   Heike: ForceSay(mine_dialogue_speaker,'D2-H-1');
                                   Oswald: ForceSay(mine_dialogue_speaker,'D2-Os-1');
                                   Kurt: ForceSay(mine_dialogue_speaker,'D2-Ku-1');
                              end;

                              DialogueOff;
                         end;
               end;


          temp_list = FilterAllUnits([f_side,you]);
          i = 1;
          while i <= mine_list do
               begin
                    un = HexInfo(mine_list[i][1],mine_list[i][2]);

                    if un <= 0 then
                         begin
                              i = i + 1;
                              continue;
                         end;

                    if un in temp_list or not InArea(mine_list[i][1],mine_list[i][2],mine_area_57_90) then
                         begin
                              LaunchMineAtPos(mine_list[i][1],mine_list[i][2],mines_side);

                              //These mines just don't hurt very much so we have to add some extra
                              //power manually.
                              if difficulty = 3 and InArea(mine_list[i][1],mine_list[i][2],mine_area_140_110) then
                                   KillUnit(un)
                              else
                                   if GetLives(un) > [0,150,300][difficulty] then
                                        SetLives(un,GetLives(un)-[0,150,300][difficulty]);

                              if GetSide(un) = you and mine_dialogue = 0 then
                                   begin
                                        mine_dialogue = 1;
                                        
                                        //Find someone to speak (near the blown mine)
                                        temp_list_2 = UnitFilter([Heike,Oswald,Kurt],[[f_distxy,mine_list[i][1],mine_list[i][2],7],[f_alive]]);

                                        if temp_list_2 > 0 then
                                             mine_dialogue_speaker = temp_list_2[Rand(1,temp_list_2)]
                                        else
                                             mine_dialogue_speaker = -1;
                                   end;
                             
                              mine_list_1 = mine_list_1 diff [mine_list[i]];
                              mine_list_2 = mine_list_2 diff [mine_list[i]];
                              all_mines_hexes = all_mines_hexes diff [mine_list[i]];
                              mine_list = Delete(mine_list,i);

                              continue;
                         end;

                    i = i + 1;
               end;   
               {
               CheckMinesInArea(mine_area_22_15,[f_side,you]);
               CheckMinesInArea(mine_area_98_38,[f_side,you]);
               CheckMinesInArea(mine_area_122_115,[f_side,you]);
               CheckMinesInArea(mine_area_165_50,[f_side,you]);
               CheckMinesInArea(mine_area_40_70,[f_side,you]);
               CheckMinesInArea(mine_area_57_90,[f_side,you]);
               CheckMinesInArea(mine_area_207_129,[f_side,you]);
               CheckMinesInArea(mine_area_140_110,[f_side,you]);
               CheckMinesInArea(mine_area_172_120,[f_side,you]);
               CheckMinesInArea(mine_area_126_64,[f_side,you]);
               }  
          until false;
     end;
         

//Heike spots the corpses in the central-sourthern mountains.
Every 0$1+0$0.1 do
     var hex;
     begin
          //After 3 minutes the bodies have almost decayed away
          if tick >= 3$0 then
               exit;

          for hex in killed_legion_hexes do
               if SeeXY(you,hex[1],hex[2]) then
                    begin
                         CenterOnXY(hex[1],hex[2]);
                         DialogueOn;
                         Say(Heike,'D3-H-1');
                         DialogueOff;

                         exit;
                    end;

          enable;
     end;


//The player finds the group consisting of Sonya, Ralph, Mark and Kowalski.
//The camp is under attack when the player finds them.
Every 0$1+0$0.4 do
     var i, ag_list, temp_list;
     begin
          if ([Sonya,MarkB,Kowalski,Ralph] diff 0) = 0 then
               exit;


          //Wait until the player is near the camp
          repeat
          wait(0$0.5);

          if group_4_position = 1 then
               begin
                    if SeeXY(you,143,42) then
                         break;
               end
          else  //= 2
               begin
                    if SeeXY(you,97,96) or SeeXY(you,126,102) then
                         break;
               end;

          if UnitFilter([Sonya,MarkB,Kowalski,Ralph],[f_alive]) = 0 then
               exit;

          until false;


          //Spawn some UPF aggressors. Not if the group is under attack by their extermination group.
          if not EnemiesNearUnits([Sonya,MarkB,Kowalski,Ralph] diff 0) then
          begin
          ag_list = CreateUnitsWithClass([1,2,2][difficulty],class_mortar,upf,false);
          if group_4_position = 1 then
               begin
                    for i in ag_list do
                         PlaceUnitXYR(i,152,33,2,false);

                    ComAgressiveMove(ag_list,169,55);
               end
          else
               begin
                    for i in ag_list do
                         PlaceUnitXYR(i,109,97,2,false);

                    ComAgressiveMove(ag_list,127,118);
               end;


          //When the player spots the aggressors
          repeat
          wait(0$0.5);                              
          until UnitFilter(ag_list,[f_see,you]) > 0 or ( UnitFilter(ag_list,[f_ok]) = 0 and GetTech(tech_stimdrugs,upf) <> state_researched ) or UnitFilter(ag_list,[f_alive]) = 0;

          if UnitFilter([Sonya,MarkB,Kowalski,Ralph],[f_alive]) = 0 then
               exit;

          temp_list = UnitsInside(group_4_breastwork);
          if temp_list > 0 and UnitFilter(ag_list,[f_see,you]) > 0 then  //should be the case (breastwork could have been destroyed, though)
               begin
                    DialogueOn;

                    PlaceSeeing(GetX(group_4_breastwork),GetY(group_4_breastwork),you,-3);
                    CenterOnUnits(group_4_breastwork);

                    i = temp_list[1];
                    case i of
                         Sonya: ForceSay(i,'D4-So-1');
                         MarkB: ForceSay(i,'D4-Ma-1');
                         Ralph: ForceSay(i,'D4-Ra-1');
                         Kowalski: ForceSay(i,'D4-Ko-1');
                    end;

                    dwait(0$0.5);
                    RemoveSeeing(GetX(group_4_breastwork),GetY(group_4_breastwork),you);
                    CenterOnUnits(Heike);

                    DialogueOff;
               end;

          //Wait until the aggressors are killed
          repeat
          wait(0$1);
          until ( UnitFilter(ag_list,[f_ok]) = 0 and GetTech(tech_stimdrugs,upf) <> state_researched ) or UnitFilter(ag_list,[f_alive]) = 0;

          //Wait until he falls dead
          wait(0$1);

          if UnitFilter([Sonya,MarkB,Kowalski,Ralph],[f_alive]) = 0 then
               exit;
          end
          else
               while UnitFilter([Sonya,MarkB,Kowalski,Ralph] ^ group_4_breastwork,[f_see,you]) = 0 do
                    begin
                         wait(0$0.5);

                         if UnitFilter([Sonya,MarkB,Kowalski,Ralph],[f_alive]) = 0 then
                              exit;
                    end;


          //The player could find the group when it was under attack by the extermination group.
          //In that case set the group to the player's side and postpone the dialogue.
          SetSide([Sonya,MarkB,Ralph,Kowalski,group_4_breastwork],you);
          ComFree([Sonya,MarkB,Ralph,Kowalski] diff UnitsInside(group_4_breastwork));  //ComFree makes units inside breastwork exit

          while EnemiesNearUnits([Sonya,MarkB,Ralph,Kowalski] diff 0) do
               wait(0$1);

          if IsLive(MarkB) or IsLive(Ralph) then
          begin
          CenterOnUnits([Sonya,MarkB,Ralph,Kowalski]);
          wait(2);

          DialogueOn;
          if IsLive(MarkB) then
               begin
                    ForceSay(MarkB,'D4-Ma-2');
                    ForceSay(Heike,'D4-H-1');
                    ForceSay(MarkB,'D4-Ma-3');

                    if IsLive(Ralph) then
                         begin
                              ForceSay(Ralph,'D4-Ra-2');
                              ForceSay(MarkB,'D4-Ma-4');

                              if IsLive(Sonya) then
                                   begin
                                        ForceSay(Sonya,'D4-So-2');
                                        ForceSay(Ralph,'D4-Ra-3');
                                   end;
                         end;
               end;

          if IsLive(Ralph) then
               begin
                    ForceSay(Ralph,'D4-Ra-4');

                    if IsLive(Sonya) then
                         begin
                              ForceSay(Sonya,'D4-So-3');
                              ForceSay(Ralph,'D4-Ra-5');
                         end;
               end;

          ForceSay(Heike,'D4-H-2');
          DialogueOff;
          end;
     end;
Function EnemiesNearUnits(unit_list);
     var i, stim, temp_list;
     begin
          result = false;

          if unit_list > 0 then
               begin
                    stim := GetTech(tech_stimdrugs,upf) = state_researched;

                    for i in unit_list do
                         begin
                              temp_list = FilterAllUnits([[f_side,upf],[f_dist,i,19]]);

                              if temp_list > 0 then
                                   begin
                                        if ( stim and UnitFilter(temp_list,[[f_type,unit_human],[f_alive]]) > 0 ) or UnitFilter(temp_list,[f_ok]) > 0 then
                                             begin
                                                  result = true;
                                                  exit;
                                             end;
                                   end;
                         end;
               end;
     end;


//The player finds the UPF deserter
Every 0$1+0$0.6 do
     var i;
     begin
          repeat
          wait(0$0.5);
          until See(you,upf_deserter);

          CenterOnUnits(upf_deserter);
          DialogueOn;

          if IsOk(Oswald) then
               Say(Oswald,'D6-Os-1')
          else
               ForceSay(Heike,'D6-H-1');

          Say(upf_deserter,'D6-Ha-1');

          if IsOk(Oswald) then
               Say(Oswald,'D6-Os-2')
          else
               ForceSay(Heike,'D6-H-2');

          if IsOk(Kurt) then
               begin
                    Say(Kurt,'D6-Ku-1_v2');
                    Say(upf_deserter,'D6-Ha-2');
               end
          else
               ForceSay(Heike,'D6-H-3');

          if IsOk(Oswald) then
               begin
                    Say(Oswald,'D6-Os-3');
                    ForceSay(Heike,'D6-H-4');
               end;
          
          Say(upf_deserter,'D6-Ha-3');
          ForceSay(Heike,'D6-H-5');
          Say(upf_deserter,'D6-Ha-4');

          if IsOk(Oswald) then
               Say(Oswald,'D6-Os-4')
          else
               ForceSay(Heike,'D6-H-6');

          Say(upf_deserter,'D6-Ha-5');

          dwait(0$0.2);
          if Query('QHagenJoin') = 1 then  //accept
               begin
                    ForceSay(Heike,'D6-H-1-1');
                    Say(upf_deserter,'D6-Ha-1-1');

                    //Reveal all mines and UPF breastworks
                    dwait(0$0.2);

                    SetSide(upf_deserter,you);

                    for i in all_mines_hexes do
                         ViewMineAtPos(i[1],i[2],you);

                    for i in upf_breastworks do
                         begin
                              PlaceSeeing(GetX(i),GetY(i),you,-3);
                              RemoveSeeing(GetX(i),GetY(i),you);
                         end;
               end
          else  //reject
               begin
                    ForceSay(Heike,'D6-H-2-1');

                    if IsOk(Sonya) and GetSide(Sonya) = you then
                         Say(Sonya,'D6-So-2-1')
                    else
                         if IsOk(Ralph) and GetSide(Ralph) = you then
                              Say(Ralph,'D6-Ra-2-1');
               end;

          DialogueOff;
     end;

//The player intentionally shoots at the UPF deserter.
Every 0$1+0$0.6 trigger GetSide(upf_deserter) = you do
     var attacked, i;
     begin
          attacked = false;

          repeat
          wait(0$0.5);

          if IsDead(upf_deserter) then
               exit;

          if not attacked then
               begin
                    i = UnitShoot(upf_deserter);
                    if i > 0 then
                         if GetSide(i) = you and Attacks(i) = upf_deserter then  //it was intentional
                              begin
                                   attacked = true;

                                   DialogueOn;
                                   ForceSay(upf_deserter,'D10-Ro-1');
                                   DialogueOff;

                                   SetSide(upf_deserter,upf_deserter_shoot_side);
                              end;
               end
          else
               begin
                    //Try to kill Heike
                    if IsLive(Heike) then
                         ComAttackUnit(upf_deserter,Heike);
               end;

          until false;
     end;


//The player finds Louis's group
Every 0$1+0$0.7 do
     begin
          if (([Louis,Martin] diff 0) ^ other_deserters_08) = 0 then
               exit;

          repeat
          wait(0$0.5);

          if UnitFilter(([Louis,Martin] diff 0) ^ other_deserters_08,[f_alive]) = 0 then
               exit;

          until UnitFilter(([Louis,Martin] diff 0) ^ other_deserters_08 ^ group_3_breastwork,[f_see,you]) > 0;

          //The player could find the group when it was under attack by the extermination group.
          //In that case set the group to the player's side and postpone the dialogue.
          SetSide(([Louis,Martin] diff 0) ^ other_deserters_08 ^ group_3_breastwork,you);
          ComFree((([Louis,Martin] diff 0) ^ other_deserters_08) diff UnitsInside(group_3_breastwork));  //ComFree makes units inside breastwork exit

          while EnemiesNearUnits(([Louis,Martin] diff 0) ^ other_deserters_08) do
               wait(0$1);

          if IsLive(Louis) then
               begin
                    CenterOnUnits(([Louis,Martin] diff 0) ^ other_deserters_08);
                    wait(2);

                    DialogueOn;

                    ForceSay(Louis,'D5-Lo-1');
                    ForceSay(Heike,'D5-H-1');
                    ForceSay(Louis,'D5-Lo-2');
                    ForceSay(Heike,'D5-H-2');

                    DialogueOff;
               end;
     end;


//The player finds the Khattam group
Every 0$1+0$0.8 do
     begin
          if ([Olaf,Suze,Khattam] diff 0) = 0 then
               exit;

          repeat
          wait(0$0.5);
          until UnitFilter([Olaf,Suze,Khattam],[f_see,you]) > 0;

          //Dialogue. Set units to player's side first so you can see them.
          SetSide([Olaf,Suze,Khattam],you);
          CenterOnUnits([Olaf,Suze,Khattam]);
          wait(2);

          DialogueOn;

          if IsOk(Olaf) or IsOk(Suze) then
               begin
                    if IsOk(Olaf) then
                         Say(Olaf,'D7-Ola-1');

                    if IsOk(Suze) then
                         Say(Suze,'D7-Su-1');

                    ForceSay(Heike,'D7-H-1');
               end;

          if IsOk(Khattam) then
               begin
                    Say(Khattam,'D7-Kh-1');
                    ForceSay(Heike,'D7-H-2');
                    Say(Khattam,'D7-Kh-2');

                    if IsOk(Olaf) and IsOk(Suze) then
                         Say(Khattam,'D7-Kh-3');

                    ForceSay(Heike,'D7-H-3');
               end;

          DialogueOff;
     end;


//A civilian is trapped inside a tiger's lair in the central south. If the player hasn't found
//her within some time she will use the radio to call for help. After yet some time the tiger
//will find her and turn her into lunch.
Every 0$1+0$0.9 do
     var spoken;
     begin
          spoken = false;

          repeat
          wait(0$0.5);

          if IsDead(tiger_captive) then
               exit;

          if not IsOk(tiger_captive) then
               continue;

          if See(you,tiger_captive) then
               begin
                    CenterOnUnits(tiger_captive);

                    DialogueOn;
                    Say(tiger_captive,'D9-SomeF-4');
                    DialogueOff;

                    SetSide(tiger_captive,you);
                    ComFree(tiger_captive);

                    exit;
               end;

          if tick >= 2$0 and not spoken and IsOk(the_tiger) then  //If the tiger is ok then we assume the player isn't nearby
               begin
                    spoken = true;

                    DialogueOn;

                    SayRadio(tiger_captive,'D9-SomeF-1');
                    ForceSay(Heike,'D9-H-1');
                    ForceSay(Heike,'D9-H-2');
                    SayRadio(tiger_captive,'D9-SomeF-2');
                    ForceSay(Heike,'D9-H-3');
                    SayRadio(tiger_captive,'D9-SomeF-3');
                    ForceSay(Heike,'D9-H-4');

                    DialogueOff;
               end;

          until false;
     end;
//Until timeout the tiger should not go near the captive or outside the lair.
//After that: "yum yum".
Every 0$1+0$0.8 do
     var temp_list;
     begin
          repeat
          wait(0$1);

          if not IsOk(the_tiger) then
               exit;

          if GetX(the_tiger) <= 136 then
               ComMoveXY(the_tiger,144,139)
          else
               begin
                    temp_list = FilterAllUnits([[f_side,you],[f_dist,the_tiger,6]]);

                    if temp_list > 0 then
                         ComAttackUnit(the_tiger,NearestUnitToUnit(temp_list,the_tiger))
                    else
                         if GetX(the_tiger) >= 157 then
                              ComMoveXY(the_tiger,151,143);
               end;

          until tick >= 2$0+4$0;


          repeat
          wait(0$1);

          if not IsOk(the_tiger) or IsDead(tiger_captive) then
               exit;

          ComAttackUnit(the_tiger,tiger_captive);

          until false;
     end;     